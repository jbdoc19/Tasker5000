<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Task Focus</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1, h3 { color: #fff; }
    .billing-reminder {
      color: #ff6b6b;
      font-weight: 600;
      margin: 0.25rem 0 1rem;
      text-align: center;
    }
    .hidden { display: none; }
    label { display: block; margin-top: 0.5rem; }
    input[type="text"], select, input[type="date"], textarea {
      background: #222; color: #eee; border: 1px solid #555;
      padding: 0.5rem; width: 100%;
    }
    textarea { resize: vertical; }
    button {
      background: #333; color: #fff; border: none; padding: 0.6rem 1rem;
      margin: 0.5rem 0.25rem; cursor: pointer; border-radius: 4px;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    .peek { background: #222; margin-top: 1rem; padding: 1rem; border-radius: 6px; max-width: 600px; }
    .peek summary { cursor: pointer; }
    .task-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }
    .time-budget-control {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: #a0a0a0;
    }
    .time-budget-control select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .show-all-toggle {
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .task-view-label {
      color: #a0a0a0;
      font-size: 0.85rem;
    }
    .task-view-select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .task-card {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 0.85rem;
      margin-bottom: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .task-card.is-completed {
      background: #161616;
      border: 1px solid #2a2a2a;
    }
    .task-card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: flex-start;
    }
    .task-card-title-group {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1;
      min-width: 0;
    }
    .task-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0;
      line-height: 1.4;
      color: #fff;
      word-break: break-word;
    }
    .task-complete-indicator {
      color: #8fc97a;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .task-card-actions {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
    }
    .task-card-actions button {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
    }
    .task-descriptors {
      font-size: 0.8rem;
      color: #b0b0b0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .task-descriptors span::before {
      content: "‚Ä¢";
      margin-right: 0.25rem;
      color: #555;
    }
    .task-descriptors span:first-child::before {
      content: "";
      margin: 0;
    }
    .task-progress {
      font-size: 0.82rem;
      color: #d0dcff;
      font-weight: 500;
    }
    .task-progress-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .task-progress-meter {
      background: #111922;
      border-radius: 999px;
      overflow: hidden;
      height: 6px;
      width: 100%;
    }
    .task-progress-meter .fill {
      display: block;
      height: 100%;
      background: #0a84ff;
      width: 0%;
      transition: width 150ms ease-out;
    }
    .task-meta {
      font-size: 0.75rem;
      color: #8f9aa8;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .task-detail-toggle {
      align-self: flex-start;
      background: #2a2a2a;
      font-size: 0.8rem;
      padding: 0.35rem 0.6rem;
    }
    .task-details {
      font-size: 0.8rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.6rem;
      width: 100%;
      box-sizing: border-box;
    }
    .task-details h5 {
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
      color: #eee;
    }
    .task-details ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .task-details li {
      margin: 0.25rem 0;
    }
    .score { font-size: 0.8rem; color: #ccc; }
    .chart-age, .urgency-hint {
      display: block;
      margin-top: 0.25rem;
      color: #aaa;
      font-size: 0.85rem;
      max-width: 600px;
    }
    .focus { font-size: 1.5rem; margin: 1rem 0; }
    .category-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .category-filter button {
      background: #444;
      color: #fff;
      border: none;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .category-filter button.active {
      background: #666;
    }
    .category-progress {
      margin-top: 0.5rem;
      width: 100%;
      max-width: 600px;
    }
    .category-progress .line {
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
    .category-progress .bar {
      background: #333;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      overflow: hidden;
    }
    .category-progress .bar .fill {
      background: #0a84ff;
      height: 100%;
      display: block;
      width: 0%;
    }
    .subtask-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.4rem 0;
      padding: 0.5rem;
      background: #1a1a1a;
      border-radius: 6px;
    }
    .subtask-row.completed {
      opacity: 0.7;
    }
    .subtask-name {
      flex: 1;
      margin-left: 0.35rem;
    }
    .subtask-actions {
      display: flex;
      gap: 0.25rem;
    }
    .subtask-actions button {
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
    }
    .timer-label {
      font-size: 0.75rem;
      color: #9aa0a6;
      min-width: 110px;
      text-align: right;
      margin-left: auto;
    }
    .chart-summary {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #181818;
      border-radius: 6px;
      width: 100%;
      max-width: 600px;
    }
    .chart-summary h4 {
      margin: 0 0 0.5rem;
    }
    .chart-summary ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .chart-summary li {
      margin: 0.25rem 0;
      padding: 0.35rem;
      background: #202020;
      border-radius: 4px;
    }
    .chart-summary li.longest-step {
      border: 1px solid #0a84ff;
      background: #0a1a33;
    }
    .chart-fields {
      width: 100%;
      overflow: hidden;
      max-height: 1000px;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 250ms ease, max-height 250ms ease;
    }
    .chart-fields.is-hidden {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .chart-total {
      margin-top: 0.5rem;
      font-weight: 600;
    }
    .chart-step-controls {
      margin-top: 0.75rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chart-step-controls button {
      font-size: 0.85rem;
    }
    #focusTimer {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #d0dcff;
    }
    #focusTimer.pulse {
      animation: focus-pulse 1s ease-out;
    }
    @keyframes focus-pulse {
      0% { color: #d0dcff; }
      50% { color: #0a84ff; }
      100% { color: #d0dcff; }
    }
    .sound-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
    }
    .sound-toggle input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #0a84ff;
    }
    .audit-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 999;
    }
    .audit-modal {
      background: #151515;
      border-radius: 10px;
      max-width: 520px;
      width: 100%;
      padding: 1.25rem;
      color: #f5f5f5;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }
    .audit-modal h3 {
      margin: 0 0 0.75rem;
    }
    .audit-summary {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #d0dcff;
    }
    .audit-task-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }
    .audit-task-list li {
      background: #1f1f1f;
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 0.85rem;
      color: #e0e0e0;
    }
    .audit-task-list li strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .audit-task-subtasks {
      margin: 0.35rem 0 0;
      padding-left: 1rem;
      color: #b0b0b0;
    }
    .audit-modal button {
      margin-top: 1rem;
    }
    [aria-live] { outline: none; }
  </style>
</head>
<body>
  <h1>üéØ Task Focus</h1>
  <p id="billingReminder" class="billing-reminder"></p>

  <!-- Task entry form -->
  <section id="capture">
    <label for="name">Task Name
      <input id="name" type="text" placeholder="3/14 ‚Äì J.M. ‚Äì Complex Care Follow-Up (Resident)" autofocus />
    </label>
    <label for="taskCategory">Category
      <select id="taskCategory">
        <option value="General" selected>General</option>
        <option value="Admin">Admin</option>
        <option value="Chart">Chart</option>
        <option value="Inbox">Inbox</option>
        <option value="Calls">Calls</option>
        <option value="Teaching">Teaching</option>
        <option value="Personal">Personal</option>
      </select>
    </label>
    <div id="chartFields" class="chart-fields is-hidden" aria-hidden="true">
      <label for="authorType">Chart Author
        <select id="authorType">
          <option value="attending" selected>Attending</option>
          <option value="resident">Resident</option>
        </select>
      </label>
      <label for="patientType" title="Complex = medically fragile, multi-specialty, or DME-dependent.">Patient Type
        <select id="patientType">
          <option value="Non-Complex" selected>Non-Complex</option>
          <option value="Complex">Complex</option>
        </select>
      </label>
      <label for="visitType" title="Determines estimated chart complexity and time to complete.">Visit Type
        <select id="visitType">
          <option value="Follow-Up" selected>Follow-Up</option>
          <option value="Establish Care">Establish Care</option>
          <option value="Well Child Visit">Well Child Visit</option>
          <option value="Acute Visit">Acute Visit</option>
        </select>
      </label>
      <label for="clinicSite" title="Same-day notes from St PJ‚Äôs or Craniofacial automatically rise to the top.">Clinic Site
        <select id="clinicSite">
          <option value="General Clinic" selected>General Clinic</option>
          <option value="St PJ‚Äôs Shelter">St PJ‚Äôs Shelter</option>
          <option value="Craniofacial Clinic">Craniofacial Clinic</option>
        </select>
      </label>
      <label for="dateOfService" title="Select the date of the encounter; defaults to today.">Date of Service
        <input type="date" id="dateOfService" />
      </label>
      <small id="chartAgeDisplay" class="chart-age"></small>
    </div>
    <label for="importance">Importance (1‚Äì5) <select id="importance"></select></label>
    <label for="urgency">Urgency (1‚Äì5)
      <select id="urgency"></select>
    </label>
    <small id="urgencyHint" class="urgency-hint"></small>
    <label for="novelty">Novelty (1‚Äì5) <select id="novelty"></select></label>
    <label for="interest">Interest (1‚Äì5) <select id="interest"></select></label>
    <label for="externalPressure">External Pressure (1‚Äì5)
      <select id="externalPressure"></select>
    </label>
    <label for="timeToStart">Time to Start (1‚Äì5) <select id="timeToStart"></select></label>
    <label for="difficulty">Difficulty (1‚Äì5) <select id="difficulty"></select></label>
    <label for="dueDate" title="Optional specific target date; used for personal scheduling.">Due Date (Optional) <input type="date" id="dueDate" /></label>
    <label for="initialSubTasks">Subtasks
      <textarea id="initialSubTasks" rows="3" placeholder="One subtask per line."></textarea>
    </label>
    <div>
      <button id="addTaskBtn" onclick="addTask()">Add Task</button>
      <button id="saveUpdateBtn" class="hidden" onclick="saveTaskUpdate()">Save Update</button>
      <button id="cancelEditBtn" class="hidden" onclick="cancelEdit()">Cancel</button>
      <button onclick="saveAsTemplate()">Add as Template</button>
      <button onclick="startFocus()" id="startBtn" disabled>Get started</button>
      <button onclick="reset()">Reset</button>
    </div>
    <div id="templateSection" style="margin-top:1rem;">
      <h3>Templates</h3>
      <div id="templateButtons"></div>
    </div>
    <label class="sound-toggle" for="focusSoundToggle">
      <input type="checkbox" id="focusSoundToggle" checked />
      Enable focus mode ping
    </label>
    <!-- Category filter bar -->
    <div id="categoryFilter" class="category-filter"></div>
    <!-- Progress per category -->
    <div id="categoryProgress" class="category-progress"></div>
    <details class="peek">
      <summary>üîç Peek at tasks</summary>
      <div class="task-list-header" id="taskListHeader">
        <label class="task-view-label" for="taskViewMode">View</label>
        <select id="taskViewMode" class="task-view-select">
          <option value="active" selected>Active Tasks</option>
          <option value="completed">Completed Tasks</option>
        </select>
        <label class="time-budget-control" for="timeBudget">
          I have
          <select id="timeBudget">
            <option value="">--</option>
            <option value="15">15</option>
            <option value="30">30</option>
            <option value="60">60</option>
          </select>
          minutes
        </label>
        <button id="showAllToggle" class="show-all-toggle hidden" type="button" onclick="toggleShowAllActive()">Show All</button>
      </div>
      <div id="taskList"></div>
    </details>
    <div id="dueTodaySection" style="margin-top:1rem;">
      <h3>üóÇÔ∏è Charts Due Today</h3>
      <div id="dueTodayList"></div>
    </div>
  </section>

  <!-- Focus mode -->
  <section id="focus" class="hidden">
    <div id="focusTimer" aria-live="polite">üß≠ Focus Time: 0:00</div>
    <div class="focus" tabindex="0" aria-live="polite"></div>
    <div class="score" id="scoreView"></div>
    <div id="subTaskView"></div>
    <div>
      <button onclick="completeTask()">Task complete</button>
      <button onclick="backToCapture()">Back to capture</button>
    </div>
  </section>

  <script>
  const $ = id => document.getElementById(id);

  const categories = ["General","Admin","Chart","Inbox","Calls","Teaching","Personal"];
  let activeCategory = "All";
  const TASK_LIST_MODES = { ACTIVE: "active", COMPLETED: "completed" };
  let taskListMode = TASK_LIST_MODES.ACTIVE;
  let showAllActiveTasks = false;
  let derivedDaysSinceVisit = null;
  let urgencyAuto = true;
  const runningTimers = new Map();
  const chartFieldIds = ["authorType", "patientType", "visitType", "clinicSite", "dateOfService"];
  let storedChartFieldValues = null;
  let currentScaleDescriptorCategory = "general";
  const FOCUS_PING_INTERVAL_MS = 10 * 60 * 1000;
  const AUDIT_STORAGE_PREFIX = "audit_";
  const AUDIT_SHOWN_SUFFIX = "_shown";

  function getChartFields() {
    return chartFieldIds
      .map(id => $(id))
      .filter(Boolean);
  }

  function setChartFieldsDisabled(isDisabled) {
    getChartFields().forEach(field => {
      field.disabled = isDisabled;
    });
  }

  function storeChartFieldValues() {
    storedChartFieldValues = {};
    chartFieldIds.forEach(id => {
      const field = $(id);
      if (field) {
        storedChartFieldValues[id] = field.value;
      }
    });
  }

  function restoreChartFieldValues() {
    if (!storedChartFieldValues) return;
    chartFieldIds.forEach(id => {
      if (Object.prototype.hasOwnProperty.call(storedChartFieldValues, id)) {
        const field = $(id);
        if (field) {
          field.value = storedChartFieldValues[id];
        }
      }
    });
    storedChartFieldValues = null;
  }

  function showChartFields() {
    const container = $("chartFields");
    if (!container) return;
    container.classList.remove("is-hidden");
    container.setAttribute("aria-hidden", "false");
    setChartFieldsDisabled(false);
    restoreChartFieldValues();
    updateDerivedFields();
  }

  function hideChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storeChartFieldValues();
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  function handleCategoryChange(value) {
    const resolvedCategory = (value ?? $("taskCategory")?.value ?? "").toString();
    populateScalesForCategory(resolvedCategory);
    if (resolvedCategory.toLowerCase() === "chart") {
      showChartFields();
    } else {
      hideChartFields();
    }
    renderTemplates();
  }

  function initializeChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storedChartFieldValues = null;
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  const NUMERIC_SCALE_FIELDS = ["importance","novelty","interest","timeToStart","difficulty"];
  const SCALE_FIELDS = [...NUMERIC_SCALE_FIELDS, "urgency", "externalPressure"];
  const BASIC_NUMERIC_DESCRIPTORS = [1, 2, 3, 4, 5].map(value => ({
    value,
    text: String(value)
  }));

  const DEFAULT_DESCRIPTOR_SET = {
    importance: BASIC_NUMERIC_DESCRIPTORS,
    urgency: [
      { value: 5, text: "5 ‚Äì Critical Billing Window or Immediate Patient Need" },
      { value: 4, text: "4 ‚Äì High Priority ‚Äì Near-Term Deadline" },
      { value: 3, text: "3 ‚Äì Moderate Priority ‚Äì Monthly Closure" },
      { value: 2, text: "2 ‚Äì Low Billing Value ‚Äì Already Overdue" },
      { value: 1, text: "1 ‚Äì Routine Follow-Up Work" }
    ],
    novelty: BASIC_NUMERIC_DESCRIPTORS,
    interest: BASIC_NUMERIC_DESCRIPTORS,
    externalPressure: [
      { value: 1, text: "1 ‚Äì Solo responsibility" },
      { value: 2, text: "2 ‚Äì Soft deadline / courtesy check" },
      { value: 3, text: "3 ‚Äì Peer or team waiting" },
      { value: 4, text: "4 ‚Äì Leadership expectation" },
      { value: 5, text: "5 ‚Äì Patient or compliance critical" }
    ],
    timeToStart: BASIC_NUMERIC_DESCRIPTORS,
    difficulty: BASIC_NUMERIC_DESCRIPTORS
  };

  const CATEGORY_DESCRIPTOR_SETS = {
    chart: {
      importance: [
        { value: 1, text: "1 ‚Äì Chart adds minimal new information or duplicates an existing note." },
        { value: 2, text: "2 ‚Äì Routine follow-up with limited clinical or legal relevance." },
        { value: 3, text: "3 ‚Äì Contains moderate clinical content or affects internal workflow (e.g., continuity documentation)." },
        { value: 4, text: "4 ‚Äì Impacts care coordination, billing, or orders being released." },
        { value: 5, text: "5 ‚Äì Critical legal or clinical documentation‚Äîsuch as a new complex care note, DME letter, or therapy order summary." }
      ],
      urgency: [
        { value: 1, text: "1 ‚Äì No immediate consequence if delayed more than a week." },
        { value: 2, text: "2 ‚Äì Should be completed within five to seven days to keep the workflow moving." },
        { value: 3, text: "3 ‚Äì Approaching the expected three-day chart completion window." },
        { value: 4, text: "4 ‚Äì Actively holding up orders, referrals, or communication with other providers." },
        { value: 5, text: "5 ‚Äì Must be completed within 24 hours‚Äîblocking patient care, billing, or compliance." }
      ],
      novelty: [
        { value: 1, text: "1 ‚Äì Repetitive, nearly identical to prior encounters‚Äîmental autopilot work." },
        { value: 2, text: "2 ‚Äì Familiar patient with predictable updates." },
        { value: 3, text: "3 ‚Äì Some variation or new findings but overall routine." },
        { value: 4, text: "4 ‚Äì Clearly different or updated scenario (new comorbidity, new specialist input)." },
        { value: 5, text: "5 ‚Äì Entirely new case or patient; requires full synthesis and high cognitive effort." }
      ],
      interest: [
        { value: 1, text: "1 ‚Äì Emotionally draining, tedious, or disengaging." },
        { value: 2, text: "2 ‚Äì Slightly more tolerable but still repetitive." },
        { value: 3, text: "3 ‚Äì Neutral‚Äîacceptable task without resistance or enthusiasm." },
        { value: 4, text: "4 ‚Äì Personally engaging or meaningful (e.g., rewarding outcome, interesting complexity)." },
        { value: 5, text: "5 ‚Äì Highly interesting or affirming‚Äîfeels worth your energy investment." }
      ],
      externalPressure: [
        { value: 1, text: "1 ‚Äì No one waiting on this; purely internal backlog." },
        { value: 2, text: "2 ‚Äì Minimal outside awareness‚Äîperhaps a resident awaiting co-signature." },
        { value: 3, text: "3 ‚Äì Family or administrative team may soon follow up." },
        { value: 4, text: "4 ‚Äì Directly affects nursing, therapy, or resident progress if left undone." },
        { value: 5, text: "5 ‚Äì Leadership, family, or compliance risk if not completed immediately." }
      ],
      timeToStart: [
        { value: 1, text: "1 ‚Äì Requires major prep‚Äîmultiple subspecialty notes or context review needed." },
        { value: 2, text: "2 ‚Äì Some setup required; moderate amount of data gathering first." },
        { value: 3, text: "3 ‚Äì Ready to begin with basic template or SmartPhrase already open." },
        { value: 4, text: "4 ‚Äì Mostly drafted or pre-filled by a resident." },
        { value: 5, text: "5 ‚Äì One click from completion‚Äîreview and sign only." }
      ],
      difficulty: [
        { value: 1, text: "1 ‚Äì Very complex visit‚Äîmultiple specialists, high stakes." },
        { value: 2, text: "2 ‚Äì High cognitive load‚Äîmultiple notes or CareEverywhere data to merge." },
        { value: 3, text: "3 ‚Äì Moderate effort‚Äîsome review of orders, results, or medication changes." },
        { value: 4, text: "4 ‚Äì Small amount of synthesis or clean-up work." },
        { value: 5, text: "5 ‚Äì Straightforward chart; minimal thought required." }
      ]
    },
    admin: {
      importance: [
        { value: 1, text: "1: Low-value clerical item ‚Äî informational only, not linked to care or billing (e.g., generic record release)." },
        { value: 2, text: "2: Routine paperwork (e.g., school letter, general clearance) with limited medical impact." },
        { value: 3, text: "3: Moderately important ‚Äî ensures continuity of services or avoids family confusion." },
        { value: 4, text: "4: Affects patient function, equipment use, or continuity of home health/therapy services." },
        { value: 5, text: "5: Legally, financially, or clinically critical (e.g., DME or home nursing orders, time-sensitive medical necessity forms)." }
      ],
      urgency: [
        { value: 1, text: "1: No time constraint; backlog cleanup or batch task." },
        { value: 2, text: "2: Preferred within a week to prevent workflow pileup." },
        { value: 3, text: "3: Due soon ‚Äî flagged or requested multiple times (within 72 hours)." },
        { value: 4, text: "4: Time-sensitive ‚Äî blocking care, equipment renewal, or external agency action." },
        { value: 5, text: "5: Immediate deadline ‚Äî service interruption or patient safety risk if not completed today." }
      ],
      novelty: [
        { value: 1, text: "1: Routine, repetitive ‚Äî identical to previous letters or forms." },
        { value: 2, text: "2: Minor variation (same patient, slightly different form)." },
        { value: 3, text: "3: Moderate variation ‚Äî new formatting or service type but same structure." },
        { value: 4, text: "4: Requires rethinking or rewriting ‚Äî new medical justification or appeal." },
        { value: 5, text: "5: Entirely new or unusual form requiring research, collaboration, or creative framing." }
      ],
      interest: [
        { value: 1, text: "1: Utterly draining paperwork with no personal reward." },
        { value: 2, text: "2: Mildly tolerable ‚Äî repetitive but manageable." },
        { value: 3, text: "3: Neutral task; emotionally flat but not difficult." },
        { value: 4, text: "4: Slightly satisfying ‚Äî clear, finite, ‚Äòbox checked‚Äô gratification." },
        { value: 5, text: "5: Emotionally rewarding ‚Äî high-impact document that feels meaningful or helps a deserving family." }
      ],
      externalPressure: [
        { value: 1, text: "1: No one waiting; background task only." },
        { value: 2, text: "2: Requested once, no follow-up." },
        { value: 3, text: "3: Family, therapist, or vendor has followed up once or twice." },
        { value: 4, text: "4: Repeated requests or escalating frustration from external partner." },
        { value: 5, text: "5: Time-sensitive escalation ‚Äî multiple stakeholders involved, risk of complaint or service disruption." }
      ],
      timeToStart: [
        { value: 1, text: "1: Fully prepped or pre-filled ‚Äî literally one click to sign, fax, or send." },
        { value: 2, text: "2: Nearly complete ‚Äî requires signatures or minor edits." },
        { value: 3, text: "3: Ready to draft ‚Äî information accessible, no major digging needed." },
        { value: 4, text: "4: Some setup required ‚Äî gathering diagnostic codes, reviewing notes." },
        { value: 5, text: "5: Requires locating old versions or supporting documents (e.g., past forms, letters)." }
      ],
      difficulty: [
        { value: 1, text: "1: Straightforward ‚Äî fill in basic info, minimal judgment." },
        { value: 2, text: "2: Simple but tedious ‚Äî multiple checkboxes or sign-offs." },
        { value: 3, text: "3: Moderate ‚Äî requires referencing recent visits or clinical notes." },
        { value: 4, text: "4: High cognitive effort ‚Äî must summarize complex clinical picture concisely." },
        { value: 5, text: "5: Very complex ‚Äî appeals, multidisciplinary coordination, or justification requiring clinical precision." }
      ]
    },
    personal: {
      importance: [
        { value: 1, text: "1 ‚Äì Trivial ‚Äî doesn‚Äôt really matter if done" },
        { value: 2, text: "2 ‚Äì Mildly useful ‚Äî minor quality-of-life improvement" },
        { value: 3, text: "3 ‚Äì Helpful ‚Äî meaningful progress toward a goal" },
        { value: 4, text: "4 ‚Äì Significant ‚Äî affects well-being or relationships" },
        { value: 5, text: "5 ‚Äì Critical ‚Äî has serious emotional, financial, or health consequences" }
      ],
      urgency: [
        { value: 1, text: "1 ‚Äì No time pressure ‚Äî can wait indefinitely" },
        { value: 2, text: "2 ‚Äì Slight ‚Äî would be good to do soon" },
        { value: 3, text: "3 ‚Äì Moderate ‚Äî needs attention within a few days" },
        { value: 4, text: "4 ‚Äì High ‚Äî needs to be done today" },
        { value: 5, text: "5 ‚Äì Immediate ‚Äî must be addressed now" }
      ],
      interest: [
        { value: 1, text: "1 ‚Äì Dreaded ‚Äî pure avoidance energy" },
        { value: 2, text: "2 ‚Äì Unpleasant but tolerable" },
        { value: 3, text: "3 ‚Äì Neutral ‚Äî neither appealing nor aversive" },
        { value: 4, text: "4 ‚Äì Mildly engaging" },
        { value: 5, text: "5 ‚Äì Genuinely energizing or rewarding" }
      ],
      difficulty: [
        { value: 1, text: "1 ‚Äì Very hard ‚Äî high resistance, many steps, or emotionally draining" },
        { value: 2, text: "2 ‚Äì Challenging ‚Äî mentally or logistically demanding" },
        { value: 3, text: "3 ‚Äì Moderate ‚Äî manageable with steady focus" },
        { value: 4, text: "4 ‚Äì Mild effort ‚Äî easy, straightforward, minimal resistance" },
        { value: 5, text: "5 ‚Äì Simple ‚Äî effortless, can be done on autopilot" }
      ],
      timeToStart: [
        { value: 1, text: "1 ‚Äì Requires major setup or emotional readiness" },
        { value: 2, text: "2 ‚Äì Some prep work before starting" },
        { value: 3, text: "3 ‚Äì Can start with minimal prep" },
        { value: 4, text: "4 ‚Äì Ready to begin immediately" },
        { value: 5, text: "5 ‚Äì Already in motion / one click from done" }
      ]
    }
  };

  function getCategoryDescriptorKey(category) {
    const normalized = (category || "").toString().trim().toLowerCase();
    return normalized || "general";
  }

  function getScaleOptions(fieldId, categoryKey) {
    const key = categoryKey || "general";
    const descriptorSet = CATEGORY_DESCRIPTOR_SETS[key];
    if (descriptorSet && Array.isArray(descriptorSet[fieldId])) {
      return descriptorSet[fieldId];
    }
    const defaults = DEFAULT_DESCRIPTOR_SET[fieldId];
    if (defaults) {
      return defaults;
    }
    return BASIC_NUMERIC_DESCRIPTORS;
  }

  function populateScaleSelect(fieldId, categoryKey) {
    const select = $(fieldId);
    if (!select) return;
    const previousValue = select.value;
    const options = getScaleOptions(fieldId, categoryKey);
    select.innerHTML = "";
    options.forEach(option => {
      const opt = document.createElement("option");
      opt.value = String(option.value);
      opt.textContent = option.text || String(option.value);
      select.appendChild(opt);
    });
    const previous = previousValue !== undefined && previousValue !== null
      ? String(previousValue)
      : "";
    const hasPrevious = options.some(option => String(option.value) === previous);
    if (hasPrevious) {
      select.value = previous;
    } else if (options.length > 0) {
      select.value = String(options[0].value);
    }
  }

  function populateScalesForCategory(category) {
    const key = getCategoryDescriptorKey(category);
    currentScaleDescriptorCategory = key;
    SCALE_FIELDS.forEach(fieldId => populateScaleSelect(fieldId, key));
    updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
  }

  const BASE_CHART_STEPS = [
    "Load Abridge (dictation)",
    "Review/modify HPI",
    "Review/modify PE",
    "Review/modify A/P",
    "Review/submit orders",
    "Enter billing code",
    "Sign off"
  ];
  const RESIDENT_ATTESTATION_STEP = "Add Attestation";
  let currentFocusTaskIndex = null;

  function generateSubTaskId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  }

  function isChartTask(task) {
    return task && String(task.category).toLowerCase() === "chart";
  }

  function buildChartSteps(authorType) {
    const steps = [...BASE_CHART_STEPS];
    if (String(authorType).toLowerCase() === "resident") {
      const billingIndex = steps.indexOf("Enter billing code");
      const insertIndex = billingIndex === -1 ? steps.length - 1 : billingIndex;
      steps.splice(insertIndex, 0, RESIDENT_ATTESTATION_STEP);
    }
    return steps;
  }

  function calculateDurationMinutes(start, end) {
    if (!start || !end) return null;
    const startDate = new Date(start);
    const endDate = new Date(end);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Number((diff / (1000 * 60)).toFixed(2));
  }

  function isTaskCompleted(task) {
    if (!task) return false;
    return Boolean(task.completed || task.completedAt);
  }

  function getCompletionTimestamp(task) {
    if (!task) return null;
    return task.completedAt || task.completionTime || null;
  }

  function formatDateTime(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  }

  function formatDuration(minutes) {
    if (minutes === null || minutes === undefined) return "--";
    const num = Number(minutes);
    if (!Number.isFinite(num)) return "--";
    return `${num.toFixed(2)} min`;
  }

  function formatElapsedMs(ms) {
    if (!Number.isFinite(ms) || ms < 0) return "--";
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
  }

  function getSelectedTimeBudget() {
    const rawValue = $("timeBudget")?.value;
    if (rawValue === undefined || rawValue === null || rawValue === "") return null;
    const parsed = Number(rawValue);
    return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
  }

  function estimateTaskMinutes(task) {
    if (!task) return 0;
    const subTasks = Array.isArray(task.subTasks) ? task.subTasks : [];
    const remaining = subTasks.filter(sub => !sub.completed);
    const remainingCount = remaining.length > 0 ? remaining.length : 1;
    const recordedDurations = subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value) && value > 0);
    if (recordedDurations.length) {
      const avg = recordedDurations.reduce((sum, value) => sum + value, 0) / recordedDurations.length;
      return Math.max(1, Math.ceil(avg * remainingCount));
    }
    const difficultyMap = { 1: 60, 2: 45, 3: 30, 4: 15, 5: 5 };
    const difficulty = clampScale(task.difficulty, 3);
    const fallback = difficultyMap[difficulty] || 30;
    return fallback * remainingCount;
  }

  function createSubTask(name, priority) {
    return {
      id: generateSubTaskId(),
      name,
      completed: false,
      priority,
      startTime: null,
      completionTime: null,
      durationMinutes: null
    };
  }

  function normalizeSubTask(sub, basePriority) {
    if (!sub) {
      return createSubTask("Step", basePriority);
    }
    const normalized = {
      id: sub.id || generateSubTaskId(),
      name: sub.name || "Step",
      completed: Boolean(sub.completed),
      priority: toNumber(sub.priority, basePriority),
      startTime: sub.startTime || null,
      completionTime: sub.completionTime || null,
      durationMinutes: sub.durationMinutes !== undefined && sub.durationMinutes !== null && Number.isFinite(Number(sub.durationMinutes))
        ? Number(sub.durationMinutes)
        : null
    };
    if (normalized.durationMinutes === null && normalized.startTime && normalized.completionTime) {
      normalized.durationMinutes = calculateDurationMinutes(normalized.startTime, normalized.completionTime);
    }
    return normalized;
  }

  function computeTotalChartDuration(subTasks) {
    if (!Array.isArray(subTasks) || subTasks.length === 0) return 0;
    return Number(subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0).toFixed(2));
  }

  function getTaskTotalDuration(task) {
    if (!task) return null;
    if (isChartTask(task)) {
      const value = Number(task.chartDurationMinutes);
      return Number.isFinite(value) && value > 0 ? value : null;
    }
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);
    if (total <= 0) return null;
    return Number(total.toFixed(2));
  }

  function updateChartDurationForTask(task) {
    if (!isChartTask(task)) {
      delete task.chartDurationMinutes;
      return;
    }
    task.chartDurationMinutes = computeTotalChartDuration(task.subTasks);
  }

  function clearRunningTimers() {
    runningTimers.forEach(intervalId => clearInterval(intervalId));
    runningTimers.clear();
  }

  function stopTimerForSubTask(subId) {
    const intervalId = runningTimers.get(subId);
    if (intervalId) {
      clearInterval(intervalId);
      runningTimers.delete(subId);
    }
  }

  function trackTimer(sub, timerEl) {
    if (!timerEl) return;
    stopTimerForSubTask(sub.id);
    if (sub.completed) {
      timerEl.textContent = `Completed ‚Äì ${formatDuration(sub.durationMinutes)}`;
      return;
    }
    if (!sub.startTime) {
      timerEl.textContent = "Timer: --";
      return;
    }
    const update = () => {
      const startDate = new Date(sub.startTime);
      if (Number.isNaN(startDate.getTime())) {
        timerEl.textContent = "Timer: --";
        return;
      }
      const now = new Date();
      timerEl.textContent = `Timer: ${formatElapsedMs(now.getTime() - startDate.getTime())}`;
    };
    update();
    const intervalId = setInterval(update, 1000);
    runningTimers.set(sub.id, intervalId);
  }

  function stopFocusTimer(resetDisplay = true) {
    if (focusTimerId) {
      clearInterval(focusTimerId);
      focusTimerId = null;
    }
    focusTimerStart = null;
    focusTimerLastPing = null;
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    timerEl.classList.remove("pulse");
    if (resetDisplay) {
      timerEl.textContent = "üß≠ Focus Time: 0:00";
    }
  }

  function updateFocusTimerDisplay(elapsedMs) {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    const minutes = Math.floor(elapsedMs / 60000);
    const seconds = Math.floor((elapsedMs % 60000) / 1000);
    timerEl.textContent = `üß≠ Focus Time: ${minutes}:${String(seconds).padStart(2, "0")}`;
  }

  function playFocusPing() {
    if (!focusSoundEnabled) return;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor) return;
    if (!focusAudioContext) {
      try {
        focusAudioContext = new AudioContextCtor();
      } catch (error) {
        focusAudioContext = null;
        return;
      }
    }
    if (focusAudioContext.state === "suspended") {
      focusAudioContext.resume().catch(() => {});
    }
    const duration = 0.4;
    const oscillator = focusAudioContext.createOscillator();
    const gain = focusAudioContext.createGain();
    oscillator.type = "sine";
    oscillator.frequency.setValueAtTime(880, focusAudioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, focusAudioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, focusAudioContext.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, focusAudioContext.currentTime + duration);
    oscillator.connect(gain);
    gain.connect(focusAudioContext.destination);
    oscillator.start();
    oscillator.stop(focusAudioContext.currentTime + duration);
  }

  function triggerFocusPing() {
    const timerEl = $("focusTimer");
    if (timerEl) {
      timerEl.classList.add("pulse");
      setTimeout(() => timerEl.classList.remove("pulse"), 1000);
    }
    playFocusPing();
  }

  function startFocusTimer() {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    stopFocusTimer(false);
    focusTimerStart = Date.now();
    focusTimerLastPing = focusTimerStart;
    updateFocusTimerDisplay(0);
    focusTimerId = setInterval(() => {
      if (focusTimerStart === null) return;
      const now = Date.now();
      const elapsed = now - focusTimerStart;
      updateFocusTimerDisplay(elapsed);
      if (!focusTimerLastPing || now - focusTimerLastPing >= FOCUS_PING_INTERVAL_MS) {
        triggerFocusPing();
        focusTimerLastPing = now;
      }
    }, 1000);
  }

  function setFocusSoundPreference(enabled) {
    focusSoundEnabled = Boolean(enabled);
    localStorage.setItem("focusSoundEnabled", focusSoundEnabled ? "true" : "false");
  }

  function getAuditStorageKey(date = new Date()) {
    return `${AUDIT_STORAGE_PREFIX}${date.toISOString().split("T")[0]}`;
  }

  function getAuditShownKey(storageKey) {
    return `${storageKey}${AUDIT_SHOWN_SUFFIX}`;
  }

  function loadAuditEntries(storageKey) {
    if (!storageKey) return [];
    const raw = localStorage.getItem(storageKey);
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  }

  function recordTaskCompletion(task) {
    if (!task) return;
    const storageKey = getAuditStorageKey();
    const entries = loadAuditEntries(storageKey);
    const subDetails = Array.isArray(task.subTasks)
      ? task.subTasks.map(sub => {
          const rawDuration = Number(sub?.durationMinutes);
          const normalizedDuration = Number.isFinite(rawDuration) && rawDuration > 0
            ? Number(rawDuration.toFixed(2))
            : null;
          return {
            name: sub?.name || "Step",
            duration: normalizedDuration
          };
        })
      : [];
    let totalDuration = getTaskTotalDuration(task);
    if (Number.isFinite(totalDuration) && totalDuration > 0) {
      totalDuration = Number(totalDuration.toFixed(2));
    } else {
      const fallbackTotal = subDetails.reduce((sum, sub) => {
        return Number.isFinite(sub.duration) ? sum + sub.duration : sum;
      }, 0);
      totalDuration = fallbackTotal > 0 ? Number(fallbackTotal.toFixed(2)) : null;
    }
    entries.push({
      name: task.name || "Task",
      subDetails,
      totalDuration,
      completedAt: getCompletionTimestamp(task) || new Date().toISOString()
    });
    localStorage.setItem(storageKey, JSON.stringify(entries));
  }

  function showEndOfDayAudit(entries = null, shownKeyOverride = null) {
    const storageKey = getAuditStorageKey();
    const auditEntries = entries || loadAuditEntries(storageKey);
    if (!auditEntries.length) return;
    const shownKey = shownKeyOverride || getAuditShownKey(storageKey);

    const overlay = document.createElement("div");
    overlay.className = "audit-backdrop";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.setAttribute("aria-labelledby", "auditModalTitle");

    const modal = document.createElement("div");
    modal.className = "audit-modal";

    const title = document.createElement("h3");
    title.id = "auditModalTitle";
    title.textContent = "End of Day Audit";
    modal.appendChild(title);

    const totalMinutes = auditEntries.reduce((sum, entry) => {
      const value = Number(entry?.totalDuration);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);

    let longestSubtask = null;
    auditEntries.forEach(entry => {
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      details.forEach(sub => {
        const duration = Number(sub?.duration);
        if (!Number.isFinite(duration)) return;
        if (!longestSubtask || duration > longestSubtask.duration) {
          longestSubtask = {
            taskName: entry?.name || "Task",
            name: sub?.name || "Step",
            duration
          };
        }
      });
    });

    const summary = document.createElement("div");
    summary.className = "audit-summary";
    const summaryLines = [
      `Tasks completed: ${auditEntries.length}`,
      `Productive minutes: ${formatDuration(totalMinutes)}`,
      longestSubtask
        ? `Longest subtask: ${longestSubtask.name} (${formatDuration(longestSubtask.duration)}) ‚Äî ${longestSubtask.taskName}`
        : "Longest subtask: --"
    ];
    summaryLines.forEach(text => {
      const line = document.createElement("div");
      line.textContent = text;
      summary.appendChild(line);
    });
    modal.appendChild(summary);

    const list = document.createElement("ul");
    list.className = "audit-task-list";
    auditEntries.forEach(entry => {
      const item = document.createElement("li");
      const header = document.createElement("strong");
      header.textContent = `${entry?.name || "Task"} ‚Äî ${formatDuration(entry?.totalDuration)}`;
      item.appendChild(header);
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      if (details.length) {
        const subList = document.createElement("ul");
        subList.className = "audit-task-subtasks";
        details.forEach(sub => {
          const subItem = document.createElement("li");
          subItem.textContent = `${sub?.name || "Step"}: ${formatDuration(sub?.duration)}`;
          subList.appendChild(subItem);
        });
        item.appendChild(subList);
      }
      list.appendChild(item);
    });
    modal.appendChild(list);

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "Close";

    const closeModal = () => {
      overlay.remove();
      document.removeEventListener("keydown", onKeyDown);
    };

    const onKeyDown = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeModal();
      }
    };

    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeModal();
      }
    });
    document.addEventListener("keydown", onKeyDown);

    modal.appendChild(closeBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    requestAnimationFrame(() => closeBtn.focus());
    if (shownKey) {
      localStorage.setItem(shownKey, "true");
    }
  }

  function maybeShowEndOfDayAudit() {
    const remainingActive = tasks.filter(task => !isTaskCompleted(task)).length;
    if (remainingActive > 0) return;
    const storageKey = getAuditStorageKey();
    const shownKey = getAuditShownKey(storageKey);
    if (localStorage.getItem(shownKey) === "true") return;
    const entries = loadAuditEntries(storageKey);
    if (!entries.length) return;
    showEndOfDayAudit(entries, shownKey);
  }

  function initializeSoundPreference() {
    const saved = localStorage.getItem("focusSoundEnabled");
    if (saved !== null) {
      focusSoundEnabled = saved === "true";
    }
    const toggle = $("focusSoundToggle");
    if (!toggle) return;
    toggle.checked = focusSoundEnabled;
    toggle.addEventListener("change", event => {
      setFocusSoundPreference(event.target.checked);
      if (focusSoundEnabled && focusAudioContext && focusAudioContext.state === "suspended") {
        focusAudioContext.resume().catch(() => {});
      }
    });
  }

  function ensureChartSubTasks(task, options = {}) {
    if (!isChartTask(task)) return false;
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    const basePriority = options.basePriority !== undefined
      ? options.basePriority
      : computePriority({ ...task, subTasks: [] });
    if (task.useChartTemplate === false) {
      task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      return false;
    }
    const defaults = buildChartSteps(task.authorType);
    const lowerDefaults = defaults.map(step => step.toLowerCase());
    const requiredSet = new Set(lowerDefaults);
    const attestationKey = RESIDENT_ATTESTATION_STEP.toLowerCase();
    let changed = false;

    if (!requiredSet.has(attestationKey)) {
      const filtered = task.subTasks.filter(sub => String(sub?.name || "").toLowerCase() !== attestationKey);
      if (filtered.length !== task.subTasks.length) {
        task.subTasks = filtered;
        changed = true;
      }
    }

    const existingByName = new Map();
    task.subTasks.forEach((sub, index) => {
      const key = String(sub?.name || "").toLowerCase();
      if (!existingByName.has(key)) {
        existingByName.set(key, { sub, index });
      }
    });

    const orderedDefaults = defaults.map(step => {
      const key = step.toLowerCase();
      const existing = existingByName.get(key);
      if (existing) {
        existingByName.delete(key);
        return existing.sub;
      }
      changed = true;
      return createSubTask(step, basePriority);
    });

    const extras = task.subTasks.filter(sub => {
      const key = String(sub?.name || "").toLowerCase();
      return !requiredSet.has(key);
    });

    const nextSubTasks = [...orderedDefaults, ...extras];
    const sameOrder = nextSubTasks.length === task.subTasks.length
      && nextSubTasks.every((sub, idx) => sub === task.subTasks[idx]);
    if (!sameOrder) {
      task.subTasks = nextSubTasks;
      if (!changed) changed = true;
    }

    task.subTasks.forEach(sub => {
      if (sub.priority !== basePriority) {
        sub.priority = basePriority;
        changed = true;
      }
    });

    return changed;
  }

  function resolveTaskAndSub(taskIndex, subIndex, options = {}) {
    let resolvedIndex = taskIndex;
    let task = tasks[resolvedIndex];
    if ((!task || resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && options.taskId) {
      resolvedIndex = tasks.findIndex(t => t.id === options.taskId);
      task = tasks[resolvedIndex];
    }
    if (!task) {
      return { task: null, taskIndex: -1, sub: null, subIndex: -1 };
    }
    let resolvedSubIndex = subIndex;
    let sub = Array.isArray(task.subTasks) ? task.subTasks[resolvedSubIndex] : undefined;
    if ((!sub || resolvedSubIndex === undefined || resolvedSubIndex === null || resolvedSubIndex < 0) && options.subId && Array.isArray(task.subTasks)) {
      resolvedSubIndex = task.subTasks.findIndex(s => s.id === options.subId);
      sub = task.subTasks[resolvedSubIndex];
    }
    return { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex };
  }

  function renderChartSummary(task) {
    const container = document.createElement("div");
    container.className = "chart-summary";
    const heading = document.createElement("h4");
    heading.textContent = "Chart Summary";
    container.appendChild(heading);
    const list = document.createElement("ul");
    const durations = task.subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value));
    const longest = durations.length ? Math.max(...durations) : null;
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      item.textContent = `${sub.name}: ${formatDuration(sub.durationMinutes)}`;
      if (longest !== null && Number(sub.durationMinutes) === longest) {
        item.classList.add("longest-step");
      }
      list.appendChild(item);
    });
    container.appendChild(list);
    const total = Number.isFinite(Number(task.chartDurationMinutes))
      ? Number(task.chartDurationMinutes)
      : computeTotalChartDuration(task.subTasks);
    const totalLabel = document.createElement("div");
    totalLabel.className = "chart-total";
    totalLabel.textContent = `Total duration: ${formatDuration(total)}`;
    container.appendChild(totalLabel);
    return container;
  }

  function refreshAfterSubTaskChange(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    persist();
    const focusActive = !$("focus").classList.contains("hidden");
    if (focusActive) {
      const currentFocusTask = focusQueue[0];
      if ((resolvedIndex !== -1 && currentFocusTaskIndex === resolvedIndex)
        || (options.taskId && currentFocusTask && currentFocusTask.id === options.taskId)) {
        renderFocusTask(task, resolvedIndex);
      }
    }
    if (!focusActive && !options.focusOnly) {
      updateUI();
    }
  }

  function startSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    sub.startTime = new Date().toISOString();
    sub.completed = false;
    sub.completionTime = null;
    sub.durationMinutes = null;
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function toggleSubTaskCompletion(taskIndex, subIndex, isCompleted, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    if (isCompleted) {
      if (!sub.startTime) {
        sub.startTime = new Date().toISOString();
      }
      sub.completed = true;
      sub.completionTime = new Date().toISOString();
      sub.durationMinutes = calculateDurationMinutes(sub.startTime, sub.completionTime) ?? 0;
      stopTimerForSubTask(sub.id);
    } else {
      sub.completed = false;
      sub.completionTime = null;
      sub.durationMinutes = null;
    }
    const nextOptions = { ...options, taskId: task.id, subId: sub.id };
    refreshAfterSubTaskChange(resolvedIndex, nextOptions);
  }

  function editSubTaskName(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const newName = prompt("Rename step", sub.name);
    if (!newName) return;
    sub.name = newName.trim();
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function removeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !Array.isArray(task.subTasks)) return;
    if (!confirm("Remove this step?")) return;
    const removed = task.subTasks.splice(resolvedSubIndex, 1);
    if (removed.length) {
      stopTimerForSubTask(removed[0].id);
    }
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function addSubTaskToTask(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    const name = prompt("New step name");
    if (!name) return;
    const base = computePriority({ ...task, subTasks: [] });
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.subTasks.push(createSubTask(name.trim(), base));
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function renderChartTask(task, taskIndex) {
    const container = document.createElement("div");
    container.style.width = "100%";
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No steps configured.";
      container.appendChild(empty);
      return container;
    }
    const progressElement = createProgressElement(task);
    if (progressElement) {
      container.appendChild(progressElement);
    }
    task.subTasks.forEach((sub, subIndex) => {
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { focusOnly: true, taskId: task.id, subId: sub.id });

      const nameSpan = document.createElement("span");
      nameSpan.className = "subtask-name";
      nameSpan.textContent = sub.name;

      const actions = document.createElement("div");
      actions.className = "subtask-actions";

      const startBtn = document.createElement("button");
      startBtn.textContent = sub.startTime ? "Restart" : "Start";
      startBtn.title = "Start or restart timer";
      startBtn.onclick = () => startSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(startBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Rename step";
      editBtn.onclick = () => editSubTaskName(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "üóëÔ∏è";
      deleteBtn.title = "Remove step";
      deleteBtn.onclick = () => removeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(deleteBtn);

      const timer = document.createElement("span");
      timer.className = "timer-label";
      trackTimer(sub, timer);

      row.appendChild(chk);
      row.appendChild(nameSpan);
      row.appendChild(actions);
      row.appendChild(timer);
      container.appendChild(row);
    });

    const controls = document.createElement("div");
    controls.className = "chart-step-controls";

    const addBtn = document.createElement("button");
    addBtn.textContent = "‚ûï Add Step";
    addBtn.onclick = () => addSubTaskToTask(taskIndex, { taskId: task.id });
    controls.appendChild(addBtn);

    const resetTimersBtn = document.createElement("button");
    resetTimersBtn.textContent = "‚è±Ô∏è Reset Timers";
    resetTimersBtn.onclick = () => {
      task.subTasks.forEach(sub => {
        stopTimerForSubTask(sub.id);
        sub.startTime = null;
        sub.completionTime = null;
        sub.durationMinutes = null;
        sub.completed = false;
      });
      refreshAfterSubTaskChange(taskIndex, { focusOnly: true, taskId: task.id });
    };
    controls.appendChild(resetTimersBtn);

    container.appendChild(controls);

    if (task.subTasks.every(sub => sub.completed)) {
      container.appendChild(renderChartSummary(task));
    }

    return container;
  }

  function renderSimpleSubTasks(task, taskIndex) {
    const container = document.createElement("div");
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      container.textContent = "No sub-tasks for this task.";
      return container;
    }
    const completedCount = task.subTasks.filter(sub => sub.completed).length;
    const progressSummary = document.createElement("div");
    progressSummary.className = "task-progress";
    progressSummary.textContent = `${completedCount}/${task.subTasks.length} steps done`;
    container.appendChild(progressSummary);
    task.subTasks.forEach((sub, subIndex) => {
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");
      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { taskId: task.id, subId: sub.id });
      const label = document.createElement("span");
      label.className = "subtask-name";
      label.textContent = sub.name;
      row.appendChild(chk);
      row.appendChild(label);
      container.appendChild(row);
    });
    return container;
  }

  function renderFocusTask(task, taskIndex) {
    const subTaskView = $("subTaskView");
    if (!subTaskView) return;
    let resolvedIndex = taskIndex;
    if ((resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && task) {
      resolvedIndex = tasks.findIndex(t => t.id === task.id);
    }
    const referenceTask = (resolvedIndex !== undefined && resolvedIndex !== null && resolvedIndex >= 0)
      ? tasks[resolvedIndex]
      : task;
    currentFocusTaskIndex = resolvedIndex;
    subTaskView.innerHTML = "";
    clearRunningTimers();
    let createdDefaults = false;
    if (isChartTask(referenceTask)) {
      createdDefaults = ensureChartSubTasks(referenceTask);
    }
    if (createdDefaults) {
      updateChartDurationForTask(referenceTask);
      referenceTask.priority = computePriority(referenceTask);
      persist();
    }
    const content = isChartTask(referenceTask)
      ? renderChartTask(referenceTask, resolvedIndex)
      : renderSimpleSubTasks(referenceTask, resolvedIndex);
    subTaskView.appendChild(content);
  }

  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function calculateDaysSince(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = today.getTime() - parsed.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  }

  function calculateDaysUntil(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = parsed.getTime() - today.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  }

  function isDateInCurrentMonth(dateString) {
    if (!dateString) return false;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return false;
    const today = new Date();
    return parsed.getFullYear() === today.getFullYear()
      && parsed.getMonth() === today.getMonth();
  }

  function getUrgencyDescriptor(value) {
    const options = getScaleOptions("urgency", currentScaleDescriptorCategory);
    const option = options.find(opt => Number(opt.value) === Number(value));
    return option ? option.text : null;
  }

  function getSuggestedUrgency(days) {
    if (days === null || days === undefined || Number.isNaN(days)) return 3;
    if (days < 0) return 3;
    if (days >= 90 && days <= 95) return 5;
    if (days > 95) return 2;
    if (days >= 30 && days < 90) return 1;
    if (days >= 2 && days <= 4) return 4;
    if (days < 30) return 3;
    return 3;
  }

  function updateChartAgeDisplay(days) {
    const display = $("chartAgeDisplay");
    if (!display) return;
    if (days === null || days === undefined) {
      display.textContent = "";
      return;
    }
    if (days < 0) {
      display.textContent = `Service date is ${Math.abs(days)} day(s) in the future.`;
      return;
    }
    display.textContent = `Chart age: ${days} day(s) since visit.`;
  }

  function updateUrgencyHint(suggested) {
    const hint = $("urgencyHint");
    const urgencyField = $("urgency");
    if (!hint || !urgencyField) return;
    const current = Number(urgencyField.value || 3);
    const suggestedDescriptor = getUrgencyDescriptor(suggested);
    const currentDescriptor = getUrgencyDescriptor(current);
    if (!suggestedDescriptor) {
      hint.textContent = currentDescriptor ? `Urgency set to ${currentDescriptor}.` : "";
      return;
    }
    if (current !== suggested) {
      hint.textContent = `Suggested: ${suggestedDescriptor}. (Current: ${currentDescriptor || current})`;
    } else {
      hint.textContent = `Suggested: ${suggestedDescriptor}.`;
    }
  }

  function updateDerivedFields() {
    const dateField = $("dateOfService");
    if (!dateField) return;
    const value = dateField.value;
    const days = calculateDaysSince(value);
    derivedDaysSinceVisit = days;
    updateChartAgeDisplay(days);
    const suggested = getSuggestedUrgency(days);
    const urgencyField = $("urgency");
    if (urgencyField && (urgencyAuto || !urgencyField.value)) {
      urgencyField.value = String(suggested);
    }
    updateUrgencyHint(suggested);
  }

  function setDefaultFieldValues() {
    const nameField = $("name");
    if (nameField) nameField.value = "";
    const categoryField = $("taskCategory");
    if (categoryField) categoryField.value = "General";
    const authorField = $("authorType");
    if (authorField) authorField.value = "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = "Non-Complex";
    const visitField = $("visitType");
    if (visitField) visitField.value = "Follow-Up";
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = "General Clinic";
    NUMERIC_SCALE_FIELDS.forEach(id => {
      const field = $(id);
      if (field) field.value = "1";
    });
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = "3";
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = "1";
    const dueDateField = $("dueDate");
    if (dueDateField) dueDateField.value = "";
    const subField = $("initialSubTasks");
    if (subField) subField.value = "";
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.value = formatDateForInput(new Date());
    }
    derivedDaysSinceVisit = calculateDaysSince($("dateOfService")?.value || null);
    urgencyAuto = true;
    updateDerivedFields();
    handleCategoryChange($("taskCategory")?.value);
  }

  let tasks = [];
  let templates = [];
  let focusQueue = [];
  let editingTaskId = null;
  let focusTimerId = null;
  let focusTimerStart = null;
  let focusTimerLastPing = null;
  let focusSoundEnabled = true;
  let focusAudioContext = null;

  function clearFormFields() {
    setDefaultFieldValues();
  }

  function toggleEditMode(isEditing) {
    const addBtn = $("addTaskBtn");
    const saveBtn = $("saveUpdateBtn");
    const cancelBtn = $("cancelEditBtn");
    if (!addBtn || !saveBtn || !cancelBtn) return;
    addBtn.classList.toggle("hidden", isEditing);
    saveBtn.classList.toggle("hidden", !isEditing);
    cancelBtn.classList.toggle("hidden", !isEditing);
  }

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function clampScale(value, fallback = 1) {
    const base = toNumber(value, fallback);
    return Math.min(5, Math.max(1, base));
  }

  function normalizePatientType(value) {
    const normalized = (value || "").toString().toLowerCase();
    return normalized === "complex" ? "Complex" : "Non-Complex";
  }

  function getPatientTypeWeight(patientType) {
    return normalizePatientType(patientType) === "Complex" ? 1.2 : 1;
  }

  function normalizeVisitType(value) {
    const normalized = (value || "").toString().toLowerCase();
    if (normalized === "establish" || normalized === "establish care") return "Establish Care";
    if (normalized === "well-child" || normalized === "well child visit") return "Well Child Visit";
    if (normalized === "acute" || normalized === "acute visit") return "Acute Visit";
    return "Follow-Up";
  }

  function getVisitTypeWeight(visitType) {
    const normalized = normalizeVisitType(visitType);
    if (normalized === "Establish Care") return 1.3;
    if (normalized === "Well Child Visit") return 1.1;
    if (normalized === "Acute Visit") return 0.9;
    return 1;
  }

  function normalizeClinicSite(value) {
    const normalized = (value || "").toString().toLowerCase().replace(/[‚Äô]/g, "'").trim();
    if (normalized.includes("cranio")) return "Craniofacial Clinic";
    if (normalized.includes("pj")) return "St PJ‚Äôs Shelter";
    if (normalized.includes("general")) return "General Clinic";
    return "General Clinic";
  }

  function isSameLocalDay(dateA, dateB) {
    if (!(dateA instanceof Date) || !(dateB instanceof Date)) return false;
    if (Number.isNaN(dateA.getTime()) || Number.isNaN(dateB.getTime())) return false;
    return dateA.getFullYear() === dateB.getFullYear()
      && dateA.getMonth() === dateB.getMonth()
      && dateA.getDate() === dateB.getDate();
  }

  function getSameDayBonus(clinicSite, createdAt) {
    const normalizedClinic = normalizeClinicSite(clinicSite);
    if (normalizedClinic !== "St PJ‚Äôs Shelter" && normalizedClinic !== "Craniofacial Clinic") {
      return 1;
    }
    if (!createdAt) return 1;
    const createdDate = new Date(createdAt);
    if (Number.isNaN(createdDate.getTime())) return 1;
    const now = new Date();
    return isSameLocalDay(createdDate, now) ? 2 : 1;
  }

  function computeRawPriorityScore(t) {
    const importance = clampScale(t.importance, 1);
    const urgency = clampScale(t.urgency, 3);
    const novelty = clampScale(t.novelty, 1);
    const interest = clampScale(t.interest, 1);
    const pressure = clampScale(t.externalPressure, 1);
    const timeToStart = clampScale(t.timeToStart, 1);
    const difficulty = clampScale(t.difficulty, 1);
    const dopamine = novelty + interest;
    const friction = (6 - timeToStart) + (6 - difficulty);
    const baseScore = (importance * 2)
         + (urgency * 2)
         + (dopamine * 2)
         + (pressure * 5)
         + (friction * 1.5);
    const patientWeight = getPatientTypeWeight(t.patientType);
    const visitWeight = getVisitTypeWeight(t.visitType);
    const sameDayBonus = getSameDayBonus(t.clinicSite, t.createdAt);
    return baseScore * patientWeight * visitWeight * sameDayBonus;
  }

  function computeTimeWeight(task) {
    if (!task) return 1;
    const isChart = isChartTask(task);
    const parsedDays = Number(task.daysSinceVisit);
    const daysSince = Number.isFinite(parsedDays)
      ? parsedDays
      : (task.dateOfService ? calculateDaysSince(task.dateOfService) : null);
    const daysUntilDue = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
    const currentMonth = isDateInCurrentMonth(task.dateOfService)
      || isDateInCurrentMonth(task.dueDate);

    if (!isChart) {
      if (daysUntilDue !== null && Number.isFinite(daysUntilDue) && daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.2;
      }
      return 1.0;
    }

    if (daysSince !== null && Number.isFinite(daysSince)) {
      if (daysSince > 95) return 0.5;
      if (daysSince >= 90 && daysSince <= 95) return 2.0;
      if (daysSince >= 0 && daysSince < 3) return 1.8;
      if (daysSince >= 3 && currentMonth) return 1.3;
    }

    if (daysUntilDue !== null && Number.isFinite(daysUntilDue)) {
      if (daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.8;
      }
      if (daysUntilDue < 0 && daysSince === null) {
        return currentMonth ? 1.3 : 1.0;
      }
      if (currentMonth) {
        return 1.3;
      }
    }

    return 1.0;
  }

  function computePriority(t) {
    const weightedBase = computeRawPriorityScore(t) * computeTimeWeight(t);
    if (Array.isArray(t.subTasks) && t.subTasks.length) {
      const remaining = t.subTasks.filter(s => !s.completed);
      if (remaining.length === 0) return 0;
      const total = remaining.reduce((sum, s) => {
        const value = Number(s.priority);
        return Number.isFinite(value) ? sum + value : sum + weightedBase;
      }, 0);
      return total / remaining.length;
    }
    return weightedBase;
  }

  function recalcTaskPriority(task) {
    if (!task) return task;
    task.authorType = task.authorType || "attending";
    task.patientType = normalizePatientType(task.patientType);
    task.visitType = normalizeVisitType(task.visitType);
    task.clinicSite = normalizeClinicSite(task.clinicSite);
    task.dateOfService = task.dateOfService || null;
    task.createdAt = task.createdAt || task.addedAt || new Date().toISOString();
    if (task.category === "Charts") task.category = "Chart";
    if (task.dateOfService) {
      task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    } else {
      const parsedDays = Number(task.daysSinceVisit);
      task.daysSinceVisit = (task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === "" || !Number.isFinite(parsedDays))
        ? null
        : parsedDays;
    }
    task.urgency = clampScale(task.urgency, 3);
    task.importance = clampScale(task.importance, 1);
    task.novelty = clampScale(task.novelty, 1);
    task.interest = clampScale(task.interest, 1);
    task.externalPressure = clampScale(task.externalPressure, 1);
    task.timeToStart = clampScale(task.timeToStart, 1);
    task.difficulty = clampScale(task.difficulty, 1);
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.completedAt = task.completedAt || null;
    if (task.completed && !task.completedAt) {
      task.completedAt = null;
    }
    if (task.completedAt && !task.completed) {
      task.completed = true;
    } else {
      task.completed = Boolean(task.completed);
    }
    if (isChartTask(task) && task.useChartTemplate === undefined) {
      const defaults = new Set(buildChartSteps(task.authorType).map(step => step.toLowerCase()));
      const hasCustomSteps = Array.isArray(task.subTasks)
        ? task.subTasks.some(sub => !defaults.has(String(sub?.name || "").toLowerCase()))
        : false;
      task.useChartTemplate = !hasCustomSteps;
    }
    const baseRaw = computeRawPriorityScore({ ...task, subTasks: [] });
    const timeWeight = computeTimeWeight(task);
    task.timeWeight = timeWeight;
    const base = baseRaw * timeWeight;
    if (isChartTask(task)) {
      ensureChartSubTasks(task, { basePriority: base });
    }
    if (task.subTasks.length) {
      task.subTasks = task.subTasks.map(sub => {
        const normalizedSub = normalizeSubTask(sub, base);
        normalizedSub.priority = base;
        return normalizedSub;
      });
    }
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    return task;
  }

  function persist() {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }

  // create a new task with optional sub‚Äëtasks from textarea
  function addTask() {
    const name = $("name").value.trim();
    if (!name) return;
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const dateField = $("dateOfService");
    const dateOfService = dateField && dateField.value ? dateField.value : null;
    const daysSinceVisit = calculateDaysSince(dateOfService);
    const task = {
      id: Date.now().toString(),
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      dateOfService,
      daysSinceVisit,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1),
      dueDate: $("dueDate").value || null,
      completed: false,
      completedAt: null,
      createdAt: new Date().toISOString(),
      addedAt: new Date().toISOString(),
      subTasks: []
    };

    // base priority for sub‚Äëtasks
    const basePriority = computePriority({ ...task, subTasks: [] });

    // parse sub‚Äëtasks from textarea (one per line)
    const subLines = $("initialSubTasks").value.split('\n')
      .map(l => l.trim())
      .filter(Boolean);
    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    }
    task.subTasks = subLines.map(line => createSubTask(line, basePriority));

    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }

    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    persist();

    clearFormFields();
    toggleEditMode(false);
    editingTaskId = null;
    updateUI();
  }

  function startEditTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    editingTaskId = taskId;
    $("name").value = task.name;
    $("taskCategory").value = task.category || "General";
    handleCategoryChange(task.category || "General");
    $("importance").value = String(task.importance || 1);
    $("urgency").value = String(task.urgency || 3);
    $("novelty").value = String(task.novelty || 1);
    $("interest").value = String(task.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = task.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(task.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(task.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(task.clinicSite);
    const dateField = $("dateOfService");
    if (dateField) {
      if (task.dateOfService) {
        dateField.value = task.dateOfService;
      } else {
        dateField.value = formatDateForInput(new Date());
      }
    }
    urgencyAuto = false;
    derivedDaysSinceVisit = task.daysSinceVisit ?? calculateDaysSince($("dateOfService")?.value || null);
    updateDerivedFields();
    const pressureField = $("externalPressure");
    if (pressureField) {
      const pressureValue = task.externalPressure;
      pressureField.value = String(pressureValue || 1);
    }
    $("timeToStart").value = String(task.timeToStart || 1);
    $("difficulty").value = String(task.difficulty || 1);
    $("dueDate").value = task.dueDate || "";
    const subs = Array.isArray(task.subTasks) ? task.subTasks.map(sub => sub.name).join("\n") : "";
    $("initialSubTasks").value = subs;
    toggleEditMode(true);
    $("name").focus();
  }

  function saveTaskUpdate() {
    if (!editingTaskId) return;
    const idx = tasks.findIndex(t => t.id === editingTaskId);
    if (idx === -1) return;
    const name = $("name").value.trim();
    if (!name) return;

    const task = tasks[idx];
    task.name = name;
    task.category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    task.authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    task.patientType = normalizePatientType(patientField ? patientField.value : task.patientType);
    const visitField = $("visitType");
    task.visitType = normalizeVisitType(visitField ? visitField.value : task.visitType);
    const clinicField = $("clinicSite");
    task.clinicSite = normalizeClinicSite(clinicField ? clinicField.value : task.clinicSite);
    const dateField = $("dateOfService");
    task.dateOfService = dateField && dateField.value ? dateField.value : null;
    task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    task.importance = clampScale($("importance").value, 1);
    task.urgency = clampScale($("urgency").value, 3);
    task.novelty = clampScale($("novelty").value, 1);
    task.interest = clampScale($("interest").value, 1);
    task.externalPressure = clampScale($("externalPressure").value, 1);
    task.timeToStart = clampScale($("timeToStart").value, 1);
    task.difficulty = clampScale($("difficulty").value, 1);
    task.dueDate = $("dueDate").value || null;
    task.updatedAt = new Date().toISOString();

    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);

    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    } else if (task.useChartTemplate !== undefined) {
      delete task.useChartTemplate;
    }

    const basePriority = computePriority({ ...task, subTasks: [] });
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks.slice() : [];
    const newSubTasks = subLines.map(line => {
      const matchIndex = existingSubs.findIndex(sub => sub.name === line);
      if (matchIndex !== -1) {
        const existing = existingSubs.splice(matchIndex, 1)[0];
        const normalizedExisting = normalizeSubTask(existing, basePriority);
        normalizedExisting.name = line;
        normalizedExisting.priority = basePriority;
        return normalizedExisting;
      }
      return createSubTask(line, basePriority);
    });

    task.subTasks = newSubTasks;
    if (isChartTask(task)) {
      const defaultsChanged = ensureChartSubTasks(task, { basePriority });
      if (defaultsChanged) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    persist();

    toggleEditMode(false);
    clearFormFields();
    editingTaskId = null;
    updateUI();
  }

  function cancelEdit() {
    editingTaskId = null;
    toggleEditMode(false);
    clearFormFields();
  }

  // render filter bar
  function renderCategoryFilter() {
    const bar = $("categoryFilter");
    bar.innerHTML = "";
    ["All", ...categories].forEach(cat => {
      const btn = document.createElement("button");
      btn.textContent = cat;
      btn.className = (cat === activeCategory) ? "active" : "";
      btn.onclick = () => { activeCategory = cat; updateUI(); };
      bar.appendChild(btn);
    });
  }

  // render progress per category
  function renderCategoryProgress() {
    const cont = $("categoryProgress");
    cont.innerHTML = "";
    categories.forEach(cat => {
      const total = tasks.filter(t => t.category === cat).length;
      if (total === 0) return;
      const done = tasks.filter(t => t.category === cat && isTaskCompleted(t)).length;
      const percent = (done / total) * 100;

      const line = document.createElement("div");
      line.className = "line";
      const title = document.createElement("span");
      title.textContent = `${cat}: ${done}/${total} complete`;
      line.appendChild(title);

      const bar = document.createElement("div");
      bar.className = "bar";
      const fill = document.createElement("span");
      fill.className = "fill";
      fill.style.width = percent + "%";
      bar.appendChild(fill);

      line.appendChild(bar);
      cont.appendChild(line);
    });
  }

  function buildTaskDescriptors(task) {
    const descriptors = [];
    if (task.patientType) descriptors.push(`Patient: ${task.patientType}`);
    if (task.visitType) descriptors.push(`Visit: ${task.visitType}`);
    if (task.clinicSite) descriptors.push(task.clinicSite);
    if (task.urgency) descriptors.push(`Urgency ${task.urgency}`);
    return descriptors;
  }

  function getSubTaskProgress(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.length;
    const completed = task.subTasks.filter(sub => sub.completed).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    const label = `${completed} of ${total} steps done`;
    return { total, completed, percent, label };
  }

  function createProgressElement(task) {
    const progressData = getSubTaskProgress(task);
    if (!progressData) return null;
    const container = document.createElement("div");
    container.className = "task-progress-group";

    const label = document.createElement("div");
    label.className = "task-progress";
    label.textContent = `${progressData.label} (${progressData.percent} %)`;
    container.appendChild(label);

    const meter = document.createElement("div");
    meter.className = "task-progress-meter";
    const fill = document.createElement("span");
    fill.className = "fill";
    fill.style.width = `${progressData.percent}%`;
    meter.appendChild(fill);
    container.appendChild(meter);

    return container;
  }

  function createMetaItem(text) {
    const span = document.createElement("span");
    span.textContent = text;
    return span;
  }

  function createTaskDetails(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const details = document.createElement("div");
    details.className = "task-details hidden";
    const heading = document.createElement("h5");
    heading.textContent = "Subtasks";
    details.appendChild(heading);
    const list = document.createElement("ul");
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      const marker = sub.completed ? "‚úì" : "‚Ä¢";
      item.textContent = `${marker} ${sub.name}`;
      list.appendChild(item);
    });
    details.appendChild(list);
    return details;
  }

  function renderTaskListCard(task, mode, timeBudgetMinutes = null) {
    const card = document.createElement("article");
    card.className = "task-card";
    if (mode === TASK_LIST_MODES.COMPLETED) {
      card.classList.add("is-completed");
    }

    const header = document.createElement("div");
    header.className = "task-card-header";

    const titleGroup = document.createElement("div");
    titleGroup.className = "task-card-title-group";

    const title = document.createElement("h4");
    title.className = "task-title";
    title.textContent = task.name;
    titleGroup.appendChild(title);

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const indicator = document.createElement("span");
      indicator.className = "task-complete-indicator";
      indicator.textContent = "‚úì Completed";
      titleGroup.appendChild(indicator);
    }

    header.appendChild(titleGroup);

    const actions = document.createElement("div");
    actions.className = "task-card-actions";

    if (mode === TASK_LIST_MODES.ACTIVE) {
      const startNowBtn = document.createElement("button");
      startNowBtn.textContent = "Start Now";
      startNowBtn.title = "Focus on this task";
      startNowBtn.onclick = () => startFocus(task.id);
      actions.appendChild(startNowBtn);

      const completeBtn = document.createElement("button");
      completeBtn.textContent = "Mark Done";
      completeBtn.title = "Complete task";
      completeBtn.onclick = () => markTaskDoneFromPeek(task.id);
      actions.appendChild(completeBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Edit task";
      editBtn.onclick = () => startEditTask(task.id);
      actions.appendChild(editBtn);
    }

    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "üóëÔ∏è";
    deleteBtn.title = "Delete task";
    deleteBtn.onclick = () => {
      if (!confirm("Delete this task?")) return;
      const idx = tasks.findIndex(t => t.id === task.id);
      if (idx !== -1) {
        if (editingTaskId === task.id) {
          cancelEdit();
        }
        tasks.splice(idx, 1);
        persist();
        updateUI();
      }
    };
    actions.appendChild(deleteBtn);

    header.appendChild(actions);
    card.appendChild(header);

    const descriptors = buildTaskDescriptors(task);
    if (descriptors.length) {
      const descriptorContainer = document.createElement("div");
      descriptorContainer.className = "task-descriptors";
      descriptors.forEach(text => {
        const span = document.createElement("span");
        span.textContent = text;
        descriptorContainer.appendChild(span);
      });
      card.appendChild(descriptorContainer);
    }

    const progress = createProgressElement(task);
    if (progress) {
      card.appendChild(progress);
    }

    const meta = document.createElement("div");
    meta.className = "task-meta";
    const metaItems = [];

    if (mode === TASK_LIST_MODES.ACTIVE) {
      metaItems.push(`Score ${task.priority.toFixed(1)}`);
      if (Number.isFinite(timeBudgetMinutes) && timeBudgetMinutes > 0) {
        const estimatedMinutes = estimateTaskMinutes(task);
        metaItems.push(`Est ${estimatedMinutes} min`);
      }
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
      if (task.addedAt) {
        const formatted = formatDateTime(task.addedAt);
        if (formatted) metaItems.push(`Added ${formatted}`);
      }
      const age = task.dateOfService ? calculateDaysSince(task.dateOfService) : (
        task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === ""
          ? null
          : Number(task.daysSinceVisit)
      );
      if (age !== null && Number.isFinite(age)) {
        const ageLabel = age < 0 ? `${Math.abs(age)} day(s) until visit` : `${age} day(s) since visit`;
        metaItems.push(ageLabel);
      }
      if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
        metaItems.push(`Chart time ${formatDuration(Number(task.chartDurationMinutes))}`);
      }
    } else {
      const completedAt = formatDateTime(getCompletionTimestamp(task));
      metaItems.push(`Completed ${completedAt || "--"}`);
      const totalDuration = getTaskTotalDuration(task);
      metaItems.push(`Duration ${formatDuration(totalDuration)}`);
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
    }

    metaItems.forEach(text => meta.appendChild(createMetaItem(text)));
    if (metaItems.length) {
      card.appendChild(meta);
    }

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const details = createTaskDetails(task);
      if (details) {
        const toggle = document.createElement("button");
        toggle.className = "task-detail-toggle";
        toggle.textContent = "View details";
        toggle.onclick = () => {
          const isHidden = details.classList.contains("hidden");
          if (isHidden) {
            details.classList.remove("hidden");
            toggle.textContent = "Hide details";
          } else {
            details.classList.add("hidden");
            toggle.textContent = "View details";
          }
        };
        card.appendChild(toggle);
        card.appendChild(details);
      }
    }

    return card;
  }

  // main UI update
  function updateUI() {
    tasks = tasks.map(recalcTaskPriority);
    persist();
    renderCategoryFilter();
    renderCategoryProgress();

    const taskList = $("taskList");
    taskList.innerHTML = "";

    const taskViewSelect = $("taskViewMode");
    if (taskViewSelect) {
      taskViewSelect.value = taskListMode;
    }

    if (taskListMode !== TASK_LIST_MODES.ACTIVE) {
      showAllActiveTasks = false;
    }

    const eligibleTasks = tasks.filter(t => activeCategory === "All" || t.category === activeCategory);
    const remaining = eligibleTasks.filter(t => !isTaskCompleted(t));
    $("startBtn").disabled = remaining.length === 0;
    const timeBudget = getSelectedTimeBudget();
    const hasTimeBudget = Number.isFinite(timeBudget);
    const sortedRemaining = [...remaining].sort((a, b) => b.priority - a.priority);
    const budgetFilteredRemaining = hasTimeBudget
      ? sortedRemaining.filter(task => estimateTaskMinutes(task) <= timeBudget)
      : sortedRemaining;

    const toggleBtn = $("showAllToggle");
    if (toggleBtn) {
      if (taskListMode !== TASK_LIST_MODES.ACTIVE || budgetFilteredRemaining.length <= 3) {
        toggleBtn.classList.add("hidden");
        toggleBtn.textContent = "Show All";
      } else {
        toggleBtn.classList.remove("hidden");
        toggleBtn.textContent = showAllActiveTasks ? "Show Top 3" : "Show All";
      }
    }

    let displayTasks = [];
    if (taskListMode === TASK_LIST_MODES.COMPLETED) {
      displayTasks = eligibleTasks
        .filter(t => isTaskCompleted(t))
        .sort((a, b) => {
          const aDate = getCompletionTimestamp(a) ? new Date(getCompletionTimestamp(a)).getTime() : 0;
          const bDate = getCompletionTimestamp(b) ? new Date(getCompletionTimestamp(b)).getTime() : 0;
          return bDate - aDate;
        });
    } else {
      const pool = budgetFilteredRemaining;
      if (pool.length <= 3 || showAllActiveTasks) {
        displayTasks = pool;
      } else {
        displayTasks = pool.slice(0, 3);
      }
    }

    if (!displayTasks.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      if (taskListMode === TASK_LIST_MODES.ACTIVE && hasTimeBudget && remaining.length > 0 && budgetFilteredRemaining.length === 0) {
        empty.textContent = "No tasks fit the selected time budget.";
      } else {
        empty.textContent = taskListMode === TASK_LIST_MODES.COMPLETED
          ? "No completed tasks yet."
          : "No active tasks to show.";
      }
      taskList.appendChild(empty);
    } else {
      displayTasks.forEach(task => {
        const card = renderTaskListCard(task, taskListMode, hasTimeBudget ? timeBudget : null);
        taskList.appendChild(card);
      });
    }

    // tasks due today
    const dueTodayList = $("dueTodayList");
    dueTodayList.innerHTML = "";
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const today = now.toISOString().split("T")[0];

    tasks.forEach(task => {
      if (isTaskCompleted(task)) return;
      if (activeCategory !== "All" && task.category !== activeCategory) return;

      const fallbackDueDate = (!task.dueDate && task.dateOfService)
        ? (() => {
            const dt = new Date(`${task.dateOfService}T00:00:00`);
            if (!Number.isNaN(dt.getTime())) {
              dt.setDate(dt.getDate() + 3);
              return dt.toISOString().split("T")[0];
            }
            return null;
          })()
        : null;

      if (task.dueDate === today || (fallbackDueDate && fallbackDueDate === today)) {
        const wrap = document.createElement("div");
        wrap.textContent = `${task.name} ‚Äî due today`;

        if (task.subTasks && task.subTasks.length) {
          const progressElement = createProgressElement(task);
          if (progressElement) {
            wrap.appendChild(progressElement);
          }
        }

        if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
          const totalRow = document.createElement("div");
          totalRow.className = "score";
          totalRow.textContent = `Chart time: ${formatDuration(Number(task.chartDurationMinutes))}`;
          wrap.appendChild(totalRow);
        }

        dueTodayList.appendChild(wrap);
      }
    });
  }

  function toggleShowAllActive() {
    if (taskListMode !== TASK_LIST_MODES.ACTIVE) return;
    showAllActiveTasks = !showAllActiveTasks;
    updateUI();
  }

  function startFocus(initialTaskId = null) {
    if (editingTaskId) cancelEdit();
    stopFocusTimer();
    $("capture").classList.add("hidden");
    $("focus").classList.remove("hidden");
    focusQueue = tasks.filter(t => !isTaskCompleted(t) && (activeCategory === "All" || t.category === activeCategory))
      .sort((a,b) => b.priority - a.priority);
    if (initialTaskId) {
      const targetIndex = focusQueue.findIndex(task => task.id === initialTaskId);
      if (targetIndex > 0) {
        const [selected] = focusQueue.splice(targetIndex, 1);
        focusQueue.unshift(selected);
      } else if (targetIndex === -1) {
        const directTask = tasks.find(t => t.id === initialTaskId && !isTaskCompleted(t));
        if (directTask) {
          focusQueue.unshift(directTask);
        }
      }
    }
    showNextTask();
  }

  function showNextTask() {
    const display = document.querySelector(".focus");
    const scoreView = $("scoreView");
    if (focusQueue.length === 0) {
      display.textContent = "‚úÖ All tasks complete!";
      scoreView.textContent = "";
      const subTaskView = $("subTaskView");
      if (subTaskView) subTaskView.innerHTML = "";
      clearRunningTimers();
      stopFocusTimer();
      currentFocusTaskIndex = null;
      return;
    }
    const current = focusQueue[0];
    display.textContent = current.name;
    startFocusTimer();
    const idx = tasks.findIndex(t => t.id === current.id);
    const task = idx !== -1 ? tasks[idx] : current;
    scoreView.textContent = `Score: ${task.priority.toFixed(1)}`;
    renderFocusTask(task, idx);
  }

  function completeTaskById(taskId, options = {}) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (task.completed) return false;
    const nowIso = new Date().toISOString();
    task.completed = true;
    task.completedAt = nowIso;
    updateChartDurationForTask(task);
    if (Array.isArray(task.subTasks)) {
      task.subTasks.forEach(sub => stopTimerForSubTask(sub.id));
    }
    persist();
    recordTaskCompletion(task);
    maybeShowEndOfDayAudit();
    if (!options.skipUI) {
      updateUI();
    }
    return true;
  }

  function markTaskDoneFromPeek(taskId) {
    const completed = completeTaskById(taskId);
    if (!completed) return;
    const wasCurrentFocus = focusQueue.length && focusQueue[0].id === taskId;
    focusQueue = focusQueue.filter(t => t.id !== taskId);
    if (wasCurrentFocus) {
      clearRunningTimers();
      stopFocusTimer();
    }
    const focusSection = $("focus");
    if (focusSection && !focusSection.classList.contains("hidden")) {
      showNextTask();
    }
  }

  function completeTask() {
    if (!focusQueue.length) return;
    const current = focusQueue[0];
    const completed = completeTaskById(current.id, { skipUI: true });
    clearRunningTimers();
    if (completed) {
      updateUI();
    }
    focusQueue.shift();
    showNextTask();
  }

  function backToCapture() {
    clearRunningTimers();
    stopFocusTimer();
    currentFocusTaskIndex = null;
    $("focus").classList.add("hidden");
    $("capture").classList.remove("hidden");
    updateUI();
  }

  function reset() {
    if (!confirm("Clear all tasks?")) return;
    cancelEdit();
    tasks = [];
    localStorage.removeItem("tasks");
    updateUI();
  }

  function saveAsTemplate() {
    const name = $("name").value.trim();
    if (!name) return alert("Task name is required");
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const template = {
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1)
    };
    templates.push(template);
    localStorage.setItem("templates", JSON.stringify(templates));
    renderTemplates();
  }

  function renderTemplates() {
    const container = $("templateButtons");
    container.innerHTML = "";
    const selectedCategory = $("taskCategory")?.value || "General";
    const matchingTemplates = templates
      .map((template, index) => ({ template, index }))
      .filter(({ template }) => (template.category || "General") === selectedCategory);

    if (!matchingTemplates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      container.appendChild(empty);
      return;
    }

    matchingTemplates.forEach(({ template: t, index: templateIndex }) => {
      const wrapper = document.createElement("div");
      const useBtn = document.createElement("button");
      useBtn.textContent = `üìã ${t.name}`;
      useBtn.onclick = () => {
        $("name").value = t.name;
        $("taskCategory").value = t.category || "General";
        handleCategoryChange(t.category || "General");
        $("importance").value = String(t.importance || 1);
        $("novelty").value = String(t.novelty || 1);
        $("interest").value = String(t.interest || 1);
        const authorField = $("authorType");
        if (authorField) authorField.value = t.authorType || "attending";
        const patientField = $("patientType");
        if (patientField) patientField.value = normalizePatientType(t.patientType);
        const visitField = $("visitType");
        if (visitField) visitField.value = normalizeVisitType(t.visitType);
        const clinicField = $("clinicSite");
        if (clinicField) clinicField.value = normalizeClinicSite(t.clinicSite);
        const urgencyField = $("urgency");
        if (urgencyField) urgencyField.value = String(t.urgency || 3);
        const pressureField = $("externalPressure");
        if (pressureField) {
          pressureField.value = String(t.externalPressure || 1);
        }
        $("timeToStart").value = String(t.timeToStart || 1);
        $("difficulty").value = String(t.difficulty || 1);
        const dateField = $("dateOfService");
        if (dateField) dateField.value = formatDateForInput(new Date());
        urgencyAuto = false;
        updateDerivedFields();
      };
      const editBtn = document.createElement("button");
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Edit template";
      editBtn.setAttribute("aria-label", "Edit template");
      editBtn.onclick = () => {
        const newName = prompt("Edit template name:", t.name);
        if (!newName) return;
        t.name = newName;
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "üóëÔ∏è";
      deleteBtn.title = "Delete template";
      deleteBtn.setAttribute("aria-label", "Delete template");
      deleteBtn.onclick = () => {
        if (!confirm("Delete this template?")) return;
        templates.splice(templateIndex, 1);
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      [useBtn, editBtn, deleteBtn].forEach(b => {
        b.style.marginRight = "0.3rem";
        b.style.fontSize = "0.9rem";
      });
      wrapper.appendChild(useBtn);
      wrapper.appendChild(editBtn);
      wrapper.appendChild(deleteBtn);
      container.appendChild(wrapper);
    });
  }

  function updateBillingReminder() {
    const reminder = $("billingReminder");
    if (!reminder) return;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 95);
    const formatted = cutoff.toLocaleDateString(undefined, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
    reminder.textContent = `Make sure that "all charts from ${formatted} must be completed today to be eligible for billing".`;
  }

  function registerFieldListeners() {
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.addEventListener("change", () => {
        updateDerivedFields();
      });
    }
    const categoryField = $("taskCategory");
    if (categoryField) {
      categoryField.addEventListener("change", event => {
        handleCategoryChange(event.target.value);
      });
    }
    const urgencyField = $("urgency");
    if (urgencyField) {
      urgencyField.addEventListener("change", () => {
        urgencyAuto = false;
        updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
      });
    }
  }

  function registerTaskListModeControl() {
    const modeSelect = $("taskViewMode");
    if (!modeSelect) return;
    modeSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_LIST_MODES.ACTIVE).toLowerCase();
      taskListMode = value === TASK_LIST_MODES.COMPLETED ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      showAllActiveTasks = false;
      updateUI();
    });
  }

  function registerTimeBudgetControl() {
    const budgetSelect = $("timeBudget");
    if (!budgetSelect) return;
    budgetSelect.addEventListener("change", () => {
      updateUI();
    });
  }

  window.addEventListener('DOMContentLoaded', () => {
    initializeChartFields();
    registerFieldListeners();
    registerTaskListModeControl();
    registerTimeBudgetControl();
    setDefaultFieldValues();
    updateBillingReminder();
    initializeSoundPreference();
    const saved = localStorage.getItem("tasks");
    if (saved) {
      tasks = JSON.parse(saved).map(task => {
        const normalizedTask = {
          ...task,
          authorType: task.authorType || "attending",
          patientType: normalizePatientType(task.patientType),
          visitType: normalizeVisitType(task.visitType),
          clinicSite: normalizeClinicSite(task.clinicSite),
          dateOfService: task.dateOfService || null,
          createdAt: task.createdAt || task.addedAt || new Date().toISOString()
        };
        if (normalizedTask.dateOfService) {
          normalizedTask.daysSinceVisit = calculateDaysSince(normalizedTask.dateOfService);
        }
        return recalcTaskPriority(normalizedTask);
      });
    }
    const savedTemplates = localStorage.getItem("templates");
    if (savedTemplates) {
      templates = JSON.parse(savedTemplates).map(template => ({
        ...template,
        authorType: template.authorType || "attending",
        patientType: normalizePatientType(template.patientType),
        visitType: normalizeVisitType(template.visitType),
        clinicSite: normalizeClinicSite(template.clinicSite)
      }));
    }
    renderTemplates();
    updateUI();
    updateDerivedFields();
  });
  </script>
</body>
</html>
