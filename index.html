<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tasker 5000</title>
  <link rel="stylesheet" href="styles/main.css">

</head>
<body>
  <div id="toastContainer" class="toast-container" aria-live="polite"></div>

  <section
    id="meltdownShield"
    class="meltdown-shield hidden"
    aria-live="polite"
    aria-label="Meltdown Shield Panel"
    aria-hidden="true"
  >
    <h4 class="meltdown-shield-header">üõ°Ô∏è‚ÄØMeltdown Shield Activated</h4>
    <div id="meltdownShieldPrompt" class="meltdown-shield-prompt" aria-live="assertive"></div>
    <ul id="meltdownShieldSteps"></ul>
    <div class="meltdown-shield-actions">
      <button id="meltdownShieldNext" type="button">‚ñ∂Ô∏è‚ÄØNext</button>
      <button type="button" onclick="deactivateShield()">‚ùå‚ÄØClose</button>
    </div>
  </section>

  <section id="capture">
    <div class="app-shell">
      <header class="app-header">
        <div class="app-header__row app-header__row--top">
          <p id="headerDate" class="app-header__date"></p>
          <div class="app-header__actions">
            <p class="billing-reminder" id="billingReminder"></p>
            <button
              id="settingsToggle"
              class="settings-trigger"
              type="button"
              aria-haspopup="true"
              aria-expanded="false"
              aria-controls="settingsMenu"
              title="Open settings"
            >
              ‚öôÔ∏è
            </button>
          </div>
        </div>
        <div id="settingsMenu" class="settings-menu" aria-hidden="true">
          <div class="settings-menu__section">
            <label class="settings-menu__toggle" for="routineHapticsToggle">
              <span>Enable haptic nudges</span>
              <input type="checkbox" id="routineHapticsToggle" />
            </label>
          </div>
          <button type="button" class="settings-menu__item" id="settingsTemplates">
            <span aria-hidden="true">üß©</span>
            <span>Templates</span>
          </button>
        </div>
        <p id="headerSubtitle" class="app-header__subtitle"></p>
        <div class="app-header__row app-header__row--title">
          <h1>Tasker 5000</h1>
        </div>
      </header>
  </section>
<!-- Legacy header block replaced by .focus-command-deck -->
<!--
<div class="starter-stack" id="starterStack">
  <div class="starter-micro-header" role="banner">
    <button
      id="nextTaskActionButton"
      class="btn hero-cta start-action next-task-start"
      type="button"
      aria-describedby="nextTaskActionHint"
    >
      Start 5-min
      <span id="nextTaskActionHint" class="visually-hidden">Long-press for quick capture.</span>
    </button>
    <div id="nextTaskChips" class="starter-fit-chips" aria-live="polite"></div>
    <button
      id="rescueLaunchButton"
      class="btn starter-rescue"
      type="button"
      aria-haspopup="dialog"
      aria-controls="sosOverlay"
      aria-expanded="false"
    >
      üõü Rescue
    </button>
  </div>
</div>
-->
<section class="focus-command-deck" id="focus-command-deck" aria-label="Focus Command Deck">
  <div class="focus-top">
    <h2 class="focus-title">‚öîÔ∏è Focus Command Deck</h2>
    <div class="focus-meter" aria-label="Momentum Meter">
      <div class="focus-meter__header">
        <span class="meter-label">Momentum</span>
        <small class="meter-note">
          <span class="cm-done">12</span> / <span class="cm-total">57</span> complete
        </small>
      </div>
      <div class="progress-strip">
        <span class="cm-fill" style="width:21%"></span>
        <span class="cm-float" aria-live="polite">21% complete</span>
      </div>
    </div>
  </div>

  <div class="focus-actions">
    <button
      id="nextTaskActionButton"
      class="hero-cta start-btn start-action"
      type="button"
      data-action="start-5"
      aria-describedby="nextTaskActionHint"
    >
      ‚ñ∂ Start 5-Min Sprint
      <span id="nextTaskActionHint" class="visually-hidden">Long-press for quick capture.</span>
    </button>
    <button
      id="rescueLaunchButton"
      class="btn-quiet rescue-btn"
      type="button"
      data-action="rescue"
      aria-haspopup="dialog"
      aria-controls="sosOverlay"
      aria-expanded="false"
    >
      üõü Rescue Mode
    </button>
    <button
      id="quickTaskShortcut"
      class="btn-quiet quick-task-shortcut"
      type="button"
      aria-controls="quickTasksCard"
    >
      ‚è© Quick Tasks
    </button>
    <button
      id="shredTopTaskButton"
      class="btn-quiet shred-top-task"
      type="button"
      aria-disabled="true"
      disabled
    >
      üî∞ shred Top Task
    </button>
  </div>

  <footer class="focus-footer">
    <p class="focus-micro">üí° Tip: Five minutes is all you need to start momentum.</p>
  </footer>
</section>

<nav class="quick-add-menu" aria-label="Quick add templates">
  <p class="quick-add-menu__label">Quick Add</p>
  <div class="quick-add-menu__buttons" role="group" aria-label="Quick add buttons">
    <button class="quick-add-button quick-add-button--plus" type="button" aria-label="Quick add new task">‚ûïÔ∏è</button>
    <button class="quick-add-button quick-add-button--cherry" type="button" aria-label="Quick add cherry template">üçí</button>
    <button class="quick-add-button quick-add-button--muscle" type="button" aria-label="Quick add muscle template">üí™</button>
    <button class="quick-add-button quick-add-button--unicorn" type="button" aria-label="Quick add unicorn template">ü¶Ñ</button>
    <button class="quick-add-button quick-add-button--home" type="button" aria-label="Quick add home template">üè°</button>
    <button class="quick-add-button quick-add-button--kiddo" type="button" aria-label="Quick add kiddo template">üßí</button>
  </div>
</nav>

        <section id="nextTaskCard" class="card next-task-card hidden" aria-live="polite">
          <header class="card-head next-focus-head">
            <div class="next-focus-head__titles">
              <h2 class="focus-title">Next focus</h2>
              <p class="next-focus-hint">
                Next best: <span id="focusLaunchHint">Add a task to unlock focus.</span>
              </p>
            </div>
            <span id="nextTaskScore" class="chip chip-muted next-task-fit hidden"></span>
          </header>
          <span id="focus-engine" class="zone-anchor" aria-hidden="true"></span>
          <p id="nextTaskName" class="next-task-name"></p>
          <p id="nextTaskSubstep" class="next-task-meta"></p>
          <p id="nextTaskEmpty" class="next-task-empty hidden">You're clear for now. Add what matters next.</p>
          <div class="next-best-inline">
            <div class="next-best-toolbar" role="toolbar" aria-label="Next best options">
              <button id="nextBestRefresh" class="btn btn-ghost next-best-refresh" type="button">Refresh</button>
              <button
                id="nextBestAdjustToggle"
                class="quick-pill"
                type="button"
                aria-expanded="false"
                aria-controls="nextBestControls"
              >
                Adjust
              </button>
              <button id="nextBestStuck" class="quick-pill" type="button">I'm stuck</button>
            </div>
            <div id="nextBestControls" class="next-best-controls" hidden aria-hidden="true">
              <div class="next-best-controls__form">
                <label for="nextBestTime">
                  Time available
                  <select id="nextBestTime">
                    <option value="10">10 minutes</option>
                    <option value="15" selected>15 minutes</option>
                    <option value="20">20 minutes</option>
                    <option value="30">30 minutes</option>
                  </select>
                </label>
                <div class="next-best-energy">
                  <label for="nextBestEnergy">Energy right now</label>
                  <input
                    id="nextBestEnergy"
                    data-field="energy-level"
                    type="range"
                    min="1"
                    max="5"
                    step="1"
                    value="3"
                    aria-label="Energy right now"
                  />
                  <div class="next-best-meter">
                    <div class="next-best-meter__fill" id="nextBestEnergyFill"></div>
                    <div class="next-best-meter__scale">
                      <span aria-hidden="true">low</span>
                      <span aria-hidden="true">max</span>
                    </div>
                  </div>
                </div>
                <label for="nextBestDeadline">
                  Deadline urgency
                  <select id="nextBestDeadline"></select>
                </label>
                <label for="nextBestSize">
                  Task size
                  <select id="nextBestSize">
                    <option value="any" selected>Any size</option>
                    <option value="small">Quick win (&lt; 15 min)</option>
                    <option value="medium">Medium (15‚Äì30 min)</option>
                    <option value="large">Deep work (&gt; 30 min)</option>
                  </select>
                </label>
                <fieldset class="nbt-frictions">
                  <legend class="visually-hidden">Friction filters</legend>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="context" />
                    Needs certain location
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="conversation" />
                    Needs another person
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="energy" />
                    Energy heavy
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="startup" />
                    High startup cost
                  </label>
                </fieldset>
              </div>
            </div>
            <div id="nextBestResults" class="next-best-results"></div>
            <p id="nextBestEmpty" class="next-best-empty hidden">Add a task to see your next best options.</p>
          </div>
        </section>
      
      <div class="momentum-zones">
        <section id="actionZone" class="momentum-zone" data-zone="action">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">‚ö°</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Action Zone</h2>
              <p class="zone-header__subtitle">Next best focus, active tasks, and due-today radar</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="tasks-zone" class="zone-anchor" aria-hidden="true"></span>
      <section class="card due-today-card hidden" aria-live="polite" data-due-today-section>
        <div class="section-heading">
          <h2>Due today</h2>
          <span class="chip chip-muted section-chip">Ready today</span>
        </div>
        <div class="due-today-accordion" data-open="false" data-accordion="dueToday">
          <button class="due-today-summary" type="button" aria-expanded="false" data-accordion-summary>
            <span data-due-today-summary-text>0 ready ‚Ä¢ est ‚Äî</span>
            <span class="due-today-summary__icon" aria-hidden="true">‚ñ∏</span>
          </button>
          <div class="due-today-list" hidden data-accordion-panel data-due-today-list></div>
        </div>
        <p class="due-today-empty hidden" data-due-today-empty>Nothing due today. You're caught up.</p>
      </section>


      <section class="card quick-tasks-card hidden" aria-live="polite" data-quick-tasks-card id="quickTasksCard">
        <span id="quickTasksAnchor" class="zone-anchor" aria-hidden="true"></span>
        <header class="quick-tasks-header">
          <h2 class="focus-title">Quick Tasks</h2>
        </header>
        <p class="quick-task-empty hidden" id="quickTaskEmpty">No quick tasks yet.</p>
        <div class="quick-task-list" id="quickTaskList" role="list"></div>
      </section>


          </div>
        </section>
        <section id="recoveryZone" class="momentum-zone" data-zone="recovery">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">üåô</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Recovery Zone</h2>
              <p class="zone-header__subtitle">Resolve conflicts, reset your nervous system, refuel dopamine</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="reset-zone" class="zone-anchor" aria-hidden="true"></span>
      <div class="routine-stack" id="routineTileStack">
        <div class="routine-grid-shell">
          <div class="routine-feature-grid recovery-routines-container">
            <article
              id="morningLaunchModule"
              class="routine-tile"
              data-module-id="morningLaunchModule"
              data-routine-id="morning"
              role="group"
              aria-label="AM Start"
            >
              <div class="routine-tile__surface routine-theme--morning" data-routine-surface>
                <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                  <span class="routine-accent" aria-hidden="true">
                    <span class="routine-accent__icon" data-accent-icon>üåÖ</span>
                  </span>
                  <div class="routine-tile__info">
                    <span class="routine-tile__title" data-routine-title>üåÖ AM Start</span>
                    <span class="routine-tile__prompt" data-routine-prompt>Ready for takeoff? Start your day ritual.</span>
                  </div>
                  <div class="routine-tile__meta">
                    <span class="routine-info-dot" title="Prime your brain for dopamine, cortisol, and clarity with a 60-minute guided ramp into the day." aria-hidden="true">i</span>
                    <span class="routine-reminder" data-routine-reminder></span>
                    <span class="routine-tile__chevron" aria-hidden="true"></span>
                  </div>
                </button>
                <div class="routine-quick-overlay" data-routine-quick-overlay>
                  <div class="routine-quick-overlay__content">
                    <h3 class="routine-quick-overlay__title">AM Start Preview</h3>
                    <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                    <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                  </div>
                </div>
                <div class="routine-tile__body" data-routine-body hidden>
                  <div class="routine-tile__actions">
                    <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                    <div class="routine-quick-actions" role="group" aria-label="AM Start quick actions">
                      <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                      <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                      <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                    </div>
                  </div>
                  <div class="routine-tile__content">
                    <div class="module-body" data-routine-content>
                      <div class="module-toggle">
                        <label for="morningLaunchToggle">Enable Morning Launch</label>
                        <input type="checkbox" id="morningLaunchToggle" />
                      </div>
                      <div class="routine-affirmation">No-phone pledge: leave your device in another room overnight and wake up with an analog alarm.</div>
                      <div id="morningLaunchContent" class="hidden" aria-hidden="true">
                        <div class="progress-strip" aria-hidden="true">
                          <span id="morningLaunchProgress"></span>
                        </div>
                        <div id="morningLaunchStatus" class="score"></div>
                        <div class="module-inline-actions">
                          <button id="morningLaunchResetBtn" type="button">Reset morning blocks</button>
                          <button id="morningLaunchSkipBtn" type="button">Skip today</button>
                        </div>
                        <div class="morning-blocks">
                          <article class="routine-block" data-block="move">
                            <h3>MOVE ‚Äî Light Aerobic + Sunlight</h3>
                            <small>Take a brisk walk, 50 jumping jacks, and soak in 5 minutes of direct sunlight.</small>
                            <div class="countdown-display" id="moveCountdown">20:00</div>
                            <div class="module-inline-actions">
                              <button id="moveStartBtn" type="button">Start 20-min timer</button>
                              <button id="moveCompleteBtn" type="button">Mark MOVE complete</button>
                            </div>
                          </article>
                          <article class="routine-block" data-block="reflect">
                            <h3>REFLECT ‚Äî Cold Splash + Intention</h3>
                            <small>Reset with a cold rinse, then name the tone for your day.</small>
                            <div class="intention-buttons">
                              <button type="button" data-intention="Calm &amp; steady">Calm &amp; steady</button>
                              <button type="button" data-intention="Playful &amp; connected">Playful &amp; connected</button>
                              <button type="button" data-intention="Focused craftsmanship">Focused craftsmanship</button>
                            </div>
                            <label for="morningIntention" style="margin:0;">
                              <textarea id="morningIntention" rows="2" placeholder="How do I want today to feel? What would make it meaningful?" style="margin-top:0.35rem;"></textarea>
                            </label>
                            <div class="module-inline-actions">
                              <button id="reflectCompleteBtn" type="button">Save intention</button>
                            </div>
                          </article>
                          <article class="routine-block" data-block="plan">
                            <h3>PLAN ‚Äî Process Anchors</h3>
                            <small>Lock in process-based actions and block time before the day takes over.</small>
                            <textarea id="morningPlanNotes" rows="2" placeholder="Ex: Draft progress notes for 2 patients before noon."></textarea>
                            <div class="module-inline-actions">
                              <button id="planCompleteBtn" type="button">Plan locked in</button>
                            </div>
                          </article>
                        </div>
                        <div class="energy-rating">
                          <label for="morningEnergy" style="margin:0;">Energy check-in</label>
                          <input id="morningEnergy" data-field="energy-level" type="range" min="1" max="5" step="1" value="3" />
                          <span id="morningEnergyLabel">--</span>
                          <button id="morningEnergySave" type="button">Log energy</button>
                        </div>
                        <div class="morning-chart-wrapper">
                          <canvas
                            id="morningLaunchChart"
                            class="chart-canvas"
                            width="360"
                            height="160"
                            role="img"
                            aria-label="Line chart of morning launch completion and energy trends"
                          ></canvas>
                          <div class="chart-legend" aria-hidden="true">
                            <span><span class="legend-swatch completion"></span>Ready progress</span>
                            <span><span class="legend-swatch energy"></span>Energy (1‚Äì5 scaled)</span>
                          </div>
                          <div id="morningLaunchChartSummary" class="module-note"></div>
                        </div>
                        <ul id="morningLaunchHistory" class="history-list" aria-live="polite"></ul>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </article>

            <article
              id="launchPadModule"
              class="routine-tile"
              data-module-id="launchPadModule"
              data-routine-id="environment"
              role="group"
              aria-label="Launch Pad"
            >
              <div class="routine-tile__surface routine-theme--environment" data-routine-surface>
                <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                  <span class="routine-accent" aria-hidden="true">
                    <span class="routine-accent__icon" data-accent-icon>üöÄ</span>
                  </span>
                  <div class="routine-tile__info">
                    <span class="routine-tile__title" data-routine-title>üöÄ Launch Pad</span>
                    <span class="routine-tile__prompt" data-routine-prompt>Tap to reset your surroundings.</span>
                  </div>
                  <div class="routine-tile__meta">
                    <span class="routine-info-dot" title="Curate a nightly launch pad so tomorrow starts calm, stocked, and on time." aria-hidden="true">i</span>
                    <span class="routine-reminder" data-routine-reminder></span>
                    <span class="routine-tile__chevron" aria-hidden="true"></span>
                  </div>
                </button>
                <div class="routine-quick-overlay" data-routine-quick-overlay>
                  <div class="routine-quick-overlay__content">
                    <h3 class="routine-quick-overlay__title">Launch Pad Preview</h3>
                    <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                    <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                  </div>
                </div>
                <div class="routine-tile__body" data-routine-body hidden>
                  <div class="routine-tile__actions">
                    <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                    <div class="routine-quick-actions" role="group" aria-label="Launch Pad quick actions">
                      <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                      <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                      <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                    </div>
                  </div>
                  <div class="routine-tile__content">
                    <div class="module-body" data-routine-content>
                      <div class="module-toggle">
                        <label for="launchPadReminderTime">Reminder time</label>
                        <input type="time" id="launchPadReminderTime" />
                      </div>
                      <div class="launch-pad-summary" id="launchPadSummary"></div>
                      <div class="module-inline-actions">
                        <button id="openLaunchPadModal" type="button">Evening checklist</button>
                        <button id="launchPadMorningReview" type="button">Morning review</button>
                      </div>
                      <div class="launch-pad-settings">
                        <label for="launchPadSiteSelect">Clinic / environment
                          <select id="launchPadSiteSelect"></select>
                        </label>
                        <div class="module-inline-actions">
                          <input type="text" id="launchPadNewItem" placeholder="Add launch pad item" />
                          <button id="launchPadAddItem" type="button">Add Item</button>
                          <button id="launchPadLoadPreset" type="button">Reset to preset</button>
                        </div>
                        <div id="launchPadItemList" class="launch-pad-list" aria-live="polite"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </article>

            <article
              id="sleepToolkitModule"
              class="routine-tile"
              data-module-id="sleepToolkitModule"
              data-routine-id="sleep"
              role="group"
              aria-label="Sleep Toolkit"
            >
              <div class="routine-tile__surface routine-theme--sleep" data-routine-surface>
                <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                  <span class="routine-accent" aria-hidden="true">
                    <span class="routine-accent__icon" data-accent-icon>üò¥</span>
                  </span>
                  <div class="routine-tile__info">
                    <span class="routine-tile__title" data-routine-title>üò¥ Sleep Toolkit</span>
                    <span class="routine-tile__prompt" data-routine-prompt>Wind down mode is ready.</span>
                  </div>
                  <div class="routine-tile__meta">
                    <span class="routine-info-dot" title="Stabilize melatonin and cortisol rhythms with gentle wind-down and light cues." aria-hidden="true">i</span>
                    <span class="routine-reminder" data-routine-reminder></span>
                    <span class="routine-tile__chevron" aria-hidden="true"></span>
                  </div>
                </button>
                <div class="routine-quick-overlay" data-routine-quick-overlay>
                  <div class="routine-quick-overlay__content">
                    <h3 class="routine-quick-overlay__title">Sleep Toolkit Preview</h3>
                    <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                    <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                  </div>
                </div>
                <div class="routine-tile__body" data-routine-body hidden>
                  <div class="routine-tile__actions">
                    <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                    <div class="routine-quick-actions" role="group" aria-label="Sleep Toolkit quick actions">
                      <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                      <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                      <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                    </div>
                  </div>
                  <div class="routine-tile__content">
                    <div class="module-body" data-routine-content>
                      <div class="module-toggle">
                        <label for="sleepToolkitToggle">Enable toolkit</label>
                        <input type="checkbox" id="sleepToolkitToggle" />
                      </div>
                      <div id="sleepToolkitContent" class="hidden" aria-hidden="true">
                        <div class="sleep-checklist" id="sleepChecklist"></div>
                        <div id="sleepCompletionSummary" class="sleep-summary"></div>
                        <div id="sleepMorningRating" class="energy-rating"></div>
                        <div id="sleepCorrelationSummary" class="sleep-summary"></div>
                        <div class="sleep-tips" id="sleepTips"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </article>

            <article
              id="dopamineModule"
              class="routine-tile"
              data-module-id="dopamineModule"
              data-routine-id="dopamine"
              role="group"
              aria-label="Dopa-Me"
            >
              <div class="routine-tile__surface routine-theme--dopamine" data-routine-surface>
                <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                  <span class="routine-accent" aria-hidden="true">
                    <span class="routine-accent__icon" data-accent-icon>üéµ</span>
                  </span>
                  <div class="routine-tile__info">
                    <span class="routine-tile__title" data-routine-title>üéµ Dopa-Me</span>
                    <span class="routine-tile__prompt" data-routine-prompt>Train focus with a 5-min win.</span>
                  </div>
                  <div class="routine-tile__meta">
                    <span class="routine-info-dot" title="Stretch reward intervals with a playlist of micro-celebrations." aria-hidden="true">i</span>
                    <span class="routine-reminder" data-routine-reminder></span>
                    <span class="routine-tile__chevron" aria-hidden="true"></span>
                  </div>
                </button>
                <div class="routine-quick-overlay" data-routine-quick-overlay>
                  <div class="routine-quick-overlay__content">
                    <h3 class="routine-quick-overlay__title">Dopa-Me Preview</h3>
                    <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                    <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                  </div>
                </div>
                <div class="routine-tile__body" data-routine-body hidden>
                  <div class="routine-tile__actions">
                    <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                    <div class="routine-quick-actions" role="group" aria-label="Dopa-Me quick actions">
                      <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                      <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                      <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                    </div>
                  </div>
                  <div class="routine-tile__content">
                    <div class="module-body" data-routine-content>
                      <div class="dopamine-playlist">
                        <label for="dopamineReward">Reward style
                          <select id="dopamineReward">
                            <option value="music">Music stinger</option>
                            <option value="confetti">GIF confetti</option>
                            <option value="coin">Coin sound</option>
                            <option value="stretch">Stretch cue</option>
                          </select>
                        </label>
                        <div class="dopamine-intervals" id="dopamineIntervals" aria-live="polite"></div>
                        <div class="dopamine-progress" aria-hidden="true">
                          <span id="dopamineProgressFill"></span>
                        </div>
                        <div class="conflict-actions">
                          <button id="dopamineStart" type="button" class="btn btn-primary">Start playlist</button>
                          <button id="dopamineStop" type="button" class="btn btn-ghost" disabled>Stop</button>
                        </div>
                        <div id="dopamineStatus" class="score" aria-live="polite"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </article>
          </div>
        </div>

      </div>
      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>
      </div>

  <div
    id="templatesOverlay"
    class="modal-overlay hidden templates-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="templatesOverlayTitle"
  >
    <div class="modal-card templates-card" role="document">
      <div class="modal-card__header">
        <h3 id="templatesOverlayTitle">üß© Templates</h3>
        <button id="templatesOverlayClose" class="modal__close" type="button" aria-label="Close templates">‚úï</button>
      </div>
      <div class="templates-overlay__body">
        <div class="template-module__actions">
          <button id="blockBatchOpen" class="btn btn-secondary" type="button">Block Batch</button>
        </div>
        <div id="templateButtons"></div>
      </div>
    </div>
  </div>

  <div
    id="conflictOverlay"
    class="modal-overlay hidden conflict-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="conflictOverlayTitle"
  >
    <div class="modal-card conflict-card" role="document">
      <div class="modal-card__header">
        <h3 id="conflictOverlayTitle">ü•ä 3-v-3 Conflict Resolver</h3>
        <button id="conflictOverlayClose" class="modal__close" type="button" aria-label="Close conflict resolver">‚úï</button>
      </div>
      <div class="conflict-overlay__body" id="conflictResolverModule">
        <div class="conflict-grid">
          <div class="conflict-column">
            <h3>Top 3 should-do</h3>
            <div id="conflictShouldList" class="conflict-list" aria-live="polite"></div>
          </div>
          <div class="conflict-column">
            <h3>Top 3 want-to</h3>
            <div id="conflictWantList" class="conflict-list" aria-live="polite"></div>
          </div>
        </div>
        <div
          id="conflictArena"
          class="conflict-arena"
          role="application"
          aria-live="polite"
          aria-label="Drag contenders here"
        >
          <div id="conflictArenaPrompt">Drag a contender from each side into the arena.</div>
        </div>
        <div class="conflict-actions">
          <button id="conflictReset" type="button" class="btn btn-ghost">Reset arena</button>
        </div>
        <div id="conflictResult" class="score" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <div id="template-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="templateModalTitle">
    <div class="modal__content">
      <div class="modal__head"><strong id="templateModalTitle">Choose a template</strong><button class="modal__close" type="button">‚úï</button></div>
      <div class="template-grid" id="template-grid"></div>
    </div>
  </div>

  <div
    id="block-batch-modal"
    class="modal hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="blockBatchModalTitle"
  >
    <div class="modal__content">
      <div class="modal__head">
        <strong id="blockBatchModalTitle">Block Batch Menu</strong>
        <button class="modal__close" type="button">‚úï</button>
      </div>
      <div class="block-batch-layout">
        <div class="block-batch-list" id="blockBatchList" role="listbox" aria-label="Batch types"></div>
        <div>
          <div class="block-batch-counts" id="blockBatchCounts"></div>
          <div id="blockBatchEditor" class="block-batch-editor hidden" aria-live="polite">
            <div class="block-batch-editor__head">
              <h3 id="blockBatchEditorTitle">Edit default profile</h3>
              <button type="button" class="link-button" id="blockBatchEditorClose">Done</button>
            </div>
            <div class="block-batch-editor__grid">
              <label for="blockBatchCategory">Category
                <select id="blockBatchCategory">
                  <option value="General">General</option>
                  <option value="Admin">Admin</option>
                  <option value="Chart">Chart</option>
                  <option value="Inbox">Inbox</option>
                  <option value="Calls">Calls</option>
                  <option value="Teaching">Teaching</option>
                  <option value="Personal">Personal</option>
                </select>
              </label>
              <label for="blockBatchAuthor">Chart Author
                <select id="blockBatchAuthor">
                  <option value="attending">Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="blockBatchPatient">Patient Type
                <select id="blockBatchPatient">
                  <option value="Non-Complex">Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="blockBatchVisit">Visit Type
                <select id="blockBatchVisit">
                  <option value="Follow-Up">Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="blockBatchClinic">Clinic Site
                <select id="blockBatchClinic">
                  <option value="General Clinic">General Clinic</option>
                  <option value="St PJ‚Äôs Shelter">St PJ‚Äôs Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="blockBatchImportance">Importance (1‚Äì5)
                <select id="blockBatchImportance">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchUrgency">Urgency (1‚Äì5)
                <select id="blockBatchUrgency">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchNovelty">Novelty (1‚Äì5)
                <select id="blockBatchNovelty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchInterest">Interest (1‚Äì5)
                <select id="blockBatchInterest">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchExternalPressure">External Pressure (1‚Äì5)
                <select id="blockBatchExternalPressure">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchTimeToStart">Time to Start (1‚Äì5)
                <select id="blockBatchTimeToStart">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchDifficulty">Difficulty (1‚Äì5)
                <select id="blockBatchDifficulty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
            </div>
            <label for="blockBatchSubtasks">Default subtasks
              <textarea id="blockBatchSubtasks" placeholder="One subtask per line"></textarea>
            </label>
            <label class="sound-toggle" for="blockBatchUseChartTemplate">
              <input type="checkbox" id="blockBatchUseChartTemplate" /> Use chart smart defaults
            </label>
            <div class="block-batch-editor__actions">
              <button id="blockBatchResetProfile" type="button" class="btn btn-ghost">Reset to default</button>
              <button id="blockBatchSaveProfile" type="button" class="btn btn-primary">Save profile</button>
            </div>
          </div>
        </div>
      </div>
      <div class="block-batch-footer">
        <label for="blockBatchDate">Service date
          <input type="date" id="blockBatchDate" />
        </label>
        <button id="blockBatchAdd" class="btn btn-primary" type="button">Add</button>
      </div>
    </div>
  </div>

  <div id="firstThreeWizard" class="wizard-overlay hidden" aria-hidden="true">
    <div class="wizard-content" role="dialog" aria-modal="true" aria-labelledby="firstThreeTitle">
      <h3 id="firstThreeTitle">ü™ú First-Three-Steps Wizard</h3>
      <p>Break the project into tiny, guaranteed-win actions to get moving.</p>
      <div class="wizard-steps">
        <label>Step 1
          <input type="text" id="firstThreeStep1" placeholder="Open patient chart" />
        </label>
        <label>Step 2
          <input type="text" id="firstThreeStep2" placeholder="Skim last visit notes" />
        </label>
        <label>Step 3
          <input type="text" id="firstThreeStep3" placeholder="Draft first paragraph" />
        </label>
      </div>
      <div class="wizard-actions">
        <button id="firstThreeSkip" type="button">Skip for this task</button>
        <button id="firstThreeCancel" type="button">Cancel</button>
        <button id="firstThreeSave" type="button">Save steps</button>
      </div>
    </div>
  </div>

  <div id="launchPadModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="launchPadModalTitle">
      <h3 id="launchPadModalTitle">üöÄ Prep Tomorrow's Launch Pad</h3>
      <p>Gather items tonight so future-you can walk out the door calm.</p>
      <div id="launchPadModalList" class="sleep-checklist" aria-live="polite"></div>
      <div class="modal-actions">
        <button id="launchPadModalClose" type="button">Done</button>
      </div>
    </div>
  </div>

  <div id="quickCaptureOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="quickCaptureTitle">
      <h3 id="quickCaptureTitle">‚úçÔ∏è Quick capture</h3>
      <label for="quickCaptureInput">Task name
        <input id="quickCaptureInput" type="text" placeholder="What's the very next action?" />
      </label>
      <div class="modal-actions">
        <button id="quickCaptureCancel" type="button" class="btn btn-ghost">Cancel</button>
        <button id="quickCaptureSave" type="button" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <div id="addTaskOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card modal-card--wide" role="dialog" aria-modal="true" aria-labelledby="addTaskTitle">
      <button id="addTaskClose" class="modal__close" type="button" aria-label="Close task builder">‚úï</button>
      <h3 id="addTaskTitle">Add task</h3>
      <div class="card-body" id="addTaskCardBody" aria-hidden="false">
        <div class="task-form-group">
          <span class="task-form-group__label">New task</span>
          <p id="quickTaskTemplateHint" class="quick-task-hint hidden">Quick task mode: name it and tap Add.</p>
          <label for="name">Task name
            <input id="name" type="text" placeholder="3/14 ‚Äì J.M. ‚Äì Complex Care Follow-Up (Resident)" />
          </label>
          <label for="taskCategory">Category
            <select id="taskCategory">
              <option value="General" selected>General</option>
              <option value="Admin">Admin</option>
              <option value="Chart">Chart</option>
              <option value="Inbox">Inbox</option>
              <option value="Calls">Calls</option>
              <option value="Teaching">Teaching</option>
              <option value="Personal">Personal</option>
              <option value="Quick Task">Quick Task</option>
            </select>
          </label>
          <div class="task-inline-actions" aria-label="Task helpers">
            <button type="button" class="link-button" id="btn-use-template">Use template</button>
            <button type="button" class="link-button" id="btn-save-template">Add as template</button>
            <button
              type="button"
              class="link-button"
              id="expandTaskDetailsButton"
              aria-controls="taskDetails"
              aria-expanded="false"
            >
              Show details
            </button>
          </div>
          <div id="taskDetails" class="task-details-panel" data-collapsed="true">
            <div id="chartFields" class="chart-fields is-hidden" aria-hidden="true">
              <label for="authorType">Chart Author
                <select id="authorType">
                  <option value="attending" selected>Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="patientType" title="Complex = medically fragile, multi-specialty, or DME-dependent.">Patient Type
                <select id="patientType">
                  <option value="Non-Complex" selected>Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="visitType" title="Determines estimated chart complexity and time to complete.">Visit Type
                <select id="visitType">
                  <option value="Follow-Up" selected>Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="clinicSite" title="Same-day notes from St PJ‚Äôs or Craniofacial automatically rise to the top.">Clinic Site
                <select id="clinicSite">
                  <option value="General Clinic" selected>General Clinic</option>
                  <option value="St PJ‚Äôs Shelter">St PJ‚Äôs Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="dateOfService" title="Select the date of the encounter; defaults to today.">Date of Service
                <input type="date" id="dateOfService" />
              </label>
              <small id="chartAgeDisplay" class="chart-age"></small>
            </div>
            <label for="importance">Importance (1‚Äì5) <select id="importance"></select></label>
            <label for="urgency">Urgency (1‚Äì5)
              <select id="urgency"></select>
            </label>
            <small id="urgencyHint" class="urgency-hint"></small>
            <label for="novelty">Novelty (1‚Äì5) <select id="novelty"></select></label>
            <label for="interest">Interest (1‚Äì5) <select id="interest"></select></label>
            <label for="externalPressure">External Pressure (1‚Äì5)
              <select id="externalPressure"></select>
            </label>
            <label for="timeToStart">Time to Start (1‚Äì5) <select id="timeToStart"></select></label>
            <label for="difficulty">Difficulty (1‚Äì5) <select id="difficulty"></select></label>
            <label for="dueDate" title="Optional specific target date; used for personal scheduling.">Due Date (Optional)
              <input type="date" id="dueDate" />
            </label>
            <label for="initialSubTasks">Subtasks
              <textarea id="initialSubTasks" rows="3" placeholder="One subtask per line."></textarea>
            </label>
            <label class="sound-toggle" for="focusSoundToggle">
              <input type="checkbox" id="focusSoundToggle" checked />
              Enable focus mode ping
            </label>
          </div>
        </div>
      </div>
      <div class="card-sticky-actions" aria-hidden="false">
        <div class="card-sticky-actions__primary">
          <button id="addTaskBtn" class="btn btn-primary" type="button" onclick="addTask()">Add Task</button>
          <button id="saveUpdateBtn" class="btn btn-primary hidden" type="button" onclick="saveTaskUpdate()">Save Update</button>
          <button id="cancelEditBtn" class="btn btn-ghost hidden" type="button" onclick="cancelEdit()">Cancel</button>
        </div>
        <div class="card-sticky-actions__secondary">
          <button type="button" class="btn btn-secondary" onclick="startFiveMinuteSprint()" id="startBtn" disabled>Start 5-min</button>
          <button type="button" class="btn btn-ghost" onclick="reset()">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <div id="focusLaunchBackdrop" class="focus-sheet__backdrop" hidden></div>
  <section
    id="focusLaunchSheet"
    class="focus-sheet"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="focusLaunchTitle"
  >
    <button id="focusLaunchHandle" class="focus-sheet__handle" type="button" aria-label="Close focus launcher"></button>
    <div class="focus-sheet__content">
      <header class="focus-sheet__header">
        <h2 id="focusLaunchTitle">Start Focus</h2>
        <p class="focus-sheet__preview">
          Next suggested: <span id="focusSuggestionText">Add a task to unlock focus.</span>
        </p>
      </header>
      <div class="focus-sheet__options">
        <button
          type="button"
          class="focus-sheet__option focus-sheet__option--primary start-action"
          data-focus-mode="sprint"
        >
          5-min Sprint
        </button>
        <button type="button" class="focus-sheet__option" data-focus-mode="session">Full Session</button>
        <button
          type="button"
          id="focusSuggestionButton"
          class="focus-sheet__option focus-sheet__option--suggestion"
          data-focus-mode="suggestion"
          disabled
          aria-disabled="true"
        >
          <span class="focus-sheet__option-label">Next Suggested Task</span>
          <span id="focusSuggestionDetail" class="focus-sheet__option-detail">Add a task to unlock focus.</span>
        </button>
      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>

  <div id="resourcesBackdrop" class="drawer-backdrop" hidden></div>
  <aside
    id="resourcesDrawer"
    class="resources-drawer"
    aria-hidden="true"
    aria-labelledby="resourcesTitle"
    tabindex="-1"
  >
    <header class="resources-drawer__header">
      <h2 id="resourcesTitle">Quick Access Partners</h2>
      <button id="resourcesClose" class="resources-drawer__close" type="button" aria-label="Close resources">‚úï</button>
    </header>
    <div class="resources-drawer__body">
      <a
        class="resource-button resource-button--planning"
        href="https://chatgpt.com/g/g-p-68feee841e7081919a28fe9b3083e9f0-karl/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>planning ally</small>
        <strong>Chat with Karl</strong>
        <span>ADHD-tailored task partner ready to map out your day.</span>
      </a>
      <a
        class="resource-button resource-button--strategies"
        href="https://chatgpt.com/g/g-p-6836a5682d0481918484506cbc1f3082-epic-companion/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>strategies</small>
        <strong>EPIC Companion</strong>
        <span>Brainstorm workflows to move faster inside the EHR.</span>
      </a>
      <a
        class="resource-button resource-button--digest"
        href="https://notebooklm.google.com/"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>digest</small>
        <strong>NotebookLM</strong>
        <span>Summarize research and notes in a focused workspace.</span>
      </a>
      <a
        class="resource-button resource-button--vault"
        href="https://www.notion.so/Assessments-and-Plans-28131b26f81f803088bad074ee0e00fb?source=copy_link"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>vault</small>
        <strong>Assessments &amp; Plans</strong>
        <span>Review ready-made assessment and plan examples.</span>
      </a>
      <a
        class="resource-button resource-button--vault"
        href="https://chatgpt.com/g/g-p-68feff1f73ac819189dcf556e573c912-assessments-plans/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>document builder</small>
        <strong>Create Assessments &amp; Plans</strong>
        <span>Draft new assessments from your history and physical notes.</span>
      </a>
    </div>
  </aside>

  <div
    id="sosOverlay"
    class="sos-overlay hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="sosOverlayTitle"
  >
    <div class="sos-card">
      <header class="sos-card__header">
        <h2 id="sosOverlayTitle">Crisis Support</h2>
        <button id="sosOverlayClose" class="sos-card__close" type="button" aria-label="Close crisis support">‚úï</button>
      </header>
      <div class="sos-card__actions">
        <div class="sos-card__action-group">
          <button id="worstDayButton" class="sos-card__action start-action" type="button">üòµ‚Äçüí´ Worst-Day Mode</button>
          <p id="worstDayHint" class="sos-card__detail"></p>
        </div>
        <button id="sosDefuse" class="sos-card__action" type="button">üßò DEFUSE Mode</button>
        <button id="sosConflict" class="sos-card__action" type="button">ü•ä 3-v-3 Conflict Resolver</button>
        <button id="sosShield" class="sos-card__action" type="button">üõ°Ô∏è Meltdown Shield</button>
      </div>
      <p class="sos-card__hint">Need a reset? These stay ready until you close them.</p>
    </div>
  </div>

  <!-- Focus mode -->
  <div id="ganttSnapshotOverlay" class="modal-overlay hidden" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="ganttSnapshotTitle">
    <div class="gantt-card">
      <div class="gantt-card__header">
        <h3 id="ganttSnapshotTitle">‚è≥ Next 3-hour snapshot</h3>
        <button id="ganttCloseButton" class="modal__close" type="button" aria-label="Close snapshot">‚úï</button>
      </div>
      <p class="gantt-intro">Blocks sized by estimated minutes so you can see what will actually fit.</p>
      <div class="gantt-blocks-wrapper">
        <div id="ganttProgressBar" class="gantt-progress"></div>
        <div id="ganttBlocks" class="gantt-blocks" role="list"></div>
      </div>
      <div id="ganttStatus" class="gantt-status"></div>
    </div>
  </div>

  <div id="worstDayOverlay" class="modal-overlay hidden worst-day-overlay" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="worstDayHeading">
    <div class="worst-day-card">
      <button id="worstDayClose" class="modal__close" type="button" aria-label="Close Worst-Day mode">‚úï</button>
      <h3 id="worstDayHeading">üòµ‚Äçüí´ Worst-Day Mode</h3>
      <p class="worst-day-subheading">One soft five-minute pass on your most meaningful project.</p>
      <div class="worst-day-focus-line">
        <span class="worst-day-label">Focus</span>
        <strong id="worstDayFocus"></strong>
      </div>
      <div id="worstDayTimer" class="worst-day-timer">05:00</div>
      <p id="worstDayPrompt" class="worst-day-prompt">Move gently. Drift happens ‚Äî we'll reset together.</p>
      <div id="worstDayActions" class="worst-day-actions hidden">
        <p class="worst-day-complete">Sprint complete! Pick your next micro-reward.</p>
        <div class="worst-day-celebrations" role="group" aria-label="Worst-Day celebration choices">
          <button type="button" data-worst-day-choice="laugh">üòÇ Laugh</button>
          <button type="button" data-worst-day-choice="stretch">üôÜ Stretch</button>
          <button type="button" data-worst-day-choice="stop">üõë Stop proudly</button>
        </div>
        <div id="worstDayCelebration" class="worst-day-celebration" aria-live="polite"></div>
      </div>
      <button id="worstDayExit" class="link-button" type="button">Leave Worst-Day Mode</button>
    </div>
  </div>

  <div
    id="defuseOverlay"
    class="modal-overlay hidden defuse-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="defuseOverlayTitle"
  >
    <div class="defuse-modal">
      <header class="defuse-modal__header">
        <h3 id="defuseOverlayTitle">üßò DEFUSE Mode</h3>
        <button id="defuseClose" class="defuse-modal__close" type="button" aria-label="Close DEFUSE mode">‚úï</button>
      </header>
      <div id="defuseModule" class="defuse-modal__body" data-module-id="defuseModule">
        <div class="defuse-grid">
          <div class="defuse-steps">
            <strong>Preflight (90s)</strong>
            <div id="defusePrompt">Feeling ‚â† instruction. You can feel tired and still send the email.</div>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseProgressFill"></span>
            </div>
            <div class="score">Countdown: <span id="defuseCountdown">90s</span></div>
          </div>
          <div>
            <strong>Fake it action</strong>
            <div class="intention-buttons">
              <button type="button" data-defuse-action="Open the doc & type the title">Open doc + type title</button>
              <button type="button" data-defuse-action="Write one bullet in the note">Draft one bullet</button>
              <button type="button" data-defuse-action="Send the 2-sentence update">Send the 2-sentence update</button>
            </div>
            <p id="defuseActionPreview" class="score">Action picked: Open the doc & type the title</p>
          </div>
          <div>
            <strong>Zone locks</strong>
            <div id="defuseLocks" class="defuse-locks">
              <label><input type="checkbox" value="Messages" /> Messages</label>
              <label><input type="checkbox" value="Email" /> Email</label>
              <label><input type="checkbox" value="Instagram" /> Instagram</label>
              <label><input type="checkbox" value="YouTube" /> YouTube</label>
            </div>
          </div>
          <div>
            <strong>Uptime sprint</strong>
            <p id="defuseUptime" class="score">Next sprint: 10 minutes</p>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseUptimeFill"></span>
            </div>
          </div>
          <div class="conflict-actions">
            <button id="defuseStart" type="button" class="btn btn-primary">Start DEFUSE</button>
            <button id="defuseCancel" type="button" class="btn btn-ghost" disabled>Cancel</button>
          </div>
          <div id="defuseStatus" class="score" aria-live="polite"></div>
        </div>
      </div>
    </div>
  </div>

  <section id="focus" class="focus-overlay hidden" aria-hidden="true">
    <div class="focus-overlay__backdrop" data-focus-dismiss></div>
    <div class="focus-overlay__sheet" role="dialog" aria-modal="true" aria-labelledby="focusTimer" tabindex="-1">
      <header class="focus-overlay__header">
        <div id="focusTimer" aria-live="polite">üß≠ Focus Time: 0:00</div>
        <div class="focus-overlay__progress" aria-hidden="true">
          <span id="focusProgressFill" class="focus-overlay__progress-fill"></span>
        </div>
      </header>
      <div class="focus-overlay__body">
        <div class="focus-overlay__summary" id="focusTaskSummary">
          <div class="focus" tabindex="0" aria-live="polite"></div>
          <div class="score task-counter" id="scoreView"></div>
        </div>
        <div id="focusFitHint" class="focus-overlay__hint" aria-live="polite"></div>
        <div id="subTaskView"></div>
        <div id="distractionTools" class="distraction-tools">
          <div class="distraction-tools__header">
            <strong>Distraction cheat sheet</strong>
            <button id="caughtMeButton" type="button" disabled aria-disabled="true">‚ÄúCaught me‚Äù</button>
          </div>
          <div id="distractionPrompt" class="distraction-prompt hidden">
            <span>What pulled you off course?</span>
            <div class="distraction-options" role="group" aria-label="Distraction triggers">
              <button type="button" data-distraction-trigger="tab">Tab hop</button>
              <button type="button" data-distraction-trigger="ping">Notification ping</button>
              <button type="button" data-distraction-trigger="thought">Thought spiral</button>
            </div>
          </div>
          <ul id="distractionLog" class="distraction-log" aria-live="polite" aria-label="Logged distractions"></ul>
          <div id="doorwayReset" class="doorway-reset hidden" aria-live="polite">
            <p id="doorwayResetMessage"></p>
            <div class="doorway-reset-actions">
              <button id="doorwayStartButton" type="button">Start 60-second reset</button>
              <button id="doorwaySkipButton" type="button" class="link-button">Not now</button>
            </div>
            <div id="doorwayCountdown" class="doorway-countdown hidden"></div>
          </div>
        </div>
      </div>
      <footer class="focus-overlay__actions">
        <button id="focusExtendButton" type="button" class="btn btn-secondary">Add 5 more min</button>
        <button id="focusAbortButton" type="button" class="btn btn-ghost">Abort</button>
        <button id="focusCompleteButton" type="button" class="btn hero-cta">Task complete</button>
      </footer>
    </div>
  </section>

  <section
    id="allTasksOverlay"
    class="all-tasks-overlay hidden"
    aria-hidden="true"
    data-all-tasks-screen
  >
    <div class="all-tasks-overlay__backdrop" data-all-tasks-dismiss></div>
    <div
      class="all-tasks-overlay__sheet"
      role="dialog"
      aria-modal="true"
      aria-labelledby="allTasksOverlayTitle"
      tabindex="-1"
    >
      <button type="button" class="all-tasks-overlay__close" data-all-tasks-close aria-label="Close All Tasks">
        ‚úï
      </button>
      <div class="all-tasks-overlay__body">
        <section class="card all-tasks-card" aria-live="polite" data-all-tasks-card>
          <button
            class="all-tasks-toggle"
            type="button"
            data-all-tasks-toggle
            aria-expanded="false"
            data-all-tasks-heading
          >
            <span id="allTasksOverlayTitle" class="all-tasks-toggle__title" data-all-tasks-title>All Tasks</span>
            <span class="all-tasks-toggle__meta">
              <span data-all-tasks-category>All categories</span>
              <span class="all-tasks-header__divider" data-all-tasks-divider aria-hidden="true">‚Ä¢</span>
              <span data-all-tasks-summary-text>0 active</span>
            </span>
            <span class="all-tasks-toggle__chevron" aria-hidden="true">‚ñ∏</span>
          </button>
          <div class="all-tasks-panel" data-all-tasks-panel hidden aria-hidden="true">
            <div class="task-list-header" id="taskListHeader">
              <label class="task-filter-field">
                <span class="task-filter-field__title">View</span>
                <select id="taskViewMode" class="task-view-select">
                  <option value="active" selected>Active Tasks</option>
                  <option value="completed">Completed Tasks</option>
                </select>
              </label>
              <label class="task-filter-field">
                <span class="task-filter-field__title">Category</span>
                <select id="taskCategoryFilter" class="task-view-select"></select>
              </label>
              <label class="task-filter-field">
                <span class="task-filter-field__title">Sort</span>
                <select id="taskSortMode" class="task-view-select">
                  <option value="priority" selected>Priority</option>
                  <option value="date-added-desc">Date added (newest)</option>
                  <option value="date-due-asc">Due date (soonest)</option>
                </select>
              </label>
              <label class="time-budget-control" for="timeBudget">
                I have
                <select id="timeBudget" data-field="time-budget">
                  <option value="">--</option>
                  <option value="15">15</option>
                  <option value="30">30</option>
                  <option value="60">60</option>
                </select>
                minutes
              </label>
            </div>
            <div class="ready-to-launch">
              <div class="task-section-head">
                <h3 class="task-section-title" data-ready-to-launch-title>Ready to Launch</h3>
              </div>
              <div id="taskList"></div>
              <button id="readyToLaunchMoreBtn" class="task-list-more-btn" type="button" aria-hidden="true">Show 5 more</button>
            </div>
          </div>
        </section>
      </div>
    </div>
  </section>
<div id="allTasksOverlay" class="hidden" aria-hidden="true">
  <div class="all-tasks-overlay__sheet" tabindex="-1">
    <header class="all-tasks-overlay__header">
      <h2>All Tasks</h2>
      <button id="closeAllTasksOverlay" aria-label="Close All Tasks">‚úñ</button>
    </header>

    <div class="all-tasks-overlay__body">
      <!-- Your task list goes here -->
    </div>
  </div>
</div>
  <nav class="command-bar" aria-label="Momentum shortcuts">
    <a href="#focus-engine" class="command-link">
      <span class="command-link__icon" aria-hidden="true">‚ö°</span>
      <span>Focus</span>
    </a>

    <button
      id="openAllTasksButton"
      class="command-link"
      type="button"
      aria-haspopup="dialog"
      aria-controls="allTasksOverlay"
      aria-expanded="false"
      data-command-all-tasks="true"
    >
      <span class="command-link__icon" aria-hidden="true">ü©∫</span>
      <span>Tasks</span>
    </button>
    <button
      id="resourcesToggle"
      class="command-link command-link--drawer"
      type="button"
      aria-haspopup="dialog"
      aria-controls="resourcesDrawer"
    >
      <span class="command-link__icon" aria-hidden="true">üìÅ</span>
      <span>Resources</span>
    </button>
    <a href="#reset-zone" class="command-link">
      <span class="command-link__icon" aria-hidden="true">üåô</span>
      <span>Reset</span>
    </a>
  </nav>

  <script>
  const $ = id => document.getElementById(id);

  const QUICK_TASK_CATEGORY = "Quick Task";
  const categories = ["General","Admin","Chart","Inbox","Calls","Teaching","Personal", QUICK_TASK_CATEGORY];
  let activeCategory = "All";
  const TASK_LIST_MODES = { ACTIVE: "active", COMPLETED: "completed" };
  const TASK_SORT_MODES = {
    PRIORITY: "priority",
    DATE_ADDED_DESC: "date-added-desc",
    DATE_DUE_ASC: "date-due-asc"
  };
  let taskSortMode = TASK_SORT_MODES.PRIORITY;
  let taskListMode = TASK_LIST_MODES.ACTIVE;
  const READY_TO_LAUNCH_INITIAL_COUNT = 3;
  const READY_TO_LAUNCH_INCREMENT = 5;
  let readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
  let readyToLaunchRevealBaseline = READY_TO_LAUNCH_INITIAL_COUNT;
  let derivedDaysSinceVisit = null;
  let urgencyAuto = true;
  const runningTimers = new Map();
  let sprintDurationMinutes = null;
  let sprintEndTime = null;
  let nextTaskId = null;
  let lastFocusedBeforeTemplateModal = null;
  let lastFocusedBeforeAllTasksOverlay = null;
  const MODULE_STATE_PREFIX = "moduleState_";
  const ADD_TASK_CARD_STATE_KEY = "ui.addTask.collapsed";
  const LEGACY_ADD_TASK_CARD_STATE_KEY = "addTaskCardState";
  const ALL_TASKS_CARD_STATE_KEY = "ui.allTasks.collapsed";
  const COLLAPSIBLE_MODULE_IDS = [];
  const ROUTINE_STATE_KEY = "ui.routines.metadata";
  const ROUTINE_HAPTIC_KEY = "ui.routines.haptics";
  const ROUTINE_REMINDER_TIMERS = new Map();
  const ROUTINE_CONTEXT_RECENT_MS = 2 * 60 * 60 * 1000;
  const ROUTINE_DEFINITIONS = [
    {
      id: "morning",
      moduleId: "morningLaunchModule",
      title: "AM Start",
      emoji: "üåÖ",
      microPrompt: "Ready for takeoff? Start your day ritual.",
      defaultSteps: [
        "Move ‚Äî Light aerobic + sunlight",
        "Reflect ‚Äî Cold splash + intention",
        "Plan ‚Äî Process anchors"
      ],
      previewSteps: [
        "Move ‚Äî Light aerobic + sunlight",
        "Reflect ‚Äî Cold splash + intention"
      ],
      quickLaunchRef: "moveStartBtn",
      category: "morning",
      reminderBody: "Ready for takeoff?",
      stuckMessage: "Take a sunrise peek and breathe for four counts ‚Äî then try the first step."
    },
    {
      id: "environment",
      moduleId: "launchPadModule",
      title: "Launch Pad",
      emoji: "üöÄ",
      microPrompt: "Tap to reset your surroundings.",
      defaultSteps: [
        "Stage tomorrow's essentials",
        "Reset work surface",
        "Preview morning checklist"
      ],
      previewSteps: [
        "Stage tomorrow's essentials",
        "Preview morning checklist"
      ],
      quickLaunchRef: "openLaunchPadModal",
      category: "environment",
      reminderBody: "Tap to reset your surroundings.",
      stuckMessage: "Focus on just one surface ‚Äî toss clutter into a quick bin sprint."
    },
    {
      id: "sleep",
      moduleId: "sleepToolkitModule",
      title: "Sleep Toolkit",
      emoji: "üò¥",
      microPrompt: "Wind down mode is ready.",
      defaultSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch",
        "Morning sunlight reminder"
      ],
      previewSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch"
      ],
      quickLaunchRef: "sleepToolkitToggle",
      category: "sleep",
      reminderBody: "Wind down mode is ready.",
      stuckMessage: "Try a 2-minute legs-up-the-wall reset before continuing."
    },
    {
      id: "conflict",
      moduleId: "conflictResolverModule",
      title: "3-v-3 Conflict Resolver",
      emoji: "ü•ä",
      microPrompt: "Reframe your mind in 3x3 steps.",
      defaultSteps: [
        "List top 3 should-do",
        "List top 3 want-to",
        "Drag contenders into the arena"
      ],
      previewSteps: [
        "List top 3 should-do",
        "List top 3 want-to"
      ],
      quickLaunchRef: null,
      category: "conflict",
      reminderBody: "Reframe with a quick 3x3.",
      stuckMessage: "Limit the duel to one should-do vs one want-to ‚Äî jot both before deciding."
    },
    {
      id: "dopamine",
      moduleId: "dopamineModule",
      title: "Dopa-Me",
      emoji: "üéµ",
      microPrompt: "Train focus with a 5-min win.",
      defaultSteps: [
        "Pick a reward style",
        "Start the playlist timer",
        "Stretch the victory window"
      ],
      previewSteps: [
        "Pick a reward style",
        "Start the playlist timer"
      ],
      quickLaunchRef: "dopamineStart",
      category: "dopamine",
      reminderBody: "Train focus with a 5-min win.",
      stuckMessage: "Take one song-length pause, then restart the timer with a micro goal."
    },
    {
      id: "templates",
      moduleId: "templateModule",
      title: "Templates",
      emoji: "üß©",
      microPrompt: "Quick launch your best blueprints.",
      defaultSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      previewSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      quickLaunchRef: "blockBatchOpen",
      category: "utility",
      allowReminder: false,
      reminderBody: "Blueprints are ready.",
      stuckMessage: "Pick the template that covers 80% and tweak only the edges."
    }
  ];
  let routineState = {};
  let routineHapticsEnabled = true;
  const routineTiles = new Map();
  let openRoutineId = null;
  let routineContextIntervalId = null;

  function getRoutineDefinition(id) {
    return ROUTINE_DEFINITIONS.find(def => def.id === id) || null;
  }

  function loadRoutineState() {
    let stored = {};
    try {
      const raw = localStorage.getItem(ROUTINE_STATE_KEY);
      if (raw) {
        stored = JSON.parse(raw);
      }
    } catch (error) {
      stored = {};
    }
    const state = {};
    ROUTINE_DEFINITIONS.forEach(def => {
      const data = stored && typeof stored === "object" ? stored[def.id] : null;
      const storedSteps = Array.isArray(data?.steps) ? data.steps.filter(Boolean).map(step => String(step)) : [];
      const steps = storedSteps.length ? storedSteps : [...def.defaultSteps];
      state[def.id] = {
        id: def.id,
        title: typeof data?.title === "string" && data.title.trim() ? data.title.trim() : def.title,
        lastUsed: typeof data?.lastUsed === "string" ? data.lastUsed : null,
        usageCount: Number.isFinite(data?.usageCount) ? Number(data.usageCount) : 0,
        streak: Number.isFinite(data?.streak) ? Number(data.streak) : 0,
        reminderTime: typeof data?.reminderTime === "string" ? data.reminderTime : null,
        steps,
        quickLaunch: typeof data?.quickLaunch === "string" && steps.includes(data.quickLaunch)
          ? data.quickLaunch
          : steps[0] || null
      };
    });
    return state;
  }

  function saveRoutineState() {
    try {
      localStorage.setItem(ROUTINE_STATE_KEY, JSON.stringify(routineState));
    } catch (error) {
      // ignore persistence errors
    }
  }

  function formatRoutineTimeAgo(iso) {
    const date = new Date(iso);
    if (!iso || Number.isNaN(date.getTime())) {
      return "just now";
    }
    const diff = Date.now() - date.getTime();
    if (diff < 0) return "just now";
    const minute = 60000;
    const hour = 3600000;
    const day = 86400000;
    if (diff < minute) {
      return "just now";
    }
    if (diff < hour) {
      const mins = Math.max(1, Math.round(diff / minute));
      return `${mins} min${mins === 1 ? "" : "s"} ago`;
    }
    if (diff < day) {
      const hours = Math.max(1, Math.round(diff / hour));
      return `${hours} hour${hours === 1 ? "" : "s"} ago`;
    }
    const days = Math.max(1, Math.round(diff / day));
    return `${days} day${days === 1 ? "" : "s"} ago`;
  }

  function computeRoutinePrompt(def, meta) {
    if (!meta) return def.microPrompt;
    if (Number(meta.streak) >= 3) {
      return `${meta.streak}-day streak ‚Äî keep it going!`;
    }
    if (meta.lastUsed) {
      return `Last used: ${formatRoutineTimeAgo(meta.lastUsed)}. Ready again?`;
    }
    return def.microPrompt;
  }

  function populateRoutineOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (!overlay) return;
    const list = overlay.querySelector('[data-quick-preview]');
    const button = overlay.querySelector('[data-quick-launch]');
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (list) {
      list.innerHTML = "";
      const steps = (meta?.steps && meta.steps.length ? meta.steps : def.defaultSteps).slice(0, 2);
      steps.forEach(step => {
        const li = document.createElement("li");
        li.textContent = step;
        list.appendChild(li);
      });
    }
    if (button) {
      button.textContent = `Quick launch ${meta?.title || def.title}`;
    }
  }

  function updateRoutineTile(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    const titleEl = tile.querySelector('[data-routine-title]');
    const promptEl = tile.querySelector('[data-routine-prompt]');
    const reminderEl = tile.querySelector('[data-routine-reminder]');
    const startBtn = tile.querySelector('[data-routine-start]');
    if (titleEl) {
      titleEl.textContent = `${def.emoji} ${meta.title || def.title}`;
    }
    if (promptEl) {
      promptEl.textContent = computeRoutinePrompt(def, meta);
    }
    if (reminderEl) {
      reminderEl.textContent = meta.reminderTime && def.allowReminder !== false ? `Reminder ‚Ä¢ ${meta.reminderTime}` : "";
    }
    if (startBtn && tile.dataset.running !== "true") {
      startBtn.textContent = "Start Routine";
    }
    populateRoutineOverlay(id);
  }

  function toggleRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    if (tile.classList.contains("routine-tile--open")) {
      closeRoutineTile(id);
    } else {
      openRoutineTile(id);
    }
  }

  function openRoutineTile(id, options = {}) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    if (openRoutineId && openRoutineId !== id) {
      closeRoutineTile(openRoutineId);
    }
    openRoutineId = id;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    body.hidden = false;
    const targetHeight = body.scrollHeight;
    body.style.maxHeight = `${targetHeight}px`;
    tile.classList.add("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "true");
      trigger.classList.add("is-active");
      trigger.setAttribute("aria-current", "true");
    }
    window.setTimeout(() => {
      if (tile.classList.contains("routine-tile--open")) {
        body.style.maxHeight = "none";
      }
    }, 260);
    if (options.scrollIntoView !== false) {
      tile.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
  }

  function closeRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    tile.classList.remove("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "false");
      trigger.classList.remove("is-active");
      trigger.removeAttribute("aria-current");
    }
    const currentHeight = body.scrollHeight;
    body.style.maxHeight = `${currentHeight}px`;
    requestAnimationFrame(() => {
      body.style.maxHeight = "0px";
    });
    window.setTimeout(() => {
      if (!tile.classList.contains("routine-tile--open")) {
        body.hidden = true;
      }
    }, 260);
    if (openRoutineId === id) {
      openRoutineId = null;
    }
  }

  function closeRoutineQuickOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (overlay) {
      overlay.classList.remove("is-visible");
    }
  }

  function quickLaunchRoutine(id) {
    const def = getRoutineDefinition(id);
    if (!def) return;
    if (def.quickLaunchRef) {
      const target = document.getElementById(def.quickLaunchRef);
      if (target) {
        target.click();
      }
    }
    startRoutine(id, { source: "quickLaunch" });
    closeRoutineQuickOverlay(id);
  }

  function attachRoutineGestures(tile, def) {
    const surface = tile.querySelector('[data-routine-surface]');
    if (!surface) return;
    const LONG_PRESS_MS = 600;
    let pointerId = null;
    let startX = 0;
    let startY = 0;
    let isSwipe = false;
    let longPressTimer = null;
    let longPressTriggered = false;

    const clearTimers = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    surface.addEventListener("pointerdown", event => {
      if (event.button !== 0) return;
      pointerId = event.pointerId;
      startX = event.clientX;
      startY = event.clientY;
      isSwipe = false;
      longPressTriggered = false;
      tile.dataset.ignoreNextClick = "false";
      surface.setPointerCapture(pointerId);
      clearTimers();
      longPressTimer = window.setTimeout(() => {
        longPressTriggered = true;
        tile.dataset.ignoreNextClick = "true";
        populateRoutineOverlay(def.id);
        const overlay = tile.querySelector('[data-routine-quick-overlay]');
        if (overlay) {
          overlay.classList.add("is-visible");
        }
        triggerRoutineHaptic([10]);
      }, LONG_PRESS_MS);
    });

    surface.addEventListener("pointermove", event => {
      if (event.pointerId !== pointerId) return;
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      if (Math.abs(dy) > 10) {
        clearTimers();
      }
      if (!isSwipe && Math.abs(dx) > 18 && Math.abs(dx) > Math.abs(dy)) {
        isSwipe = true;
        clearTimers();
        surface.classList.add("swiping");
      }
      if (isSwipe) {
        event.preventDefault();
        const clamped = Math.max(-120, Math.min(120, dx));
        surface.style.transform = `translateX(${clamped}px)`;
      }
    });

    const release = event => {
      if (event.pointerId !== pointerId) return;
      surface.releasePointerCapture(pointerId);
      clearTimers();
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      surface.classList.remove("swiping");
      surface.style.transform = "";
      pointerId = null;
      if (isSwipe) {
        if (dx > 80) {
          tile.dataset.ignoreNextClick = "true";
          startRoutine(def.id, { source: "swipe" });
        } else if (dx < -80) {
          tile.dataset.ignoreNextClick = "true";
          openRoutineEdit(def.id);
        }
        return;
      }
      if (longPressTriggered) {
        return;
      }
    };

    surface.addEventListener("pointerup", release);
    surface.addEventListener("pointercancel", release);
    surface.addEventListener("pointerleave", event => {
      if (event.pointerId === pointerId) {
        clearTimers();
      }
    });
  }

  function triggerRoutineHaptic(pattern = [12]) {
    if (!routineHapticsEnabled) return;
    if (navigator?.vibrate) {
      try {
        navigator.vibrate(pattern);
      } catch (error) {
        // ignore vibration errors
      }
    }
  }

  function startRoutine(id, options = {}) {
    const def = getRoutineDefinition(id);
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!def || !tile || !meta) return;
    closeRoutineQuickOverlay(id);
    const shouldExpand = !options.source || options.source === "tap";
    if (shouldExpand) {
      openRoutineTile(id, { scrollIntoView: options.source !== "quickLaunch" });
    }
    const previous = {
      lastUsed: meta.lastUsed,
      usageCount: meta.usageCount,
      streak: meta.streak
    };
    const now = new Date();
    const todayKey = getDateKey(now);
    const previousKey = meta.lastUsed ? getDateKey(new Date(meta.lastUsed)) : null;
    meta.lastUsed = now.toISOString();
    meta.usageCount = (meta.usageCount || 0) + 1;
    if (previousKey === todayKey) {
      meta.streak = meta.streak || 1;
    } else if (previousKey === getOffsetDateKey(todayKey, -1)) {
      meta.streak = (meta.streak || 0) + 1;
    } else {
      meta.streak = 1;
    }
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "true";
    tile.classList.add("is-running");
    const surface = tile.querySelector('[data-routine-surface]');
    if (surface) {
      surface.classList.add("is-pulsing");
      window.setTimeout(() => surface.classList.remove("is-pulsing"), 250);
    }
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Mark complete";
    }
    triggerRoutineHaptic();
    if (typeof playFocusPing === "function") {
      playFocusPing();
    }
    window.setTimeout(() => tile.classList.remove("is-running"), 1800);
    const message = options.source === "swipe"
      ? `${def.emoji} ${meta.title || def.title} started ‚Äî undo?`
      : `${def.emoji} Routine started.`;
    const toastOptions = options.source === "swipe"
      ? {
          action: {
            label: "Undo",
            onClick: () => undoRoutineStart(id, previous)
          },
          position: "bottom",
          timeout: 4000
        }
      : { timeout: 3500 };
    showToast(meta.title || def.title, message, toastOptions);
    updateRoutineContextGlow();
  }

  function undoRoutineStart(id, previous) {
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!tile || !meta) return;
    meta.lastUsed = previous.lastUsed || null;
    meta.usageCount = Number.isFinite(previous.usageCount) ? previous.usageCount : 0;
    meta.streak = Number.isFinite(previous.streak) ? previous.streak : 0;
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    updateRoutineContextGlow();
  }

  function completeRoutine(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    tile.classList.add("routine-tile--celebrate");
    window.setTimeout(() => tile.classList.remove("routine-tile--celebrate"), 900);
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    triggerRoutineHaptic([16, 32, 16]);
    showToast(meta.title || def.title, "Routine done ‚Äî nice work!", { timeout: 4200 });
    updateRoutineContextGlow();
  }

  function handleRoutineQuickAction(id, action) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    switch (action) {
      case "refresh":
        meta.lastUsed = null;
        meta.streak = 0;
        saveRoutineState();
        updateRoutineTile(id);
        showToast(meta.title || def.title, "Micro prompt refreshed.", { timeout: 2500 });
        updateRoutineContextGlow();
        break;
      case "adjust":
        openRoutineEdit(id);
        break;
      case "stuck":
        showToast(meta.title || def.title, def.stuckMessage || "Take one tiny step toward the next action.", { timeout: 4000 });
        break;
      default:
        break;
    }
  }

  let activeRoutineEditId = null;

  function openRoutineEdit(id) {
    const sheet = document.getElementById("routineEditSheet");
    const meta = routineState[id];
    const def = getRoutineDefinition(id);
    if (!sheet || !meta || !def) return;
    closeRoutineQuickOverlay(id);
    activeRoutineEditId = id;
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    if (nameField) nameField.value = meta.title || def.title;
    if (stepsField) stepsField.value = meta.steps.join("\n");
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
      if (meta.quickLaunch && meta.steps.includes(meta.quickLaunch)) {
        quickSelect.value = meta.quickLaunch;
      }
    }
    if (reminderField) {
      reminderField.value = meta.reminderTime || "";
      reminderField.disabled = def.allowReminder === false;
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.checked = routineHapticsEnabled;
    }
    sheet.classList.add("is-visible");
    const panel = sheet.querySelector('.routine-sheet__panel');
    if (panel) {
      panel.setAttribute("tabindex", "-1");
      panel.focus({ preventScroll: true });
    }
  }

  function closeRoutineEdit() {
    const sheet = document.getElementById("routineEditSheet");
    if (!sheet) return;
    sheet.classList.remove("is-visible");
    activeRoutineEditId = null;
  }

  function setRoutineHaptics(enabled) {
    routineHapticsEnabled = Boolean(enabled);
    try {
      localStorage.setItem(ROUTINE_HAPTIC_KEY, routineHapticsEnabled ? "true" : "false");
    } catch (error) {
      // ignore
    }
    const toggle = document.getElementById("routineHapticsToggle");
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (toggle) toggle.checked = routineHapticsEnabled;
    if (sheetToggle) sheetToggle.checked = routineHapticsEnabled;
  }

  async function saveRoutineEdit() {
    if (!activeRoutineEditId) {
      closeRoutineEdit();
      return;
    }
    const def = getRoutineDefinition(activeRoutineEditId);
    const meta = routineState[activeRoutineEditId];
    if (!def || !meta) {
      closeRoutineEdit();
      return;
    }
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    meta.title = nameField?.value?.trim() || def.title;
    const steps = (stepsField?.value || "")
      .split(/\n+/)
      .map(step => step.trim())
      .filter(Boolean);
    meta.steps = steps.length ? steps : [...def.defaultSteps];
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
    }
    const selectedQuick = quickSelect?.value && meta.steps.includes(quickSelect.value) ? quickSelect.value : meta.steps[0] || null;
    meta.quickLaunch = selectedQuick;
    if (def.allowReminder !== false && reminderField) {
      const timeValue = reminderField.value || null;
      meta.reminderTime = timeValue;
      if (timeValue) {
        const granted = await ensureNotificationPermission();
        if (!granted) {
          meta.reminderTime = null;
          reminderField.value = "";
          showToast(meta.title, "Notifications blocked. Reminder cleared.", { timeout: 3500 });
        }
      }
      scheduleRoutineReminder(activeRoutineEditId);
    }
    saveRoutineState();
    updateRoutineTile(activeRoutineEditId);
    closeRoutineEdit();
    showToast(meta.title, "Routine updated", { timeout: 2600 });
    updateRoutineContextGlow();
  }

  function syncRoutineReminderDisplays() {
    ROUTINE_DEFINITIONS.forEach(def => updateRoutineTile(def.id));
  }

  async function ensureNotificationPermission() {
    if (!("Notification" in window)) return false;
    if (Notification.permission === "granted") return true;
    if (Notification.permission === "denied") return false;
    try {
      const result = await Notification.requestPermission();
      return result === "granted";
    } catch (error) {
      return false;
    }
  }

  function cancelRoutineReminder(id) {
    const timer = ROUTINE_REMINDER_TIMERS.get(id);
    if (timer) {
      window.clearTimeout(timer);
      ROUTINE_REMINDER_TIMERS.delete(id);
    }
  }

  function scheduleRoutineReminder(id) {
    cancelRoutineReminder(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta || def.allowReminder === false || !meta.reminderTime) return;
    const [hours, minutes] = meta.reminderTime.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return;
    const now = new Date();
    const next = new Date();
    next.setHours(hours, minutes, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    const delay = Math.max(0, next.getTime() - now.getTime());
    const timerId = window.setTimeout(() => {
      deliverRoutineReminder(id);
      ROUTINE_REMINDER_TIMERS.delete(id);
      scheduleRoutineReminder(id);
    }, delay);
    ROUTINE_REMINDER_TIMERS.set(id, timerId);
  }

  async function deliverRoutineReminder(id) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    const title = `${def.emoji} ${meta.title || def.title}`;
    const body = def.reminderBody || def.microPrompt;
    if (document.visibilityState !== "hidden") {
      openRoutineTile(id, { scrollIntoView: true });
      showToast(title, body, {
        action: { label: "Open", onClick: () => openRoutineTile(id) },
        timeout: 5000,
        className: "toast--inline"
      });
      return;
    }
    if (!("serviceWorker" in navigator)) return;
    try {
      const registration = await navigator.serviceWorker.ready;
      if (Notification.permission === "granted") {
        registration.showNotification(title, {
          body,
          tag: `routine-${id}`,
          data: { routineId: id },
          renotify: true
        });
      }
    } catch (error) {
      // ignore notification failures
    }
  }

  function updateRoutineContextGlow() {
    const priority = computeRoutinePriority();
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = routineTiles.get(def.id);
      if (!tile) return;
      const surface = tile.querySelector('[data-routine-surface]');
      if (priority === def.id) {
        tile.classList.add("routine-tile--context");
        const meta = routineState[def.id];
        const alpha = computeRoutineGlowAlpha(meta);
        if (surface) {
          surface.style.setProperty("--routine-context-glow-alpha", alpha.toFixed(2));
        }
      } else {
        tile.classList.remove("routine-tile--context");
        if (surface) {
          surface.style.removeProperty("--routine-context-glow-alpha");
        }
      }
    });
  }

  function computeRoutinePriority() {
    const hour = new Date().getHours();
    if (hour >= 6 && hour <= 11) return "morning";
    if (hour >= 19 || hour <= 23) return "sleep";
    const conflict = routineState.conflict;
    if (conflict?.lastUsed) {
      const last = new Date(conflict.lastUsed).getTime();
      if (!Number.isNaN(last) && Date.now() - last < ROUTINE_CONTEXT_RECENT_MS) {
        return "conflict";
      }
    }
    return null;
  }

  function computeRoutineGlowAlpha(meta) {
    const base = 0.18;
    if (!meta) return base;
    const now = Date.now();
    const hour = 60 * 60 * 1000;
    const day = 24 * hour;
    let alpha = base;
    if (!meta.lastUsed) {
      alpha = 0.26;
    } else {
      const last = new Date(meta.lastUsed).getTime();
      if (!Number.isNaN(last)) {
        const diff = Math.max(0, now - last);
        if (diff < 3 * hour) {
          alpha = 0.14;
        } else if (diff < 12 * hour) {
          alpha = 0.18;
        } else if (diff < day) {
          alpha = 0.22;
        } else {
          alpha = 0.26;
        }
      } else {
        alpha = 0.22;
      }
    }
    if (Number(meta.streak) >= 3) {
      alpha = Math.max(0.12, alpha - 0.02);
    }
    return Math.min(0.28, Math.max(0.12, alpha));
  }

  function initializeRoutineTiles() {
    routineState = loadRoutineState();
    try {
      const storedHaptics = localStorage.getItem(ROUTINE_HAPTIC_KEY);
      if (storedHaptics !== null) {
        routineHapticsEnabled = storedHaptics === "true";
      }
    } catch (error) {
      routineHapticsEnabled = true;
    }
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = document.querySelector(`[data-routine-id="${def.id}"]`);
      if (!tile) return;
      routineTiles.set(def.id, tile);
      tile.dataset.running = "false";
      const trigger = tile.querySelector('[data-routine-trigger]');
      const startBtn = tile.querySelector('[data-routine-start]');
      const quickActions = tile.querySelectorAll('[data-quick-action]');
      const overlay = tile.querySelector('[data-routine-quick-overlay]');
      if (trigger) {
        trigger.setAttribute("role", "button");
        trigger.setAttribute("aria-expanded", "false");
        trigger.addEventListener("click", () => {
          if (tile.dataset.ignoreNextClick === "true") {
            tile.dataset.ignoreNextClick = "false";
            return;
          }
          toggleRoutineTile(def.id);
        });
      }
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          if (tile.dataset.running === "true") {
            completeRoutine(def.id);
          } else {
            startRoutine(def.id, { source: "tap" });
          }
        });
      }
      quickActions.forEach(button => {
        button.addEventListener("click", () => handleRoutineQuickAction(def.id, button.getAttribute("data-quick-action")));
      });
      if (overlay) {
        const quickLaunchBtn = overlay.querySelector('[data-quick-launch]');
        if (quickLaunchBtn) {
          quickLaunchBtn.addEventListener("click", () => quickLaunchRoutine(def.id));
        }
        overlay.addEventListener("click", event => {
          if (event.target === overlay) {
            closeRoutineQuickOverlay(def.id);
          }
        });
      }
      attachRoutineGestures(tile, def);
      updateRoutineTile(def.id);
      if (def.allowReminder !== false) {
        scheduleRoutineReminder(def.id);
      }
    });
    setRoutineHaptics(routineHapticsEnabled);
    const hapticsToggle = document.getElementById("routineHapticsToggle");
    if (hapticsToggle) {
      hapticsToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheet = document.getElementById("routineEditSheet");
    if (sheet) {
      const scrim = sheet.querySelector('[data-routine-sheet-dismiss]');
      const cancelBtn = sheet.querySelector('[data-routine-sheet-cancel]');
      const saveBtn = sheet.querySelector('[data-routine-sheet-save]');
      if (scrim) scrim.addEventListener("click", () => closeRoutineEdit());
      if (cancelBtn) cancelBtn.addEventListener("click", () => closeRoutineEdit());
      if (saveBtn) saveBtn.addEventListener("click", () => saveRoutineEdit());
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.getElementById("routineEditSheet")?.classList.contains("is-visible")) {
        closeRoutineEdit();
      }
    });
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js").catch(() => {});
    }
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener("message", event => {
        const data = event.data || {};
        if (data.type === "routine-reminder" && data.routineId) {
          openRoutineTile(data.routineId, { scrollIntoView: true });
        }
      });
    }
    const hashMatch = window.location.hash && window.location.hash.match(/^#routine-(.+)$/);
    if (hashMatch && routineTiles.has(hashMatch[1])) {
      openRoutineTile(hashMatch[1], { scrollIntoView: true });
    }
    updateRoutineContextGlow();
    if (routineContextIntervalId) {
      window.clearInterval(routineContextIntervalId);
    }
    routineContextIntervalId = window.setInterval(updateRoutineContextGlow, 60 * 1000);
  }

  const chartFieldIds = ["authorType", "patientType", "visitType", "clinicSite", "dateOfService"];
  let storedChartFieldValues = null;
  let currentScaleDescriptorCategory = "general";
  const FOCUS_PING_INTERVAL_MS = 10 * 60 * 1000;
  const DISTRACTION_TRIGGER_OPTIONS = [
    { value: "tab", label: "Tab hop" },
    { value: "ping", label: "Notification ping" },
    { value: "thought", label: "Thought spiral" }
  ];
  const DOORWAY_RESET_THRESHOLD = 2;
  const DOORWAY_RESET_DURATION_MS = 60 * 1000;
  const GANTT_WINDOW_MINUTES = 180;
  const WORST_DAY_DURATION_MS = 5 * 60 * 1000;
  const WORST_DAY_LAUGHS = [
    "You just taught your nervous system a new party trick.",
    "That five-minute win still counts on your CV.",
    "Future-you is slow clapping right now."
  ];
  const WORST_DAY_STRETCHES = [
    "Shake out wrists, roll shoulders, slow neck circles.",
    "Stand tall, inhale for four, exhale for six.",
    "Touch the door frame, feel the reset, come back in."
  ];
  const AUDIT_STORAGE_PREFIX = "audit_";
  const AUDIT_SHOWN_SUFFIX = "_shown";
  const MORNING_LAUNCH_KEY = "morningLaunchState";
  const LAUNCH_PAD_KEY = "launchPadState";
  const SLEEP_TOOLKIT_KEY = "sleepToolkitState";
  let lastFocusEnergyLevel = null;
  let lastFocusTimeBudget = null;
  let syncingEnergySliders = false;
  let conflictArenaSelection = { should: null, want: null };
  const DEFUSE_MINUTES_MIN = 10;
  const DEFUSE_MINUTES_MAX = 30;
  const DEFAULT_DEFUSE_ACTION = "Open the doc & type the title";
  let defuseState = {
    active: false,
    countdown: 90,
    intervalId: null,
    uptime: DEFUSE_MINUTES_MIN,
    uptimeIntervalId: null,
    selectedAction: DEFAULT_DEFUSE_ACTION
  };
  let dopamineState = null;
  const FIRST_THREE_KEYWORDS = [
    "report",
    "project",
    "backlog",
    "chart",
    "presentation",
    "summary",
    "documentation",
    "analysis",
    "panel",
    "prep"
  ];
  const FIRST_THREE_WORD_THRESHOLD = 5;
  const DEFAULT_MORNING_TIMER_MINUTES = 20;
  const MORNING_BLOCKS = ["move", "reflect", "plan"];
  const MORNING_CHART_LIMIT = 10;
  const MORNING_CHART_COLORS = {
    completion: "#0a84ff",
    energy: "#f97316",
    grid: "rgba(148, 163, 184, 0.25)",
    axis: "rgba(148, 163, 184, 0.4)"
  };
  const DEFAULT_LAUNCH_PAD_REMINDER = "20:00";
  const DEFAULT_MELATONIN_TIME = "21:30";
  const DEFAULT_SUNLIGHT_TIME = "08:00";
  const DEFAULT_LAUNCH_PAD_SITE = "General Clinic";
  const NEXT_BEST_STORAGE_KEY = "nextBest.inputs";
  const PREFLIGHT_TOGGLES_KEY = "preflight.toggles";
  const DEFUSE_BASE_MINUTES_KEY = "defuse.baseMinutes";
  const DEFUSE_ACTION_KEY = "defuse.action";
  const DEFUSE_LOCKS_KEY = "defuse.locks";
  const DOPAMINE_REWARD_KEY = "dopamine.reward";
  const DOPAMINE_INTERVALS = [2, 6, 12];
  const BLOCK_BATCH_STORAGE_KEY = "blockBatch.profiles";
  const LAST_ZONE_STORAGE_KEY = "momentum.lastZone";
  const BRIEF_MODE_STORAGE_KEY = "momentum.briefMode";

  let latestNextBestPicks = {};
  let nextBestUpdatePending = false;
  let lastActiveZoneId = null;
  let focusLaunchOpen = false;
  let scrollCalmTimer = null;
  let taskGestureObserver = null;
  let lastDefuseOpener = null;
  let lastSosTrigger = null;
  let lastTemplatesOpener = null;
  let lastConflictOpener = null;

  function isElementMostlyInView(element, ratio = 0.3) {
    if (!element) return false;
    const rect = element.getBoundingClientRect();
    const viewHeight = window.innerHeight || document.documentElement.clientHeight;
    if (rect.height <= 0 || rect.bottom <= 0 || rect.top >= viewHeight) return false;
    const visibleTop = Math.max(0, -rect.top);
    const visibleBottom = Math.max(0, Math.min(viewHeight, rect.bottom) - Math.max(0, rect.top));
    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
    return visibleHeight / rect.height >= ratio;
  }

  function scrollToZone(zoneId, options = {}) {
    if (!zoneId) return;
    const target = document.getElementById(zoneId);
    if (!target) return;
    const behavior = options.behavior || "smooth";
    target.scrollIntoView({ behavior, block: "start" });
  }

  function applyBriefMode(enabled, { silent = false } = {}) {
    document.body.classList.toggle("brief-mode", Boolean(enabled));
    try {
      localStorage.setItem(BRIEF_MODE_STORAGE_KEY, enabled ? "1" : "0");
    } catch (error) {
      console.warn("Unable to persist brief mode", error);
    }
    if (!silent) {
      showToast("Brief mode", enabled ? "Minimal view on." : "Full detail restored.");
    }
  }

  function toggleBriefMode() {
    const nextState = !document.body.classList.contains("brief-mode");
    applyBriefMode(nextState);
  }

  function restoreBriefModePreference() {
    try {
      const stored = localStorage.getItem(BRIEF_MODE_STORAGE_KEY);
      if (stored === "1") {
        applyBriefMode(true, { silent: true });
      }
    } catch (error) {
      console.warn("Unable to load brief mode preference", error);
    }
  }

  function setFocusLaunchOpen(open) {
    focusLaunchOpen = Boolean(open);
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    if (fab) {
      fab.setAttribute("aria-expanded", focusLaunchOpen ? "true" : "false");
    }
    if (sheet) {
      sheet.classList.toggle("is-open", focusLaunchOpen);
      sheet.setAttribute("aria-hidden", focusLaunchOpen ? "false" : "true");
    }
    if (backdrop) {
      if (focusLaunchOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!focusLaunchOpen) {
            backdrop.hidden = true;
          }
        }, 220);
      }
    }
    if (!focusLaunchOpen && fab) {
      fab.focus();
    }
  }

  function updateCommandLinkStates(activeZoneId) {
    const overlayActive = document.body.classList.contains("all-tasks-overlay-active");
    const links = document.querySelectorAll(".command-bar .command-link");
    links.forEach(link => {
      const isAllTasksTrigger = link.dataset.commandAllTasks === "true";
      if (isAllTasksTrigger && overlayActive) {
        link.classList.add("is-active");
        link.setAttribute("aria-current", "true");
        return;
      }
      const hash = link.getAttribute("href") || "";
      const targetId = hash.startsWith("#") ? hash.slice(1) : null;
      const anchor = targetId ? document.getElementById(targetId) : null;
      const zone = anchor ? anchor.closest(".momentum-zone") : null;
      const isActive = Boolean(zone && zone.id === activeZoneId);
      link.classList.toggle("is-active", isActive);
      if (isActive) {
        link.setAttribute("aria-current", "true");
      } else {
        link.removeAttribute("aria-current");
        if (isAllTasksTrigger) {
          link.classList.remove("is-active");
        }
      }
    });
  }

  function persistLastActiveZone(zoneId) {
    if (!zoneId) return;
    lastActiveZoneId = zoneId;
    try {
      localStorage.setItem(LAST_ZONE_STORAGE_KEY, zoneId);
    } catch (error) {
      console.warn("Unable to persist last active zone", error);
    }
  }

  function handleActiveZoneChange(zoneId) {
    if (!zoneId) return;
    persistLastActiveZone(zoneId);
    updateCommandLinkStates(zoneId);
  }

  function setupMomentumZones() {
    const zones = Array.from(document.querySelectorAll(".momentum-zone"));
    if (!zones.length) return;

    let storedZoneId = null;
    try {
      storedZoneId = localStorage.getItem(LAST_ZONE_STORAGE_KEY);
    } catch (error) {
      console.warn("Unable to read last zone", error);
    }

    const fallbackZone =
      document.getElementById("actionZone") ||
      document.getElementById("launchZone") ||
      zones[0];
    const initialZone = zones.find(zone => zone.id === storedZoneId) || fallbackZone;
    if (initialZone) {
      handleActiveZoneChange(initialZone.id);
    }

    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              handleActiveZoneChange(entry.target.id);
            }
          });
        },
        { threshold: 0.35 }
      );
      zones.forEach(zone => observer.observe(zone));
    }

    const commandLinks = document.querySelectorAll(".command-bar .command-link");
    commandLinks.forEach(link => {
      link.addEventListener("click", event => {
        if (link.dataset.commandAllTasks === "true") {
          return;
        }
        if (document.body.classList.contains("all-tasks-overlay-active")) {
          closeAllTasksOverlay({ restoreFocus: false });
        }
        const hash = link.getAttribute("href") || "";
        if (!hash.startsWith("#")) return;
        event.preventDefault();
        const targetId = hash.slice(1);
        if (!targetId) return;
        scrollToZone(targetId);
        const anchor = document.getElementById(targetId);
        const zone = anchor ? anchor.closest(".momentum-zone") : null;
        if (zone) {
          handleActiveZoneChange(zone.id);
        }
      });
    });

    const handleScrollEffects = () => {
      document.body.classList.add("is-scrolling");
      if (scrollCalmTimer) {
        window.clearTimeout(scrollCalmTimer);
      }
      scrollCalmTimer = window.setTimeout(() => {
        document.body.classList.remove("is-scrolling");
      }, 180);
    };

    window.addEventListener("scroll", handleScrollEffects, { passive: true });
    window.addEventListener("resize", handleScrollEffects);
    handleScrollEffects();
  }

  function setupNextBestObserver() {
    const target = $("nextBestEngineCard");
    if (!target || typeof IntersectionObserver === "undefined") return;
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting && nextBestUpdatePending) {
            updateNextBestOptions({ force: true });
          }
        });
      },
      { threshold: 0.3 }
    );
    observer.observe(target);
  }

  function setupSmartCollapse() {
    if (!window.matchMedia) return;
    const media = window.matchMedia("(max-width: 768px)");

    const resetCards = () => {
      document.querySelectorAll('.card[data-smart-collapsed="true"]').forEach(card => {
        card.classList.remove("collapsed");
        card.removeAttribute("data-smart-collapsed");
      });
    };

    const evaluateCards = () => {
      if (!media.matches) {
        resetCards();
        return;
      }
      const cards = document.querySelectorAll(".card");
      cards.forEach(card => {
        if (!card.isConnected) return;
        const rect = card.getBoundingClientRect();
        if (rect.height <= 0) return;
        if (rect.top < -100) {
          if (card.getAttribute("data-smart-collapsed") !== "true") {
            card.classList.add("collapsed");
            card.setAttribute("data-smart-collapsed", "true");
          }
        } else if (card.getAttribute("data-smart-collapsed") === "true" && rect.top > -80) {
          card.classList.remove("collapsed");
          card.removeAttribute("data-smart-collapsed");
        }
      });
    };

    let scheduled = false;
    const scheduleEvaluation = () => {
      if (!media.matches) return;
      if (scheduled) return;
      scheduled = true;
      window.requestAnimationFrame(() => {
        scheduled = false;
        evaluateCards();
      });
    };

    const handleMediaChange = event => {
      if (event.matches) {
        evaluateCards();
      } else {
        resetCards();
      }
    };

    if (typeof media.addEventListener === "function") {
      media.addEventListener("change", handleMediaChange);
    } else if (typeof media.addListener === "function") {
      media.addListener(handleMediaChange);
    }

    window.addEventListener("scroll", scheduleEvaluation, { passive: true });
    window.addEventListener("resize", scheduleEvaluation);
    evaluateCards();

    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(scheduleEvaluation);
      observer.observe(document.body, { childList: true, subtree: true });
    }
  }

  function refreshTaskGestureTargets() {
    const list = $("taskList");
    if (!list) return;
    const cards = list.querySelectorAll(".task-card[data-task-id]");
    cards.forEach(card => {
      const mode = card.classList.contains("is-completed") ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      attachTaskGestureHandlers(card, card.dataset.taskId, mode);
    });
  }

  function attachTaskGestureHandlers(card, taskId, mode = TASK_LIST_MODES.ACTIVE) {
    if (!card || !taskId || mode !== TASK_LIST_MODES.ACTIVE) return;
    if (!window.PointerEvent) return;
    if (card.dataset.gesturesAttached === "true") return;
    card.dataset.gesturesAttached = "true";

    const normalizedId = String(taskId);
    let pointerActive = false;
    let startX = 0;
    let startY = 0;
    let pointerId = null;
    let handled = false;
    let longPressTimer = null;
    const LONG_PRESS_MS = 550;
    const SWIPE_THRESHOLD = 56;
    const MAX_VERTICAL_DRIFT = 28;

    const clearLongPress = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    const resetState = () => {
      pointerActive = false;
      handled = false;
      pointerId = null;
      clearLongPress();
    };

    const handlePointerDown = event => {
      if (!event.isPrimary || event.button !== 0) return;
      if (event.target.closest("button") || event.target.closest("a")) return;
      pointerActive = true;
      handled = false;
      startX = event.clientX;
      startY = event.clientY;
      pointerId = event.pointerId;
      clearLongPress();
      longPressTimer = window.setTimeout(() => {
        handled = true;
        startEditTask(normalizedId);
        showToast("Task details", "Opening task editor.");
      }, LONG_PRESS_MS);
      if (card.setPointerCapture) {
        card.setPointerCapture(pointerId);
      }
    };

    const handlePointerMove = event => {
      if (!pointerActive || pointerId !== event.pointerId) return;
      const dx = event.clientX - startX;
      const dy = Math.abs(event.clientY - startY);
      if (dy > MAX_VERTICAL_DRIFT) {
        clearLongPress();
        return;
      }
      if (!handled && Math.abs(dx) >= SWIPE_THRESHOLD) {
        handled = true;
        clearLongPress();
        if (card.releasePointerCapture && pointerId !== null) {
          card.releasePointerCapture(pointerId);
        }
        pointerActive = false;
        if (dx > 0) {
          startFiveMinuteSprint(normalizedId);
          showToast("Sprint", "Starting a 5-minute focus pass.");
        } else {
          markTaskDoneFromPeek(normalizedId);
          showToast("Task complete", "Marked as done.");
        }
      }
    };

    const handlePointerEnd = event => {
      if (pointerActive && pointerId === event.pointerId && card.releasePointerCapture) {
        card.releasePointerCapture(pointerId);
      }
      resetState();
    };

    card.addEventListener("pointerdown", handlePointerDown);
    card.addEventListener("pointermove", handlePointerMove);
    card.addEventListener("pointerup", handlePointerEnd);
    card.addEventListener("pointerleave", handlePointerEnd);
    card.addEventListener("pointercancel", handlePointerEnd);
  }

  function setupTaskGestures() {
    if (!window.PointerEvent) return;
    const list = $("taskList");
    if (!list) return;
    refreshTaskGestureTargets();
    if (typeof MutationObserver === "undefined") return;
    if (taskGestureObserver) {
      taskGestureObserver.disconnect();
    }
    taskGestureObserver = new MutationObserver(() => refreshTaskGestureTargets());
    taskGestureObserver.observe(list, { childList: true });
  }

  function setupFocusOverlay() {
    const extendBtn = $("focusExtendButton");
    if (extendBtn) {
      extendBtn.addEventListener("click", () => extendSprintBy(5));
    }

    const abortBtn = $("focusAbortButton");
    if (abortBtn) {
      abortBtn.addEventListener("click", () => {
        backToCapture();
        setFocusLaunchOpen(false);
      });
    }

    const completeBtn = $("focusCompleteButton");
    if (completeBtn) {
      completeBtn.addEventListener("click", () => completeTask());
    }

    const overlay = $("focus");
    if (overlay) {
      overlay.addEventListener("click", event => {
        const dismissTarget = event.target.closest("[data-focus-dismiss]");
        if (dismissTarget) {
          backToCapture();
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.body.classList.contains("focus-overlay-active")) {
        backToCapture();
      }
    });
  }

  function setupLazyMedia() {
    const nodes = document.querySelectorAll('img:not([loading]), iframe:not([loading])');
    nodes.forEach(node => {
      node.setAttribute("loading", "lazy");
    });
  }

  const DEFAULT_BLOCK_BATCHES = [
    {
      id: "complex-care",
      label: "Complex Care",
      prefix: "CLX",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "General Clinic",
        importance: 4,
        urgency: 4,
        novelty: 2,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Review vitals and growth chart",
          "Summarize specialty updates",
          "Draft plan and follow-up steps"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "st-pjs",
      label: "St. PJ‚Äôs Shelter",
      prefix: "SPJ",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "St PJ‚Äôs Shelter",
        importance: 4,
        urgency: 5,
        novelty: 3,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Confirm shelter coordination notes",
          "Capture social work updates",
          "List pending referrals"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "craniofacial",
      label: "Craniofacial Clinic",
      prefix: "CRN",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "Craniofacial Clinic",
        importance: 5,
        urgency: 4,
        novelty: 3,
        interest: 4,
        externalPressure: 4,
        timeToStart: 3,
        difficulty: 3,
        subTasks: [
          "Pull imaging summary",
          "Outline surgical recommendations",
          "Document caregiver education"
        ],
        useChartTemplate: true
      }
    }
  ];
  let blockBatchProfiles = {};
  let blockBatchState = {
    activeId: DEFAULT_BLOCK_BATCHES.length ? DEFAULT_BLOCK_BATCHES[0].id : null,
    counts: {}
  };
  let blockBatchIdCounter = 0;
  const ENERGY_LABELS = {
    1: "Foggy",
    2: "Sleepy",
    3: "Steady",
    4: "Energized",
    5: "Lit up"
  };
  const SLEEP_RATING_LABELS = {
    1: "Exhausted",
    2: "Restless",
    3: "Adequate",
    4: "Rested",
    5: "Recharged"
  };
  const NEXT_BEST_FRICTION_RULES = {
    start: task => (Number(task.timeToStart) || 3) <= 3,
    perfection: task => estimateTaskMinutes(task) <= 25,
    social: task => !["Calls", "Inbox"].includes(task.category || ""),
    focus: task => {
      const remaining = Array.isArray(task.subTasks) ? task.subTasks.filter(sub => !sub.completed).length : 0;
      return remaining <= 4;
    }
  };
  const DEFUSE_PROMPTS = [
    { threshold: 60, message: "Feeling ‚â† instruction. You can feel tired and still send the email." },
    { threshold: 30, message: "Fake it: open the doc, type the title, breathe." },
    { threshold: 0, message: "Zone check: distractions locked. You're cleared for takeoff." }
  ];
  const MMP_MIN_MINUTES = 10;
  const MMP_MAX_MINUTES = 20;
  const CONFLICT_DEFAULT_SPRINT = 12;
  const LAUNCH_PAD_PRESETS = {
    "General Clinic": [
      "Stethoscope",
      "Laptop + charger",
      "Clinic badge",
      "Progress note templates",
      "Snacks / water"
    ],
    "St PJ‚Äôs Shelter": [
      "ID badge",
      "Warm layers",
      "Resource handouts",
      "Portable charger",
      "Snacks"
    ],
    "Craniofacial Clinic": [
      "Care plan binders",
      "Growth charts",
      "Camera / tablet",
      "Consent forms",
      "Comfort items"
    ]
  };
  const SLEEP_CHECKLIST_ITEMS = [
    {
      id: "warmShower",
      label: "Warm shower or bath 1‚Äì2 hours before bed",
      tip: "Warm water triggers a cooling rebound that cues melatonin."
    },
    {
      id: "blueLight",
      label: "Blue-light blocker on screens",
      tip: "Filtering blue light reduces melatonin suppression from devices."
    },
    {
      id: "activity",
      label: "Light physical activity earlier today",
      tip: "Daytime movement builds sleep pressure for smoother nights."
    },
    {
      id: "caffeine",
      label: "Caffeine curfew observed (last sip by 2‚ÄØPM)",
      tip: "Caffeine has a ~6 hour half-life‚Äîcurbing it prevents bedtime jitters."
    },
    {
      id: "magnesium",
      label: "Optional magnesium or electrolytes",
      tip: "Magnesium calms the nervous system and supports muscle recovery."
    }
  ];
  const WEEKDAY_OPTIONS = [
    { label: "Any day", value: "any" },
    { label: "Weekdays", value: "weekdays" },
    { label: "Monday", value: "1" },
    { label: "Tuesday", value: "2" },
    { label: "Wednesday", value: "3" },
    { label: "Thursday", value: "4" },
    { label: "Friday", value: "5" },
    { label: "Saturday", value: "6" },
    { label: "Sunday", value: "0" }
  ];

  function getChartFields() {
    return chartFieldIds
      .map(id => $(id))
      .filter(Boolean);
  }

  function setChartFieldsDisabled(isDisabled) {
    getChartFields().forEach(field => {
      field.disabled = isDisabled;
    });
  }

  function storeChartFieldValues() {
    storedChartFieldValues = {};
    chartFieldIds.forEach(id => {
      const field = $(id);
      if (field) {
        storedChartFieldValues[id] = field.value;
      }
    });
  }

  function restoreChartFieldValues() {
    if (!storedChartFieldValues) return;
    chartFieldIds.forEach(id => {
      if (Object.prototype.hasOwnProperty.call(storedChartFieldValues, id)) {
        const field = $(id);
        if (field) {
          field.value = storedChartFieldValues[id];
        }
      }
    });
    storedChartFieldValues = null;
  }

  function showChartFields() {
    const container = $("chartFields");
    if (!container) return;
    container.classList.remove("is-hidden");
    container.setAttribute("aria-hidden", "false");
    setChartFieldsDisabled(false);
    restoreChartFieldValues();
    updateDerivedFields();
  }

  function hideChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storeChartFieldValues();
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  function getToastContainer() {
    return $("toastContainer");
  }

  function showToast(title, message, options = {}) {
    const container = getToastContainer();
    const useContainer = options.position !== "bottom";
    if (useContainer && !container) return;
    const toast = document.createElement("div");
    toast.className = `toast${options.className ? ` ${options.className}` : ""}`;
    if (options.position === "bottom") {
      toast.classList.add("toast--bottom");
    }
    toast.setAttribute("role", "status");
    if (typeof title === "string" && title.trim()) {
      const heading = document.createElement("strong");
      heading.textContent = title;
      toast.appendChild(heading);
    }
    const body = document.createElement("div");
    body.textContent = message;
    toast.appendChild(body);
    if (options.action && typeof options.action.onClick === "function") {
      const actionBtn = document.createElement("button");
      actionBtn.type = "button";
      actionBtn.className = "toast__action";
      actionBtn.textContent = options.action.label || "Action";
      actionBtn.addEventListener("click", () => {
        options.action.onClick();
        toast.remove();
      });
      toast.appendChild(actionBtn);
    }
    if (useContainer) {
      container.appendChild(toast);
    } else {
      document.body.appendChild(toast);
    }
    const timeout = Number.isFinite(options.timeout) ? options.timeout : 6000;
    const hide = () => {
      toast.classList.add("hidden");
      window.setTimeout(() => toast.remove(), 350);
      if (typeof options.onClose === "function") {
        options.onClose();
      }
    };
    if (timeout > 0) {
      window.setTimeout(hide, timeout);
    }
    return toast;
  }

  let taskAddedToastTimer = null;
  let taskAddedToastRemoveTimer = null;

  function showTaskAddedConfirmation(count = 1) {
    let toast = document.querySelector(".task-added-toast");
    if (!toast) {
      toast = document.createElement("div");
      toast.className = "task-added-toast";
      document.body.appendChild(toast);
    }
    toast.textContent = count > 1 ? `${count} tasks added` : "Task added";
    window.requestAnimationFrame(() => toast.classList.add("task-added-toast--visible"));
    if (taskAddedToastTimer) {
      window.clearTimeout(taskAddedToastTimer);
    }
    if (taskAddedToastRemoveTimer) {
      window.clearTimeout(taskAddedToastRemoveTimer);
    }
    taskAddedToastTimer = window.setTimeout(() => {
      toast.classList.remove("task-added-toast--visible");
      taskAddedToastRemoveTimer = window.setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 320);
    }, 1800);
  }

  function getDateKey(date = new Date()) {
    const dt = new Date(date);
    dt.setHours(0, 0, 0, 0);
    const year = dt.getFullYear();
    const month = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function getTodayKey() {
    return getDateKey(new Date());
  }

  function getTomorrowKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() + 1);
    return getDateKey(dt);
  }

  function getOffsetDateKey(dateKey, offsetDays = 0) {
    if (!dateKey || typeof dateKey !== "string") return null;
    const parts = dateKey.split("-").map(part => Number(part));
    if (parts.length !== 3) return null;
    const [year, month, day] = parts;
    if (![year, month, day].every(Number.isFinite)) return null;
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return null;
    const offset = Number(offsetDays);
    if (Number.isFinite(offset) && offset !== 0) {
      dt.setDate(dt.getDate() + offset);
    }
    return getDateKey(dt);
  }

  function getYesterdayKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() - 1);
    return getDateKey(dt);
  }

  function formatFriendlyDate(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function formatShortDateLabel(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  function getDateKeyFromIso(isoString) {
    if (!isoString) return null;
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) return null;
    return getDateKey(date);
  }

  function getDefaultMorningEntry() {
    return {
      completed: {
        move: false,
        reflect: false,
        plan: false
      },
      intention: "",
      planNotes: "",
      energy: null,
      skip: false,
      countdownBlock: null,
      countdownEnd: null,
      celebrated: false,
      lastUpdated: null
    };
  }

  function getDefaultMorningState() {
    return {
      enabled: false,
      entries: {}
    };
  }

  function loadMorningLaunchState() {
    if (morningLaunchState) return morningLaunchState;
    try {
      const raw = localStorage.getItem(MORNING_LAUNCH_KEY);
      if (!raw) {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const state = { ...getDefaultMorningState(), ...parsed };
      if (!state.entries || typeof state.entries !== "object") {
        state.entries = {};
      }
      Object.keys(state.entries).forEach(key => {
        state.entries[key] = { ...getDefaultMorningEntry(), ...state.entries[key] };
      });
      morningLaunchState = state;
    } catch (error) {
      console.error("Unable to load morning launch state", error);
      morningLaunchState = getDefaultMorningState();
    }
    return morningLaunchState;
  }

  function persistMorningLaunchState() {
    if (!morningLaunchState) return;
    try {
      if (morningLaunchState.entries) {
        const keys = Object.keys(morningLaunchState.entries).sort();
        if (keys.length > 60) {
          const toRemove = keys.slice(0, keys.length - 60);
          toRemove.forEach(key => delete morningLaunchState.entries[key]);
        }
      }
      const serialized = JSON.stringify(morningLaunchState);
      localStorage.setItem(MORNING_LAUNCH_KEY, serialized);
    } catch (error) {
      console.error("Unable to persist morning launch state", error);
    }
  }

  function getMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    if (!state.entries) state.entries = {};
    if (!state.entries[dateKey]) {
      state.entries[dateKey] = getDefaultMorningEntry();
    }
    return state.entries[dateKey];
  }

  function resetMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    state.entries[dateKey] = getDefaultMorningEntry();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function setMorningSkip(dateKey = getTodayKey(), skip = true) {
    const entry = getMorningEntry(dateKey);
    entry.skip = skip;
    if (skip) {
      MORNING_BLOCKS.forEach(block => {
        entry.completed[block] = false;
      });
      entry.celebrated = false;
    }
    clearMorningCountdown(entry);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function clearMorningCountdown(entry) {
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = null;
    if (entry) {
      entry.countdownBlock = null;
      entry.countdownEnd = null;
    }
  }

  function formatCountdown(msRemaining) {
    if (!Number.isFinite(msRemaining) || msRemaining <= 0) {
      return "00:00";
    }
    const totalSeconds = Math.ceil(msRemaining / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }

  function updateMoveCountdownDisplay(remainingMs) {
    const display = $("moveCountdown");
    if (!display) return;
    if (!Number.isFinite(remainingMs) || remainingMs <= 0) {
      display.textContent = "20:00";
      return;
    }
    display.textContent = formatCountdown(remainingMs);
  }

  function resumeMorningCountdown(entry) {
    if (!entry || !entry.countdownBlock || !entry.countdownEnd) {
      updateMoveCountdownDisplay(null);
      return;
    }
    const remaining = entry.countdownEnd - Date.now();
    if (remaining <= 0) {
      clearMorningCountdown(entry);
      updateMoveCountdownDisplay(null);
      showToast("MOVE timer", "20 minutes are up. Celebrate the endorphins!");
      return;
    }
    updateMoveCountdownDisplay(remaining);
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = {
      block: entry.countdownBlock,
      intervalId: setInterval(() => {
        const nowRemaining = entry.countdownEnd - Date.now();
        if (nowRemaining <= 0) {
          clearMorningCountdown(entry);
          updateMoveCountdownDisplay(null);
          showToast("MOVE timer", "20 minutes are up. Nice job getting sunlight and motion!");
        } else {
          updateMoveCountdownDisplay(nowRemaining);
        }
      }, 1000)
    };
  }

  function startMorningCountdown(block = "move") {
    const entry = getMorningEntry();
    entry.skip = false;
    entry.countdownBlock = block;
    entry.countdownEnd = Date.now() + DEFAULT_MORNING_TIMER_MINUTES * 60 * 1000;
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    resumeMorningCountdown(entry);
  }

  function setMorningBlockCompleted(block, data = {}) {
    const entry = getMorningEntry();
    entry.skip = false;
    if (!entry.completed) {
      entry.completed = { move: false, reflect: false, plan: false };
    }
    entry.completed[block] = true;
    if (block === "reflect" && data.intention !== undefined) {
      entry.intention = data.intention;
    }
    if (block === "plan" && data.planNotes !== undefined) {
      entry.planNotes = data.planNotes;
    }
    if (block === "move") {
      clearMorningCountdown(entry);
    }
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    showToast("Morning Launch", `Nice momentum! ${block.toUpperCase()} locked in.`);
  }

  function logMorningEnergy(value) {
    const entry = getMorningEntry();
    entry.energy = Number(value);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    if (Number.isFinite(entry.energy)) {
      const label = ENERGY_LABELS[entry.energy] || entry.energy;
      showToast("Energy logged", `Morning energy set to ${label}.`);
    }
  }

  function getMorningHistory(limit = 10) {
    const state = loadMorningLaunchState();
    const entries = Object.entries(state.entries || {});
    return entries
      .sort((a, b) => (a[0] > b[0] ? -1 : 1))
      .slice(0, limit)
      .map(([dateKey, entry]) => ({ dateKey, entry }));
  }

  function buildMorningStatus(entry) {
    if (entry.skip) {
      return "Launch skipped today. Reset whenever you‚Äôre ready.";
    }
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed[block]);
    if (!completedBlocks.length) {
      return "Start with MOVE to flood dopamine and sunlight cues.";
    }
    if (completedBlocks.length === MORNING_BLOCKS.length) {
      if (!entry.celebrated) {
        entry.celebrated = true;
        persistMorningLaunchState();
        showToast("Morning Launch", "All three blocks complete. Notice your focus surge later today.");
      }
      return "üåü All three blocks complete. Anchor this momentum into your next action.";
    }
    if (completedBlocks.length === 1) {
      return `Great job completing ${completedBlocks[0].toUpperCase()}! Next up: ${completedBlocks[0] === "move" ? "REFLECT" : "PLAN"}.`;
    }
    return "Great job completing MOVE and REFLECT! Lock in a process-based PLAN next.";
  }

  function updateMorningHistoryList() {
    const list = $("morningLaunchHistory");
    if (!list) return;
    const history = getMorningHistory(7);
    list.innerHTML = "";
    if (!history.length) {
      const item = document.createElement("li");
      item.textContent = "No mornings logged yet.";
      list.appendChild(item);
      return;
    }
    history.forEach(({ dateKey, entry }) => {
      const item = document.createElement("li");
      const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
      const energyLabel = entry.energy ? ENERGY_LABELS[entry.energy] || entry.energy : "--";
      item.textContent = `${formatFriendlyDate(dateKey)} ‚Äî ${completedCount}/${MORNING_BLOCKS.length} blocks ‚Ä¢ Energy: ${energyLabel}`;
      list.appendChild(item);
    });
  }

  function calculateMorningCompletionPercent(entry) {
    if (!entry || entry.skip) return 0;
    const totalBlocks = MORNING_BLOCKS.length || 1;
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    return Math.round((completedBlocks / totalBlocks) * 100);
  }

  function renderMorningLaunchChart(limit = MORNING_CHART_LIMIT) {
    const canvas = $("morningLaunchChart");
    const summaryEl = $("morningLaunchChartSummary");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const width = canvas.clientWidth || canvas.width || 360;
    const height = canvas.clientHeight || canvas.height || 160;
    canvas.width = width;
    canvas.height = height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const history = getMorningHistory(limit);
    if (!history.length) {
      ctx.fillStyle = "#6b7280";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Complete your morning launch to unlock insights.", canvas.width / 2, canvas.height / 2);
      if (summaryEl) {
        summaryEl.textContent = "Complete your morning launch to unlock momentum and energy trends.";
      }
      return;
    }
    const chronological = [...history].reverse();
    const padding = 28;
    const graphWidth = canvas.width - padding * 2;
    const graphHeight = canvas.height - padding * 2;
    const xStep = chronological.length > 1 ? graphWidth / (chronological.length - 1) : 0;
    const completionPoints = [];
    const energyPoints = [];
    chronological.forEach((item, index) => {
      const { entry, dateKey } = item;
      completionPoints.push({
        index,
        value: calculateMorningCompletionPercent(entry),
        dateKey
      });
      const energy = Number(entry.energy);
      energyPoints.push({
        index,
        value: Number.isFinite(energy) ? Math.round(Math.max(0, Math.min(100, ((energy - 1) / 4) * 100))) : null,
        energy: Number.isFinite(energy) ? energy : null,
        dateKey
      });
    });
    const project = value => {
      const safeValue = Math.max(0, Math.min(100, Number(value) || 0));
      return canvas.height - padding - (safeValue / 100) * graphHeight;
    };
    ctx.strokeStyle = MORNING_CHART_COLORS.axis;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    const gridValues = [25, 50, 75, 100];
    ctx.setLineDash([4, 4]);
    gridValues.forEach(value => {
      const y = project(value);
      ctx.strokeStyle = MORNING_CHART_COLORS.grid;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      ctx.fillStyle = "#7f8a9c";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      ctx.fillText(`${value}%`, padding - 6, y + 3);
    });
    ctx.setLineDash([]);
    ctx.fillStyle = "#9aa6b8";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    chronological.forEach((item, index) => {
      const x = padding + xStep * index;
      ctx.fillText(formatShortDateLabel(item.dateKey), x, canvas.height - padding + 14);
    });
    ctx.fillStyle = "#8893a5";
    ctx.textAlign = "left";
    ctx.fillText("Energy line scaled so top = level 5", padding, padding - 10);
    const drawLine = (points, color, dashed = false) => {
      const valid = points.filter(point => Number.isFinite(point.value));
      if (!valid.length) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dashed ? [6, 4] : []);
      ctx.beginPath();
      valid.forEach((point, idx) => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);
      valid.forEach(point => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });
      ctx.restore();
    };
    drawLine(completionPoints, MORNING_CHART_COLORS.completion, false);
    drawLine(energyPoints, MORNING_CHART_COLORS.energy, true);
    if (summaryEl) {
      const completionSum = completionPoints.reduce((sum, point) => sum + (Number.isFinite(point.value) ? point.value : 0), 0);
      const completionAvg = completionPoints.length
        ? Math.round(completionSum / completionPoints.length)
        : 0;
      const energyValid = energyPoints.filter(point => Number.isFinite(point.energy));
      let summary = `Last ${chronological.length}-day average completion: ${completionAvg}%`;
      if (energyValid.length) {
        const avgEnergy = energyValid.reduce((sum, point) => sum + point.energy, 0) / energyValid.length;
        const label = ENERGY_LABELS[Math.round(avgEnergy)] || "";
        summary += ` ‚Ä¢ Energy ‚âà ${avgEnergy.toFixed(1)}${label ? ` (${label})` : ""}`;
      } else {
        summary += " ‚Ä¢ Log energy to compare how rested mornings drive completion";
      }
      summaryEl.textContent = `${summary}.`;
    }
  }

  function updateMorningLaunchUI() {
    const state = loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    const content = $("morningLaunchContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      clearMorningCountdown(getMorningEntry());
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const summary = $("morningLaunchChartSummary");
      if (summary) {
        summary.textContent = "Enable Morning Launch to start tracking your morning momentum.";
      }
      const chart = $("morningLaunchChart");
      if (chart) {
        const ctx = chart.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, chart.width, chart.height);
        }
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    const entry = getMorningEntry();
    const intentionField = $("morningIntention");
    const planField = $("morningPlanNotes");
    if (intentionField) {
      intentionField.value = entry.intention || "";
    }
    if (planField) {
      planField.value = entry.planNotes || "";
    }
    const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    const progress = $("morningLaunchProgress");
    if (progress) {
      const width = Math.round((completedCount / MORNING_BLOCKS.length) * 100);
      progress.style.width = `${width}%`;
    }
    const status = $("morningLaunchStatus");
    if (status) {
      status.textContent = buildMorningStatus(entry);
    }
    MORNING_BLOCKS.forEach(block => {
      const blockEl = document.querySelector(`.routine-block[data-block="${block}"]`);
      if (blockEl) {
        blockEl.classList.toggle("completed", Boolean(entry.completed?.[block]));
      }
    });
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      const value = Number.isFinite(entry.energy) ? entry.energy : 3;
      energySlider.value = String(value);
      if (energyLabel) {
        const label = ENERGY_LABELS[value] || value;
        energyLabel.textContent = `${label}`;
      }
      alignEnergySliders(value, "morning");
    }
    resumeMorningCountdown(entry);
    updateMorningHistoryList();
    renderMorningLaunchChart();
  }

  function initializeMorningLaunchModule() {
    loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadMorningLaunchState();
        state.enabled = event.target.checked;
        persistMorningLaunchState();
        updateMorningLaunchUI();
      });
    }
    const resetBtn = $("morningLaunchResetBtn");
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        if (confirm("Reset today's launch blocks?")) {
          resetMorningEntry();
        }
      });
    }
    const skipBtn = $("morningLaunchSkipBtn");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => setMorningSkip(getTodayKey(), true));
    }
    const moveStart = $("moveStartBtn");
    if (moveStart) {
      moveStart.addEventListener("click", () => startMorningCountdown("move"));
    }
    const moveComplete = $("moveCompleteBtn");
    if (moveComplete) {
      moveComplete.addEventListener("click", () => setMorningBlockCompleted("move"));
    }
    const reflectSave = $("reflectCompleteBtn");
    if (reflectSave) {
      reflectSave.addEventListener("click", () => {
        const intention = $("morningIntention")?.value.trim() || "";
        setMorningBlockCompleted("reflect", { intention });
      });
    }
    const planSave = $("planCompleteBtn");
    if (planSave) {
      planSave.addEventListener("click", () => {
        const planNotes = $("morningPlanNotes")?.value.trim() || "";
        setMorningBlockCompleted("plan", { planNotes });
      });
    }
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || 3);
        if (energyLabel) {
          const label = ENERGY_LABELS[value] || value;
          energyLabel.textContent = label;
        }
        alignEnergySliders(value, "morning");
      });
    }
    const energySave = $("morningEnergySave");
    if (energySave) {
      energySave.addEventListener("click", () => {
        const value = Number($("morningEnergy")?.value || 3);
        logMorningEnergy(value);
      });
    }
    const intentionButtons = document.querySelectorAll(".intention-buttons button[data-intention]");
    if (intentionButtons.length) {
      intentionButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const intention = btn.getAttribute("data-intention") || "";
          const field = $("morningIntention");
          if (field) {
            field.value = intention;
            field.focus();
          }
        });
      });
    }
    updateMorningLaunchUI();
  }

  function generateLaunchPadItemId() {
    return `lp_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`;
  }

  function getDefaultLaunchPadState() {
    return {
      reminderTime: DEFAULT_LAUNCH_PAD_REMINDER,
      activeSite: DEFAULT_LAUNCH_PAD_SITE,
      items: {},
      status: {},
      lastReminderDate: null,
      lastMorningNudge: null
    };
  }

  function normalizeLaunchPadState(state) {
    const base = { ...getDefaultLaunchPadState(), ...state };
    if (!base.items || typeof base.items !== "object") {
      base.items = {};
    }
    if (!base.status || typeof base.status !== "object") {
      base.status = {};
    }
    Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
      if (!Array.isArray(base.items[site]) || !base.items[site].length) {
        base.items[site] = LAUNCH_PAD_PRESETS[site].map(name => ({
          id: generateLaunchPadItemId(),
          name,
          dayRule: "any",
          isCustom: false
        }));
      } else {
        base.items[site] = base.items[site].map(item => ({
          id: item.id || generateLaunchPadItemId(),
          name: item.name || "Item",
          dayRule: item.dayRule || "any",
          isCustom: Boolean(item.isCustom)
        }));
      }
    });
    if (!base.items[base.activeSite]) {
      base.activeSite = DEFAULT_LAUNCH_PAD_SITE;
    }
    return base;
  }

  function loadLaunchPadState() {
    if (launchPadState) return launchPadState;
    try {
      const raw = localStorage.getItem(LAUNCH_PAD_KEY);
      if (!raw) {
        launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
        return launchPadState;
      }
      const parsed = JSON.parse(raw);
      launchPadState = normalizeLaunchPadState(parsed || {});
    } catch (error) {
      console.error("Unable to load launch pad state", error);
      launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
    }
    return launchPadState;
  }

  function persistLaunchPadState() {
    if (!launchPadState) return;
    try {
      if (launchPadState.status) {
        const keys = Object.keys(launchPadState.status).sort();
        if (keys.length > 90) {
          const toRemove = keys.slice(0, keys.length - 90);
          toRemove.forEach(key => delete launchPadState.status[key]);
        }
      }
      localStorage.setItem(LAUNCH_PAD_KEY, JSON.stringify(launchPadState));
    } catch (error) {
      console.error("Unable to persist launch pad state", error);
    }
    updateLaunchPadSummary();
  }

  function ensureLaunchPadSite(site) {
    const state = loadLaunchPadState();
    if (!state.items[site]) {
      const preset = LAUNCH_PAD_PRESETS[site] || [];
      state.items[site] = preset.map(name => ({
        id: generateLaunchPadItemId(),
        name,
        dayRule: "any",
        isCustom: false
      }));
    }
    return state.items[site];
  }

  function setLaunchPadActiveSite(site) {
    const state = loadLaunchPadState();
    state.activeSite = site;
    ensureLaunchPadSite(site);
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function loadPresetForActiveSite() {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const preset = LAUNCH_PAD_PRESETS[site] || [];
    state.items[site] = preset.map(name => ({
      id: generateLaunchPadItemId(),
      name,
      dayRule: "any",
      isCustom: false
    }));
    persistLaunchPadState();
    renderLaunchPadSettings();
    showToast("Launch pad reset", `${site} preset restored.`);
  }

  function addLaunchPadItem(name) {
    const trimmed = (name || "").trim();
    if (!trimmed) return;
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    ensureLaunchPadSite(site);
    state.items[site].push({
      id: generateLaunchPadItemId(),
      name: trimmed,
      dayRule: "any",
      isCustom: true
    });
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function removeLaunchPadItem(itemId) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const next = list.filter(item => item.id !== itemId);
    state.items[site] = next;
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function updateLaunchPadDayRule(itemId, dayRule) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const item = list.find(entry => entry.id === itemId);
    if (item) {
      item.dayRule = dayRule;
      persistLaunchPadState();
    }
  }

  function shouldIncludeLaunchPadItemOnDate(item, dateKey) {
    if (!item || !dateKey) return false;
    if (!item.dayRule || item.dayRule === "any") return true;
    const dt = new Date(`${dateKey}T00:00:00`);
    if (Number.isNaN(dt.getTime())) return true;
    const weekday = dt.getDay();
    if (item.dayRule === "weekdays") {
      return weekday >= 1 && weekday <= 5;
    }
    return String(weekday) === String(item.dayRule);
  }

  function getLaunchPadStatus(dateKey) {
    const state = loadLaunchPadState();
    if (!state.status[dateKey]) {
      state.status[dateKey] = {};
    }
    return state.status[dateKey];
  }

  function setLaunchPadItemReady(dateKey, itemId, ready) {
    const status = getLaunchPadStatus(dateKey);
    status[itemId] = Boolean(ready);
    persistLaunchPadState();
    updateLaunchPadSummary();
  }

  function computeLaunchPadReadiness(dateKey) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const relevant = list.filter(item => shouldIncludeLaunchPadItemOnDate(item, dateKey));
    const status = getLaunchPadStatus(dateKey);
    const readyCount = relevant.filter(item => status[item.id]).length;
    return {
      total: relevant.length,
      ready: readyCount,
      items: relevant,
      status
    };
  }

  function updateLaunchPadSummary() {
    const summary = $("launchPadSummary");
    if (!summary) return;
    const todayKey = getTodayKey();
    const readiness = computeLaunchPadReadiness(todayKey);
    if (readiness.total === 0) {
      summary.textContent = "No launch pad items scheduled for today.";
      return;
    }
    summary.innerHTML = "";
    const header = document.createElement("strong");
    header.textContent = `Launch Pad: ${readiness.ready}/${readiness.total} items ready`;
    summary.appendChild(header);
    const hint = document.createElement("div");
    if (readiness.ready === readiness.total) {
      hint.textContent = "Everything is staged ‚Äî future you says thanks!";
    } else {
      const remaining = readiness.total - readiness.ready;
      hint.textContent = `${remaining} item(s) still need attention before heading out.`;
    }
    summary.appendChild(hint);
  }

  function renderLaunchPadSettings() {
    const state = loadLaunchPadState();
    const siteSelect = $("launchPadSiteSelect");
    if (siteSelect) {
      siteSelect.innerHTML = "";
      Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
        const option = document.createElement("option");
        option.value = site;
        option.textContent = site;
        if (site === state.activeSite) {
          option.selected = true;
        }
        siteSelect.appendChild(option);
      });
      siteSelect.onchange = event => {
        setLaunchPadActiveSite(event.target.value);
      };
    }
    const timeInput = $("launchPadReminderTime");
    if (timeInput) {
      timeInput.value = state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER;
      timeInput.onchange = event => {
        state.reminderTime = event.target.value || DEFAULT_LAUNCH_PAD_REMINDER;
        persistLaunchPadState();
      };
    }
    const listContainer = $("launchPadItemList");
    if (listContainer) {
      listContainer.innerHTML = "";
      const items = ensureLaunchPadSite(state.activeSite || DEFAULT_LAUNCH_PAD_SITE);
      if (!items.length) {
        const empty = document.createElement("p");
        empty.className = "score";
        empty.textContent = "No launch pad items yet.";
        listContainer.appendChild(empty);
      } else {
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "launch-pad-item";
          const name = document.createElement("div");
          name.textContent = item.name;
          if (item.isCustom) {
            const custom = document.createElement("small");
            custom.textContent = "custom";
            name.appendChild(document.createElement("br"));
            name.appendChild(custom);
          }
          const select = document.createElement("select");
          WEEKDAY_OPTIONS.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            if (option.value === item.dayRule) {
              opt.selected = true;
            }
            select.appendChild(opt);
          });
          select.addEventListener("change", event => {
            updateLaunchPadDayRule(item.id, event.target.value);
          });
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "üóë";
          removeBtn.title = "Remove item";
          removeBtn.addEventListener("click", () => {
            if (confirm(`Remove ${item.name}?`)) {
              removeLaunchPadItem(item.id);
            }
          });
          row.appendChild(name);
          row.appendChild(select);
          row.appendChild(removeBtn);
          listContainer.appendChild(row);
        });
      }
    }
    updateLaunchPadSummary();
  }

  function renderLaunchPadModalList(targetDateKey) {
    const container = $("launchPadModalList");
    if (!container) return;
    container.innerHTML = "";
    const readiness = computeLaunchPadReadiness(targetDateKey);
    if (!readiness.total) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No items needed for that day.";
      container.appendChild(empty);
      return;
    }
    readiness.items.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(readiness.status[item.id]);
      checkbox.addEventListener("change", event => {
        setLaunchPadItemReady(targetDateKey, item.id, event.target.checked);
      });
      const span = document.createElement("span");
      span.textContent = item.name;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function setModalVisibility(modalId, isVisible) {
    const overlay = $(modalId);
    if (!overlay) return;
    if (isVisible) {
      overlay.classList.remove("hidden");
      overlay.setAttribute("aria-hidden", "false");
    } else {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
  }

  function openLaunchPadModal(options = {}) {
    const { targetDateKey = getTomorrowKey() } = options;
    renderLaunchPadModalList(targetDateKey);
    const overlay = $("launchPadModal");
    if (!overlay) return;
    overlay.dataset.targetDate = targetDateKey;
    setModalVisibility("launchPadModal", true);
  }

  function closeLaunchPadModal() {
    setModalVisibility("launchPadModal", false);
  }

  function initializeLaunchPadModule() {
    loadLaunchPadState();
    renderLaunchPadSettings();
    const addBtn = $("launchPadAddItem");
    if (addBtn) {
      addBtn.addEventListener("click", () => {
        const field = $("launchPadNewItem");
        addLaunchPadItem(field?.value || "");
        if (field) field.value = "";
      });
    }
    const presetBtn = $("launchPadLoadPreset");
    if (presetBtn) {
      presetBtn.addEventListener("click", () => {
        if (confirm("Reset this site's launch pad to the curated preset?")) {
          loadPresetForActiveSite();
        }
      });
    }
    const openEvening = $("openLaunchPadModal");
    if (openEvening) {
      openEvening.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTomorrowKey() }));
    }
    const morningReview = $("launchPadMorningReview");
    if (morningReview) {
      morningReview.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTodayKey() }));
    }
    const modalClose = $("launchPadModalClose");
    if (modalClose) {
      modalClose.addEventListener("click", () => {
        closeLaunchPadModal();
      });
    }
    const overlay = $("launchPadModal");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeLaunchPadModal();
        }
      });
    }
    updateLaunchPadSummary();
  }

  function getDefaultSleepState() {
    return {
      enabled: false,
      checklist: {},
      melatonin: {
        enabled: false,
        time: DEFAULT_MELATONIN_TIME,
        lastPrompt: null
      },
      sunlight: {
        enabled: false,
        time: DEFAULT_SUNLIGHT_TIME,
        lastPrompt: null
      },
      restRatings: {}
    };
  }

  function loadSleepToolkitState() {
    if (sleepToolkitState) return sleepToolkitState;
    try {
      const raw = localStorage.getItem(SLEEP_TOOLKIT_KEY);
      if (!raw) {
        sleepToolkitState = getDefaultSleepState();
        return sleepToolkitState;
      }
      const parsed = JSON.parse(raw);
      sleepToolkitState = { ...getDefaultSleepState(), ...parsed };
      if (!sleepToolkitState.checklist || typeof sleepToolkitState.checklist !== "object") {
        sleepToolkitState.checklist = {};
      }
      if (!sleepToolkitState.restRatings || typeof sleepToolkitState.restRatings !== "object") {
        sleepToolkitState.restRatings = {};
      }
    } catch (error) {
      console.error("Unable to load sleep toolkit state", error);
      sleepToolkitState = getDefaultSleepState();
    }
    return sleepToolkitState;
  }

  function persistSleepToolkitState() {
    if (!sleepToolkitState) return;
    try {
      if (sleepToolkitState.checklist) {
        const keys = Object.keys(sleepToolkitState.checklist).sort();
        if (keys.length > 120) {
          const toRemove = keys.slice(0, keys.length - 120);
          toRemove.forEach(key => delete sleepToolkitState.checklist[key]);
        }
      }
      if (sleepToolkitState.restRatings) {
        const ratingKeys = Object.keys(sleepToolkitState.restRatings).sort();
        if (ratingKeys.length > 180) {
          const prune = ratingKeys.slice(0, ratingKeys.length - 180);
          prune.forEach(key => delete sleepToolkitState.restRatings[key]);
        }
      }
      localStorage.setItem(SLEEP_TOOLKIT_KEY, JSON.stringify(sleepToolkitState));
    } catch (error) {
      console.error("Unable to persist sleep toolkit state", error);
    }
  }

  function getSleepChecklistEntry(dateKey = getTodayKey()) {
    const state = loadSleepToolkitState();
    if (!state.checklist[dateKey]) {
      const entry = {};
      SLEEP_CHECKLIST_ITEMS.forEach(item => {
        entry[item.id] = false;
      });
      state.checklist[dateKey] = entry;
    }
    return state.checklist[dateKey];
  }

  function toggleSleepChecklistItem(itemId, value, dateKey = getTodayKey()) {
    const checklist = getSleepChecklistEntry(dateKey);
    if (!Object.prototype.hasOwnProperty.call(checklist, itemId)) return;
    checklist[itemId] = Boolean(value);
    persistSleepToolkitState();
    updateSleepToolkitUI();
  }

  function computeSleepCompletionFromChecklist(checklist) {
    const total = SLEEP_CHECKLIST_ITEMS.length;
    if (!checklist) {
      return { total, completed: 0, percent: 0 };
    }
    const completed = SLEEP_CHECKLIST_ITEMS.filter(item => checklist[item.id]).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function computeSleepCompletion(dateKey = getTodayKey(), options = {}) {
    const { createIfMissing = true } = options || {};
    let checklist;
    if (createIfMissing) {
      checklist = getSleepChecklistEntry(dateKey);
    } else {
      const state = loadSleepToolkitState();
      checklist = state.checklist?.[dateKey];
    }
    return computeSleepCompletionFromChecklist(checklist);
  }

  function renderSleepChecklist(dateKey = getTodayKey()) {
    const container = $("sleepChecklist");
    if (!container) return;
    const checklist = getSleepChecklistEntry(dateKey);
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(checklist[item.id]);
      checkbox.addEventListener("change", event => {
        toggleSleepChecklistItem(item.id, event.target.checked, dateKey);
      });
      const span = document.createElement("div");
      const title = document.createElement("strong");
      title.textContent = item.label;
      const tip = document.createElement("div");
      tip.textContent = item.tip;
      tip.style.fontSize = "0.78rem";
      tip.style.color = "#9aa0a6";
      span.appendChild(title);
      span.appendChild(tip);
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function updateSleepCompletionSummary(dateKey = getTodayKey()) {
    const summary = $("sleepCompletionSummary");
    if (!summary) return;
    const { total, completed, percent } = computeSleepCompletion(dateKey);
    summary.textContent = `You set ${completed}/${total} sleep steps ready ‚Äì ${percent}% of the plan primed.`;
  }

  function renderSleepTips() {
    const container = $("sleepTips");
    if (!container) return;
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const tip = document.createElement("div");
      tip.textContent = `‚Ä¢ ${item.tip}`;
      container.appendChild(tip);
    });
  }

  function recordSleepRating(dateKey, rating) {
    const state = loadSleepToolkitState();
    state.restRatings[dateKey] = Number(rating);
    persistSleepToolkitState();
    updateSleepToolkitUI();
    const label = SLEEP_RATING_LABELS[rating] || rating;
    showToast("Sleep logged", `Restfulness marked as ${label}.`);
  }

  function countChartTasksCompletedOn(dateKey) {
    if (!dateKey) return 0;
    return tasks.filter(task => {
      if (!isChartTask(task)) return false;
      const completionKey = getDateKeyFromIso(task.completedAt);
      return completionKey === dateKey;
    }).length;
  }

  function updateSleepCorrelationSummary() {
    const summary = $("sleepCorrelationSummary");
    if (!summary) return;
    const state = loadSleepToolkitState();
    const fragments = [];

    const ratingEntries = Object.entries(state.restRatings || {});
    if (!ratingEntries.length) {
      fragments.push("Log rest ratings to see how sleep fuels charting momentum.");
    } else {
      let highCount = 0;
      let highCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      ratingEntries.forEach(([dateKey, rating]) => {
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (Number(rating) >= 4) {
          highCount += 1;
          highCharts += charts;
        } else {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      const restedAvgValue = highCount ? highCharts / highCount : null;
      const draggyAvgValue = lowCount ? lowCharts / lowCount : null;
      const restedAvg = restedAvgValue !== null ? restedAvgValue.toFixed(1) : "‚Äî";
      const draggyAvg = draggyAvgValue !== null ? draggyAvgValue.toFixed(1) : "‚Äî";
      let ratingText = `Rest rating impact ‚Üí Rested mornings (‚â•4) yielded ${restedAvg} next-day chart(s); low-energy mornings (‚â§3) managed ${draggyAvg}.`;
      if (restedAvgValue !== null && draggyAvgValue !== null) {
        const delta = restedAvgValue - draggyAvgValue;
        if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
          ratingText += ` (‚âà${delta > 0 ? "+" : ""}${delta.toFixed(1)} boost when you're rested)`;
        }
      } else {
        ratingText += " Keep logging a mix of scores to sharpen this insight.";
      }
      fragments.push(ratingText);
    }

    const checklistEntries = Object.entries(state.checklist || {});
    if (!checklistEntries.length) {
      fragments.push("Check off sleep steps to measure how consistency drives next-day charting.");
    } else {
      let strongCount = 0;
      let strongCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      checklistEntries.forEach(([dateKey, checklist]) => {
        const { percent } = computeSleepCompletionFromChecklist(checklist);
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (percent >= 80) {
          strongCount += 1;
          strongCharts += charts;
        } else if (percent <= 40) {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      if (!strongCount && !lowCount) {
        fragments.push("Track both dialed-in and skipped nights to see how the checklist nudges tomorrow's throughput.");
      } else {
        const strongAvgValue = strongCount ? strongCharts / strongCount : null;
        const lowAvgValue = lowCount ? lowCharts / lowCount : null;
        const strongAvg = strongAvgValue !== null ? strongAvgValue.toFixed(1) : "‚Äî";
        const lowAvg = lowAvgValue !== null ? lowAvgValue.toFixed(1) : "‚Äî";
        let checklistText = `Sleep steps impact ‚Üí Nights hitting ‚â•80% of steps led to ${strongAvg} chart(s) the next day; nights under 40% slid to ${lowAvg}.`;
        if (strongAvgValue !== null && lowAvgValue !== null) {
          const delta = strongAvgValue - lowAvgValue;
          if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
            checklistText += ` (‚âà${delta > 0 ? "+" : ""}${delta.toFixed(1)} chart swing when you protect the routine)`;
          }
        } else {
          checklistText += " Keep collecting data on both ends to firm up the comparison.";
        }
        fragments.push(checklistText);
      }
    }

    if (fragments.length === 0) {
      fragments.push("Log sleep data to let the system prove that care rituals beat pushing through fatigue.");
    } else {
      fragments.push("Let these cues remind you: honoring circadian rhythms outruns brute-force catch-up.");
    }

    summary.innerHTML = fragments.join("<br/>");
  }

  function renderSleepMorningRating() {
    const container = $("sleepMorningRating");
    if (!container) return;
    container.innerHTML = "";
    const state = loadSleepToolkitState();
    const targetKey = getYesterdayKey();
    if (!targetKey) return;
    const existing = state.restRatings[targetKey];
    const label = document.createElement("label");
    label.style.margin = "0";
    label.textContent = `How rested do you feel this morning (${formatFriendlyDate(targetKey)})?`;
    container.appendChild(label);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "1";
    slider.max = "5";
    slider.step = "1";
    slider.value = String(existing || 3);
    slider.style.flex = "1";
    const valueLabel = document.createElement("span");
    valueLabel.textContent = SLEEP_RATING_LABELS[slider.value] || slider.value;
    slider.addEventListener("input", event => {
      const val = Number(event.target.value);
      valueLabel.textContent = SLEEP_RATING_LABELS[val] || val;
    });
    const save = document.createElement("button");
    save.textContent = existing ? "Update rating" : "Log rating";
    save.addEventListener("click", () => {
      recordSleepRating(targetKey, Number(slider.value));
    });
    container.appendChild(slider);
    container.appendChild(valueLabel);
    container.appendChild(save);
  }

  function updateSleepToolkitUI() {
    const state = loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    const content = $("sleepToolkitContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const alert = $("sunlightAlert");
      if (alert) {
        alert.classList.add("hidden");
        alert.setAttribute("aria-hidden", "true");
      }
      if (sunlightAlertTimeoutId) {
        clearTimeout(sunlightAlertTimeoutId);
        sunlightAlertTimeoutId = null;
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    renderSleepChecklist();
    updateSleepCompletionSummary();
    renderSleepTips();
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.checked = Boolean(state.melatonin?.enabled);
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.value = state.melatonin?.time || DEFAULT_MELATONIN_TIME;
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.checked = Boolean(state.sunlight?.enabled);
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.value = state.sunlight?.time || DEFAULT_SUNLIGHT_TIME;
    }
    renderSleepMorningRating();
    updateSleepCorrelationSummary();
  }

  function initializeSleepToolkitModule() {
    loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.enabled = event.target.checked;
        persistSleepToolkitState();
        updateSleepToolkitUI();
      });
    }
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.time = event.target.value || DEFAULT_MELATONIN_TIME;
        persistSleepToolkitState();
      });
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.time = event.target.value || DEFAULT_SUNLIGHT_TIME;
        persistSleepToolkitState();
      });
    }
    updateSleepToolkitUI();
  }

  function getMinutesFromTimeString(timeString) {
    if (!timeString || typeof timeString !== "string") return null;
    const [hours, minutes] = timeString.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    return hours * 60 + minutes;
  }

  function showSunlightBanner(message) {
    const alert = $("sunlightAlert");
    if (!alert) return;
    alert.textContent = message;
    alert.classList.remove("hidden");
    alert.setAttribute("aria-hidden", "false");
    if (sunlightAlertTimeoutId) {
      clearTimeout(sunlightAlertTimeoutId);
    }
    sunlightAlertTimeoutId = setTimeout(() => {
      alert.classList.add("hidden");
      alert.setAttribute("aria-hidden", "true");
    }, 5 * 60 * 1000);
  }

  function checkLaunchPadReminder() {
    const state = loadLaunchPadState();
    const timeMinutes = getMinutesFromTimeString(state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.lastReminderDate !== todayKey) {
      state.lastReminderDate = todayKey;
      persistLaunchPadState();
      showToast("Launch pad", "Prepare tomorrow's kit? Check your evening checklist.");
    }
  }

  function checkMelatoninReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.melatonin?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.melatonin.time || DEFAULT_MELATONIN_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.melatonin.lastPrompt !== todayKey) {
      state.melatonin.lastPrompt = todayKey;
      persistSleepToolkitState();
      showToast("Melatonin reminder", "Dim the lights and consider your melatonin routine.");
    }
  }

  function checkSunlightReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.sunlight?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.sunlight.time || DEFAULT_SUNLIGHT_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.sunlight.lastPrompt !== todayKey) {
      state.sunlight.lastPrompt = todayKey;
      persistSleepToolkitState();
      showSunlightBanner("Sunlight exposure due ‚Äî step outside for 10 minutes to halt melatonin.");
      showToast("Sunlight cue", "Morning light = cortisol boost + melatonin shutoff.");
    }
  }

  function checkAllReminders() {
    checkLaunchPadReminder();
    checkMelatoninReminder();
    checkSunlightReminder();
  }

  function startReminderLoop() {
    if (reminderIntervalId) {
      clearInterval(reminderIntervalId);
    }
    checkAllReminders();
    reminderIntervalId = setInterval(checkAllReminders, 60 * 1000);
  }

  function setQuickTaskTemplateMode(enabled) {
    const overlay = $("addTaskOverlay");
    const hint = $("quickTaskTemplateHint");
    const state = enabled ? "true" : "false";
    if (overlay) {
      if (enabled) {
        overlay.setAttribute("data-quick-task-mode", state);
      } else {
        overlay.removeAttribute("data-quick-task-mode");
      }
    }
    if (hint) {
      hint.classList.toggle("hidden", !enabled);
    }
    if (enabled) {
      setTaskDetailsCollapsed(true);
    }
  }

  function handleCategoryChange(value) {
    const resolvedCategory = (value ?? $("taskCategory")?.value ?? "").toString();
    populateScalesForCategory(resolvedCategory);
    if (resolvedCategory.toLowerCase() === "chart") {
      showChartFields();
    } else {
      hideChartFields();
    }
    setQuickTaskTemplateMode(isQuickTaskCategory(resolvedCategory));
    renderTemplates();
  }

  function initializeChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storedChartFieldValues = null;
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  const NUMERIC_SCALE_FIELDS = ["importance","novelty","interest","timeToStart","difficulty"];
  const SCALE_FIELDS = [...NUMERIC_SCALE_FIELDS, "urgency", "externalPressure"];
  const BASIC_NUMERIC_DESCRIPTORS = [1, 2, 3, 4, 5].map(value => ({
    value,
    text: String(value)
  }));

  const DEFAULT_DESCRIPTOR_SET = {
    importance: BASIC_NUMERIC_DESCRIPTORS,
    urgency: [
      { value: 5, text: "5 ‚Äì Critical Billing Window or Immediate Patient Need" },
      { value: 4, text: "4 ‚Äì High Priority ‚Äì Near-Term Deadline" },
      { value: 3, text: "3 ‚Äì Moderate Priority ‚Äì Monthly Closure" },
      { value: 2, text: "2 ‚Äì Low Billing Value ‚Äì Ready today" },
      { value: 1, text: "1 ‚Äì Routine Follow-Up Work" }
    ],
    novelty: BASIC_NUMERIC_DESCRIPTORS,
    interest: BASIC_NUMERIC_DESCRIPTORS,
    externalPressure: [
      { value: 1, text: "1 ‚Äì Solo responsibility" },
      { value: 2, text: "2 ‚Äì Soft deadline / courtesy check" },
      { value: 3, text: "3 ‚Äì Peer or team waiting" },
      { value: 4, text: "4 ‚Äì Leadership expectation" },
      { value: 5, text: "5 ‚Äì Patient or compliance critical" }
    ],
    timeToStart: BASIC_NUMERIC_DESCRIPTORS,
    difficulty: BASIC_NUMERIC_DESCRIPTORS
  };

  const CATEGORY_DESCRIPTOR_SETS = {
    chart: {
      importance: [
        { value: 1, text: "1 ‚Äì Chart adds minimal new information or duplicates an existing note." },
        { value: 2, text: "2 ‚Äì Routine follow-up with limited clinical or legal relevance." },
        { value: 3, text: "3 ‚Äì Contains moderate clinical content or affects internal workflow (e.g., continuity documentation)." },
        { value: 4, text: "4 ‚Äì Impacts care coordination, billing, or orders being released." },
        { value: 5, text: "5 ‚Äì Critical legal or clinical documentation‚Äîsuch as a new complex care note, DME letter, or therapy order summary." }
      ],
      urgency: [
        { value: 1, text: "1 ‚Äì No immediate consequence if delayed more than a week." },
        { value: 2, text: "2 ‚Äì Should be completed within five to seven days to keep the workflow moving." },
        { value: 3, text: "3 ‚Äì Approaching the expected three-day chart completion window." },
        { value: 4, text: "4 ‚Äì Actively holding up orders, referrals, or communication with other providers." },
        { value: 5, text: "5 ‚Äì Must be completed within 24 hours‚Äîblocking patient care, billing, or compliance." }
      ],
      novelty: [
        { value: 1, text: "1 ‚Äì Repetitive, nearly identical to prior encounters‚Äîmental autopilot work." },
        { value: 2, text: "2 ‚Äì Familiar patient with predictable updates." },
        { value: 3, text: "3 ‚Äì Some variation or new findings but overall routine." },
        { value: 4, text: "4 ‚Äì Clearly different or updated scenario (new comorbidity, new specialist input)." },
        { value: 5, text: "5 ‚Äì Entirely new case or patient; requires full synthesis and high cognitive effort." }
      ],
      interest: [
        { value: 1, text: "1 ‚Äì Emotionally draining, tedious, or disengaging." },
        { value: 2, text: "2 ‚Äì Slightly more tolerable but still repetitive." },
        { value: 3, text: "3 ‚Äì Neutral‚Äîacceptable task without resistance or enthusiasm." },
        { value: 4, text: "4 ‚Äì Personally engaging or meaningful (e.g., rewarding outcome, interesting complexity)." },
        { value: 5, text: "5 ‚Äì Highly interesting or affirming‚Äîfeels worth your energy investment." }
      ],
      externalPressure: [
        { value: 1, text: "1 ‚Äì No one waiting on this; purely internal backlog." },
        { value: 2, text: "2 ‚Äì Minimal outside awareness‚Äîperhaps a resident awaiting co-signature." },
        { value: 3, text: "3 ‚Äì Family or administrative team may soon follow up." },
        { value: 4, text: "4 ‚Äì Directly affects nursing, therapy, or resident progress if left undone." },
        { value: 5, text: "5 ‚Äì Leadership, family, or compliance risk if not completed immediately." }
      ],
      timeToStart: [
        { value: 1, text: "1 ‚Äì Requires major prep‚Äîmultiple subspecialty notes or context review needed." },
        { value: 2, text: "2 ‚Äì Some setup required; moderate amount of data gathering first." },
        { value: 3, text: "3 ‚Äì Ready to begin with basic template or SmartPhrase already open." },
        { value: 4, text: "4 ‚Äì Mostly drafted or pre-filled by a resident." },
        { value: 5, text: "5 ‚Äì One click from completion‚Äîreview and sign only." }
      ],
      difficulty: [
        { value: 1, text: "1 ‚Äì Very complex visit‚Äîmultiple specialists, high stakes." },
        { value: 2, text: "2 ‚Äì High cognitive load‚Äîmultiple notes or CareEverywhere data to merge." },
        { value: 3, text: "3 ‚Äì Moderate effort‚Äîsome review of orders, results, or medication changes." },
        { value: 4, text: "4 ‚Äì Small amount of synthesis or clean-up work." },
        { value: 5, text: "5 ‚Äì Straightforward chart; minimal thought required." }
      ]
    },
    admin: {
      importance: [
        { value: 1, text: "1: Low-value clerical item ‚Äî informational only, not linked to care or billing (e.g., generic record release)." },
        { value: 2, text: "2: Routine paperwork (e.g., school letter, general clearance) with limited medical impact." },
        { value: 3, text: "3: Moderately important ‚Äî ensures continuity of services or avoids family confusion." },
        { value: 4, text: "4: Affects patient function, equipment use, or continuity of home health/therapy services." },
        { value: 5, text: "5: Legally, financially, or clinically critical (e.g., DME or home nursing orders, time-sensitive medical necessity forms)." }
      ],
      urgency: [
        { value: 1, text: "1: No time constraint; backlog cleanup or batch task." },
        { value: 2, text: "2: Preferred within a week to prevent workflow pileup." },
        { value: 3, text: "3: Due soon ‚Äî flagged or requested multiple times (within 72 hours)." },
        { value: 4, text: "4: Time-sensitive ‚Äî blocking care, equipment renewal, or external agency action." },
        { value: 5, text: "5: Immediate deadline ‚Äî service interruption or patient safety risk if not completed today." }
      ],
      novelty: [
        { value: 1, text: "1: Routine, repetitive ‚Äî identical to previous letters or forms." },
        { value: 2, text: "2: Minor variation (same patient, slightly different form)." },
        { value: 3, text: "3: Moderate variation ‚Äî new formatting or service type but same structure." },
        { value: 4, text: "4: Requires rethinking or rewriting ‚Äî new medical justification or appeal." },
        { value: 5, text: "5: Entirely new or unusual form requiring research, collaboration, or creative framing." }
      ],
      interest: [
        { value: 1, text: "1: Utterly draining paperwork with no personal reward." },
        { value: 2, text: "2: Mildly tolerable ‚Äî repetitive but manageable." },
        { value: 3, text: "3: Neutral task; emotionally flat but not difficult." },
        { value: 4, text: "4: Slightly satisfying ‚Äî clear, finite, ‚Äòbox checked‚Äô gratification." },
        { value: 5, text: "5: Emotionally rewarding ‚Äî high-impact document that feels meaningful or helps a deserving family." }
      ],
      externalPressure: [
        { value: 1, text: "1: No one waiting; background task only." },
        { value: 2, text: "2: Requested once, no follow-up." },
        { value: 3, text: "3: Family, therapist, or vendor has followed up once or twice." },
        { value: 4, text: "4: Repeated requests or escalating frustration from external partner." },
        { value: 5, text: "5: Time-sensitive escalation ‚Äî multiple stakeholders involved, risk of complaint or service disruption." }
      ],
      timeToStart: [
        { value: 1, text: "1: Fully prepped or pre-filled ‚Äî literally one click to sign, fax, or send." },
        { value: 2, text: "2: Nearly complete ‚Äî requires signatures or minor edits." },
        { value: 3, text: "3: Ready to draft ‚Äî information accessible, no major digging needed." },
        { value: 4, text: "4: Some setup required ‚Äî gathering diagnostic codes, reviewing notes." },
        { value: 5, text: "5: Requires locating old versions or supporting documents (e.g., past forms, letters)." }
      ],
      difficulty: [
        { value: 1, text: "1: Straightforward ‚Äî fill in basic info, minimal judgment." },
        { value: 2, text: "2: Simple but tedious ‚Äî multiple checkboxes or sign-offs." },
        { value: 3, text: "3: Moderate ‚Äî requires referencing recent visits or clinical notes." },
        { value: 4, text: "4: High cognitive effort ‚Äî must summarize complex clinical picture concisely." },
        { value: 5, text: "5: Very complex ‚Äî appeals, multidisciplinary coordination, or justification requiring clinical precision." }
      ]
    },
    personal: {
      importance: [
        { value: 1, text: "1 ‚Äì Trivial ‚Äî doesn‚Äôt really matter if done" },
        { value: 2, text: "2 ‚Äì Mildly useful ‚Äî minor quality-of-life improvement" },
        { value: 3, text: "3 ‚Äì Helpful ‚Äî meaningful progress toward a goal" },
        { value: 4, text: "4 ‚Äì Significant ‚Äî affects well-being or relationships" },
        { value: 5, text: "5 ‚Äì Critical ‚Äî has serious emotional, financial, or health consequences" }
      ],
      urgency: [
        { value: 1, text: "1 ‚Äì No time pressure ‚Äî can wait indefinitely" },
        { value: 2, text: "2 ‚Äì Slight ‚Äî would be good to do soon" },
        { value: 3, text: "3 ‚Äì Moderate ‚Äî needs attention within a few days" },
        { value: 4, text: "4 ‚Äì High ‚Äî needs to be done today" },
        { value: 5, text: "5 ‚Äì Immediate ‚Äî must be addressed now" }
      ],
      interest: [
        { value: 1, text: "1 ‚Äì Dreaded ‚Äî pure avoidance energy" },
        { value: 2, text: "2 ‚Äì Unpleasant but tolerable" },
        { value: 3, text: "3 ‚Äì Neutral ‚Äî neither appealing nor aversive" },
        { value: 4, text: "4 ‚Äì Mildly engaging" },
        { value: 5, text: "5 ‚Äì Genuinely energizing or rewarding" }
      ],
      difficulty: [
        { value: 1, text: "1 ‚Äì Very hard ‚Äî high resistance, many steps, or emotionally draining" },
        { value: 2, text: "2 ‚Äì Challenging ‚Äî mentally or logistically demanding" },
        { value: 3, text: "3 ‚Äì Moderate ‚Äî manageable with steady focus" },
        { value: 4, text: "4 ‚Äì Mild effort ‚Äî easy, straightforward, minimal resistance" },
        { value: 5, text: "5 ‚Äì Simple ‚Äî effortless, can be done on autopilot" }
      ],
      timeToStart: [
        { value: 1, text: "1 ‚Äì Requires major setup or emotional readiness" },
        { value: 2, text: "2 ‚Äì Some prep work before starting" },
        { value: 3, text: "3 ‚Äì Can start with minimal prep" },
        { value: 4, text: "4 ‚Äì Ready to begin immediately" },
        { value: 5, text: "5 ‚Äì Already in motion / one click from done" }
      ]
    }
  };

  function getCategoryDescriptorKey(category) {
    const normalized = (category || "").toString().trim().toLowerCase();
    return normalized || "general";
  }

  function getScaleOptions(fieldId, categoryKey) {
    const key = categoryKey || "general";
    const descriptorSet = CATEGORY_DESCRIPTOR_SETS[key];
    if (descriptorSet && Array.isArray(descriptorSet[fieldId])) {
      return descriptorSet[fieldId];
    }
    const defaults = DEFAULT_DESCRIPTOR_SET[fieldId];
    if (defaults) {
      return defaults;
    }
    return BASIC_NUMERIC_DESCRIPTORS;
  }

  function populateScaleSelect(fieldId, categoryKey) {
    const select = $(fieldId);
    if (!select) return;
    const previousValue = select.value;
    const options = getScaleOptions(fieldId, categoryKey);
    select.innerHTML = "";
    options.forEach(option => {
      const opt = document.createElement("option");
      opt.value = String(option.value);
      opt.textContent = option.text || String(option.value);
      select.appendChild(opt);
    });
    const previous = previousValue !== undefined && previousValue !== null
      ? String(previousValue)
      : "";
    const hasPrevious = options.some(option => String(option.value) === previous);
    if (hasPrevious) {
      select.value = previous;
    } else if (options.length > 0) {
      select.value = String(options[0].value);
    }
  }

  function populateScalesForCategory(category) {
    const key = getCategoryDescriptorKey(category);
    currentScaleDescriptorCategory = key;
    SCALE_FIELDS.forEach(fieldId => populateScaleSelect(fieldId, key));
    updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
  }

  const BASE_CHART_STEPS = [
    "Load Abridge (dictation)",
    "Review/modify HPI",
    "Review/modify PE",
    "Review/modify A/P",
    "Review/submit orders",
    "Enter billing code",
    "Sign off"
  ];
  const RESIDENT_ATTESTATION_STEP = "Add Attestation";
  let currentFocusTaskIndex = null;

  function generateSubTaskId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  }

  function isChartTask(task) {
    return task && String(task.category).toLowerCase() === "chart";
  }

  function isQuickTaskCategory(value) {
    return String(value || "").toLowerCase() === QUICK_TASK_CATEGORY.toLowerCase();
  }

  function isQuickTask(task) {
    return task && isQuickTaskCategory(task.category);
  }

  function buildChartSteps(authorType) {
    const steps = [...BASE_CHART_STEPS];
    if (String(authorType).toLowerCase() === "resident") {
      const billingIndex = steps.indexOf("Enter billing code");
      const insertIndex = billingIndex === -1 ? steps.length - 1 : billingIndex;
      steps.splice(insertIndex, 0, RESIDENT_ATTESTATION_STEP);
    }
    return steps;
  }

  function calculateDurationMinutes(start, end) {
    if (!start || !end) return null;
    const startDate = new Date(start);
    const endDate = new Date(end);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Number((diff / (1000 * 60)).toFixed(2));
  }

  function isTaskCompleted(task) {
    if (!task) return false;
    return Boolean(task.completed || task.completedAt);
  }

  function getCompletionTimestamp(task) {
    if (!task) return null;
    return task.completedAt || task.completionTime || null;
  }

  function formatDateTime(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  }

  function formatDuration(minutes) {
    if (minutes === null || minutes === undefined) return "--";
    const num = Number(minutes);
    if (!Number.isFinite(num)) return "--";
    return `${num.toFixed(2)} min`;
  }

  function formatElapsedMs(ms) {
    if (!Number.isFinite(ms) || ms < 0) return "--";
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
  }

  function estimateTaskMinutes(task) {
    if (!task) return 0;
    const subTasks = Array.isArray(task.subTasks) ? task.subTasks : [];
    const remaining = subTasks.filter(sub => !sub.completed);
    const remainingCount = remaining.length > 0 ? remaining.length : 1;
    const recordedDurations = subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value) && value > 0);
    if (recordedDurations.length) {
      const avg = recordedDurations.reduce((sum, value) => sum + value, 0) / recordedDurations.length;
      return Math.max(1, Math.ceil(avg * remainingCount));
    }
    const n = subTasks.length;
    const difficulty = Number(task.difficulty || 3);
    const startFriction = Number(task.timeToStart || 3);
    const estimate = Math.round((10 + 2 * n) * (0.7 + 0.15 * difficulty) + (startFriction - 3) * 2);
    return Math.max(5, estimate);
  }

  function getEnergyLevel() {
    const el = document.querySelector('[data-field="energy-level"]');
    if (el) {
      const value = Number(el.value || el.getAttribute('data-value'));
      if (Number.isFinite(value)) return value;
    }
    return 3;
  }

  function getTimeBudgetMinutes() {
    const el = document.querySelector('[data-field="time-budget"]');
    if (!el) return Infinity;
    const value = Number(el.value);
    return Number.isFinite(value) && value > 0 ? value : Infinity;
  }

  function alignEnergySliders(value, source = "next") {
    const resolved = clampScale(value, 3);
    if (syncingEnergySliders) {
      return resolved;
    }
    syncingEnergySliders = true;
    const nextSlider = $("nextBestEnergy");
    if (nextSlider && source !== "next" ) {
      nextSlider.value = String(resolved);
      nextSlider.setAttribute("data-value", String(resolved));
    }
    const nextLabel = $("nextBestEnergyLabel");
    if (nextLabel) {
      const label = ENERGY_LABELS[resolved] || resolved;
      nextLabel.textContent = label;
    }
    const morningSlider = $("morningEnergy");
    if (morningSlider && source !== "morning") {
      morningSlider.value = String(resolved);
      const morningLabel = $("morningEnergyLabel");
      if (morningLabel) {
        const label = ENERGY_LABELS[resolved] || resolved;
        morningLabel.textContent = label;
      }
    }
    const nextField = document.querySelector('#nextBestEnergy');
    if (nextField) {
      nextField.setAttribute('data-value', String(resolved));
    }
    syncingEnergySliders = false;
    return resolved;
  }

  function energyFit(task, energyLevel) {
    if (!Number.isFinite(energyLevel)) return 1;
    const est = estimateTaskMinutes(task);
    const difficulty = Number(task?.difficulty || 3);
    const lowEnergyWeight = energyLevel <= 2 ? (est > 20 ? 0.85 : 1) * (difficulty >= 4 ? 0.85 : 1) : 1;
    const highEnergyWeight = energyLevel >= 4 ? 1.05 : 1;
    return lowEnergyWeight * highEnergyWeight;
  }

  function timeFit(task, budgetMinutes) {
    if (!Number.isFinite(budgetMinutes)) return 1;
    const est = estimateTaskMinutes(task);
    if (!Number.isFinite(est) || est <= 0) return 1;
    if (est <= budgetMinutes) {
      const ratio = est / (budgetMinutes * 0.85);
      return Math.max(0.85, Math.min(1.05, 1.05 - Math.abs(1 - ratio) * 0.3));
    }
    const overRatio = est / budgetMinutes;
    return Math.max(0.55, 1 - (overRatio - 1) * 0.6);
  }


  function getEffectiveEnergyLevel() {
    let level = null;
    try {
      if (typeof getMorningEntry === "function") {
        const entry = getMorningEntry();
        if (entry && Number.isFinite(Number(entry.energy))) {
          level = clampScale(entry.energy, 3);
        }
      }
    } catch (error) {
      console.warn("Unable to read morning energy entry", error);
    }
    if (!Number.isFinite(level)) {
      const slider = $("morningEnergy");
      if (slider) {
        const sliderValue = Number(slider.value);
        if (Number.isFinite(sliderValue)) {
          level = clampScale(sliderValue, 3);
        }
      }
    }
    if (!Number.isFinite(level)) {
      level = 3;
    }
    return level;
  }

  function computeEnergyFit(task, energyLevel) {
    return energyFit(task, energyLevel);
  }

  function computeTimeFit(task, budgetMinutes) {
    return timeFit(task, budgetMinutes);
  }

  function createSubTask(name, priority, options = {}) {
    return {
      id: generateSubTaskId(),
      name,
      completed: false,
      priority,
      startTime: null,
      completionTime: null,
      durationMinutes: null,
      activeDurationMs: 0,
      lastResumedAt: null,
      isPaused: false,
      isFirstThree: Boolean(options.isFirstThree),
      deferredUntilUnlock: Boolean(options.deferredUntilUnlock)
    };
  }

  function normalizeSubTask(sub, basePriority) {
    if (!sub) {
      return createSubTask("Step", basePriority);
    }
    const normalized = {
      id: sub.id || generateSubTaskId(),
      name: sub.name || "Step",
      completed: Boolean(sub.completed),
      priority: toNumber(sub.priority, basePriority),
      startTime: sub.startTime || null,
      completionTime: sub.completionTime || null,
      durationMinutes: sub.durationMinutes !== undefined && sub.durationMinutes !== null && Number.isFinite(Number(sub.durationMinutes))
        ? Number(sub.durationMinutes)
        : null,
      activeDurationMs: Number.isFinite(Number(sub.activeDurationMs)) ? Number(sub.activeDurationMs) : 0,
      lastResumedAt: sub.lastResumedAt || null,
      isPaused: Boolean(sub.isPaused),
      isFirstThree: Boolean(sub.isFirstThree),
      deferredUntilUnlock: Boolean(sub.deferredUntilUnlock)
    };
    if (normalized.durationMinutes === null && normalized.startTime && normalized.completionTime) {
      normalized.durationMinutes = calculateDurationMinutes(normalized.startTime, normalized.completionTime);
    }
    if (normalized.completed) {
      normalized.isPaused = false;
      normalized.lastResumedAt = null;
    }
    return normalized;
  }

  function shouldTriggerFirstThreeWizard(taskName, subLines, category) {
    const normalizedName = (taskName || "").toLowerCase();
    const wordCount = normalizedName.split(/\s+/).filter(Boolean).length;
    const hasKeyword = FIRST_THREE_KEYWORDS.some(keyword => normalizedName.includes(keyword));
    const isChart = (category || "").toLowerCase() === "chart";
    if (Array.isArray(subLines) && subLines.length > 0) {
      return false;
    }
    return wordCount >= FIRST_THREE_WORD_THRESHOLD || hasKeyword || isChart;
  }

  function applyFirstThreeSteps(task, steps, basePriority) {
    if (!task) return;
    const trimmed = Array.isArray(steps)
      ? steps.map(step => step.trim()).filter(Boolean)
      : [];
    while (trimmed.length < 3) {
      const defaults = ["Open workspace", "Outline first move", "Start five-minute draft"];
      trimmed.push(defaults[trimmed.length] || `Micro step ${trimmed.length + 1}`);
    }
    task.firstThreeMode = true;
    task.firstThreeUnlocked = Boolean(task.firstThreeUnlocked);
    task.firstThreeSteps = trimmed.slice(0, 3);
    const firstThreeSubs = trimmed.slice(0, 3).map(step => createSubTask(step, basePriority, { isFirstThree: true }));
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const deferred = !task.firstThreeUnlocked;
    const remainder = existingSubs.map(sub => ({
      ...sub,
      deferredUntilUnlock: deferred && !sub.isFirstThree
    }));
    task.subTasks = [...firstThreeSubs, ...remainder];
  }

  function getVisibleSubTasks(task) {
    if (!task || !Array.isArray(task.subTasks)) return [];
    if (!task.firstThreeMode || task.firstThreeUnlocked) {
      return task.subTasks;
    }
    return task.subTasks.filter(sub => sub.isFirstThree || !sub.deferredUntilUnlock);
  }

  function maybeUnlockFirstThree(task, { silent = false } = {}) {
    if (!task || !task.firstThreeMode) return;
    const subs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const firstThreeSubs = subs.filter(sub => sub.isFirstThree);
    if (firstThreeSubs.length === 0) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      return;
    }
    const allComplete = firstThreeSubs.every(sub => sub.completed);
    if (allComplete && !task.firstThreeUnlocked) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      if (!silent) {
        showToast("Momentum!", "Nice momentum! Here's what's next.");
      }
    }
  }

  function computeTotalChartDuration(subTasks) {
    if (!Array.isArray(subTasks) || subTasks.length === 0) return 0;
    return Number(subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0).toFixed(2));
  }

  function getTaskTotalDuration(task) {
    if (!task) return null;
    if (isChartTask(task)) {
      const value = Number(task.chartDurationMinutes);
      return Number.isFinite(value) && value > 0 ? value : null;
    }
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);
    if (total <= 0) return null;
    return Number(total.toFixed(2));
  }

  function updateChartDurationForTask(task) {
    if (!isChartTask(task)) {
      delete task.chartDurationMinutes;
      return;
    }
    task.chartDurationMinutes = computeTotalChartDuration(task.subTasks);
  }

  function clearRunningTimers() {
    runningTimers.forEach(intervalId => clearInterval(intervalId));
    runningTimers.clear();
  }

  function stopTimerForSubTask(subId) {
    const intervalId = runningTimers.get(subId);
    if (intervalId) {
      clearInterval(intervalId);
      runningTimers.delete(subId);
    }
  }

  function getSubTaskElapsedMs(sub, includeRunning = true) {
    if (!sub) return 0;
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    if (!includeRunning) {
      return base;
    }
    if (!sub.startTime || sub.completed || sub.isPaused) {
      return base;
    }
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    if (Number.isNaN(resumeDate.getTime())) {
      return base;
    }
    return base + Math.max(0, Date.now() - resumeDate.getTime());
  }

  function dispatchFocusStepEvent(eventName, detail) {
    const target = $("focus") || document;
    target.dispatchEvent(new CustomEvent(eventName, { bubbles: true, detail }));
  }

  function trackTimer(sub, timerEl) {
    if (!timerEl) return;
    stopTimerForSubTask(sub.id);
    if (sub.completed) {
      timerEl.textContent = `Completed ‚Äì ${formatDuration(sub.durationMinutes)}`;
      return;
    }
    if (!sub.startTime) {
      timerEl.textContent = "Timer: --";
      return;
    }
    if (sub.isPaused) {
      const pausedElapsed = getSubTaskElapsedMs(sub, false);
      timerEl.textContent = `Paused ‚Äì ${formatElapsedMs(pausedElapsed)}`;
      return;
    }
    const update = () => {
      const elapsedMs = getSubTaskElapsedMs(sub);
      if (!Number.isFinite(elapsedMs) || elapsedMs < 0) {
        timerEl.textContent = "Timer: --";
        return;
      }
      timerEl.textContent = `Timer: ${formatElapsedMs(elapsedMs)}`;
    };
    update();
    const intervalId = setInterval(update, 1000);
    runningTimers.set(sub.id, intervalId);
  }

  function setSprintVisualState(active) {
    const bodyEl = document.body;
    if (!bodyEl) return;
    bodyEl.classList.toggle("sprint-active", Boolean(active));
  }

  function stopFocusTimer(resetDisplay = true) {
    if (focusTimerId) {
      clearInterval(focusTimerId);
      focusTimerId = null;
    }
    focusTimerStart = null;
    focusTimerLastPing = null;
    sprintEndTime = null;
    if (resetDisplay) {
      sprintDurationMinutes = null;
      resetDistractionTracking();
      setSprintVisualState(false);
    }
    setCaughtMeEnabled(false);
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    timerEl.classList.remove("pulse");
    if (resetDisplay) {
      timerEl.textContent = "üß≠ Focus Time: 0:00";
      setFocusProgress(0);
    }
  }

  function setFocusProgress(percent) {
    const fill = $("focusProgressFill");
    if (!fill) return;
    const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
    fill.style.width = `${clamped}%`;
  }

  function updateFocusTimerDisplay(elapsedMs) {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0 && sprintEndTime) {
      const remaining = Math.max(0, sprintEndTime - Date.now());
      if (remaining > 0) {
        const minutesLeft = Math.floor(remaining / 60000);
        const secondsLeft = Math.floor((remaining % 60000) / 1000);
        timerEl.textContent = `‚è±Ô∏è Sprint: ${minutesLeft}:${String(secondsLeft).padStart(2, "0")}`;
        const total = sprintDurationMinutes * 60000;
        const elapsed = Math.max(0, total - remaining);
        setFocusProgress(total > 0 ? (elapsed / total) * 100 : 0);
        return;
      }
      sprintDurationMinutes = null;
      sprintEndTime = null;
      timerEl.textContent = "‚úÖ Sprint complete";
      setFocusProgress(100);
      triggerFocusPing();
      return;
    }
    const minutes = Math.floor(elapsedMs / 60000);
    const seconds = Math.floor((elapsedMs % 60000) / 1000);
    timerEl.textContent = `üß≠ Focus Time: ${minutes}:${String(seconds).padStart(2, "0")}`;
    const gentlePercent = Math.min(100, (elapsedMs / (25 * 60000)) * 100);
    setFocusProgress(gentlePercent);
  }

  function playFocusPing() {
    if (!focusSoundEnabled) return;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor) return;
    if (!focusAudioContext) {
      try {
        focusAudioContext = new AudioContextCtor();
      } catch (error) {
        focusAudioContext = null;
        return;
      }
    }
    if (focusAudioContext.state === "suspended") {
      focusAudioContext.resume().catch(() => {});
    }
    const duration = 0.4;
    const oscillator = focusAudioContext.createOscillator();
    const gain = focusAudioContext.createGain();
    oscillator.type = "sine";
    oscillator.frequency.setValueAtTime(880, focusAudioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, focusAudioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, focusAudioContext.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, focusAudioContext.currentTime + duration);
    oscillator.connect(gain);
    gain.connect(focusAudioContext.destination);
    oscillator.start();
    oscillator.stop(focusAudioContext.currentTime + duration);
  }

  function triggerFocusPing() {
    const timerEl = $("focusTimer");
    if (timerEl) {
      timerEl.classList.add("pulse");
      setTimeout(() => timerEl.classList.remove("pulse"), 1000);
    }
    playFocusPing();
  }

  function startFocusTimer() {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    stopFocusTimer(false);
    focusTimerStart = Date.now();
    focusTimerLastPing = focusTimerStart;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0) {
      sprintEndTime = focusTimerStart + sprintDurationMinutes * 60000;
    } else {
      sprintEndTime = null;
    }
    updateFocusTimerDisplay(0);
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0) {
      setFocusProgress(0);
    }
    focusTimerId = setInterval(() => {
      if (focusTimerStart === null) return;
      const now = Date.now();
      const elapsed = now - focusTimerStart;
      updateFocusTimerDisplay(elapsed);
      if (!focusTimerLastPing || now - focusTimerLastPing >= FOCUS_PING_INTERVAL_MS) {
        triggerFocusPing();
        focusTimerLastPing = now;
      }
    }, 1000);
    setCaughtMeEnabled(true);
  }

  function setCaughtMeEnabled(enabled) {
    const button = $("caughtMeButton");
    if (!button) return;
    button.disabled = !enabled;
    button.setAttribute("aria-disabled", enabled ? "false" : "true");
    if (!enabled) {
      hideDistractionPrompt();
    }
  }

  function hideDistractionPrompt() {
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.classList.add("hidden");
    }
  }

  function toggleDistractionPrompt() {
    if (!focusTimerStart) return;
    const prompt = $("distractionPrompt");
    if (!prompt) return;
    prompt.classList.toggle("hidden");
  }

  function resetDistractionTracking() {
    focusDistractionLog = [];
    distractionTriggersSinceReset = 0;
    updateDistractionLogUI();
    hideDistractionPrompt();
    clearDoorwayResetState({ hidePrompt: true });
  }

  function updateDistractionLogUI() {
    const list = $("distractionLog");
    if (!list) return;
    list.innerHTML = "";
    if (!focusDistractionLog.length) {
      const empty = document.createElement("li");
      empty.className = "distraction-empty";
      empty.textContent = "Clear runway. Keep cruising.";
      list.appendChild(empty);
      return;
    }
    const entries = focusDistractionLog.slice().reverse();
    entries.forEach(entry => {
      const item = document.createElement("li");
      const time = document.createElement("span");
      time.className = "distraction-log__time";
      if (Number.isFinite(entry.offset)) {
        time.textContent = formatElapsedMs(entry.offset);
      } else {
        time.textContent = new Date(entry.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
      const label = document.createElement("div");
      label.className = "distraction-log__label";
      label.textContent = entry.label;
      item.appendChild(time);
      item.appendChild(label);
      list.appendChild(item);
    });
  }

  function logDistractionTrigger(triggerValue) {
    if (!focusTimerStart) return;
    const option = DISTRACTION_TRIGGER_OPTIONS.find(entry => entry.value === triggerValue);
    const label = option ? option.label : String(triggerValue || "Trigger");
    const timestamp = Date.now();
    const offset = focusTimerStart ? Math.max(0, timestamp - focusTimerStart) : null;
    focusDistractionLog.push({ label, timestamp, offset });
    if (focusDistractionLog.length > 8) {
      focusDistractionLog = focusDistractionLog.slice(focusDistractionLog.length - 8);
    }
    distractionTriggersSinceReset += 1;
    updateDistractionLogUI();
    hideDistractionPrompt();
    maybePromptDoorwayReset();
  }

  function maybePromptDoorwayReset() {
    if (doorwayResetState.active || doorwayResetState.pending) return;
    if (distractionTriggersSinceReset < DOORWAY_RESET_THRESHOLD) return;
    showDoorwayResetPrompt();
  }

  function showDoorwayResetPrompt() {
    const container = $("doorwayReset");
    const message = $("doorwayResetMessage");
    if (!container || !message) return;
    container.classList.remove("hidden");
    message.textContent = "Two distractions logged. Take a 60-second doorway reset?";
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: true, endTime: null, countdownId: null };
    showToast("Doorway reset", "Stand, walk to the doorway, clear the mental cache, then glide back.");
  }

  function startDoorwayResetCountdown() {
    const container = $("doorwayReset");
    if (!container) return;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Stand, walk to the doorway, and let the reset happen.";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: true, pending: false, endTime: Date.now() + DOORWAY_RESET_DURATION_MS, countdownId: null };
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Reset running‚Ä¶";
      startBtn.disabled = true;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Skip reset";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.classList.remove("hidden");
    }
    updateDoorwayCountdownUI();
    doorwayResetState.countdownId = setInterval(updateDoorwayCountdownUI, 250);
  }

  function updateDoorwayCountdownUI() {
    if (!doorwayResetState.active) return;
    const countdown = $("doorwayCountdown");
    if (!countdown) return;
    const remaining = Math.max(0, doorwayResetState.endTime - Date.now());
    const seconds = Math.ceil(remaining / 1000);
    countdown.textContent = `‚è≥ ${seconds}s remaining`;
    if (remaining <= 0) {
      completeDoorwayReset();
    }
  }

  function completeDoorwayReset() {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    distractionTriggersSinceReset = 0;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Doorway reset complete. Notice what feels lighter.";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "‚úÖ Reset done";
      countdown.classList.remove("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Do it again";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Close";
    }
    setTimeout(() => clearDoorwayResetState({ hidePrompt: true }), 6000);
  }

  function clearDoorwayResetState({ hidePrompt = false } = {}) {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    const container = $("doorwayReset");
    if (!container) return;
    if (hidePrompt) {
      container.classList.add("hidden");
    }
    const message = $("doorwayResetMessage");
    if (message && hidePrompt) {
      message.textContent = "";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
  }

  function skipDoorwayResetPrompt() {
    clearDoorwayResetState({ hidePrompt: true });
    distractionTriggersSinceReset = 0;
  }

  function initializeDistractionTools() {
    const button = $("caughtMeButton");
    if (button) {
      button.addEventListener("click", () => {
        if (button.disabled) return;
        toggleDistractionPrompt();
      });
    }
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.addEventListener("click", event => {
        const target = event.target.closest('[data-distraction-trigger]');
        if (!target) return;
        const value = target.getAttribute('data-distraction-trigger');
        if (value) {
          logDistractionTrigger(value);
        }
      });
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.addEventListener("click", startDoorwayResetCountdown);
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipDoorwayResetPrompt);
    }
    updateDistractionLogUI();
    setCaughtMeEnabled(false);
  }

  function setFocusSoundPreference(enabled) {
    focusSoundEnabled = Boolean(enabled);
    localStorage.setItem("focusSoundEnabled", focusSoundEnabled ? "true" : "false");
  }

  function getAuditStorageKey(date = new Date()) {
    return `${AUDIT_STORAGE_PREFIX}${date.toISOString().split("T")[0]}`;
  }

  function getAuditShownKey(storageKey) {
    return `${storageKey}${AUDIT_SHOWN_SUFFIX}`;
  }

  function loadAuditEntries(storageKey) {
    if (!storageKey) return [];
    const raw = localStorage.getItem(storageKey);
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  }

  function recordTaskCompletion(task) {
    if (!task) return;
    const storageKey = getAuditStorageKey();
    const entries = loadAuditEntries(storageKey);
    const subDetails = Array.isArray(task.subTasks)
      ? task.subTasks.map(sub => {
          const rawDuration = Number(sub?.durationMinutes);
          const normalizedDuration = Number.isFinite(rawDuration) && rawDuration > 0
            ? Number(rawDuration.toFixed(2))
            : null;
          return {
            name: sub?.name || "Step",
            duration: normalizedDuration
          };
        })
      : [];
    let totalDuration = getTaskTotalDuration(task);
    if (Number.isFinite(totalDuration) && totalDuration > 0) {
      totalDuration = Number(totalDuration.toFixed(2));
    } else {
      const fallbackTotal = subDetails.reduce((sum, sub) => {
        return Number.isFinite(sub.duration) ? sum + sub.duration : sum;
      }, 0);
      totalDuration = fallbackTotal > 0 ? Number(fallbackTotal.toFixed(2)) : null;
    }
    entries.push({
      name: task.name || "Task",
      subDetails,
      totalDuration,
      completedAt: getCompletionTimestamp(task) || new Date().toISOString()
    });
    localStorage.setItem(storageKey, JSON.stringify(entries));
  }

  function showEndOfDayAudit(entries = null, shownKeyOverride = null) {
    const storageKey = getAuditStorageKey();
    const auditEntries = entries || loadAuditEntries(storageKey);
    if (!auditEntries.length) return;
    const shownKey = shownKeyOverride || getAuditShownKey(storageKey);

    const overlay = document.createElement("div");
    overlay.className = "audit-backdrop";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.setAttribute("aria-labelledby", "auditModalTitle");

    const modal = document.createElement("div");
    modal.className = "audit-modal";

    const title = document.createElement("h3");
    title.id = "auditModalTitle";
    title.textContent = "End of Day Audit";
    modal.appendChild(title);

    const totalMinutes = auditEntries.reduce((sum, entry) => {
      const value = Number(entry?.totalDuration);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);

    let longestSubtask = null;
    auditEntries.forEach(entry => {
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      details.forEach(sub => {
        const duration = Number(sub?.duration);
        if (!Number.isFinite(duration)) return;
        if (!longestSubtask || duration > longestSubtask.duration) {
          longestSubtask = {
            taskName: entry?.name || "Task",
            name: sub?.name || "Step",
            duration
          };
        }
      });
    });

    const summary = document.createElement("div");
    summary.className = "audit-summary";
    const summaryLines = [
      `Tasks completed: ${auditEntries.length}`,
      `Productive minutes: ${formatDuration(totalMinutes)}`,
      longestSubtask
        ? `Longest subtask: ${longestSubtask.name} (${formatDuration(longestSubtask.duration)}) ‚Äî ${longestSubtask.taskName}`
        : "Longest subtask: --"
    ];
    summaryLines.forEach(text => {
      const line = document.createElement("div");
      line.textContent = text;
      summary.appendChild(line);
    });
    modal.appendChild(summary);

    const list = document.createElement("ul");
    list.className = "audit-task-list";
    auditEntries.forEach(entry => {
      const item = document.createElement("li");
      const header = document.createElement("strong");
      header.textContent = `${entry?.name || "Task"} ‚Äî ${formatDuration(entry?.totalDuration)}`;
      item.appendChild(header);
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      if (details.length) {
        const subList = document.createElement("ul");
        subList.className = "audit-task-subtasks";
        details.forEach(sub => {
          const subItem = document.createElement("li");
          subItem.textContent = `${sub?.name || "Step"}: ${formatDuration(sub?.duration)}`;
          subList.appendChild(subItem);
        });
        item.appendChild(subList);
      }
      list.appendChild(item);
    });
    modal.appendChild(list);

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "Close";

    const closeModal = () => {
      overlay.remove();
      document.removeEventListener("keydown", onKeyDown);
    };

    const onKeyDown = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeModal();
      }
    };

    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeModal();
      }
    });
    document.addEventListener("keydown", onKeyDown);

    modal.appendChild(closeBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    requestAnimationFrame(() => closeBtn.focus());
    if (shownKey) {
      localStorage.setItem(shownKey, "true");
    }
  }

  function maybeShowEndOfDayAudit() {
    const remainingActive = tasks.filter(task => !isTaskCompleted(task)).length;
    if (remainingActive > 0) return;
    const storageKey = getAuditStorageKey();
    const shownKey = getAuditShownKey(storageKey);
    if (localStorage.getItem(shownKey) === "true") return;
    const entries = loadAuditEntries(storageKey);
    if (!entries.length) return;
    showEndOfDayAudit(entries, shownKey);
  }

  function initializeSoundPreference() {
    const saved = localStorage.getItem("focusSoundEnabled");
    if (saved !== null) {
      focusSoundEnabled = saved === "true";
    }
    const toggle = $("focusSoundToggle");
    if (!toggle) return;
    toggle.checked = focusSoundEnabled;
    toggle.addEventListener("change", event => {
      setFocusSoundPreference(event.target.checked);
      if (focusSoundEnabled && focusAudioContext && focusAudioContext.state === "suspended") {
        focusAudioContext.resume().catch(() => {});
      }
    });
  }

  function ensureChartSubTasks(task, options = {}) {
    if (!isChartTask(task)) return false;
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    const basePriority = options.basePriority !== undefined
      ? options.basePriority
      : computePriority({ ...task, subTasks: [] });
    if (task.useChartTemplate === false) {
      task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      return false;
    }
    const defaults = buildChartSteps(task.authorType);
    const lowerDefaults = defaults.map(step => step.toLowerCase());
    const requiredSet = new Set(lowerDefaults);
    const attestationKey = RESIDENT_ATTESTATION_STEP.toLowerCase();
    let changed = false;

    if (!requiredSet.has(attestationKey)) {
      const filtered = task.subTasks.filter(sub => String(sub?.name || "").toLowerCase() !== attestationKey);
      if (filtered.length !== task.subTasks.length) {
        task.subTasks = filtered;
        changed = true;
      }
    }

    const existingByName = new Map();
    task.subTasks.forEach((sub, index) => {
      const key = String(sub?.name || "").toLowerCase();
      if (!existingByName.has(key)) {
        existingByName.set(key, { sub, index });
      }
    });

    const orderedDefaults = defaults.map(step => {
      const key = step.toLowerCase();
      const existing = existingByName.get(key);
      if (existing) {
        existingByName.delete(key);
        return existing.sub;
      }
      changed = true;
      return createSubTask(step, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    const extras = task.subTasks.filter(sub => {
      const key = String(sub?.name || "").toLowerCase();
      return !requiredSet.has(key);
    });

    const nextSubTasks = [...orderedDefaults, ...extras];
    const sameOrder = nextSubTasks.length === task.subTasks.length
      && nextSubTasks.every((sub, idx) => sub === task.subTasks[idx]);
    if (!sameOrder) {
      task.subTasks = nextSubTasks;
      if (!changed) changed = true;
    }

    task.subTasks.forEach(sub => {
      if (sub.priority !== basePriority) {
        sub.priority = basePriority;
        changed = true;
      }
      if (task.firstThreeMode) {
        sub.deferredUntilUnlock = !task.firstThreeUnlocked && !sub.isFirstThree;
      } else if (sub.deferredUntilUnlock) {
        sub.deferredUntilUnlock = false;
      }
    });

    return changed;
  }

  function resolveTaskAndSub(taskIndex, subIndex, options = {}) {
    let resolvedIndex = taskIndex;
    let task = tasks[resolvedIndex];
    if ((!task || resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && options.taskId) {
      resolvedIndex = tasks.findIndex(t => t.id === options.taskId);
      task = tasks[resolvedIndex];
    }
    if (!task) {
      return { task: null, taskIndex: -1, sub: null, subIndex: -1 };
    }
    let resolvedSubIndex = subIndex;
    let sub = Array.isArray(task.subTasks) ? task.subTasks[resolvedSubIndex] : undefined;
    if ((!sub || resolvedSubIndex === undefined || resolvedSubIndex === null || resolvedSubIndex < 0) && options.subId && Array.isArray(task.subTasks)) {
      resolvedSubIndex = task.subTasks.findIndex(s => s.id === options.subId);
      sub = task.subTasks[resolvedSubIndex];
    }
    return { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex };
  }

  function renderChartSummary(task) {
    const container = document.createElement("div");
    container.className = "chart-summary";
    const heading = document.createElement("h4");
    heading.textContent = "Chart Summary";
    container.appendChild(heading);
    const list = document.createElement("ul");
    const durations = task.subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value));
    const longest = durations.length ? Math.max(...durations) : null;
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      item.textContent = `${sub.name}: ${formatDuration(sub.durationMinutes)}`;
      if (longest !== null && Number(sub.durationMinutes) === longest) {
        item.classList.add("longest-step");
      }
      list.appendChild(item);
    });
    container.appendChild(list);
    const total = Number.isFinite(Number(task.chartDurationMinutes))
      ? Number(task.chartDurationMinutes)
      : computeTotalChartDuration(task.subTasks);
    const totalLabel = document.createElement("div");
    totalLabel.className = "chart-total";
    totalLabel.textContent = `Total duration: ${formatDuration(total)}`;
    container.appendChild(totalLabel);
    return container;
  }

  function refreshAfterSubTaskChange(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    persist();
    const focusActive = !$("focus").classList.contains("hidden");
    if (focusActive) {
      const currentFocusTask = focusQueue[0];
      if ((resolvedIndex !== -1 && currentFocusTaskIndex === resolvedIndex)
        || (options.taskId && currentFocusTask && currentFocusTask.id === options.taskId)) {
        renderFocusTask(task, resolvedIndex);
      }
    }
    if (!focusActive && !options.focusOnly) {
      updateUI();
    }
  }

  function startSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const nowIso = new Date().toISOString();
    sub.startTime = nowIso;
    sub.lastResumedAt = nowIso;
    sub.activeDurationMs = 0;
    sub.isPaused = false;
    sub.completed = false;
    sub.completionTime = null;
    sub.durationMinutes = null;
    stopTimerForSubTask(sub.id);
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function pauseSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || !sub.startTime || sub.completed || sub.isPaused) return;
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    const now = Date.now();
    const additional = Number.isNaN(resumeDate.getTime()) ? 0 : Math.max(0, now - resumeDate.getTime());
    sub.activeDurationMs = base + additional;
    sub.lastResumedAt = null;
    sub.isPaused = true;
    stopTimerForSubTask(sub.id);
    dispatchFocusStepEvent("focus:step-paused", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function resumeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || sub.completed) return;
    const nowIso = new Date().toISOString();
    if (!sub.startTime) {
      sub.startTime = nowIso;
      sub.activeDurationMs = Math.max(0, Number(sub.activeDurationMs) || 0);
    }
    sub.lastResumedAt = nowIso;
    sub.isPaused = false;
    dispatchFocusStepEvent("focus:step-resumed", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function toggleSubTaskCompletion(taskIndex, subIndex, isCompleted, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    if (isCompleted) {
      if (!sub.startTime) {
        const nowIso = new Date().toISOString();
        sub.startTime = nowIso;
        sub.lastResumedAt = nowIso;
        sub.activeDurationMs = 0;
      }
      const completionTimestamp = new Date().toISOString();
      const elapsedMs = getSubTaskElapsedMs(sub);
      sub.completed = true;
      sub.completionTime = completionTimestamp;
      sub.durationMinutes = Number.isFinite(elapsedMs) && elapsedMs > 0 ? Number((elapsedMs / 60000).toFixed(2)) : 0;
      sub.activeDurationMs = Math.max(0, elapsedMs);
      sub.lastResumedAt = null;
      sub.isPaused = false;
      stopTimerForSubTask(sub.id);
      if (task.firstThreeMode) {
        maybeUnlockFirstThree(task);
      }
    } else {
      sub.completed = false;
      sub.completionTime = null;
      sub.durationMinutes = null;
      sub.isPaused = false;
      sub.lastResumedAt = null;
      if (task.firstThreeMode && sub.isFirstThree) {
        task.firstThreeUnlocked = false;
        task.subTasks.forEach(step => {
          if (!step.isFirstThree) {
            step.deferredUntilUnlock = true;
          }
        });
      }
      stopTimerForSubTask(sub.id);
    }
    const nextOptions = { ...options, taskId: task.id, subId: sub.id };
    refreshAfterSubTaskChange(resolvedIndex, nextOptions);
  }

  function editSubTaskName(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const newName = prompt("Rename step", sub.name);
    if (!newName) return;
    sub.name = newName.trim();
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function removeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !Array.isArray(task.subTasks)) return;
    if (!confirm("Remove this step?")) return;
    const removed = task.subTasks.splice(resolvedSubIndex, 1);
    if (removed.length) {
      stopTimerForSubTask(removed[0].id);
    }
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function addSubTaskToTask(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    const name = prompt("New step name");
    if (!name) return;
    const base = computePriority({ ...task, subTasks: [] });
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.subTasks.push(createSubTask(name.trim(), base, {
      deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
    }));
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function renderChartTask(task, taskIndex) {
    const container = document.createElement("div");
    container.style.width = "100%";
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No steps configured.";
      container.appendChild(empty);
      return container;
    }
    const progressElement = createProgressElement(task);
    if (progressElement) {
      container.appendChild(progressElement);
    }
    const visibleSubs = getVisibleSubTasks(task);
    const hiddenCount = task.firstThreeMode && !task.firstThreeUnlocked
      ? task.subTasks.length - visibleSubs.length
      : 0;
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row focus-overlay__task";
      if (sub.completed) row.classList.add("completed");

      const titleWrapper = document.createElement("label");
      titleWrapper.className = "task-title";

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { focusOnly: true, taskId: task.id, subId: sub.id });

      const nameSpan = document.createElement("span");
      nameSpan.className = "subtask-name";
      nameSpan.textContent = sub.name;

      titleWrapper.appendChild(chk);
      titleWrapper.appendChild(nameSpan);

      const actions = document.createElement("div");
      actions.className = "subtask-actions task-actions";

      const startBtn = document.createElement("button");
      startBtn.type = "button";
      startBtn.textContent = sub.startTime ? "üîÅ" : "‚ñ∂Ô∏è";
      startBtn.title = "Start or restart timer";
      startBtn.setAttribute("aria-label", sub.startTime ? "Restart timer" : "Start timer");
      startBtn.onclick = () => startSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(startBtn);

      const pauseBtn = document.createElement("button");
      pauseBtn.type = "button";
      const updatePauseButton = () => {
        const paused = Boolean(sub.isPaused);
        pauseBtn.textContent = paused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
        pauseBtn.title = paused ? "Resume step timer" : "Pause step timer";
        pauseBtn.setAttribute("aria-label", paused ? "Resume step timer" : "Pause step timer");
        pauseBtn.setAttribute("aria-pressed", paused ? "true" : "false");
        pauseBtn.disabled = !sub.startTime || sub.completed;
      };
      pauseBtn.onclick = () => {
        if (!sub.startTime || sub.completed) {
          return;
        }
        if (sub.isPaused) {
          resumeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        } else {
          pauseSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        }
      };
      updatePauseButton();
      actions.appendChild(pauseBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Rename step";
      editBtn.setAttribute("aria-label", "Rename step");
      editBtn.onclick = () => editSubTaskName(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "üóëÔ∏è";
      deleteBtn.title = "Remove step";
      deleteBtn.setAttribute("aria-label", "Remove step");
      deleteBtn.onclick = () => removeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(deleteBtn);

      const timer = document.createElement("span");
      timer.className = "timer-label task-counter";
      trackTimer(sub, timer);

      row.appendChild(titleWrapper);
      row.appendChild(timer);
      row.appendChild(actions);
      row.dataset.paused = sub.isPaused ? "true" : "false";
      container.appendChild(row);
    });

    if (hiddenCount > 0) {
      const gate = document.createElement("div");
      gate.className = "celebration";
      gate.textContent = "Complete the first three micro-steps to reveal the rest of the chart flow.";
      container.appendChild(gate);
    }

    const controls = document.createElement("div");
    controls.className = "chart-step-controls";

    const addBtn = document.createElement("button");
    addBtn.textContent = "‚ûï Add Step";
    addBtn.onclick = () => addSubTaskToTask(taskIndex, { taskId: task.id });
    controls.appendChild(addBtn);

    const resetTimersBtn = document.createElement("button");
    resetTimersBtn.textContent = "‚è±Ô∏è Reset Timers";
    resetTimersBtn.onclick = () => {
      task.subTasks.forEach(sub => {
        stopTimerForSubTask(sub.id);
        sub.startTime = null;
        sub.completionTime = null;
        sub.durationMinutes = null;
        sub.completed = false;
        sub.activeDurationMs = 0;
        sub.lastResumedAt = null;
        sub.isPaused = false;
      });
      refreshAfterSubTaskChange(taskIndex, { focusOnly: true, taskId: task.id });
    };
    controls.appendChild(resetTimersBtn);

    container.appendChild(controls);

    if (task.subTasks.every(sub => sub.completed)) {
      container.appendChild(renderChartSummary(task));
    }

    return container;
  }

  function renderSimpleSubTasks(task, taskIndex) {
    const container = document.createElement("div");
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      container.textContent = "No sub-tasks for this task.";
      return container;
    }
    const completedCount = task.subTasks.filter(sub => sub.completed).length;
    const progressSummary = document.createElement("div");
    progressSummary.className = "task-progress";
    progressSummary.textContent = `${completedCount}/${task.subTasks.length} steps done`;
    container.appendChild(progressSummary);
    const visibleSubs = getVisibleSubTasks(task);
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");
      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { taskId: task.id, subId: sub.id });
      const label = document.createElement("span");
      label.className = "subtask-name";
      label.textContent = sub.name;
      row.appendChild(chk);
      row.appendChild(label);
      container.appendChild(row);
    });
    if (task.firstThreeMode && !task.firstThreeUnlocked) {
      const hint = document.createElement("div");
      hint.className = "celebration";
      hint.textContent = "Unlock the remaining steps by completing your first three micro-actions.";
      container.appendChild(hint);
    }
    return container;
  }

  function renderFocusTask(task, taskIndex) {
    const subTaskView = $("subTaskView");
    if (!subTaskView) return;
    let resolvedIndex = taskIndex;
    if ((resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && task) {
      resolvedIndex = tasks.findIndex(t => t.id === task.id);
    }
    const referenceTask = (resolvedIndex !== undefined && resolvedIndex !== null && resolvedIndex >= 0)
      ? tasks[resolvedIndex]
      : task;
    currentFocusTaskIndex = resolvedIndex;
    subTaskView.innerHTML = "";
    clearRunningTimers();
    let createdDefaults = false;
    if (isChartTask(referenceTask)) {
      createdDefaults = ensureChartSubTasks(referenceTask);
    }
    if (createdDefaults) {
      updateChartDurationForTask(referenceTask);
      referenceTask.priority = computePriority(referenceTask);
      persist();
    }
    const content = isChartTask(referenceTask)
      ? renderChartTask(referenceTask, resolvedIndex)
      : renderSimpleSubTasks(referenceTask, resolvedIndex);
    subTaskView.appendChild(content);
  }

  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function addDays(date, amount) {
    const base = date instanceof Date && !Number.isNaN(date.getTime()) ? new Date(date) : new Date();
    const offset = Number.isFinite(Number(amount)) ? Number(amount) : 0;
    base.setDate(base.getDate() + offset);
    return base;
  }

  function calculateDaysSince(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = today.getTime() - parsed.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  }

  function calculateDaysUntil(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = parsed.getTime() - today.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  }

  function isDateInCurrentMonth(dateString) {
    if (!dateString) return false;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return false;
    const today = new Date();
    return parsed.getFullYear() === today.getFullYear()
      && parsed.getMonth() === today.getMonth();
  }

  function getUrgencyDescriptor(value) {
    const options = getScaleOptions("urgency", currentScaleDescriptorCategory);
    const option = options.find(opt => Number(opt.value) === Number(value));
    return option ? option.text : null;
  }

  function getSuggestedUrgency(days) {
    if (days === null || days === undefined || Number.isNaN(days)) return 3;
    if (days < 0) return 3;
    if (days >= 90 && days <= 95) return 5;
    if (days > 95) return 2;
    if (days >= 30 && days < 90) return 1;
    if (days >= 2 && days <= 4) return 4;
    if (days < 30) return 3;
    return 3;
  }

  function updateChartAgeDisplay(days) {
    const display = $("chartAgeDisplay");
    if (!display) return;
    if (days === null || days === undefined) {
      display.textContent = "";
      return;
    }
    if (days < 0) {
      display.textContent = `Service date is ${Math.abs(days)} day(s) in the future.`;
      return;
    }
    display.textContent = `Chart age: ${days} day(s) since visit.`;
  }

  function updateUrgencyHint(suggested) {
    const hint = $("urgencyHint");
    const urgencyField = $("urgency");
    if (!hint || !urgencyField) return;
    const current = Number(urgencyField.value || 3);
    const suggestedDescriptor = getUrgencyDescriptor(suggested);
    const currentDescriptor = getUrgencyDescriptor(current);
    if (!suggestedDescriptor) {
      hint.textContent = currentDescriptor ? `Urgency set to ${currentDescriptor}.` : "";
      return;
    }
    if (current !== suggested) {
      hint.textContent = `Suggested: ${suggestedDescriptor}. (Current: ${currentDescriptor || current})`;
    } else {
      hint.textContent = `Suggested: ${suggestedDescriptor}.`;
    }
  }

  function updateDerivedFields() {
    const dateField = $("dateOfService");
    if (!dateField) return;
    const value = dateField.value;
    const days = calculateDaysSince(value);
    derivedDaysSinceVisit = days;
    updateChartAgeDisplay(days);
    const suggested = getSuggestedUrgency(days);
    const urgencyField = $("urgency");
    if (urgencyField && (urgencyAuto || !urgencyField.value)) {
      urgencyField.value = String(suggested);
    }
    updateUrgencyHint(suggested);
  }

  function setDefaultFieldValues() {
    const nameField = $("name");
    if (nameField) nameField.value = "";
    const categoryField = $("taskCategory");
    if (categoryField) categoryField.value = "General";
    const authorField = $("authorType");
    if (authorField) authorField.value = "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = "Non-Complex";
    const visitField = $("visitType");
    if (visitField) visitField.value = "Follow-Up";
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = "General Clinic";
    NUMERIC_SCALE_FIELDS.forEach(id => {
      const field = $(id);
      if (field) field.value = "1";
    });
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = "3";
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = "1";
    const dueDateField = $("dueDate");
    if (dueDateField) dueDateField.value = "";
    const subField = $("initialSubTasks");
    if (subField) subField.value = "";
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.value = formatDateForInput(new Date());
    }
    derivedDaysSinceVisit = calculateDaysSince($("dateOfService")?.value || null);
    urgencyAuto = true;
    updateDerivedFields();
    handleCategoryChange($("taskCategory")?.value);
    setQuickTaskTemplateMode(false);
  }

  let tasks = [];
  let templates = [];
  let focusQueue = [];
  let editingTaskId = null;
  let focusTimerId = null;
  let focusTimerStart = null;
  let focusTimerLastPing = null;
  let focusDistractionLog = [];
  let distractionTriggersSinceReset = 0;
  let doorwayResetState = { active: false, pending: false, countdownId: null, endTime: null };
  let ganttPlanState = { entries: [], totalMinutes: 0 };
  let ganttOverlayStartTime = null;
  let ganttProgressIntervalId = null;
  let worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
  let focusSoundEnabled = true;
  let focusAudioContext = null;
  let morningLaunchState = null;
  let launchPadState = null;
  let sleepToolkitState = null;
  let morningCountdown = null;
  let reminderIntervalId = null;
  let pendingTaskDraft = null;
  let sunlightAlertTimeoutId = null;

  const meltdownShieldState = {
    stepIndex: 0
  };

  const MELTDOWN_STEPS = [
    {
      title: "Noise Reduction",
      description: "Close all other browser tabs to eliminate competing stimuli."
    },
    {
      title: "4‚Äì4‚Äì4 Breathing",
      description: "Take three cycles: inhale for four seconds, hold for four, exhale for four."
    },
    {
      title: "Verbal Grounding",
      description: "Say aloud: ‚ÄòI am safe. I can pick one thing.‚Äô"
    },
    {
      title: "Task Narrowing",
      descriptionBuilder: () => {
        const topTaskName = getTopTaskName();
        const fragment = document.createDocumentFragment();
        const intro = document.createElement("span");
        intro.textContent = "Remember there is just one next step. Top priority task:";
        const nameEl = document.createElement("span");
        nameEl.className = "meltdown-top-task";
        nameEl.textContent = topTaskName || "No active tasks available.";
        fragment.appendChild(intro);
        fragment.appendChild(document.createElement("br"));
        fragment.appendChild(nameEl);
        return fragment;
      }
    },
    {
      title: "5-Minute Action Timer",
      description: "Set a five-minute timer and commit to only the first subtask for this session."
    },
    {
      title: "Body Movement",
      description: "Stand up, shake out your arms, and loosen your shoulders."
    },
    {
      title: "Music Cue",
      description: "Play a favorite upbeat song to pair with your movement."
    },
    {
      title: "Re-entry",
      description: "Slide back into Focus Mode ready to attack the task with reduced anxiety."
    }
  ];

  function resolvePriorityValue(value) {
    const num = Number(value);
    return Number.isFinite(num) ? num : 0;
  }

  function getTopTaskName() {
    const sourceTasks = Array.isArray(tasks) ? tasks : [];
    const activeTasks = sourceTasks
      .filter(task => !isTaskCompleted(task))
      .sort((a, b) => resolvePriorityValue(b.priority) - resolvePriorityValue(a.priority));

    if (activeTasks.length > 0) {
      return activeTasks[0]?.name || null;
    }

    try {
      const saved = localStorage.getItem("tasks");
      if (!saved) return null;
      const parsed = JSON.parse(saved);
      if (!Array.isArray(parsed)) return null;
      const fallbackActive = parsed
        .filter(task => task && !isTaskCompleted(task))
        .map(task => ({
          ...task,
          priority: resolvePriorityValue(task?.priority)
        }))
        .sort((a, b) => b.priority - a.priority);
      return fallbackActive.length > 0 ? (fallbackActive[0].name || null) : null;
    } catch (error) {
      console.error("Unable to parse saved tasks for Meltdown Shield.", error);
      return null;
    }
  }

  function buildMeltdownDescription(step) {
    if (typeof step.descriptionBuilder === "function") {
      return step.descriptionBuilder();
    }
    const span = document.createElement("span");
    span.textContent = step.description;
    return span;
  }

  function resetMeltdownShieldProgress() {
    meltdownShieldState.stepIndex = 0;
    const list = $("meltdownShieldSteps");
    if (list) {
      list.innerHTML = "";
    }
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.textContent = "‚ñ∂Ô∏è‚ÄØNext";
    }
    updateMeltdownPrompt();
  }

  function updateMeltdownPrompt() {
    const prompt = $("meltdownShieldPrompt");
    const nextBtn = $("meltdownShieldNext");
    if (!prompt || !nextBtn) return;

    prompt.innerHTML = "";

    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      const finalMessage = document.createElement("strong");
      finalMessage.textContent = "System stabilized. Ready for Focus Mode.";
      prompt.appendChild(finalMessage);
      nextBtn.disabled = true;
      nextBtn.textContent = "Complete";
      return;
    }

    const currentStep = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const heading = document.createElement("strong");
    heading.textContent = `Step ${meltdownShieldState.stepIndex + 1}: ${currentStep.title}`;
    const description = buildMeltdownDescription(currentStep);
    prompt.appendChild(heading);
    prompt.appendChild(description);
    nextBtn.disabled = false;
    nextBtn.textContent = "‚ñ∂Ô∏è‚ÄØNext";
  }

  function activateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.remove("hidden");
    panel.setAttribute("aria-hidden", "false");
    resetMeltdownShieldProgress();
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.focus();
    }
  }

  function deactivateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.add("hidden");
    panel.setAttribute("aria-hidden", "true");
    resetMeltdownShieldProgress();
    const focusTarget =
      lastSosTrigger ||
      $("rescueLaunchButton") ||
      $("meltdownSosButton");
    if (focusTarget) {
      window.requestAnimationFrame(() => focusTarget.focus());
    }
  }

  function completeCurrentMeltdownStep() {
    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      updateMeltdownPrompt();
      return;
    }

    const list = $("meltdownShieldSteps");
    if (!list) return;

    const step = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const listItem = document.createElement("li");
    const stepLabel = document.createElement("strong");
    stepLabel.textContent = `${step.title}`;
    listItem.appendChild(stepLabel);
    listItem.appendChild(document.createElement("br"));
    listItem.appendChild(buildMeltdownDescription(step));
    list.appendChild(listItem);

    meltdownShieldState.stepIndex += 1;
    updateMeltdownPrompt();
  }

  function clearFormFields() {
    setDefaultFieldValues();
  }

  function toggleEditMode(isEditing) {
    const addBtn = $("addTaskBtn");
    const saveBtn = $("saveUpdateBtn");
    const cancelBtn = $("cancelEditBtn");
    if (!addBtn || !saveBtn || !cancelBtn) return;
    addBtn.classList.toggle("hidden", isEditing);
    saveBtn.classList.toggle("hidden", !isEditing);
    cancelBtn.classList.toggle("hidden", !isEditing);
  }

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function clampScale(value, fallback = 1) {
    const base = toNumber(value, fallback);
    return Math.min(5, Math.max(1, base));
  }

  function normalizePatientType(value) {
    const normalized = (value || "").toString().toLowerCase();
    return normalized === "complex" ? "Complex" : "Non-Complex";
  }

  function getPatientTypeWeight(patientType) {
    return normalizePatientType(patientType) === "Complex" ? 1.2 : 1;
  }

  function normalizeVisitType(value) {
    const normalized = (value || "").toString().toLowerCase();
    if (normalized === "establish" || normalized === "establish care") return "Establish Care";
    if (normalized === "well-child" || normalized === "well child visit") return "Well Child Visit";
    if (normalized === "acute" || normalized === "acute visit") return "Acute Visit";
    return "Follow-Up";
  }

  function getVisitTypeWeight(visitType) {
    const normalized = normalizeVisitType(visitType);
    if (normalized === "Establish Care") return 1.3;
    if (normalized === "Well Child Visit") return 1.1;
    if (normalized === "Acute Visit") return 0.9;
    return 1;
  }

  function normalizeClinicSite(value) {
    const normalized = (value || "").toString().toLowerCase().replace(/[‚Äô]/g, "'").trim();
    if (normalized.includes("cranio")) return "Craniofacial Clinic";
    if (normalized.includes("pj")) return "St PJ‚Äôs Shelter";
    if (normalized.includes("general")) return "General Clinic";
    return "General Clinic";
  }

  function isSameLocalDay(dateA, dateB) {
    if (!(dateA instanceof Date) || !(dateB instanceof Date)) return false;
    if (Number.isNaN(dateA.getTime()) || Number.isNaN(dateB.getTime())) return false;
    return dateA.getFullYear() === dateB.getFullYear()
      && dateA.getMonth() === dateB.getMonth()
      && dateA.getDate() === dateB.getDate();
  }

  function getSameDayBonus(clinicSite, createdAt) {
    const normalizedClinic = normalizeClinicSite(clinicSite);
    if (normalizedClinic !== "St PJ‚Äôs Shelter" && normalizedClinic !== "Craniofacial Clinic") {
      return 1;
    }
    if (!createdAt) return 1;
    const createdDate = new Date(createdAt);
    if (Number.isNaN(createdDate.getTime())) return 1;
    const now = new Date();
    return isSameLocalDay(createdDate, now) ? 2 : 1;
  }

  function computeRawPriorityScore(t) {
    const importance = clampScale(t.importance, 1);
    const urgency = clampScale(t.urgency, 3);
    const novelty = clampScale(t.novelty, 1);
    const interest = clampScale(t.interest, 1);
    const pressure = clampScale(t.externalPressure, 1);
    const timeToStart = clampScale(t.timeToStart, 1);
    const difficulty = clampScale(t.difficulty, 1);
    const dopamine = novelty + interest;
    const friction = (6 - timeToStart) + (6 - difficulty);
    const baseScore = (importance * 2)
         + (urgency * 2)
         + (dopamine * 2)
         + (pressure * 5)
         + (friction * 1.5);
    const patientWeight = getPatientTypeWeight(t.patientType);
    const visitWeight = getVisitTypeWeight(t.visitType);
    const sameDayBonus = getSameDayBonus(t.clinicSite, t.createdAt);
    return baseScore * patientWeight * visitWeight * sameDayBonus;
  }

  function computeTimeWeight(task) {
    if (!task) return 1;
    if (isQuickTask(task)) return 1;
    const isChart = isChartTask(task);
    const parsedDays = Number(task.daysSinceVisit);
    const daysSince = Number.isFinite(parsedDays)
      ? parsedDays
      : (task.dateOfService ? calculateDaysSince(task.dateOfService) : null);
    const daysUntilDue = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
    const currentMonth = isDateInCurrentMonth(task.dateOfService)
      || isDateInCurrentMonth(task.dueDate);

    if (!isChart) {
      if (daysUntilDue !== null && Number.isFinite(daysUntilDue) && daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.2;
      }
      return 1.0;
    }

    if (daysSince !== null && Number.isFinite(daysSince)) {
      if (daysSince > 95) return 0.5;
      if (daysSince >= 90 && daysSince <= 95) return 2.0;
      if (daysSince >= 0 && daysSince < 3) return 1.8;
      if (daysSince >= 3 && currentMonth) return 1.3;
    }

    if (daysUntilDue !== null && Number.isFinite(daysUntilDue)) {
      if (daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.8;
      }
      if (daysUntilDue < 0 && daysSince === null) {
        return currentMonth ? 1.3 : 1.0;
      }
      if (currentMonth) {
        return 1.3;
      }
    }

    return 1.0;
  }

  function computePriority(t) {
    if (isQuickTask(t)) {
      return 1;
    }
    const weightedBase = computeRawPriorityScore(t) * computeTimeWeight(t);
    if (Array.isArray(t.subTasks) && t.subTasks.length) {
      const remaining = t.subTasks.filter(s => !s.completed);
      if (remaining.length === 0) return 0;
      const total = remaining.reduce((sum, s) => {
        const value = Number(s.priority);
        return Number.isFinite(value) ? sum + value : sum + weightedBase;
      }, 0);
      return total / remaining.length;
    }
    return weightedBase;
  }

  function recalcTaskPriority(task) {
    if (!task) return task;
    task.authorType = task.authorType || "attending";
    task.patientType = normalizePatientType(task.patientType);
    task.visitType = normalizeVisitType(task.visitType);
    task.clinicSite = normalizeClinicSite(task.clinicSite);
    task.dateOfService = task.dateOfService || null;
    task.createdAt = task.createdAt || task.addedAt || new Date().toISOString();
    if (task.category === "Charts") task.category = "Chart";
    task.firstThreeMode = Boolean(task.firstThreeMode);
    if (!Array.isArray(task.firstThreeSteps)) {
      task.firstThreeSteps = [];
    }
    if (!task.firstThreeMode) {
      task.firstThreeUnlocked = true;
      task.firstThreeSteps = [];
    } else if (task.firstThreeUnlocked === undefined) {
      task.firstThreeUnlocked = false;
    }
    if (task.dateOfService) {
      task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    } else {
      const parsedDays = Number(task.daysSinceVisit);
      task.daysSinceVisit = (task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === "" || !Number.isFinite(parsedDays))
        ? null
        : parsedDays;
    }
    task.urgency = clampScale(task.urgency, 3);
    task.importance = clampScale(task.importance, 1);
    task.novelty = clampScale(task.novelty, 1);
    task.interest = clampScale(task.interest, 1);
    task.externalPressure = clampScale(task.externalPressure, 1);
    task.timeToStart = clampScale(task.timeToStart, 1);
    task.difficulty = clampScale(task.difficulty, 1);
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    if (isQuickTask(task)) {
      task.subTasks = [];
      task.firstThreeMode = false;
      task.firstThreeSteps = [];
      task.firstThreeUnlocked = true;
    }
    task.completedAt = task.completedAt || null;
    if (task.completed && !task.completedAt) {
      task.completedAt = null;
    }
    if (task.completedAt && !task.completed) {
      task.completed = true;
    } else {
      task.completed = Boolean(task.completed);
    }
    if (isChartTask(task) && task.useChartTemplate === undefined) {
      const defaults = new Set(buildChartSteps(task.authorType).map(step => step.toLowerCase()));
      const hasCustomSteps = Array.isArray(task.subTasks)
        ? task.subTasks.some(sub => !defaults.has(String(sub?.name || "").toLowerCase()))
        : false;
      task.useChartTemplate = !hasCustomSteps;
    }
    const baseRaw = computeRawPriorityScore({ ...task, subTasks: [] });
    const timeWeight = computeTimeWeight(task);
    task.timeWeight = timeWeight;
    const base = baseRaw * timeWeight;
    if (isChartTask(task)) {
      ensureChartSubTasks(task, { basePriority: base });
    }
    if (task.subTasks.length) {
      task.subTasks = task.subTasks.map(sub => {
        const normalizedSub = normalizeSubTask(sub, base);
        normalizedSub.priority = base;
        return normalizedSub;
      });
      if (task.firstThreeMode) {
        if (!task.firstThreeSteps.length) {
          task.firstThreeSteps = task.subTasks.slice(0, 3).map(sub => sub.name);
        } else {
          task.firstThreeSteps = task.firstThreeSteps.slice(0, 3);
        }
        task.subTasks.forEach((sub, index) => {
          const isFirst = index < 3;
          sub.isFirstThree = isFirst;
          sub.deferredUntilUnlock = !task.firstThreeUnlocked && !isFirst;
        });
        maybeUnlockFirstThree(task, { silent: true });
      } else {
        task.subTasks.forEach(sub => {
          sub.isFirstThree = false;
          sub.deferredUntilUnlock = false;
        });
      }
    }
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    return task;
  }

  function persist() {
    try {
      localStorage.setItem("tasks", JSON.stringify(tasks));
    } catch (error) {
      console.warn("Unable to persist tasks", error);
    }
  }

  function buildTaskDraftFromForm() {
    const nameField = $("name");
    if (!nameField) return null;
    const name = nameField.value.trim();
    if (!name) return null;
    const category = $("taskCategory").value || "General";
    const quickMode = isQuickTaskCategory(category);
    const authorField = $("authorType");
    const authorType = quickMode ? "attending" : (authorField ? (authorField.value || "attending") : "attending");
    const patientField = $("patientType");
    const patientType = quickMode ? "Non-Complex" : normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = quickMode ? "Follow-Up" : normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = quickMode ? "General Clinic" : normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const dateField = $("dateOfService");
    const dateOfService = quickMode ? null : (dateField && dateField.value ? dateField.value : null);
    const daysSinceVisit = quickMode ? null : calculateDaysSince(dateOfService);
    const task = {
      id: Date.now().toString(),
      name,
      category,
      authorType,
      patientType,
      visitType,
      clinicSite,
      dateOfService,
      daysSinceVisit,
      importance: quickMode ? 1 : clampScale($("importance").value, 1),
      urgency: quickMode ? 1 : clampScale($("urgency").value, 3),
      novelty: quickMode ? 1 : clampScale($("novelty").value, 1),
      interest: quickMode ? 1 : clampScale($("interest").value, 1),
      externalPressure: quickMode ? 1 : clampScale($("externalPressure").value, 1),
      timeToStart: quickMode ? 1 : clampScale($("timeToStart").value, 1),
      difficulty: quickMode ? 1 : clampScale($("difficulty").value, 1),
      dueDate: quickMode ? null : ($("dueDate").value || null),
      completed: false,
      completedAt: null,
      createdAt: new Date().toISOString(),
      addedAt: new Date().toISOString(),
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: []
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);
    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    }
    return { task, basePriority, subLines };
  }

  function finalizeNewTask(draft, options = {}) {
    if (!draft) return;
    const { task, basePriority, subLines } = draft;
    const firstThreeSteps = Array.isArray(options.firstThreeSteps) ? options.firstThreeSteps : null;
    const deferred = task.firstThreeMode && !task.firstThreeUnlocked;
    task.subTasks = Array.isArray(subLines)
      ? subLines.map(line => createSubTask(line, basePriority, {
          deferredUntilUnlock: deferred
        }))
      : [];
    if (firstThreeSteps && firstThreeSteps.length) {
      task.firstThreeMode = true;
      task.firstThreeUnlocked = false;
      applyFirstThreeSteps(task, firstThreeSteps, basePriority);
    } else {
      if (!task.firstThreeMode) {
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
      }
    }
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    showTaskAddedConfirmation();
    persist();
    clearFormFields();
    toggleEditMode(false);
    editingTaskId = null;
    updateUI();
  }

  // create a new task with optional sub‚Äëtasks from textarea
  function addTask() {
    const draft = buildTaskDraftFromForm();
    if (!draft) return;
    const triggerWizard = shouldTriggerFirstThreeWizard(
      draft.task.name,
      draft.subLines,
      draft.task.category
    );
    if (triggerWizard) {
      pendingTaskDraft = draft;
      openFirstThreeWizard();
      return;
    }
    finalizeNewTask(draft);
  }

  function generateFirstThreeSuggestions(taskName) {
    const anchor = (taskName || "").split(/[‚Äì‚Äî:-]/)[0].trim() || "this work";
    return [
      `Open materials for ${anchor}`,
      "List three micro-actions in your notebook",
      "Start a 5-minute draft or outline"
    ];
  }

  function setFirstThreeInputs(values) {
    const ids = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"];
    ids.forEach((id, index) => {
      const field = $(id);
      if (field) {
        field.value = values[index] || "";
      }
    });
  }

  function openFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    const suggestions = generateFirstThreeSuggestions(pendingTaskDraft?.task?.name);
    setFirstThreeInputs(suggestions);
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const firstInput = $("firstThreeStep1");
    if (firstInput) {
      firstInput.focus();
      firstInput.select();
    }
  }

  function closeFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }

  function submitFirstThreeWizard() {
    if (!pendingTaskDraft) {
      closeFirstThreeWizard();
      return;
    }
    const steps = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"]
      .map(id => $(id)?.value || "")
      .map(value => value.trim())
      .filter(Boolean);
    finalizeNewTask(pendingTaskDraft, { firstThreeSteps: steps });
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function skipFirstThreeWizard() {
    if (pendingTaskDraft) {
      pendingTaskDraft.task.firstThreeMode = false;
      pendingTaskDraft.task.firstThreeUnlocked = true;
      pendingTaskDraft.task.firstThreeSteps = [];
      finalizeNewTask(pendingTaskDraft);
      pendingTaskDraft = null;
    }
    closeFirstThreeWizard();
  }

  function cancelFirstThreeWizard() {
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function initializeFirstThreeWizard() {
    const saveBtn = $("firstThreeSave");
    if (saveBtn) {
      saveBtn.addEventListener("click", submitFirstThreeWizard);
    }
    const skipBtn = $("firstThreeSkip");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipFirstThreeWizard);
    }
    const cancelBtn = $("firstThreeCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelFirstThreeWizard);
    }
    const overlay = $("firstThreeWizard");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          cancelFirstThreeWizard();
        }
      });
    }
  }

  function startEditTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    editingTaskId = taskId;
    $("name").value = task.name;
    $("taskCategory").value = task.category || "General";
    handleCategoryChange(task.category || "General");
    $("importance").value = String(task.importance || 1);
    $("urgency").value = String(task.urgency || 3);
    $("novelty").value = String(task.novelty || 1);
    $("interest").value = String(task.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = task.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(task.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(task.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(task.clinicSite);
    const dateField = $("dateOfService");
    if (dateField) {
      if (task.dateOfService) {
        dateField.value = task.dateOfService;
      } else {
        dateField.value = formatDateForInput(new Date());
      }
    }
    urgencyAuto = false;
    derivedDaysSinceVisit = task.daysSinceVisit ?? calculateDaysSince($("dateOfService")?.value || null);
    updateDerivedFields();
    const pressureField = $("externalPressure");
    if (pressureField) {
      const pressureValue = task.externalPressure;
      pressureField.value = String(pressureValue || 1);
    }
    $("timeToStart").value = String(task.timeToStart || 1);
    $("difficulty").value = String(task.difficulty || 1);
    $("dueDate").value = task.dueDate || "";
    const subs = Array.isArray(task.subTasks) ? task.subTasks.map(sub => sub.name).join("\n") : "";
    $("initialSubTasks").value = subs;
    toggleEditMode(true);
    $("name").focus();
  }

  function saveTaskUpdate() {
    if (!editingTaskId) return;
    const idx = tasks.findIndex(t => t.id === editingTaskId);
    if (idx === -1) return;
    const name = $("name").value.trim();
    if (!name) return;

    const task = tasks[idx];
    task.name = name;
    task.category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    task.authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    task.patientType = normalizePatientType(patientField ? patientField.value : task.patientType);
    const visitField = $("visitType");
    task.visitType = normalizeVisitType(visitField ? visitField.value : task.visitType);
    const clinicField = $("clinicSite");
    task.clinicSite = normalizeClinicSite(clinicField ? clinicField.value : task.clinicSite);
    const dateField = $("dateOfService");
    task.dateOfService = dateField && dateField.value ? dateField.value : null;
    task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    task.importance = clampScale($("importance").value, 1);
    task.urgency = clampScale($("urgency").value, 3);
    task.novelty = clampScale($("novelty").value, 1);
    task.interest = clampScale($("interest").value, 1);
    task.externalPressure = clampScale($("externalPressure").value, 1);
    task.timeToStart = clampScale($("timeToStart").value, 1);
    task.difficulty = clampScale($("difficulty").value, 1);
    task.dueDate = $("dueDate").value || null;
    task.updatedAt = new Date().toISOString();

    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);

    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    } else if (task.useChartTemplate !== undefined) {
      delete task.useChartTemplate;
    }

    const basePriority = computePriority({ ...task, subTasks: [] });
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks.slice() : [];
    const newSubTasks = subLines.map(line => {
      const matchIndex = existingSubs.findIndex(sub => sub.name === line);
      if (matchIndex !== -1) {
        const existing = existingSubs.splice(matchIndex, 1)[0];
        const normalizedExisting = normalizeSubTask(existing, basePriority);
        normalizedExisting.name = line;
        normalizedExisting.priority = basePriority;
        return normalizedExisting;
      }
      return createSubTask(line, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    task.subTasks = newSubTasks;
    if (task.firstThreeMode) {
      const firstThreeSubset = task.subTasks.slice(0, 3);
      if (firstThreeSubset.length < 3) {
        task.firstThreeMode = false;
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
        task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
      } else {
        task.firstThreeSteps = firstThreeSubset.map(sub => sub.name);
        task.subTasks = task.subTasks.map((sub, index) => {
          const isFirst = index < 3;
          return {
            ...sub,
            isFirstThree: isFirst,
            deferredUntilUnlock: !task.firstThreeUnlocked && !isFirst
          };
        });
        maybeUnlockFirstThree(task, { silent: true });
      }
    } else {
      task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
    }
    if (isChartTask(task)) {
      const defaultsChanged = ensureChartSubTasks(task, { basePriority });
      if (defaultsChanged) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    if (task.firstThreeMode) {
      maybeUnlockFirstThree(task, { silent: true });
    }
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    persist();

    toggleEditMode(false);
    clearFormFields();
    editingTaskId = null;
    updateUI();
  }

  function cancelEdit() {
    editingTaskId = null;
    toggleEditMode(false);
    clearFormFields();
  }

  // render filter bar
  function renderCategoryFilter() {
    const select = $("taskCategoryFilter");
    if (!select) return;
    const options = ["All", ...categories];
    if (!options.includes(activeCategory)) {
      activeCategory = "All";
    }
    const previous = select.value;
    select.innerHTML = "";
    options.forEach(cat => {
      const option = document.createElement("option");
      option.value = cat;
      option.textContent = cat;
      select.appendChild(option);
    });
    const targetValue = options.includes(activeCategory) ? activeCategory : "All";
    select.value = options.includes(previous) ? previous : targetValue;
    if (select.value !== targetValue) {
      select.value = targetValue;
    }
  }

  // render chart-specific momentum progress
  function renderCategoryProgress() {
    const cont = $("categoryProgress");
    if (!cont) return;

    const labelEl = cont.querySelector('[data-chart-label]');
    const fillEl = cont.querySelector('[data-chart-fill]');
    const floatingEl = cont.querySelector('[data-chart-floating]');
    if (!labelEl || !fillEl) return;

    const chartTasks = tasks.filter(t => t.category === "Chart");
    const total = chartTasks.length;
    const done = chartTasks.filter(t => isTaskCompleted(t)).length;
    const percent = total === 0 ? 0 : (done / total) * 100;
    const clamped = Math.max(0, Math.min(100, percent));

    labelEl.textContent = `Chart: ${done}/${total} complete`;

    const previous = Number.parseFloat(cont.dataset.percent || "0");
    const progressIncreased = clamped > (Number.isFinite(previous) ? previous : 0);

    fillEl.style.width = `${clamped}%`;
    fillEl.classList.remove("is-warm", "is-complete");
    if (total > 0 && done === total) {
      fillEl.classList.add("is-complete");
    } else if (clamped > 50) {
      fillEl.classList.add("is-warm");
    }

    if (!fillEl.dataset.listened) {
      fillEl.addEventListener("animationend", event => {
        if (event.animationName === "chartGlowPulse") {
          fillEl.classList.remove("progress-glow");
        }
        if (event.animationName === "chartCompletePulse") {
          fillEl.classList.remove("complete-pulse");
        }
      });
      fillEl.dataset.listened = "true";
    }

    if (progressIncreased) {
      fillEl.classList.remove("progress-glow");
      void fillEl.offsetWidth;
      fillEl.classList.add("progress-glow");
      if (floatingEl) {
        floatingEl.textContent = `${Math.round(clamped)}% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1200);
      }
    } else if (floatingEl) {
      floatingEl.classList.remove("is-visible");
    }

    if (clamped >= 100 && (Number.isFinite(previous) ? previous : 0) < 100 && total > 0) {
      fillEl.classList.remove("complete-pulse");
      void fillEl.offsetWidth;
      fillEl.classList.add("complete-pulse");
      if (floatingEl) {
        floatingEl.textContent = `100% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1500);
      }
    }

    cont.dataset.percent = clamped;
  }

  function renderQuickTasks() {
    const card = document.querySelector("[data-quick-tasks-card]");
    const list = $("quickTaskList");
    const empty = $("quickTaskEmpty");
    if (!card || !list || !empty) return;
    list.innerHTML = "";
    const quickTasks = tasks.filter(task => isQuickTask(task));
    const activeQuick = quickTasks.filter(task => !isTaskCompleted(task));
    const sorted = activeQuick.sort((a, b) => {
      const aTime = new Date(a.createdAt || a.addedAt || 0).getTime();
      const bTime = new Date(b.createdAt || b.addedAt || 0).getTime();
      return aTime - bTime;
    });
    sorted.forEach(task => {
      const item = document.createElement("div");
      item.className = "quick-task-item";
      item.setAttribute("role", "listitem");
      const name = document.createElement("span");
      name.className = "quick-task-name";
      name.textContent = task.name;
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "quick-task-checkbox";
      checkbox.setAttribute("aria-label", `Complete quick task: ${task.name}`);
      checkbox.addEventListener("change", () => {
        checkbox.disabled = true;
        const completed = completeTaskById(task.id);
        if (!completed) {
          checkbox.checked = false;
          checkbox.disabled = false;
        }
      });
      item.appendChild(name);
      item.appendChild(checkbox);
      list.appendChild(item);
    });
    const emptyMessage = sorted.length === 0
      ? (quickTasks.length
          ? "All quick tasks are cleared. Add a new one when you're ready."
          : "No quick tasks yet.")
      : "No quick tasks yet.";
    empty.textContent = emptyMessage;
    empty.classList.toggle("hidden", sorted.length > 0);
    card.classList.remove("hidden");
  }

  function buildTaskDescriptors(task) {
    const descriptors = [];
    if (task.patientType) descriptors.push(`Patient: ${task.patientType}`);
    if (task.visitType) descriptors.push(`Visit: ${task.visitType}`);
    if (task.clinicSite) descriptors.push(task.clinicSite);
    if (task.urgency) descriptors.push(`Urgency ${task.urgency}`);
    return descriptors;
  }

  function getSubTaskProgress(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.length;
    const completed = task.subTasks.filter(sub => sub.completed).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function createProgressElement(task) {
    const progressData = getSubTaskProgress(task);
    if (!progressData) return null;
    const container = document.createElement("div");
    container.className = "task-progress-group";

    const label = document.createElement("div");
    label.className = "task-progress";
    const stepsLabel = `${progressData.total} ${progressData.total === 1 ? "step" : "steps"}`;
    let statusText;
    if (progressData.completed === 0) {
      statusText = "first step ready.";
    } else if (progressData.completed >= progressData.total) {
      statusText = "plan complete.";
    } else {
      statusText = `${progressData.completed} done.`;
    }
    label.textContent = `${stepsLabel} ‚Ä¢ ${statusText}`;
    container.appendChild(label);

    const meter = document.createElement("div");
    meter.className = "task-progress-meter";
    const fill = document.createElement("span");
    fill.className = "fill";
    const fillPercent = progressData.percent <= 0 ? 1 : Math.max(progressData.percent, 1);
    fill.style.width = `${fillPercent}%`;
    meter.appendChild(fill);
    container.appendChild(meter);

    return container;
  }

  function createMetaItem(text) {
    const span = document.createElement("span");
    span.textContent = text;
    return span;
  }

  function createTaskDetails(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const details = document.createElement("div");
    details.className = "task-details hidden";
    const heading = document.createElement("h5");
    heading.textContent = "Subtasks";
    details.appendChild(heading);
    const list = document.createElement("ul");
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      const marker = sub.completed ? "‚úì" : "‚Ä¢";
      item.textContent = `${marker} ${sub.name}`;
      list.appendChild(item);
    });
    details.appendChild(list);
    return details;
  }

  function getTaskCreatedTime(task) {
    if (!task) return 0;
    const createdValue = task.createdAt || task.addedAt || null;
    if (!createdValue) return 0;
    const createdDate = new Date(createdValue);
    const timestamp = createdDate.getTime();
    return Number.isFinite(timestamp) ? timestamp : 0;
  }

  function getTaskDueTimestamp(task) {
    if (!task) return Number.POSITIVE_INFINITY;
    if (task.dueDate) {
      const dueDate = new Date(`${task.dueDate}T00:00:00`);
      const dueTime = dueDate.getTime();
      if (Number.isFinite(dueTime)) return dueTime;
    }
    if (task.dateOfService) {
      const serviceDate = new Date(`${task.dateOfService}T00:00:00`);
      const serviceTime = serviceDate.getTime();
      if (Number.isFinite(serviceTime)) {
        serviceDate.setDate(serviceDate.getDate() + 3);
        const fallbackTime = serviceDate.getTime();
        if (Number.isFinite(fallbackTime)) return fallbackTime;
      }
    }
    return Number.POSITIVE_INFINITY;
  }

  function sortTasksByMode(list, mode) {
    const items = Array.isArray(list) ? [...list] : [];
    switch (mode) {
      case TASK_SORT_MODES.DATE_ADDED_DESC:
        return items.sort((a, b) => getTaskCreatedTime(b) - getTaskCreatedTime(a));
      case TASK_SORT_MODES.DATE_DUE_ASC:
        return items.sort((a, b) => {
          const aDue = getTaskDueTimestamp(a);
          const bDue = getTaskDueTimestamp(b);
          if (aDue === bDue) {
            return getTaskCreatedTime(b) - getTaskCreatedTime(a);
          }
          return aDue - bDue;
        });
      case TASK_SORT_MODES.PRIORITY:
      default:
        return items.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    }
  }

  function renderTaskListCard(task, mode, timeBudgetMinutes = null) {
    const card = document.createElement("article");
    card.className = "task-card";
    if (task?.id) {
      card.dataset.taskId = String(task.id);
    }
    if (mode === TASK_LIST_MODES.COMPLETED) {
      card.classList.add("is-completed");
    }
    if (mode === TASK_LIST_MODES.ACTIVE && task?.id) {
      attachTaskGestureHandlers(card, task.id, mode);
    }

    const header = document.createElement("div");
    header.className = "task-card-header";

    const titleGroup = document.createElement("div");
    titleGroup.className = "task-card-title-group";

    const title = document.createElement("h4");
    title.className = "task-title";
    title.textContent = task.name;
    titleGroup.appendChild(title);

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const indicator = document.createElement("span");
      indicator.className = "task-complete-indicator";
      indicator.textContent = "‚úì Completed";
      titleGroup.appendChild(indicator);
    }

    header.appendChild(titleGroup);

    const actions = document.createElement("div");
    actions.className = "task-card-actions";

    if (mode === TASK_LIST_MODES.ACTIVE) {
      const startNowBtn = document.createElement("button");
      startNowBtn.type = "button";
      startNowBtn.textContent = "üöÄ";
      startNowBtn.title = "Focus on this task";
      startNowBtn.setAttribute("aria-label", "Start task");
      startNowBtn.onclick = () => startFocus(task.id);
      actions.appendChild(startNowBtn);

      const completeBtn = document.createElement("button");
      completeBtn.type = "button";
      completeBtn.textContent = "‚úÖ";
      completeBtn.title = "Complete task";
      completeBtn.setAttribute("aria-label", "Complete task");
      completeBtn.onclick = () => markTaskDoneFromPeek(task.id);
      actions.appendChild(completeBtn);

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Edit task";
      editBtn.onclick = () => startEditTask(task.id);
      actions.appendChild(editBtn);
    }

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.textContent = "üóëÔ∏è";
    deleteBtn.title = "Delete task";
    deleteBtn.onclick = () => {
      if (!confirm("Delete this task?")) return;
      const idx = tasks.findIndex(t => t.id === task.id);
      if (idx !== -1) {
        if (editingTaskId === task.id) {
          cancelEdit();
        }
        tasks.splice(idx, 1);
        persist();
        updateUI();
      }
    };
    actions.appendChild(deleteBtn);

    card.appendChild(header);
    card.appendChild(actions);

    const descriptors = buildTaskDescriptors(task);
    if (descriptors.length) {
      const descriptorContainer = document.createElement("div");
      descriptorContainer.className = "task-descriptors";
      descriptors.forEach(text => {
        const span = document.createElement("span");
        span.textContent = text;
        descriptorContainer.appendChild(span);
      });
      card.appendChild(descriptorContainer);
    }

    if (task.firstThreeMode && !task.firstThreeUnlocked && mode === TASK_LIST_MODES.ACTIVE) {
      const nudge = document.createElement("div");
      nudge.className = "score";
      nudge.textContent = "Start with the first three micro-steps to unlock the rest.";
      card.appendChild(nudge);
    }

    const progress = createProgressElement(task);
    if (progress) {
      card.appendChild(progress);
    }

    const meta = document.createElement("div");
    meta.className = "task-meta";
    const metaItems = [];

    if (mode === TASK_LIST_MODES.ACTIVE) {
      metaItems.push(`Score ${task.priority.toFixed(1)}`);
      if (Number.isFinite(timeBudgetMinutes) && timeBudgetMinutes > 0) {
        const estimatedMinutes = estimateTaskMinutes(task);
        metaItems.push(`Est ${estimatedMinutes} min`);
      }
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
      if (task.addedAt) {
        const formatted = formatDateTime(task.addedAt);
        if (formatted) metaItems.push(`Added ${formatted}`);
      }
      const age = task.dateOfService ? calculateDaysSince(task.dateOfService) : (
        task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === ""
          ? null
          : Number(task.daysSinceVisit)
      );
      if (age !== null && Number.isFinite(age)) {
        const ageLabel = age < 0 ? `${Math.abs(age)} day(s) until visit` : `${age} day(s) since visit`;
        metaItems.push(ageLabel);
      }
      if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
        metaItems.push(`Chart time ${formatDuration(Number(task.chartDurationMinutes))}`);
      }
    } else {
      const completedAt = formatDateTime(getCompletionTimestamp(task));
      metaItems.push(`Completed ${completedAt || "--"}`);
      const totalDuration = getTaskTotalDuration(task);
      metaItems.push(`Duration ${formatDuration(totalDuration)}`);
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
    }

    metaItems.forEach(text => meta.appendChild(createMetaItem(text)));
    if (metaItems.length) {
      card.appendChild(meta);
    }

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const details = createTaskDetails(task);
      if (details) {
        const toggle = document.createElement("button");
        toggle.className = "task-detail-toggle";
        toggle.textContent = "View details";
        toggle.onclick = () => {
          const isHidden = details.classList.contains("hidden");
          if (isHidden) {
            details.classList.remove("hidden");
            toggle.textContent = "Hide details";
          } else {
            details.classList.add("hidden");
            toggle.textContent = "View details";
          }
        };
        card.appendChild(toggle);
        card.appendChild(details);
      }
    }

    return card;
  }

  function computeFocusScore(task, energyLevel, timeBudget) {
    if (!task) return 0;
    const base = Number(task?.priority || 0);
    if (!Number.isFinite(base) || base <= 0) {
      return base || 0;
    }
    const energyWeight = computeEnergyFit(task, energyLevel);
    const timeWeight = computeTimeFit(task, timeBudget);
    return base * energyWeight * timeWeight;
  }

  function buildNextTaskInsights(task, energyLevel, timeBudget) {
    const insights = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(estimated) && estimated > 0) {
      insights.push(`Est. ${Math.max(1, Math.round(estimated))} min`);
    }
    if (Number.isFinite(timeBudget)) {
      const timeScore = timeFit(task, timeBudget);
      if (!Number.isFinite(estimated) || estimated <= 0) {
        insights.push(`${timeBudget}-min window`);
      } else if (timeScore > 1) {
        insights.push(`Fits ${timeBudget}-min`);
      } else if (estimated > timeBudget) {
        insights.push(`Stretch past ${timeBudget} min`);
      }
    }
    const energyScore = energyFit(task, energyLevel);
    if (energyScore < 1) {
      insights.push('Easy win');
    } else if (Number.isFinite(energyLevel) && ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
      insights.push(`Energy: ${ENERGY_LABELS[energyLevel]}`);
    }
    if (isChartTask(task) && Number.isFinite(Number(task.daysSinceVisit)) && Number(task.daysSinceVisit) > 0) {
      insights.push(`${task.daysSinceVisit}d since visit`);
    }
    if (task.category) {
      insights.push(task.category);
    }
    return insights.filter(Boolean).slice(0, 3);
  }

  function updateNextTaskCard() {
    const card = $("nextTaskCard");
    if (!card) return;
    const nameEl = $("nextTaskName");
    const substepEl = $("nextTaskSubstep");
    const chipsEl = $("nextTaskChips");
    const scoreEl = $("nextTaskScore");
    const emptyEl = $("nextTaskEmpty");
    const startActionBtn = $("nextTaskActionButton");

    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();

    const candidates = tasks
      .filter(task => !isTaskCompleted(task) && (activeCategory === "All" || task.category === activeCategory))
      .sort((a, b) => computeFocusScore(b, energyLevel, timeBudget) - computeFocusScore(a, energyLevel, timeBudget));

    const topTask = candidates[0] || null;
    nextTaskId = topTask ? topTask.id : null;

    card.classList.remove("hidden");
    if (!topTask) {
      if (nameEl) nameEl.textContent = "";
      if (substepEl) substepEl.textContent = "";
      if (chipsEl) chipsEl.innerHTML = "";
      if (scoreEl) {
        scoreEl.textContent = "";
        scoreEl.classList.add("hidden");
      }
      if (emptyEl) emptyEl.classList.remove("hidden");
      if (startActionBtn) startActionBtn.disabled = true;
      return;
    }

    if (emptyEl) emptyEl.classList.add("hidden");
    if (nameEl) nameEl.textContent = topTask.name;
    const firstSub = Array.isArray(topTask.subTasks)
      ? topTask.subTasks.find(sub => !sub.completed)
      : null;
    if (substepEl) {
      substepEl.textContent = firstSub
        ? `Next substep: ${firstSub.name}`
        : "Set your first micro-step.";
    }
    if (chipsEl) {
      chipsEl.innerHTML = "";
      buildNextTaskInsights(topTask, energyLevel, timeBudget).forEach(text => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = text;
        chipsEl.appendChild(chip);
      });
    }
    if (scoreEl) {
      scoreEl.innerHTML = "";
      const scoreText = document.createElement("span");
      const rawScore = Number(topTask.priority);
      const displayScore = Number.isFinite(rawScore) ? Math.round(rawScore) : 0;
      scoreText.textContent = `Fit ${displayScore}`;
      const info = document.createElement("span");
      info.className = "next-task-fit__info";
      info.textContent = "i";
      info.title = "Just a nudge, not a grade.";
      info.setAttribute("aria-label", "Just a nudge, not a grade.");
      scoreEl.appendChild(scoreText);
      scoreEl.appendChild(info);
      const srOnly = document.createElement("span");
      srOnly.className = "visually-hidden";
      srOnly.textContent = "Fit guidance. Just a nudge, not a grade.";
      scoreEl.appendChild(srOnly);
      scoreEl.classList.remove("hidden");
    }
    if (startActionBtn) startActionBtn.disabled = false;
  }

  const DEFAULT_NEXT_BEST_INPUTS = {
    time: 15,
    energy: 3,
    deadline: 3,
    size: "any",
    frictions: []
  };
  const DEFAULT_PREFLIGHT_TOGGLES = {
    focusMusic: false,
    dnd: false,
    timer: false
  };

  function loadPreflightToggles() {
    try {
      const stored = JSON.parse(localStorage.getItem(PREFLIGHT_TOGGLES_KEY) || "null");
      if (stored && typeof stored === "object") {
        return { ...DEFAULT_PREFLIGHT_TOGGLES, ...stored };
      }
    } catch (error) {
      console.warn("Unable to load pre-flight toggles", error);
    }
    return { ...DEFAULT_PREFLIGHT_TOGGLES };
  }

  function savePreflightToggles(state) {
    try {
      localStorage.setItem(PREFLIGHT_TOGGLES_KEY, JSON.stringify(state));
    } catch (error) {
      console.warn("Unable to save pre-flight toggles", error);
    }
  }

  function initializePreflightToggles() {
    const buttons = document.querySelectorAll('[data-preflight-toggle]');
    if (!buttons.length) return;
    const state = loadPreflightToggles();
    buttons.forEach(button => {
      const key = button.getAttribute("data-preflight-toggle");
      if (!key) return;
      const active = Boolean(state[key]);
      button.classList.toggle("is-active", active);
      button.setAttribute("aria-pressed", active ? "true" : "false");
      button.addEventListener("click", () => {
        const next = !button.classList.contains("is-active");
        state[key] = next;
        button.classList.toggle("is-active", next);
        button.setAttribute("aria-pressed", next ? "true" : "false");
        savePreflightToggles(state);
      });
    });
  }

  function clampMmpMinutes(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) return MMP_MIN_MINUTES;
    return Math.max(MMP_MIN_MINUTES, Math.min(MMP_MAX_MINUTES, Math.round(numeric)));
  }

  function loadNextBestInputs() {
    try {
      const stored = JSON.parse(localStorage.getItem(NEXT_BEST_STORAGE_KEY) || "null");
      if (stored && typeof stored === "object") {
        const frictions = Array.isArray(stored.frictions)
          ? Array.from(new Set(stored.frictions.map(String)))
          : [];
        return {
          ...DEFAULT_NEXT_BEST_INPUTS,
          ...stored,
          time: Number(stored.time) || DEFAULT_NEXT_BEST_INPUTS.time,
          energy: clampScale(stored.energy, DEFAULT_NEXT_BEST_INPUTS.energy),
          deadline: clampScale(stored.deadline, DEFAULT_NEXT_BEST_INPUTS.deadline),
          size: stored.size || DEFAULT_NEXT_BEST_INPUTS.size,
          frictions
        };
      }
    } catch (error) {
      console.warn("Unable to load Next Best inputs", error);
    }
    return { ...DEFAULT_NEXT_BEST_INPUTS };
  }

  function saveNextBestInputs(inputs) {
    try {
      localStorage.setItem(NEXT_BEST_STORAGE_KEY, JSON.stringify(inputs));
    } catch (error) {
      console.warn("Unable to save Next Best inputs", error);
    }
  }

  function applyNextBestInputs(inputs) {
    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.value = String(inputs.time);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.value = String(inputs.energy);
      energySlider.setAttribute("data-value", String(inputs.energy));
    }
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect) {
      deadlineSelect.value = String(inputs.deadline);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.value = inputs.size || "any";
    }
    const checkboxes = document.querySelectorAll('input[name="nextBestFriction"]');
    checkboxes.forEach(box => {
      box.checked = inputs.frictions.includes(box.value);
    });
    alignEnergySliders(inputs.energy, "next");
  }

  function getSelectedFrictionTags() {
    return Array.from(document.querySelectorAll('input[name="nextBestFriction"]:checked'))
      .map(input => input.value)
      .filter(Boolean);
  }

  function getNextBestInputs() {
    const defaults = loadNextBestInputs();
    const timeSelect = $("nextBestTime");
    const energySlider = $("nextBestEnergy");
    const deadlineSelect = $("nextBestDeadline");
    const sizeSelect = $("nextBestSize");
    const timeValue = Number(timeSelect?.value || defaults.time);
    const energyValue = Number(energySlider?.value || defaults.energy);
    const deadlineValue = Number(deadlineSelect?.value || defaults.deadline);
    const frictions = getSelectedFrictionTags();
    const resolvedEnergy = alignEnergySliders(energyValue, "next");
    return {
      time: Number.isFinite(timeValue) && timeValue > 0 ? timeValue : defaults.time,
      energy: resolvedEnergy,
      deadline: clampScale(deadlineValue, defaults.deadline),
      size: sizeSelect?.value || defaults.size,
      frictions
    };
  }

  function estimateSubTaskMinutes(task, sub) {
    if (!sub) return null;
    const recorded = Number(sub.durationMinutes);
    if (Number.isFinite(recorded) && recorded > 0) {
      return clampMmpMinutes(recorded);
    }
    const total = estimateTaskMinutes(task);
    const remainingCount = Array.isArray(task.subTasks) && task.subTasks.length
      ? task.subTasks.filter(step => !step.completed).length || 1
      : 1;
    const approx = Number.isFinite(total)
      ? Math.max(6, total / Math.max(1, remainingCount))
      : 15;
    return clampMmpMinutes(approx);
  }

  function deriveMmpChunk(task) {
    if (!task) return null;
    const remainingSubs = Array.isArray(task.subTasks)
      ? task.subTasks.filter(sub => !sub.completed)
      : [];
    if (remainingSubs.length) {
      const prioritized = remainingSubs.map(sub => ({ sub, minutes: estimateSubTaskMinutes(task, sub) }));
      const candidate = prioritized.find(entry => entry.minutes <= MMP_MAX_MINUTES) || prioritized[0];
      if (candidate) {
        return {
          label: candidate.sub.name,
          minutes: clampMmpMinutes(candidate.minutes),
          subId: candidate.sub.id || null
        };
      }
    }
    const fallback = estimateTaskMinutes(task);
    const sprint = Number.isFinite(fallback) ? Math.max(fallback * 0.5, MMP_MIN_MINUTES) : MMP_MIN_MINUTES;
    const minutes = clampMmpMinutes(sprint);
    return {
      label: `First ${minutes} minutes on ${task.name}`,
      minutes,
      subId: null
    };
  }

  function isEasyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    return difficulty <= 3 && evaluation.chunk.minutes <= 15;
  }

  function isBuddyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    const category = evaluation.task?.category || "";
    return difficulty >= 4 || evaluation.chunk.minutes >= 18 || ["Calls", "Teaching"].includes(category);
  }

  function evaluateTaskForNextBest(task, inputs) {
    if (!task || isTaskCompleted(task)) return null;
    const chunk = deriveMmpChunk(task);
    if (!chunk) return null;
    const timeBudget = Number.isFinite(inputs.time) ? inputs.time : Infinity;
    const energyLevel = clampScale(inputs.energy, 3);
    let score = computeFocusScore(task, energyLevel, timeBudget);
    if (!Number.isFinite(score)) score = 0;
    (inputs.frictions || []).forEach(tag => {
      const rule = NEXT_BEST_FRICTION_RULES[tag];
      if (typeof rule === "function") {
        score *= rule(task) ? 1.08 : 0.78;
      }
    });
    const deadlineLevel = clampScale(inputs.deadline, 3);
    if (deadlineLevel !== 3) {
      const daysUntil = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
      const overdue = Number.isFinite(daysUntil) && daysUntil < 0;
      const dueSoon = Number.isFinite(daysUntil) && daysUntil >= 0 && daysUntil <= 2;
      const daysSince = Number(task.daysSinceVisit);
      if (deadlineLevel > 3) {
        const boost = 1 + (deadlineLevel - 3) * 0.12;
        if (overdue || dueSoon || (Number.isFinite(daysSince) && daysSince >= 5)) {
          score *= boost;
        } else {
          score *= 1 + (deadlineLevel - 3) * 0.05;
        }
      } else {
        score *= Math.max(0.6, 1 - (3 - deadlineLevel) * 0.06);
      }
    }
    const estimate = estimateTaskMinutes(task);
    const effectiveEstimate = Number.isFinite(estimate) && estimate > 0 ? estimate : chunk.minutes;
    if (inputs.size === "small") {
      score *= effectiveEstimate <= 20 ? 1.1 : 0.82;
    } else if (inputs.size === "medium") {
      score *= effectiveEstimate >= 15 && effectiveEstimate <= 40 ? 1.08 : 0.88;
    } else if (inputs.size === "large") {
      score *= effectiveEstimate >= 30 ? 1.12 : 0.85;
    }
    const impact = Number(task.priority || 0);
    const impactPerMinute = chunk.minutes > 0 ? impact / chunk.minutes : impact;
    const insights = buildNextTaskInsights(task, energyLevel, timeBudget);
    return {
      task,
      score,
      chunk,
      impactPerMinute,
      estimate: effectiveEstimate,
      insights
    };
  }

  function launchNextBestOption(label, evaluation) {
    if (!evaluation || !evaluation.task) return;
    const minutes = Number.isFinite(evaluation.chunk?.minutes)
      ? evaluation.chunk.minutes
      : MMP_MIN_MINUTES;
    showToast("Next Best Thing", `${label}: ${evaluation.chunk?.label || evaluation.task.name}`);
    startFocus(evaluation.task.id, { sprintMinutes: minutes });
  }

  function setActivationSuggestion(evaluation) {
    const suggestionBtn = $("focusSuggestionButton");
    const detailEl = $("focusSuggestionDetail");
    const previewEl = $("focusSuggestionText");
    const heroHint = $("focusLaunchHint");
    if (!suggestionBtn || !detailEl || !previewEl || !heroHint) return;
    const hasActiveTasks = tasks.some(task => !isTaskCompleted(task));
    if (evaluation && evaluation.task) {
      const message = evaluation.chunk?.label || evaluation.task.name;
      detailEl.textContent = message;
      previewEl.textContent = message;
      heroHint.textContent = message;
      suggestionBtn.disabled = false;
      suggestionBtn.setAttribute("aria-disabled", "false");
      suggestionBtn.dataset.pickKey = "now";
      suggestionBtn.dataset.taskId = evaluation.task.id || "";
    } else {
      const fallback = hasActiveTasks
        ? "Refresh Next Best to see a top pick."
        : "Add a task to unlock focus.";
      detailEl.textContent = fallback;
      previewEl.textContent = fallback;
      heroHint.textContent = fallback;
      suggestionBtn.disabled = true;
      suggestionBtn.setAttribute("aria-disabled", "true");
      delete suggestionBtn.dataset.pickKey;
      delete suggestionBtn.dataset.taskId;
    }
  }

  function createNextBestCard(config) {
    const { label, payoff, cta, evaluation, inputs } = config;
    if (!evaluation) return null;

    const energyValue = Number(inputs?.energy) || DEFAULT_NEXT_BEST_INPUTS.energy;
    const energyLabelRaw = ENERGY_LABELS && ENERGY_LABELS[energyValue] ? ENERGY_LABELS[energyValue] : "Current";
    const energyLabel = typeof energyLabelRaw === "string" ? energyLabelRaw : String(energyLabelRaw);
    const energyMode = energyValue <= 2 ? "low" : energyValue >= 4 ? "high" : "steady";
    const minutesWindow = Number.isFinite(inputs?.time) ? `${inputs.time}m` : `${Math.max(5, evaluation.chunk?.minutes || DEFAULT_NEXT_BEST_INPUTS.time)}m`;

    const card = document.createElement("article");
    card.className = "next-best-option";
    card.dataset.energyMode = energyMode;

    const ring = document.createElement("div");
    ring.className = "next-best-ring";
    const ringLabel = document.createElement("span");
    ringLabel.textContent = "Primed";
    ring.appendChild(ringLabel);
    card.appendChild(ring);

    const labelEl = document.createElement("span");
    labelEl.className = "next-best-option__label";
    labelEl.textContent = label;
    card.appendChild(labelEl);

    const heading = document.createElement("h3");
    heading.className = "next-best-option__title";
    heading.textContent = evaluation.task.name;
    card.appendChild(heading);

    if (payoff) {
      const payoffLine = document.createElement("p");
      payoffLine.className = "next-best-option__payoff";
      payoffLine.textContent = `${payoff} for ${minutesWindow} + ${energyLabel.toLowerCase()} energy`;
      card.appendChild(payoffLine);
    }

    const chips = document.createElement("div");
    chips.className = "next-best-option__chips";

    const addChip = text => {
      if (!text) return;
      const chip = document.createElement("span");
      chip.className = "chip spec-chip";
      chip.textContent = text;
      chips.appendChild(chip);
    };

    const estimatedMinutes = Math.max(1, Math.round(evaluation.estimate || evaluation.chunk?.minutes || inputs?.time || DEFAULT_NEXT_BEST_INPUTS.time));
    addChip(`Est. time ‚Ä¢ ${estimatedMinutes}m`);
    if (evaluation.chunk?.label) {
      addChip(`Stretch ‚Ä¢ ${evaluation.chunk.label}`);
    }
    addChip(`Energy ‚Ä¢ ${energyLabel}`);

    if (chips.childElementCount) {
      card.appendChild(chips);
    }

    const meter = document.createElement("div");
    meter.className = "next-best-meter";
    const meterLabel = document.createElement("div");
    meterLabel.className = "next-best-meter__label";
    meterLabel.textContent = "Impact/min";
    meter.appendChild(meterLabel);

    const track = document.createElement("div");
    track.className = "next-best-meter__track";
    const bar = document.createElement("div");
    bar.className = "next-best-meter__bar";
    const normalizedImpact = Number.isFinite(evaluation.impactPerMinute)
      ? Math.max(4, Math.min(100, (evaluation.impactPerMinute / 10) * 100))
      : 4;
    bar.style.width = `${normalizedImpact}%`;
    track.appendChild(bar);
    meter.appendChild(track);

    const scale = document.createElement("div");
    scale.className = "next-best-meter__scale";
    const startTick = document.createElement("span");
    startTick.textContent = "0";
    const endTick = document.createElement("span");
    endTick.textContent = "‚â•10";
    scale.appendChild(startTick);
    scale.appendChild(endTick);
    meter.appendChild(scale);
    card.appendChild(meter);

    const button = document.createElement("button");
    button.type = "button";
    button.className = `btn next-best-cta next-best-cta--${energyMode}`;
    button.textContent = cta || "Start";
    button.addEventListener("click", () => launchNextBestOption(label, evaluation));
    card.appendChild(button);

    return card;
  }

  function handleNextBestRefresh(event) {
    if (event) event.preventDefault();
    const button = event?.currentTarget || $("nextBestRefresh");
    if (button) {
      button.classList.add("is-loading");
      button.disabled = true;
    }
    try {
      updateNextBestOptions({ force: true });
    } finally {
      if (button) {
        window.setTimeout(() => {
          button.classList.remove("is-loading");
          button.disabled = false;
        }, 320);
      }
    }
  }

  function updateNextBestOptions(options = {}) {
    const forceUpdate = Boolean(options.force);
    const results = $("nextBestResults");
    const empty = $("nextBestEmpty");
    if (!results || !empty) return;

    if (!forceUpdate && !isElementMostlyInView(results, 0.25)) {
      nextBestUpdatePending = true;
      return;
    }

    nextBestUpdatePending = false;
    setActivationSuggestion(null);
    const inputs = getNextBestInputs();
    saveNextBestInputs(inputs);

    results.innerHTML = "";
    empty.classList.add("hidden");
    latestNextBestPicks = {};

    const candidates = tasks.filter(task => !isTaskCompleted(task));
    if (!candidates.length) {
      empty.textContent = "Add a task to see your next best options.";
      empty.classList.remove("hidden");
      return;
    }

    const evaluations = candidates
      .map(task => evaluateTaskForNextBest(task, inputs))
      .filter(Boolean)
      .sort((a, b) => b.score - a.score);

    if (!evaluations.length) {
      empty.textContent = "No tasks match this window. Adjust your filters.";
      empty.classList.remove("hidden");
      return;
    }

    const used = new Set();
    const picks = {};
    const assignCandidate = (key, predicate = null) => {
      const match = evaluations.find(entry => !used.has(entry.task.id) && (!predicate || predicate(entry)));
      if (match) {
        used.add(match.task.id);
        picks[key] = match;
      }
    };

    assignCandidate("now");
    assignCandidate("easy", isEasyNextBest);
    assignCandidate("buddy", isBuddyNextBest);

    ["easy", "buddy"].forEach(key => {
      if (!picks[key]) {
        const fallback = evaluations.find(entry => !used.has(entry.task.id));
        if (fallback) {
          used.add(fallback.task.id);
          picks[key] = fallback;
        }
      }
    });

    const configs = [
      { key: "now", label: "Do now", payoff: "Highest ROI", cta: "Start" },
      { key: "easy", label: "Do if easy", payoff: "Low friction win", cta: "Start easy" },
      { key: "buddy", label: "Do with buddy", payoff: "Accountability boost", cta: "Start with buddy" }
    ];

    setActivationSuggestion(picks.now || null);

    configs.forEach(config => {
      const evaluation = picks[config.key];
      if (evaluation) {
        const card = createNextBestCard({ ...config, evaluation, inputs });
        if (card) results.appendChild(card);
      }
    });
    latestNextBestPicks = { ...picks };
  }

  function initializeNextBestEngine() {
    const results = $("nextBestResults");
    if (!results) return;
    const storedRaw = localStorage.getItem(NEXT_BEST_STORAGE_KEY);
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect && deadlineSelect.options.length === 0) {
      for (let i = 1; i <= 5; i += 1) {
        const option = document.createElement("option");
        option.value = String(i);
        option.textContent = String(i);
        deadlineSelect.appendChild(option);
      }
    }
    const stored = loadNextBestInputs();
    applyNextBestInputs(stored);

    const controlsPanel = $("nextBestControls");
    const adjustToggle = $("nextBestAdjustToggle");
    const stuckBtn = $("nextBestStuck");
    const setControlsOpen = open => {
      if (!controlsPanel || !adjustToggle) return;
      controlsPanel.hidden = !open;
      controlsPanel.setAttribute("aria-hidden", open ? "false" : "true");
      adjustToggle.setAttribute("aria-expanded", open ? "true" : "false");
      adjustToggle.classList.toggle("is-active", open);
    };
    if (controlsPanel) {
      setControlsOpen(!storedRaw);
    }
    if (adjustToggle) {
      adjustToggle.addEventListener("click", () => {
        const nextOpen = controlsPanel ? controlsPanel.hidden : false;
        setControlsOpen(nextOpen);
      });
    }
    if (stuckBtn) {
      stuckBtn.addEventListener("click", () => {
        setControlsOpen(true);
        const firstFriction = controlsPanel?.querySelector('input[name="nextBestFriction"]');
        if (firstFriction) {
          firstFriction.focus();
        }
      });
    }

    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.addEventListener("change", updateNextBestOptions);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || stored.energy);
        alignEnergySliders(value, "next");
        updateNextBestOptions();
      });
    }
    if (deadlineSelect) {
      deadlineSelect.addEventListener("change", updateNextBestOptions);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.addEventListener("change", updateNextBestOptions);
    }
    const frictionBoxes = document.querySelectorAll('input[name="nextBestFriction"]');
    frictionBoxes.forEach(box => {
      box.addEventListener("change", updateNextBestOptions);
    });
    const refreshBtn = $("nextBestRefresh");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", handleNextBestRefresh);
    }
    updateNextBestOptions();
  }

  function prepareAccordionContainers() {
    const counters = {};
    document.querySelectorAll('[data-accordion]').forEach(container => {
      const name = container.dataset.accordion || "accordion";
      const index = counters[name] || 0;
      counters[name] = index + 1;
      const summary = container.querySelector('[data-accordion-summary]');
      const panel = container.querySelector('[data-accordion-panel]');
      if (!summary || !panel) return;
      const suffix = index === 0 ? "" : `-${index}`;
      const panelId = `${name}Panel${suffix}`;
      panel.id = panelId;
      summary.setAttribute("aria-controls", panelId);
    });
  }

  function getDueTodaySections() {
    return Array.from(document.querySelectorAll('[data-due-today-section]'))
      .map(section => {
        const accordion = section.querySelector('[data-accordion="dueToday"]');
        const summaryBtn = accordion?.querySelector('[data-accordion-summary]');
        const summaryText = accordion?.querySelector('[data-due-today-summary-text]');
        const listEl = section.querySelector('[data-due-today-list]');
        const emptyEl = section.querySelector('[data-due-today-empty]');
        return { section, accordion, summaryBtn, summaryText, listEl, emptyEl };
      })
      .filter(instance => instance.section && instance.accordion && instance.summaryBtn && instance.summaryText && instance.listEl && instance.emptyEl);
  }

  function initializeDueTodayAccordionState() {
    const sections = getDueTodaySections();
    if (!sections.length) return;

    sections.forEach(({ accordion, summaryBtn, listEl }) => {
      if (!accordion || !summaryBtn || !listEl) return;

      // Set initial state to CLOSED
      accordion.dataset.open = "false";
      summaryBtn.setAttribute("aria-expanded", "false");
      listEl.hidden = true;

      // Attach click listener once during initialization
      if (!summaryBtn.dataset.listenerBound) {
        summaryBtn.dataset.listenerBound = "true";
        summaryBtn.addEventListener("click", () => {
          const nextOpen = accordion.dataset.open !== "true";
          setDueTodayAccordionOpen(nextOpen, { highlight: nextOpen, source: accordion });
        });
      }
    });
  }

  function createDueTodayItem(entry) {
    const item = document.createElement("div");
    item.className = "due-today-item";

    const title = document.createElement("p");
    title.className = "due-today-title";
    title.textContent = entry.task.name;
    item.appendChild(title);

    const meta = document.createElement("div");
    meta.className = "due-today-meta";
    const metaBits = ["Due today"];
    if (entry.fallback && entry.task.dateOfService) {
      metaBits.push(`Visit ${entry.task.dateOfService}`);
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" ‚Ä¢ ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" ‚Ä¢ ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready ‚Ä¢ est ‚Äî";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready ‚Ä¢ est ‚Äî";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    if (!entries.length) {
      return;
    }

    const readyLabel = entries.length === 1 ? "1 ready" : `${entries.length} ready`;
    const estimatedMinutes = entries.reduce((sum, entry) => {
      const minutes = estimateTaskMinutes(entry.task);
      return Number.isFinite(minutes) ? sum + minutes : sum;
    }, 0);
    const hasEstimate = Number.isFinite(estimatedMinutes) && estimatedMinutes > 0;
    const estimateText = hasEstimate ? `est ${Math.max(1, Math.round(estimatedMinutes))} min` : "est ‚Äî";

    instances.forEach(({ accordion, summaryBtn, summaryText, listEl }) => {
      summaryText.textContent = `${readyLabel} ‚Ä¢ ${estimateText}`;
      entries.forEach(entry => {
        listEl.appendChild(createDueTodayItem(entry));
      });
      const isOpen = accordion.dataset.open === "true";
      summaryBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
      listEl.hidden = !isOpen;
    });
  }

  function setDueTodayAccordionOpen(open, options = {}) {
    const { highlight = true, focusSummary = false, skipSync = false, source = null } = options;
    const instances = getDueTodaySections();
    if (!instances.length) return;
    instances.forEach(({ accordion, summaryBtn, listEl, section }) => {
      const nextState = open ? "true" : "false";
      accordion.dataset.open = nextState;
      summaryBtn.setAttribute("aria-expanded", open ? "true" : "false");
      listEl.hidden = !open;
      if (open && highlight !== false && (!source || source === section || source === accordion)) {
        window.requestAnimationFrame(() => {
          const firstCard = listEl.querySelector(".due-today-item");
          if (firstCard) {
            firstCard.classList.add("due-today-item--spotlight");
            window.setTimeout(() => firstCard.classList.remove("due-today-item--spotlight"), 900);
          }
        });
      }
      if (open && focusSummary && (!source || source === section || source === accordion)) {
        summaryBtn.focus();
      }
    });
    if (open && !skipSync) {
      setAllTasksAccordionOpen(false, { skipSync: true });
    }
  }

  function computeWantScore(task) {
    const interest = Number(task?.interest || 3);
    const novelty = Number(task?.novelty || 3);
    const difficulty = Number(task?.difficulty || 3);
    const est = estimateTaskMinutes(task);
    const ease = Number.isFinite(est) && est <= 20 ? 1.15 : 0.95;
    return (interest + novelty) * ease - difficulty * 0.2;
  }

  function renderConflictList(candidates, container, type) {
    if (!container) return;
    container.innerHTML = "";
    if (!candidates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No tasks available.";
      container.appendChild(empty);
      return;
    }
    candidates.slice(0, 3).forEach(({ task, descriptor }) => {
      const item = document.createElement("div");
      item.className = "conflict-item";
      item.setAttribute("draggable", "true");
      item.setAttribute("role", "button");
      item.setAttribute("tabindex", "0");
      item.dataset.type = type;
      item.dataset.taskId = task.id;
      const title = document.createElement("strong");
      title.textContent = task.name;
      const meta = document.createElement("span");
      meta.textContent = descriptor;
      item.appendChild(title);
      item.appendChild(meta);
      item.addEventListener("dragstart", event => {
        if (!event.dataTransfer) return;
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", JSON.stringify({ type, taskId: task.id }));
      });
      item.addEventListener("click", () => setConflictSelection(type, task.id));
      item.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          setConflictSelection(type, task.id);
        }
      });
      container.appendChild(item);
    });
  }

  function getActiveTaskById(taskId) {
    return tasks.find(task => task.id === taskId && !isTaskCompleted(task));
  }

  function renderConflictArena() {
    const arena = $("conflictArena");
    if (!arena) return;
    arena.innerHTML = "";
    const selections = [];
    if (conflictArenaSelection.should) {
      selections.push({ label: "Should-do", task: conflictArenaSelection.should });
    }
    if (conflictArenaSelection.want) {
      selections.push({ label: "Want-to", task: conflictArenaSelection.want });
    }
    if (!selections.length) {
      const prompt = document.createElement("div");
      prompt.id = "conflictArenaPrompt";
      prompt.textContent = "Drag a contender from each side into the arena.";
      arena.appendChild(prompt);
      arena.classList.remove("is-ready");
      return;
    }
    selections.forEach(selection => {
      const slot = document.createElement("div");
      slot.className = "arena-slot";
      slot.textContent = `${selection.label}: ${selection.task.name}`;
      arena.appendChild(slot);
    });
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      arena.classList.add("is-ready");
    } else {
      arena.classList.remove("is-ready");
    }
  }

  function setConflictSelection(type, taskId) {
    const task = getActiveTaskById(taskId);
    if (!task) return;
    conflictArenaSelection = {
      ...conflictArenaSelection,
      [type]: task
    };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      evaluateConflictArena();
    }
  }

  function resetConflictArena() {
    conflictArenaSelection = { should: null, want: null };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
  }

  function handleConflictDrop(event) {
    event.preventDefault();
    if (!event.dataTransfer) return;
    try {
      const payload = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (payload?.type && payload?.taskId) {
        setConflictSelection(payload.type, payload.taskId);
      }
    } catch (error) {
      console.warn("Unable to parse dropped conflict item", error);
    }
  }

  function evaluateConflictArena() {
    const shouldTask = conflictArenaSelection.should;
    const wantTask = conflictArenaSelection.want;
    if (!shouldTask || !wantTask) return;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldChunk = deriveMmpChunk(shouldTask);
    const wantChunk = deriveMmpChunk(wantTask);
    const shouldScore = computeFocusScore(shouldTask, energy, timeBudget) * 0.6
      + (Number(shouldTask.importance) || 1) * 2
      + (shouldChunk.minutes <= 15 ? 1.1 : 1);
    const wantScore = computeFocusScore(wantTask, energy, timeBudget) * 0.45
      + (Number(wantTask.interest) || 3) + (Number(wantTask.novelty) || 3)
      + (wantChunk.minutes <= 15 ? 1.05 : 0.9);
    const recommended = shouldScore >= wantScore
      ? { task: shouldTask, chunk: shouldChunk, label: "Should-do" }
      : { task: wantTask, chunk: wantChunk, label: "Want-to" };
    const sprintMinutes = Number.isFinite(recommended.chunk?.minutes)
      ? recommended.chunk.minutes
      : CONFLICT_DEFAULT_SPRINT;
    showToast("Conflict resolved", `${recommended.label} wins: ${recommended.task.name}`);
    const result = $("conflictResult");
    if (result) {
      result.textContent = `${recommended.label} wins ‚Äì ${sprintMinutes} minute sprint queued.`;
    }
    startFocus(recommended.task.id, { sprintMinutes });
    resetConflictArena();
    updateConflictResolver();
  }

  function updateConflictResolver() {
    const shouldList = $("conflictShouldList");
    const wantList = $("conflictWantList");
    if (!shouldList || !wantList) return;
    const activeTasks = tasks.filter(task => !isTaskCompleted(task));
    conflictArenaSelection.should = conflictArenaSelection.should
      ? getActiveTaskById(conflictArenaSelection.should.id)
      : null;
    conflictArenaSelection.want = conflictArenaSelection.want
      ? getActiveTaskById(conflictArenaSelection.want.id)
      : null;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Focus score ${computeFocusScore(task, energy, timeBudget).toFixed(1)}`
      }))
      .sort((a, b) => computeFocusScore(b.task, energy, timeBudget) - computeFocusScore(a.task, energy, timeBudget));
    const wantCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Spark score ${computeWantScore(task).toFixed(1)}`
      }))
      .sort((a, b) => computeWantScore(b.task) - computeWantScore(a.task));
    renderConflictList(shouldCandidates, shouldList, "should");
    renderConflictList(wantCandidates, wantList, "want");
    renderConflictArena();
  }

  function initializeConflictResolverModule() {
    const module = $("conflictResolverModule");
    if (!module) return;
    const arena = $("conflictArena");
    if (arena) {
      arena.addEventListener("dragover", event => {
        event.preventDefault();
        arena.classList.add("is-ready");
      });
      arena.addEventListener("dragleave", () => {
        if (!conflictArenaSelection.should || !conflictArenaSelection.want) {
          arena.classList.remove("is-ready");
        }
      });
      arena.addEventListener("drop", handleConflictDrop);
    }
    const resetBtn = $("conflictReset");
    if (resetBtn) {
      resetBtn.addEventListener("click", resetConflictArena);
    }
    updateConflictResolver();
  }

  function getDefuseBaseMinutes() {
    const stored = Number(localStorage.getItem(DEFUSE_BASE_MINUTES_KEY));
    if (Number.isFinite(stored) && stored >= DEFUSE_MINUTES_MIN) {
      return Math.min(DEFUSE_MINUTES_MAX, Math.max(DEFUSE_MINUTES_MIN, Math.round(stored)));
    }
    return DEFUSE_MINUTES_MIN;
  }

  function setDefuseBaseMinutes(value) {
    const clamped = Math.max(DEFUSE_MINUTES_MIN, Math.min(DEFUSE_MINUTES_MAX, Math.round(value)));
    try {
      localStorage.setItem(DEFUSE_BASE_MINUTES_KEY, String(clamped));
    } catch (error) {
      console.warn("Unable to store DEFUSE base minutes", error);
    }
    defuseState.uptime = clamped;
    updateDefuseUptimeUI();
  }

  function getDefuseLocks() {
    try {
      const raw = JSON.parse(localStorage.getItem(DEFUSE_LOCKS_KEY) || "[]");
      return Array.isArray(raw) ? raw.map(String) : [];
    } catch (error) {
      console.warn("Unable to parse DEFUSE locks", error);
      return [];
    }
  }

  function saveDefuseLocks(values) {
    try {
      localStorage.setItem(DEFUSE_LOCKS_KEY, JSON.stringify(values));
    } catch (error) {
      console.warn("Unable to save DEFUSE locks", error);
    }
  }

  function loadDefuseAction() {
    try {
      const stored = localStorage.getItem(DEFUSE_ACTION_KEY);
      return stored || DEFAULT_DEFUSE_ACTION;
    } catch (error) {
      console.warn("Unable to load DEFUSE action", error);
      return DEFAULT_DEFUSE_ACTION;
    }
  }

  function saveDefuseAction(action) {
    try {
      if (!action) {
        localStorage.removeItem(DEFUSE_ACTION_KEY);
      } else {
        localStorage.setItem(DEFUSE_ACTION_KEY, action);
      }
    } catch (error) {
      console.warn("Unable to store DEFUSE action", error);
    }
  }

  function getSelectedDefuseLocks() {
    return Array.from(document.querySelectorAll('#defuseLocks input[type="checkbox"]:checked'))
      .map(box => box.value)
      .filter(Boolean);
  }

  function updateDefuseLocksUI() {
    const stored = getDefuseLocks();
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    boxes.forEach(box => {
      box.checked = stored.includes(box.value);
    });
  }

  function updateDefuseUptimeUI() {
    const base = defuseState.uptime || getDefuseBaseMinutes();
    const uptime = $("defuseUptime");
    if (uptime) {
      uptime.textContent = `Next sprint: ${base} minutes`;
    }
    const fill = $("defuseUptimeFill");
    if (fill) {
      const ratio = (base - DEFUSE_MINUTES_MIN) / (DEFUSE_MINUTES_MAX - DEFUSE_MINUTES_MIN);
      fill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
  }

  function updateDefuseCountdownUI() {
    const countdownEl = $("defuseCountdown");
    if (countdownEl) {
      countdownEl.textContent = `${Math.max(0, defuseState.countdown)}s`;
    }
    const progress = $("defuseProgressFill");
    if (progress) {
      const ratio = defuseState.active ? (1 - defuseState.countdown / 90) : 0;
      progress.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
    if (defuseState.active) {
      const prompt = DEFUSE_PROMPTS.find(entry => defuseState.countdown <= entry.threshold);
      const promptEl = $("defusePrompt");
      if (prompt && promptEl) {
        promptEl.textContent = prompt.message;
      }
    } else {
      const promptEl = $("defusePrompt");
      if (promptEl) {
        promptEl.textContent = DEFUSE_PROMPTS[0].message;
      }
    }
  }

  function setDefuseStatus(message) {
    const status = $("defuseStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function selectDefuseAction(action) {
    defuseState.selectedAction = action || DEFAULT_DEFUSE_ACTION;
    saveDefuseAction(defuseState.selectedAction);
    const preview = $("defuseActionPreview");
    if (preview) {
      preview.textContent = `Action picked: ${defuseState.selectedAction}`;
    }
  }

  function autoLockDefuseApps() {
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    const values = [];
    boxes.forEach(box => {
      box.checked = true;
      values.push(box.value);
    });
    saveDefuseLocks(values);
  }

  function startDefusePreflight() {
    if (defuseState.active) return;
    defuseState.active = true;
    defuseState.countdown = 90;
    defuseState.selectedAction = defuseState.selectedAction || DEFAULT_DEFUSE_ACTION;
    autoLockDefuseApps();
    updateDefuseCountdownUI();
    setDefuseStatus("Preflight running‚Ä¶ stay with the prompt.");
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = true;
    if (cancelBtn) cancelBtn.disabled = false;
    defuseState.intervalId = setInterval(() => {
      defuseState.countdown -= 1;
      if (defuseState.countdown <= 0) {
        completeDefusePreflight();
      } else {
        updateDefuseCountdownUI();
      }
    }, 1000);
    updateDefuseModeUI();
  }

  function cancelDefusePreflight() {
    if (!defuseState.active) return;
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    setDefuseStatus("Preflight cancelled.");
    updateDefuseModeUI();
  }

  function completeDefusePreflight() {
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    const sprintMinutes = getDefuseBaseMinutes();
    setDefuseStatus(`Launching ${sprintMinutes}-minute DEFUSE sprint.`);
    showToast("DEFUSE Mode", `${defuseState.selectedAction}. Sprinting for ${sprintMinutes} minutes.`);
    const nextBase = Math.min(DEFUSE_MINUTES_MAX, sprintMinutes + 2);
    setDefuseBaseMinutes(nextBase);
    startFocus(null, { sprintMinutes });
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    updateDefuseModeUI();
  }

  function updateDefuseModeUI() {
    updateDefuseLocksUI();
    updateDefuseUptimeUI();
    updateDefuseCountdownUI();
    selectDefuseAction(defuseState.selectedAction || DEFAULT_DEFUSE_ACTION);
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = defuseState.active;
    if (cancelBtn) cancelBtn.disabled = !defuseState.active;
  }

  function initializeDefuseMode() {
    const module = $("defuseModule");
    if (!module) return;
    defuseState.selectedAction = loadDefuseAction();
    defuseState.uptime = getDefuseBaseMinutes();
    updateDefuseModeUI();
    const actionButtons = document.querySelectorAll('[data-defuse-action]');
    actionButtons.forEach(button => {
      button.addEventListener("click", () => selectDefuseAction(button.getAttribute("data-defuse-action")));
    });
    const lockBoxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    lockBoxes.forEach(box => {
      box.addEventListener("change", () => saveDefuseLocks(getSelectedDefuseLocks()));
    });
    const startBtn = $("defuseStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDefusePreflight);
    }
    const cancelBtn = $("defuseCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelDefusePreflight);
    }
  }

  function loadDopamineReward() {
    const stored = localStorage.getItem(DOPAMINE_REWARD_KEY);
    return stored || "music";
  }

  function saveDopamineReward(value) {
    try {
      localStorage.setItem(DOPAMINE_REWARD_KEY, value);
    } catch (error) {
      console.warn("Unable to save dopamine reward preference", error);
    }
  }

  function updateDopamineStatus(message) {
    const status = $("dopamineStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function renderDopamineIntervals() {
    const container = $("dopamineIntervals");
    if (!container) return;
    container.innerHTML = "";
    DOPAMINE_INTERVALS.forEach((minutes, index) => {
      const row = document.createElement("div");
      row.className = "dopamine-interval";
      const label = document.createElement("span");
      label.textContent = `${minutes} min`;
      const status = document.createElement("span");
      if (dopamineState?.currentIntervalIndex > index) {
        status.textContent = "‚úÖ complete";
      } else if (dopamineState?.active && dopamineState.currentIntervalIndex === index) {
        status.textContent = "‚ñ∂Ô∏è now";
      } else {
        status.textContent = "‚Ä¶ pending";
      }
      row.appendChild(label);
      row.appendChild(status);
      container.appendChild(row);
    });
  }

  function updateDopamineProgress() {
    const progress = $("dopamineProgressFill");
    if (!progress) return;
    if (!dopamineState || !dopamineState.active) {
      const completed = dopamineState?.currentIntervalIndex >= DOPAMINE_INTERVALS.length;
      progress.style.width = completed ? "100%" : "0%";
      updateGanttOverlayProgress();
      return;
    }
    const totalMinutes = DOPAMINE_INTERVALS[DOPAMINE_INTERVALS.length - 1];
    const totalMs = Math.max(1, totalMinutes * 60 * 1000);
    const elapsed = Date.now() - dopamineState.startTime;
    const ratio = Math.max(0, Math.min(1, elapsed / totalMs));
    progress.style.width = `${Math.round(ratio * 100)}%`;
    updateGanttOverlayProgress();
  }

  function spawnConfetti() {
    const burst = document.createElement("div");
    burst.className = "confetti-burst";
    const icons = ["üéâ", "‚ú®", "ü™Ñ", "üéä", "üí´"];
    burst.textContent = icons[Math.floor(Math.random() * icons.length)];
    document.body.appendChild(burst);
    setTimeout(() => {
      if (burst.parentNode) {
        burst.parentNode.removeChild(burst);
      }
    }, 900);
  }

  function playTone(frequency, durationMs = 320) {
    try {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) return;
      const context = new AudioContextClass();
      const oscillator = context.createOscillator();
      const gain = context.createGain();
      oscillator.type = "sine";
      oscillator.frequency.value = frequency;
      gain.gain.setValueAtTime(0.2, context.currentTime);
      oscillator.connect(gain);
      gain.connect(context.destination);
      oscillator.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + durationMs / 1000);
      oscillator.stop(context.currentTime + durationMs / 1000);
      setTimeout(() => context.close(), durationMs + 120);
    } catch (error) {
      console.warn("Tone playback unavailable", error);
    }
  }

  function triggerDopamineReward(index) {
    if (!dopamineState) return;
    dopamineState.currentIntervalIndex = Math.max(dopamineState.currentIntervalIndex, index + 1);
    renderDopamineIntervals();
    updateDopamineProgress();
    const minutes = DOPAMINE_INTERVALS[index];
    if (dopamineState.rewardType === "music") {
      playTone(440, 320);
      setTimeout(() => playTone(660, 200), 180);
    } else if (dopamineState.rewardType === "coin") {
      playTone(880, 200);
      setTimeout(() => playTone(660, 180), 180);
    } else if (dopamineState.rewardType === "confetti") {
      spawnConfetti();
    } else {
      showToast("Stretch cue", "Stand, reach tall, breathe for 10 seconds.");
    }
    if (index >= DOPAMINE_INTERVALS.length - 1) {
      updateDopamineStatus("Intervals complete. Ride the momentum!");
      stopDopaminePlaylist({ completed: true });
    } else {
      const next = DOPAMINE_INTERVALS[index + 1] - minutes;
      updateDopamineStatus(`Nice! Next reward in ${next} min.`);
    }
  }

  function stopDopaminePlaylist(options = {}) {
    if (!dopamineState) return;
    (dopamineState.timers || []).forEach(timerId => clearTimeout(timerId));
    if (dopamineState.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    const completed = Boolean(options.completed);
    const rewardType = dopamineState.rewardType || loadDopamineReward();
    const currentIndex = completed ? DOPAMINE_INTERVALS.length : (dopamineState.currentIntervalIndex || 0);
    dopamineState = {
      active: false,
      rewardType,
      currentIntervalIndex: currentIndex,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    if (!completed) {
      updateDopamineStatus("Playlist stopped.");
    }
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = false;
    if (stopBtn) stopBtn.disabled = true;
  }

  function startDopaminePlaylist() {
    if (dopamineState?.active) return;
    const select = $("dopamineReward");
    const rewardType = select?.value || loadDopamineReward();
    saveDopamineReward(rewardType);
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = true;
    if (stopBtn) stopBtn.disabled = false;
    const timers = DOPAMINE_INTERVALS.map((minutes, index) =>
      setTimeout(() => triggerDopamineReward(index), minutes * 60 * 1000)
    );
    if (dopamineState?.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    dopamineState = {
      active: true,
      rewardType,
      timers,
      startTime: Date.now(),
      tickIntervalId: setInterval(updateDopamineProgress, 1000),
      currentIntervalIndex: 0
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    updateDopamineStatus("Playlist started ‚Äì settle in.");
  }

  function initializeDopamineModule() {
    const module = $("dopamineModule");
    if (!module) return;
    const stored = loadDopamineReward();
    dopamineState = {
      active: false,
      rewardType: stored,
      currentIntervalIndex: 0,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    const select = $("dopamineReward");
    if (select) {
      select.value = stored;
      select.addEventListener("change", event => {
        const value = event.target.value || "music";
        saveDopamineReward(value);
        if (dopamineState) {
          dopamineState.rewardType = value;
        }
      });
    }
    const startBtn = $("dopamineStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDopaminePlaylist);
    }
    const stopBtn = $("dopamineStop");
    if (stopBtn) {
      stopBtn.addEventListener("click", () => stopDopaminePlaylist({ completed: false }));
      stopBtn.disabled = true;
    }
    renderDopamineIntervals();
    updateDopamineProgress();
    updateDopamineStatus("Stretch rewards from 2 ‚Üí 6 ‚Üí 12 minutes.");
  }

  function buildAdaptiveGanttPlan(windowMinutes = GANTT_WINDOW_MINUTES) {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const available = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({
        task,
        score: computeFocusScore(task, energyLevel, timeBudget),
        minutes: Math.max(5, Math.round(estimateTaskMinutes(task) || 15))
      }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    const entries = [];
    let remaining = Number.isFinite(windowMinutes) && windowMinutes > 0 ? windowMinutes : GANTT_WINDOW_MINUTES;
    available.forEach(entry => {
      if (remaining <= 0) return;
      const blockMinutes = Math.min(entry.minutes, remaining);
      entries.push({
        task: entry.task,
        minutes: blockMinutes,
        fullMinutes: entry.minutes
      });
      remaining -= blockMinutes;
    });
    const totalMinutes = entries.reduce((sum, entry) => sum + entry.minutes, 0);
    return { entries, totalMinutes };
  }

  function renderGanttSnapshot(plan) {
    ganttPlanState = plan;
    const container = $("ganttBlocks");
    const status = $("ganttStatus");
    if (container) {
      container.innerHTML = "";
      if (!plan.entries.length) {
        const empty = document.createElement("div");
        empty.className = "score";
        empty.textContent = "Add a task to see your next blocks.";
        container.appendChild(empty);
      } else {
        plan.entries.forEach((entry, index) => {
          const block = document.createElement("div");
          block.className = "gantt-block";
          block.style.flex = String(Math.max(1, entry.minutes));
          const title = document.createElement("strong");
          title.textContent = entry.task.name || "Task";
          const detail = document.createElement("small");
          const startOffset = plan.entries.slice(0, index).reduce((sum, current) => sum + current.minutes, 0);
          const start = new Date(Date.now() + startOffset * 60000);
          detail.textContent = `${entry.minutes} min ‚Ä¢ starts ${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
          block.appendChild(title);
          block.appendChild(detail);
          container.appendChild(block);
        });
      }
    }
    if (status) {
      status.textContent = plan.entries.length
        ? `Covers ${plan.totalMinutes} min. Playlist progress will sweep across.`
        : "";
    }
  }

    function updateGanttOverlayProgress() {
    const bar = $("ganttProgressBar");
    const status = $("ganttStatus");
    if (!bar || !ganttPlanState) return;
    const total = ganttPlanState.totalMinutes || 0;
    if (!ganttOverlayStartTime || total <= 0) {
      bar.style.width = "0%";
      bar.classList.add("is-paused");
      if (status && status.textContent === "") {
        status.textContent = "Hit play on the playlist to animate your time.";
      }
      return;
    }
    if (!dopamineState || !dopamineState.active) {
      bar.classList.add("is-paused");
      if (status) {
        status.textContent = "Playlist paused ‚Äî progress holds until you press play.";
      }
      return;
    }
    bar.classList.remove("is-paused");
    const elapsed = Math.max(0, Date.now() - ganttOverlayStartTime);
    const ratio = Math.min(1, elapsed / (total * 60000));
    bar.style.width = `${Math.round(ratio * 100)}%`;
    if (status) {
      status.textContent = `Playlist pacing ${Math.round(ratio * 100)}% of this snapshot.`;
    }
  }

    function openGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    updateGanttOverlayProgress();
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
    }
    ganttProgressIntervalId = setInterval(updateGanttOverlayProgress, 1000);
  }

    function closeGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
      ganttProgressIntervalId = null;
    }
    ganttOverlayStartTime = null;
  }

    function refreshGanttSnapshotIfOpen() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    updateGanttOverlayProgress();
  }

    function initializeGanttSnapshot() {
    const trigger = $("ganttSnapshotAction");
    if (trigger) {
      trigger.addEventListener("click", openGanttSnapshot);
    }
    const closeBtn = $("ganttCloseButton");
    if (closeBtn) {
      closeBtn.addEventListener("click", closeGanttSnapshot);
    }
    const overlay = $("ganttSnapshotOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeGanttSnapshot();
        }
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        closeGanttSnapshot();
      }
    });
  }

  function setAddTaskCardCollapsed(collapsed, options = {}) {
    const overlay = $("addTaskOverlay");
    const body = $("addTaskCardBody");
    if (!overlay || !body) return;
    const { skipFocus = false, skipPersist = false, focusTarget = null } = options;
    const open = !collapsed;
    overlay.classList.toggle("hidden", collapsed);
    overlay.setAttribute("aria-hidden", collapsed ? "true" : "false");
    if (!skipPersist) {
      localStorage.setItem(ADD_TASK_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
    if (!open) {
      return;
    }
    window.setTimeout(() => {
      if (skipFocus) return;
      if (focusTarget === "dueDate") {
        if (!focusDueDateField()) {
          focusFirstEditableField();
        }
        return;
      }
      focusFirstEditableField();
    }, 120);
  }

  function toggleAddTaskCard() {
    const overlay = $("addTaskOverlay");
    const collapsed = !overlay || overlay.classList.contains("hidden") ? true : false;
    setAddTaskCardCollapsed(!collapsed);
  }

  function initializeAddTaskCardState() {
    let stored = localStorage.getItem(ADD_TASK_CARD_STATE_KEY);
    if (!stored) {
      const legacy = localStorage.getItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      if (legacy) {
        stored = legacy;
        localStorage.setItem(ADD_TASK_CARD_STATE_KEY, legacy);
        localStorage.removeItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      }
    }
    const collapsed = stored ? stored !== "expanded" : true;
    setAddTaskCardCollapsed(collapsed, { skipFocus: true, skipPersist: true });
  }


  function getAllTasksCards() {
    return Array.from(document.querySelectorAll('[data-all-tasks-card]')).map(card => {
      const panel = card.querySelector('[data-all-tasks-panel]') || null;
      const title = card.querySelector('[data-all-tasks-title]') || null;
      const categoryLabel = card.querySelector('[data-all-tasks-category]') || null;
      const divider = card.querySelector('[data-all-tasks-divider]') || null;
      const summaryText = card.querySelector('[data-all-tasks-summary-text]') || null;
      const heading = card.querySelector('[data-all-tasks-heading]') || null;
      const toggle = card.querySelector('[data-all-tasks-toggle]') || heading || null;
      return { card, panel, title, categoryLabel, divider, summaryText, heading, toggle };
    });
  }

  function initializeAllTasksCardState() {
    const cards = getAllTasksCards();
    if (!cards.length) return;
    const hasStandaloneScreen = cards.some(({ card }) => card?.closest('[data-all-tasks-screen]'));
    cards.forEach(({ toggle, card }) => {
      if (!toggle) return;
      toggle.addEventListener("click", () => {
        const expanded = toggle.getAttribute("aria-expanded") === "true";
        setAllTasksAccordionOpen(!expanded, { source: card });
      });
    });
    if (hasStandaloneScreen) {
      setAllTasksAccordionOpen(true, { skipPersist: true, skipSync: true });
      return;
    }
    let storedState = null;
    try {
      storedState = localStorage.getItem(ALL_TASKS_CARD_STATE_KEY);
    } catch (error) {
      console.warn("Unable to access stored All Tasks state", error);
    }
    const shouldOpen = storedState ? storedState === "expanded" : false;
    setAllTasksAccordionOpen(shouldOpen, { skipPersist: true, skipSync: true });
  }

  function focusFirstEditableField() {
    const nameField = $("name");
    if (nameField) {
      window.requestAnimationFrame(() => {
        nameField.focus();
        if (typeof nameField.select === "function") {
          nameField.select();
        }
      });
    }
  }

  function focusDueDateField() {
    const dueField = $("dueDate");
    if (dueField) {
      window.requestAnimationFrame(() => dueField.focus());
      return true;
    }
    const serviceField = $("dateOfService");
    if (serviceField) {
      window.requestAnimationFrame(() => serviceField.focus());
      return true;
    }
    return false;
  }

  function scrollCardHeaderIntoView(card) {
    if (!card) return;
    const target = card.querySelector(".card-head") || card;
    window.requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const offset = Math.max(0, window.scrollY + rect.top - 24);
      window.scrollTo({ top: offset, behavior: "smooth" });
    });
  }

  function handleTemplateModalKeydown(event) {
    if (event.key === "Escape") {
      closeTemplateModal();
    }
  }

  function closeTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    document.removeEventListener("keydown", handleTemplateModalKeydown);
    if (lastFocusedBeforeTemplateModal && typeof lastFocusedBeforeTemplateModal.focus === "function") {
      lastFocusedBeforeTemplateModal.focus();
    }
    lastFocusedBeforeTemplateModal = null;
  }

  function renderTemplateCards(list) {
    const grid = $("template-grid");
    if (!grid) return;
    grid.innerHTML = "";
    if (!list || !list.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      grid.appendChild(empty);
      return;
    }
    list.forEach(template => {
      const card = document.createElement("div");
      card.className = "template-card";
      const title = document.createElement("strong");
      title.textContent = template.name;
      card.appendChild(title);
      const meta = document.createElement("p");
      meta.className = "score";
      const categoryLabel = template.category || "General";
      meta.textContent = `Category: ${categoryLabel}`;
      card.appendChild(meta);
      const stats = document.createElement("p");
      stats.className = "score";
      stats.textContent = `Imp ${template.importance || 1} ‚Ä¢ Urg ${template.urgency || 3} ‚Ä¢ Diff ${template.difficulty || 3}`;
      card.appendChild(stats);
      const applyBtn = document.createElement("button");
      applyBtn.type = "button";
      applyBtn.className = "btn btn-primary";
      applyBtn.textContent = "Apply";
      applyBtn.addEventListener("click", () => applyTemplate(template));
      card.appendChild(applyBtn);
      grid.appendChild(card);
    });
  }

  function openTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    lastFocusedBeforeTemplateModal = document.activeElement;
    const category = $("taskCategory")?.value || "General";
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    document.addEventListener("keydown", handleTemplateModalKeydown);
    const firstButton = modal.querySelector(".template-card button") || modal.querySelector(".modal__close");
    if (firstButton) {
      firstButton.focus();
    }
  }

  function fillTaskFormFromTemplate(template, options = {}) {
    if (!template) return;
    $("name").value = template.name || "";
    const keepCurrent = Boolean(options.keepCurrentCategory);
    const categoryField = $("taskCategory");
    const currentCategory = categoryField ? (categoryField.value || "General") : "General";
    const category = keepCurrent ? currentCategory : (template.category || currentCategory);
    if (categoryField) {
      categoryField.value = category;
    }
    handleCategoryChange(category);
    $("importance").value = String(template.importance || 1);
    $("novelty").value = String(template.novelty || 1);
    $("interest").value = String(template.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = template.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(template.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(template.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(template.clinicSite);
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = String(template.urgency || 3);
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = String(template.externalPressure || 1);
    $("timeToStart").value = String(template.timeToStart || 1);
    $("difficulty").value = String(template.difficulty || 1);
    const dateField = $("dateOfService");
    if (dateField) dateField.value = formatDateForInput(new Date());
    urgencyAuto = false;
    updateDerivedFields();
  }

  function applyTemplate(template) {
    fillTaskFormFromTemplate(template, { keepCurrentCategory: true });
    setTaskDetailsCollapsed(false);
    setAddTaskCardCollapsed(false, { focusTarget: "dueDate" });
    closeTemplateModal();
  }

  function updateTemplateModalForCategory(category) {
    const modal = $("template-modal");
    if (!modal || modal.classList.contains("hidden")) return;
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
  }

  function setTaskDetailsCollapsed(collapsed) {
    const panel = $("taskDetails");
    const button = $("expandTaskDetailsButton");
    if (!panel || !button) return;
    panel.dataset.collapsed = collapsed ? "true" : "false";
    button.textContent = collapsed ? "Show details" : "Hide details";
    button.setAttribute("aria-expanded", collapsed ? "false" : "true");
    panel.setAttribute("aria-hidden", collapsed ? "true" : "false");
  }

  function toggleTaskDetails() {
    const panel = $("taskDetails");
    if (!panel) return;
    const collapsed = panel.dataset.collapsed !== "false";
    setTaskDetailsCollapsed(!collapsed);
  }

  function syncAddTaskActions() {
    const nameField = $("name");
    const addBtn = $("addTaskBtn");
    const startBtn = $("startBtn");
    if (!nameField || !addBtn || !startBtn) return;
    const hasName = Boolean(nameField.value.trim());
    const hasTasks = startBtn.dataset.hasTasks === "true";
    addBtn.classList.toggle("btn-primary", !hasName);
    addBtn.classList.toggle("btn-quiet", hasName);
    startBtn.classList.toggle("hero-cta", hasName);
    startBtn.classList.toggle("btn-secondary", !hasName);
    startBtn.disabled = !hasName && !hasTasks;
  }


  let allTasksAccordionOpen = true;

  function setAllTasksAccordionOpen(open, options = {}) {
    const { skipPersist = false, highlight = false, skipSync = false, source = null } = options;
    const cards = getAllTasksCards();
    if (!cards.length) return;
    const previousState = allTasksAccordionOpen;
    allTasksAccordionOpen = Boolean(open);
    cards.forEach(({ panel, card, toggle }) => {
      if (panel) {
        panel.hidden = !allTasksAccordionOpen;
        panel.setAttribute("aria-hidden", allTasksAccordionOpen ? "false" : "true");
        if (highlight && allTasksAccordionOpen && (!source || source === card || source === panel)) {
          panel.classList.add("is-highlighted");
          window.setTimeout(() => panel.classList.remove("is-highlighted"), 600);
        }
      }
      if (toggle) {
        toggle.setAttribute("aria-expanded", allTasksAccordionOpen ? "true" : "false");
        toggle.classList.toggle("is-open", allTasksAccordionOpen);
      }
      if (card) {
        card.classList.toggle("is-collapsed", !allTasksAccordionOpen);
        card.classList.toggle("is-open", allTasksAccordionOpen);
        if (highlight && allTasksAccordionOpen && (!source || source === card)) {
          card.classList.add("is-highlighted");
          window.setTimeout(() => card.classList.remove("is-highlighted"), 600);
        }
      }
    });
    if (allTasksAccordionOpen && !skipSync) {
      setDueTodayAccordionOpen(false, { skipSync: true });
    }
    if (!skipPersist) {
      try {
        localStorage.setItem(ALL_TASKS_CARD_STATE_KEY, allTasksAccordionOpen ? "expanded" : "collapsed");
      } catch (error) {
        console.warn("Unable to persist All Tasks state", error);
      }
    }
    if (previousState !== allTasksAccordionOpen) {
      if (allTasksAccordionOpen) {
        readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
        readyToLaunchRevealBaseline = 0;
        updateUI();
      } else {
        resetReadyToLaunchVisibility();
      }
    }
  }

  function handleAllTasksOverlayKeydown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      closeAllTasksOverlay();
    }
  }

  function openAllTasksOverlay() {
  const overlay = document.getElementById("allTasksOverlay");
  const trigger = document.getElementById("openAllTasksButton");

  if (!overlay || !overlay.classList.contains("hidden")) return;

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  document.body.classList.add("all-tasks-overlay-active");

  if (trigger) {
    trigger.setAttribute("aria-expanded", "true");
    trigger.classList.add("is-active");
  }

  const sheet = overlay.querySelector(".all-tasks-overlay__sheet");
  if (sheet && typeof sheet.focus === "function") sheet.focus();
}

function closeAllTasksOverlay() {
  const overlay = document.getElementById("allTasksOverlay");
  const trigger = document.getElementById("openAllTasksButton");

  if (!overlay || overlay.classList.contains("hidden")) return;

  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden", "true");
  document.body.classList.remove("all-tasks-overlay-active");

  if (trigger) {
    trigger.setAttribute("aria-expanded", "false");
    trigger.classList.remove("is-active");
    trigger.focus();
  }
}

document.getElementById("openAllTasksButton").addEventListener("click", openAllTasksOverlay);
document.getElementById("closeAllTasksOverlay").addEventListener("click", closeAllTasksOverlay);

  function closeAllTasksOverlay({ restoreFocus = true } = {}) {
    const overlay = $("allTasksOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    document.body.classList.remove("all-tasks-overlay-active");
    const trigger = $("openAllTasksButton");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "false");
      trigger.classList.remove("is-active");
      trigger.removeAttribute("aria-current");
    }
    document.removeEventListener("keydown", handleAllTasksOverlayKeydown);
    if (restoreFocus) {
      const focusTarget = (lastFocusedBeforeAllTasksOverlay && typeof lastFocusedBeforeAllTasksOverlay.focus === "function")
        ? lastFocusedBeforeAllTasksOverlay
        : trigger;
      if (focusTarget && typeof focusTarget.focus === "function") {
        window.requestAnimationFrame(() => focusTarget.focus());
      }
    }
    lastFocusedBeforeAllTasksOverlay = null;
  }

  function initializeAllTasksOverlay() {
    const overlay = $("allTasksOverlay");
    const trigger = $("openAllTasksButton");
    if (!overlay || !trigger) return;
    const closeButton = overlay.querySelector("[data-all-tasks-close]");
    const backdrop = overlay.querySelector("[data-all-tasks-dismiss]");
    trigger.addEventListener("click", () => {
      if (overlay.classList.contains("hidden")) {
        openAllTasksOverlay();
      } else {
        closeAllTasksOverlay();
      }
    });
    if (closeButton) {
      closeButton.addEventListener("click", () => closeAllTasksOverlay());
    }
    if (backdrop) {
      backdrop.addEventListener("click", () => closeAllTasksOverlay());
    }
  }

  function setModuleOpenState(module, body, open, header = null) {
    if (!module || !body) return;
    module.classList.toggle("is-open", open);
    body.hidden = !open;
    if (header) {
      header.setAttribute("aria-expanded", open ? "true" : "false");
    }
    body.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function openModuleById(id) {
    const routineDef = getRoutineDefinition(id) || ROUTINE_DEFINITIONS.find(def => def.moduleId === id);
    if (routineDef) {
      openRoutineTile(routineDef.id, { scrollIntoView: true });
      return;
    }
    const module = $(id);
    if (!module) return;
    const body = module.querySelector(".module-body");
    const header = module.querySelector(".module-header");
    if (!body) return;
    setModuleOpenState(module, body, true, header);
    localStorage.setItem(`${MODULE_STATE_PREFIX}${id}`, "open");
  }

  function initializeCollapsibleModules() {
    initializeRoutineTiles();
  }

  function getMostMeaningfulTask() {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const scored = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({ task, score: computeFocusScore(task, energyLevel, timeBudget) }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    return scored.length ? scored[0].task : null;
  }

  function getHighestPriorityTask() {
    const candidates = tasks.filter(task => !isTaskCompleted(task));
    if (!candidates.length) return null;
    return candidates.reduce((best, task) => {
      const bestScore = Number(best?.priority) || 0;
      const taskScore = Number(task?.priority) || 0;
      if (!best || taskScore > bestScore) {
        return task;
      }
      return best;
    }, null);
  }

  function updateWorstDayBanner() {
    const button = $("worstDayButton");
    const hint = $("worstDayHint");
    const focusTask = getMostMeaningfulTask();
    const hasTask = Boolean(focusTask);
    if (button) {
      button.disabled = !hasTask;
      button.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    const focusFab = $("startFocusFab");
    if (focusFab) {
      focusFab.disabled = !hasTask;
      focusFab.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    if (hint) {
      hint.textContent = hasTask ? `Most meaningful project: ${focusTask.name}` : "Add a task to unlock Worst-Day Mode.";
    }
  }

    function startWorstDayMode() {
    if (worstDayState.active) return;
    const overlay = $("worstDayOverlay");
    const focusLine = $("worstDayFocus");
    const prompt = $("worstDayPrompt");
    const timerEl = $("worstDayTimer");
    const actions = $("worstDayActions");
    const celebration = $("worstDayCelebration");
    const focusTask = getMostMeaningfulTask();
    if (!overlay || !focusTask) {
      showToast("Worst-Day Mode", "Add a task to give yourself something kind to focus on.");
      return;
    }
    const chunk = deriveMmpChunk(focusTask) || { label: focusTask.name, minutes: 5, subId: null };
    worstDayState = {
      active: true,
      countdownId: null,
      endTime: Date.now() + WORST_DAY_DURATION_MS,
      task: focusTask,
      chunk
    };
    if (focusLine) {
      focusLine.textContent = chunk.label || focusTask.name;
    }
    if (prompt) {
      prompt.textContent = "Move gently. Drift happens ‚Äî we'll reset together.";
    }
    if (timerEl) {
      timerEl.textContent = "05:00";
    }
    if (actions) {
      actions.classList.add("hidden");
    }
    if (celebration) {
      celebration.textContent = "";
    }
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = setInterval(updateWorstDayTimer, 250);
    updateWorstDayTimer();
  }

    function updateWorstDayTimer() {
    if (!worstDayState.active) return;
    const timerEl = $("worstDayTimer");
    const prompt = $("worstDayPrompt");
    if (!timerEl) return;
    const remaining = Math.max(0, worstDayState.endTime - Date.now());
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    if (remaining <= 0) {
      completeWorstDaySprint();
      if (prompt) {
        prompt.textContent = "You stayed. Pick a gentle reward.";
      }
    }
  }

    function completeWorstDaySprint() {
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = null;
    worstDayState.active = false;
    worstDayState.endTime = null;
    const actions = $("worstDayActions");
    if (actions) {
      actions.classList.remove("hidden");
    }
    const celebration = $("worstDayCelebration");
    if (celebration) {
      celebration.textContent = "";
    }
  }

    function handleWorstDayChoice(choice) {
    const celebration = $("worstDayCelebration");
    if (choice === "laugh") {
      const line = WORST_DAY_LAUGHS[Math.floor(Math.random() * WORST_DAY_LAUGHS.length)] || "You showed up.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stretch") {
      const line = WORST_DAY_STRETCHES[Math.floor(Math.random() * WORST_DAY_STRETCHES.length)] || "Shoulder rolls, deep breath.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stop") {
      stopWorstDayMode({ celebrate: true });
    }
  }

    function stopWorstDayMode(options = {}) {
    const overlay = $("worstDayOverlay");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
    if (overlay) {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
    if (options.celebrate) {
      showToast("Worst-Day Mode", "Five minutes banked. That counts.");
    }
    updateWorstDayBanner();
  }

    function initializeWorstDayMode() {
    const button = $("worstDayButton");
    if (button) {
      button.addEventListener("click", startWorstDayMode);
    }
    const overlay = $("worstDayOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          stopWorstDayMode();
        }
      });
    }
    const closeBtn = $("worstDayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const exitBtn = $("worstDayExit");
    if (exitBtn) {
      exitBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const actions = $("worstDayActions");
    if (actions) {
      actions.addEventListener("click", event => {
        const buttonEl = event.target.closest('[data-worst-day-choice]');
        if (!buttonEl) return;
        handleWorstDayChoice(buttonEl.getAttribute('data-worst-day-choice'));
      });
    }
    updateWorstDayBanner();
  }

  function startFiveMinuteSprint(taskId = null) {
    setTaskDetailsCollapsed(false);
    const targetId = taskId || nextTaskId || null;
    startFocus(targetId, { sprintMinutes: 5 });
  }

  function extendSprintBy(minutes) {
    const extraMinutes = Number(minutes);
    if (!Number.isFinite(extraMinutes) || extraMinutes <= 0) return;
    const extraMs = extraMinutes * 60000;
    const now = Date.now();
    if (focusTimerStart === null) {
      startFocus(nextTaskId, { sprintMinutes: extraMinutes });
      return;
    }
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0 || !sprintEndTime) {
      const elapsed = Math.max(0, now - focusTimerStart);
      sprintDurationMinutes = Math.max(extraMinutes, (elapsed + extraMs) / 60000);
      sprintEndTime = now + extraMs;
      setSprintVisualState(true);
    } else {
      sprintEndTime += extraMs;
      const total = Math.max(sprintEndTime - focusTimerStart, extraMs);
      sprintDurationMinutes = Math.max(sprintDurationMinutes, total / 60000);
    }
    const remaining = Math.max(0, sprintEndTime - now);
    const totalDuration = Math.max(remaining, sprintDurationMinutes * 60000);
    setFocusProgress(totalDuration > 0 ? ((totalDuration - remaining) / totalDuration) * 100 : 0);
    showToast("Focus cocoon", `Sprint extended by ${extraMinutes} minute${extraMinutes === 1 ? "" : "s"}.`);
  }

  function quickAddTask(nameOverride = null) {
    const provided = typeof nameOverride === "string" ? nameOverride : prompt("Quick add task");
    if (!provided) return;
    const name = provided.trim();
    if (!name) return;
    const nowIso = new Date().toISOString();
    const task = {
      id: Date.now().toString(),
      name,
      category: QUICK_TASK_CATEGORY,
      authorType: "attending",
      patientType: "Non-Complex",
      visitType: "Follow-Up",
      clinicSite: "General Clinic",
      dateOfService: null,
      daysSinceVisit: null,
      importance: 1,
      urgency: 1,
      novelty: 1,
      interest: 1,
      externalPressure: 1,
      timeToStart: 1,
      difficulty: 1,
      dueDate: null,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: false
    };
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    showTaskAddedConfirmation();
    persist();
    setTaskDetailsCollapsed(true);
    updateUI();
  }

  let quickCaptureKeydownHandler = null;

  function openQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const input = $("quickCaptureInput");
    if (input) {
      input.value = "";
      window.requestAnimationFrame(() => input.focus());
    }
    quickCaptureKeydownHandler = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeQuickCaptureModal();
      }
      if (event.key === "Enter" && event.target === input) {
        event.preventDefault();
        handleQuickCaptureSubmit();
      }
    };
    document.addEventListener("keydown", quickCaptureKeydownHandler);
  }

  function closeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (quickCaptureKeydownHandler) {
      document.removeEventListener("keydown", quickCaptureKeydownHandler);
      quickCaptureKeydownHandler = null;
    }
    const trigger = $("nextTaskActionButton");
    if (trigger) {
      window.requestAnimationFrame(() => trigger.focus());
    }
  }

  function handleQuickCaptureSubmit() {
    const input = $("quickCaptureInput");
    if (!input) return;
    const value = input.value.trim();
    if (!value) {
      input.focus();
      return;
    }
    quickAddTask(value);
    closeQuickCaptureModal();
  }

  function initializeFocusLaunchSheet() {
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    const handle = $("focusLaunchHandle");
    const suggestionBtn = $("focusSuggestionButton");
    const options = sheet ? sheet.querySelector(".focus-sheet__options") : null;
    const labelMap = { now: "Do now", easy: "Do if easy", buddy: "Do with buddy" };
    const nextTaskAction = $("nextTaskActionButton");

    const activatePick = pickKey => {
      if (!pickKey) return false;
      const evaluation = latestNextBestPicks[pickKey];
      if (!evaluation) return false;
      launchNextBestOption(labelMap[pickKey] || "Start", evaluation);
      return true;
    };

    if (nextTaskAction) {
      const LONG_PRESS_MS = 650;
      let longPressTriggered = false;
      let pressTimer = null;

      const clearPressTimer = () => {
        if (pressTimer) {
          window.clearTimeout(pressTimer);
          pressTimer = null;
        }
      };

      const handlePointerEnd = () => {
        if (longPressTriggered) {
          window.setTimeout(() => nextTaskAction.classList.remove("is-long-press"), 220);
        }
        clearPressTimer();
      };

      nextTaskAction.addEventListener("pointerdown", event => {
        if (event.button !== 0) return;
        clearPressTimer();
        longPressTriggered = false;
        pressTimer = window.setTimeout(() => {
          longPressTriggered = true;
          nextTaskAction.classList.add("is-long-press");
          openQuickCaptureModal();
        }, LONG_PRESS_MS);
      });

      nextTaskAction.addEventListener("pointerup", handlePointerEnd);
      nextTaskAction.addEventListener("pointerleave", handlePointerEnd);
      nextTaskAction.addEventListener("pointercancel", handlePointerEnd);

      nextTaskAction.addEventListener("click", event => {
        if (longPressTriggered) {
          event.preventDefault();
          longPressTriggered = false;
          return;
        }
        startFiveMinuteSprint(nextTaskId);
      });
    }

    if (fab) {
      fab.addEventListener("click", event => {
        event.preventDefault();
        if (fab.disabled) return;
        setFocusLaunchOpen(!focusLaunchOpen);
      });
    }

    if (handle) {
      handle.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (backdrop) {
      backdrop.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (options) {
      options.addEventListener("click", event => {
        const button = event.target.closest(".focus-sheet__option");
        if (!button || button.disabled || button.getAttribute("aria-disabled") === "true") return;
        const mode = button.getAttribute("data-focus-mode");
        setFocusLaunchOpen(false);
        if (mode === "sprint") {
          if (!activatePick("now")) {
            startFiveMinuteSprint(nextTaskId);
          }
          return;
        }
        if (mode === "session") {
          if (!activatePick("easy")) {
            const fallbackId = latestNextBestPicks.now?.task?.id || nextTaskId;
            if (fallbackId) {
              startFocus(fallbackId);
            } else {
              startFocus();
            }
          }
          return;
        }
        if (mode === "suggestion") {
          const pickKey = button.dataset.pickKey || "now";
          if (!activatePick(pickKey)) {
            startFiveMinuteSprint(nextTaskId);
          }
        }
      });
    }

    if (suggestionBtn) {
      suggestionBtn.addEventListener("click", () => {
        const pickKey = suggestionBtn.dataset.pickKey;
        setFocusLaunchOpen(false);
        if (!activatePick(pickKey)) {
          startFiveMinuteSprint(nextTaskId);
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && focusLaunchOpen) {
        setFocusLaunchOpen(false);
      }
    });
  }

  function openDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function initializeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    const cancelBtn = $("quickCaptureCancel");
    const saveBtn = $("quickCaptureSave");
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeQuickCaptureModal();
      }
    });
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => closeQuickCaptureModal());
    }
    if (saveBtn) {
      saveBtn.addEventListener("click", () => handleQuickCaptureSubmit());
    }
  }

  function closeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (lastDefuseOpener) {
      lastDefuseOpener.focus();
      lastDefuseOpener = null;
    }
  }

  function initializeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeDefuseOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeDefuseOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeDefuseOverlay();
      }
    });
  }

  function openTemplatesOverlay(trigger = null) {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    lastTemplatesOpener = trigger || document.activeElement;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("templatesOverlayClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function closeTemplatesOverlay({ restoreFocus = true } = {}) {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (restoreFocus && lastTemplatesOpener) {
      const target = lastTemplatesOpener;
      lastTemplatesOpener = null;
      window.requestAnimationFrame(() => target?.focus?.());
    } else {
      lastTemplatesOpener = null;
    }
  }

  function initializeTemplatesOverlay() {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    const closeBtn = $("templatesOverlayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeTemplatesOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeTemplatesOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeTemplatesOverlay();
      }
    });
  }

  function openConflictOverlay(trigger = null) {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    lastConflictOpener = trigger || document.activeElement;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("conflictOverlayClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function closeConflictOverlay({ restoreFocus = true } = {}) {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (restoreFocus && lastConflictOpener) {
      const target = lastConflictOpener;
      lastConflictOpener = null;
      window.requestAnimationFrame(() => target?.focus?.());
    } else {
      lastConflictOpener = null;
    }
  }

  function initializeConflictOverlay() {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    const closeBtn = $("conflictOverlayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeConflictOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeConflictOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeConflictOverlay();
      }
    });
  }

  function initializeSettingsMenu() {
    const toggle = $("settingsToggle");
    const menu = $("settingsMenu");
    if (!toggle || !menu) return;

    let open = false;

    const setOpen = value => {
      open = Boolean(value);
      menu.classList.toggle("is-open", open);
      menu.setAttribute("aria-hidden", open ? "false" : "true");
      toggle.setAttribute("aria-expanded", open ? "true" : "false");
    };

    setOpen(false);

    const closeMenu = () => setOpen(false);

    toggle.addEventListener("click", () => {
      setOpen(!open);
    });

    document.addEventListener("click", event => {
      if (!open) return;
      if (event.target === toggle || toggle.contains(event.target)) return;
      if (menu.contains(event.target)) return;
      closeMenu();
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && open) {
        event.stopPropagation();
        closeMenu();
        toggle.focus();
      }
    });

    const templatesBtn = $("settingsTemplates");
    if (templatesBtn) {
      templatesBtn.addEventListener("click", () => {
        closeMenu();
        openTemplatesOverlay(templatesBtn);
      });
    }
  }

  function initializeResourcesDrawer() {
    const toggle = $("resourcesToggle");
    const drawer = $("resourcesDrawer");
    const closeBtn = $("resourcesClose");
    const backdrop = $("resourcesBackdrop");
    if (!toggle || !drawer || !backdrop) return;

    let drawerOpen = false;
    const setDrawerOpen = open => {
      drawerOpen = Boolean(open);
      drawer.classList.toggle("is-open", drawerOpen);
      drawer.setAttribute("aria-hidden", drawerOpen ? "false" : "true");
      if (drawerOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
        drawer.focus();
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!drawerOpen) {
            backdrop.hidden = true;
          }
        }, 200);
        toggle.focus();
      }
    };

    toggle.addEventListener("click", () => setDrawerOpen(true));
    if (closeBtn) {
      closeBtn.addEventListener("click", () => setDrawerOpen(false));
    }
    backdrop.addEventListener("click", () => setDrawerOpen(false));
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && drawerOpen) {
        setDrawerOpen(false);
      }
    });
  }

  function initializeSosPanel() {
    const overlay = $("sosOverlay");
    const closeBtn = $("sosOverlayClose");
    const shieldBtn = $("sosShield");
    const defuseBtn = $("sosDefuse");
    const conflictBtn = $("sosConflict");
    const worstDayBtn = $("worstDayButton");
    const triggers = ["rescueLaunchButton", "meltdownSosButton"].map(id => $(id)).filter(Boolean);
    if (!triggers.length || !overlay) return;

    let sosOpen = false;
    let activeTrigger = null;

    const updateTriggerExpanded = () => {
      triggers.forEach(trigger => {
        trigger.setAttribute("aria-expanded", sosOpen && trigger === activeTrigger ? "true" : "false");
      });
    };

    updateTriggerExpanded();

    const setSosOpen = (open, { restoreFocus = true, focusTarget = null } = {}) => {
      sosOpen = Boolean(open);
      updateTriggerExpanded();
      if (sosOpen) {
        overlay.classList.remove("hidden");
        overlay.setAttribute("aria-hidden", "false");
        if (closeBtn) {
          closeBtn.focus();
        }
        lastSosTrigger = activeTrigger || triggers[0] || null;
      } else {
        overlay.classList.add("hidden");
        overlay.setAttribute("aria-hidden", "true");
        if (restoreFocus) {
          const target = focusTarget || activeTrigger || lastSosTrigger || triggers[0] || null;
          if (target) {
            window.requestAnimationFrame(() => target.focus());
          }
        }
      }
    };

    triggers.forEach(trigger => {
      trigger.addEventListener("click", () => {
        activeTrigger = trigger;
        lastSosTrigger = trigger;
        setSosOpen(true);
      });
    });

    if (closeBtn) {
      closeBtn.addEventListener("click", () => setSosOpen(false));
    }

    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        setSosOpen(false);
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && sosOpen) {
        setSosOpen(false);
      }
    });

    if (shieldBtn) {
      shieldBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        activateShield();
      });
    }

    if (defuseBtn) {
      defuseBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        lastDefuseOpener = activeTrigger || lastSosTrigger || triggers[0] || null;
        openDefuseOverlay();
      });
    }

    if (conflictBtn) {
      conflictBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        openConflictOverlay(conflictBtn);
      });
    }

    if (worstDayBtn) {
      worstDayBtn.addEventListener("click", () => setSosOpen(false, { restoreFocus: false }));
    }
  }

  function initializeCommandBarAutohide() {
    const bar = document.querySelector(".command-bar");
    if (!bar) return;
    let lastScrollY = window.scrollY || 0;
    let rafId = null;
    let hidden = false;

    const evaluate = () => {
      rafId = null;
      const currentY = window.scrollY || 0;
      const delta = currentY - lastScrollY;
      const hide = currentY > 96 && delta > 6;
      const reveal = delta < -6 || currentY <= 96;
      if (hide && !hidden) {
        bar.classList.add("is-hidden");
        hidden = true;
      } else if (reveal && hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = currentY;
    };

    window.addEventListener(
      "scroll",
      () => {
        if (rafId !== null) return;
        rafId = window.requestAnimationFrame(evaluate);
      },
      { passive: true }
    );

    window.addEventListener("focusin", () => {
      if (hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = window.scrollY || 0;
    });
  }

  function initializeTaskForm() {
    setTaskDetailsCollapsed(true);
    const expandBtn = $("expandTaskDetailsButton");
    if (expandBtn) {
      expandBtn.addEventListener("click", toggleTaskDetails);
    }
    const templateBtn = $("btn-use-template");
    if (templateBtn) {
      templateBtn.addEventListener("click", () => {
        setAddTaskCardCollapsed(false, { skipFocus: true });
        openTemplateModal();
      });
    }
    const saveTemplateBtn = $("btn-save-template");
    if (saveTemplateBtn) {
      saveTemplateBtn.addEventListener("click", () => saveAsTemplate());
    }
    const openCardBtn = $("openAddTaskPanel");
    if (openCardBtn) {
      openCardBtn.addEventListener("click", () => setAddTaskCardCollapsed(false));
    }
    const closeBtn = $("addTaskClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => setAddTaskCardCollapsed(true));
    }
    const overlay = $("addTaskOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
      document.addEventListener("keydown", event => {
        if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
    }
    const modal = $("template-modal");
    if (modal) {
      modal.addEventListener("click", event => {
        if (event.target === modal) {
          closeTemplateModal();
        }
      });
      const closeBtn = modal.querySelector(".modal__close");
      if (closeBtn) {
        closeBtn.addEventListener("click", closeTemplateModal);
      }
    }
    syncAddTaskActions();
    const nameInput = $("name");
    if (nameInput) {
      nameInput.addEventListener("input", syncAddTaskActions);
    }
  }

  function initializeQuickAddMenu() {
    const plusBtn = document.querySelector(".quick-add-button--plus");
    if (plusBtn) {
      plusBtn.addEventListener("click", () => {
        cancelEdit();
        setAddTaskCardCollapsed(false);
        syncAddTaskActions();
      });
    }
    const quickTemplateBtn = document.querySelector(".quick-add-button--cherry");
    if (quickTemplateBtn) {
      quickTemplateBtn.addEventListener("click", () => {
        cancelEdit();
        const categoryField = $("taskCategory");
        if (categoryField) {
          categoryField.value = QUICK_TASK_CATEGORY;
        }
        handleCategoryChange(QUICK_TASK_CATEGORY);
        setAddTaskCardCollapsed(false, { skipFocus: true });
        const nameField = $("name");
        if (nameField) {
          nameField.value = "";
          window.requestAnimationFrame(() => {
            nameField.focus();
            if (typeof nameField.select === "function") {
              nameField.select();
            }
          });
        }
        syncAddTaskActions();
      });
    }
  }

  function initializeQuickTaskShortcut() {
    const shortcut = $("quickTaskShortcut");
    if (!shortcut) return;
    shortcut.addEventListener("click", () => {
      const card = document.querySelector("[data-quick-tasks-card]");
      if (!card) return;
      scrollCardHeaderIntoView(card);
      card.classList.add("is-highlighted");
      window.setTimeout(() => card.classList.remove("is-highlighted"), 650);
    });
  }

  function initializeShredTopTaskButton() {
    const button = $("shredTopTaskButton");
    if (!button) return;
    button.addEventListener("click", () => {
      const topTask = getHighestPriorityTask();
      if (!topTask) {
        showToast("Shred Top Task", "No active tasks to shred right now.");
        return;
      }
      startFocus(topTask.id);
      window.setTimeout(() => {
        const completeBtn = $("focusCompleteButton");
        if (completeBtn) {
          completeBtn.focus();
        }
      }, 260);
      showToast("Shred Top Task", `Ready to complete: ${topTask.name}`);
    });
  }
// === START: Long-press Quick Capture from Focus button ===
function initializeFocusFabLongPress() {
  const fab = document.getElementById("nextTaskActionButton");
  if (!fab) return;

  const LONG_PRESS_MS = 600;
  let timer = null;

  fab.addEventListener("pointerdown", () => {
    timer = setTimeout(() => {
      // open your Quick Capture modal
      openModal();
    }, LONG_PRESS_MS);
  });

  ["pointerup", "pointerleave", "pointercancel"].forEach(type =>
    fab.addEventListener(type, () => clearTimeout(timer))
  );
}

// Call this once at startup
initializeFocusFabLongPress();
// === END: Long-press Quick Capture from Focus button ===
    
  // main UI update
  function updateUI() {
    tasks = tasks.map(recalcTaskPriority);
    persist();
    renderCategoryFilter();
    renderCategoryProgress();
    renderQuickTasks();

    const totalTasks = tasks.length;
    const activeTasksCount = tasks.filter(t => !isTaskCompleted(t)).length;
    const shredButton = $("shredTopTaskButton");
    if (shredButton) {
      const hasActiveTasks = activeTasksCount > 0;
      shredButton.disabled = !hasActiveTasks;
      shredButton.setAttribute("aria-disabled", hasActiveTasks ? "false" : "true");
    }
    const categoryDisplay = activeCategory === "All" ? "All categories" : activeCategory;
    const hasTasks = totalTasks > 0;
    getAllTasksCards().forEach(({ title, summaryText, categoryLabel, divider }) => {
      if (title) {
        title.textContent = `All Tasks (${totalTasks})`;
      }
      if (summaryText) {
        summaryText.textContent = hasTasks
          ? `${activeTasksCount} active ‚Ä¢ ${totalTasks} total`
          : "No tasks yet";
      }
      if (categoryLabel) {
        if (hasTasks) {
          categoryLabel.textContent = categoryDisplay;
          categoryLabel.classList.remove("hidden");
        } else {
          categoryLabel.classList.add("hidden");
        }
      }
      if (divider) {
        divider.classList.toggle("hidden", !hasTasks);
      }
    });

    const taskList = $("taskList");
    taskList.innerHTML = "";

    const taskViewSelect = $("taskViewMode");
    if (taskViewSelect) {
      taskViewSelect.value = taskListMode;
    }

    const sortSelect = $("taskSortMode");
    if (sortSelect) {
      const validSortValues = Object.values(TASK_SORT_MODES);
      sortSelect.value = validSortValues.includes(taskSortMode) ? taskSortMode : TASK_SORT_MODES.PRIORITY;
    }

    const eligibleTasks = tasks.filter(t => activeCategory === "All" || t.category === activeCategory);
    const remaining = eligibleTasks.filter(t => !isTaskCompleted(t));
    const startBtn = $("startBtn");
    if (startBtn) {
      startBtn.dataset.hasTasks = remaining.length > 0 ? "true" : "false";
    }
    syncAddTaskActions();
    const timeBudget = getTimeBudgetMinutes();
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const hasTimeBudget = Number.isFinite(timeBudget);
    const sortedRemaining = sortTasksByMode(remaining, taskSortMode);
    const budgetFilteredRemaining = hasTimeBudget
      ? sortedRemaining.filter(task => estimateTaskMinutes(task) <= timeBudget)
      : sortedRemaining;

    const isActiveMode = taskListMode === TASK_LIST_MODES.ACTIVE;

    let allDisplayableTasks;
    if (taskListMode === TASK_LIST_MODES.COMPLETED) {
      const completedTasks = eligibleTasks.filter(t => isTaskCompleted(t));
      if (taskSortMode === TASK_SORT_MODES.PRIORITY) {
        allDisplayableTasks = [...completedTasks].sort((a, b) => {
          const aDate = getCompletionTimestamp(a) ? new Date(getCompletionTimestamp(a)).getTime() : 0;
          const bDate = getCompletionTimestamp(b) ? new Date(getCompletionTimestamp(b)).getTime() : 0;
          return bDate - aDate;
        });
      } else {
        allDisplayableTasks = sortTasksByMode(completedTasks, taskSortMode);
      }
    } else {
      allDisplayableTasks = budgetFilteredRemaining;
    }

    const visibleCount = isActiveMode
      ? Math.min(readyToLaunchVisibleCount, allDisplayableTasks.length)
      : allDisplayableTasks.length;
    const displayTasks = visibleCount > 0 ? allDisplayableTasks.slice(0, visibleCount) : [];

    const showMoreBtn = $("readyToLaunchMoreBtn");
    if (showMoreBtn) {
      const hasMore = isActiveMode && visibleCount < allDisplayableTasks.length;
      showMoreBtn.classList.toggle("is-visible", hasMore);
      showMoreBtn.disabled = !hasMore;
      showMoreBtn.setAttribute("aria-hidden", hasMore ? "false" : "true");
    }

    const revealBaseline = isActiveMode
      ? Math.min(readyToLaunchRevealBaseline, displayTasks.length)
      : displayTasks.length;

    if (!displayTasks.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      if (taskListMode === TASK_LIST_MODES.ACTIVE && hasTimeBudget && remaining.length > 0 && budgetFilteredRemaining.length === 0) {
        empty.textContent = "No tasks fit the selected time budget.";
      } else {
        empty.textContent = taskListMode === TASK_LIST_MODES.COMPLETED
          ? "No completed tasks yet."
          : "No active tasks to show.";
      }
      taskList.appendChild(empty);
    } else {
      displayTasks.forEach((task, index) => {
        const card = renderTaskListCard(task, taskListMode, hasTimeBudget ? timeBudget : null);
        if (isActiveMode && index >= revealBaseline) {
          card.classList.add("task-card--reveal");
        }
        taskList.appendChild(card);
        if (isActiveMode && index >= revealBaseline) {
          requestAnimationFrame(() => {
            card.classList.add("is-visible");
          });
        }
      });
    }

    if (isActiveMode) {
      readyToLaunchRevealBaseline = displayTasks.length ? visibleCount : READY_TO_LAUNCH_INITIAL_COUNT;
    }

    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const today = now.toISOString().split("T")[0];
    const dueTodayEntries = [];

    tasks.forEach(task => {
      if (isTaskCompleted(task)) return;
      if (activeCategory !== "All" && task.category !== activeCategory) return;

      const fallbackDueDate = (!task.dueDate && task.dateOfService)
        ? (() => {
            const dt = new Date(`${task.dateOfService}T00:00:00`);
            if (!Number.isNaN(dt.getTime())) {
              dt.setDate(dt.getDate() + 3);
              return dt.toISOString().split("T")[0];
            }
            return null;
          })()
        : null;

      if (task.dueDate === today || (fallbackDueDate && fallbackDueDate === today)) {
        dueTodayEntries.push({
          task,
          fallback: Boolean(fallbackDueDate && !task.dueDate)
        });
      }
    });

    dueTodayEntries.sort((a, b) => computeFocusScore(b.task, energyLevel, timeBudget) - computeFocusScore(a.task, energyLevel, timeBudget));
    renderDueTodayList(dueTodayEntries);
    updateNextTaskCard();
    updateNextBestOptions();
    updateConflictResolver();
    refreshGanttSnapshotIfOpen();
    updateWorstDayBanner();
    updateSleepToolkitUI();
    refreshTaskGestureTargets();
  }

  function resetReadyToLaunchVisibility() {
    readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
    readyToLaunchRevealBaseline = READY_TO_LAUNCH_INITIAL_COUNT;
  }

  function showMoreReadyToLaunchTasks() {
    const previousVisible = readyToLaunchVisibleCount;
    readyToLaunchVisibleCount += READY_TO_LAUNCH_INCREMENT;
    readyToLaunchRevealBaseline = previousVisible;
    updateUI();
  }

  function startFocus(initialTaskId = null, options = {}) {
    if (editingTaskId) cancelEdit();
    if (options && options.expandDetails) {
      setTaskDetailsCollapsed(false);
    }
    const sprintMinutes = Number(options?.sprintMinutes);
    stopFocusTimer();
    if (Number.isFinite(sprintMinutes) && sprintMinutes > 0) {
      sprintDurationMinutes = sprintMinutes;
    } else {
      sprintDurationMinutes = null;
    }
    setSprintVisualState(Boolean(sprintDurationMinutes));
    setFocusLaunchOpen(false);
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.setAttribute("aria-hidden", "true");
    }
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.remove("hidden");
      focusSection.setAttribute("aria-hidden", "false");
      const focusSheet = focusSection.querySelector(".focus-overlay__sheet");
      if (focusSheet) {
        window.requestAnimationFrame(() => focusSheet.focus());
      }
    }
    document.body.classList.add("focus-overlay-active");
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    lastFocusEnergyLevel = energyLevel;
    lastFocusTimeBudget = timeBudget;
    const score = task => Number(task?.priority || 0) * energyFit(task, energyLevel) * timeFit(task, timeBudget);
    focusQueue = tasks
      .filter(t => !isTaskCompleted(t) && (activeCategory === "All" || t.category === activeCategory))
      .sort((a, b) => score(b) - score(a));
    if (initialTaskId) {
      const targetIndex = focusQueue.findIndex(task => task.id === initialTaskId);
      if (targetIndex > 0) {
        const [selected] = focusQueue.splice(targetIndex, 1);
        focusQueue.unshift(selected);
      } else if (targetIndex === -1) {
        const directTask = tasks.find(t => t.id === initialTaskId && !isTaskCompleted(t));
        if (directTask) {
          focusQueue.unshift(directTask);
        }
      }
    }
    showNextTask();
  }

  function showNextTask() {
    const display = document.querySelector(".focus");
    const scoreView = $("scoreView");
    if (focusQueue.length === 0) {
      display.textContent = "‚úÖ All tasks complete!";
      scoreView.textContent = "";
      updateFocusFitHint(null, lastFocusEnergyLevel, lastFocusTimeBudget);
      const subTaskView = $("subTaskView");
      if (subTaskView) subTaskView.innerHTML = "";
      clearRunningTimers();
      stopFocusTimer();
      currentFocusTaskIndex = null;
      setSprintVisualState(false);
      return;
    }
    const current = focusQueue[0];
    display.textContent = current.name;
    startFocusTimer();
    const idx = tasks.findIndex(t => t.id === current.id);
    const task = idx !== -1 ? tasks[idx] : current;
    scoreView.textContent = `Score: ${task.priority.toFixed(1)}`;
    updateFocusFitHint(task, lastFocusEnergyLevel, lastFocusTimeBudget);
    renderFocusTask(task, idx);
  }

  function updateFocusFitHint(task, energyLevel, timeBudget) {
    const hintEl = $("focusFitHint");
    if (!hintEl) return;
    if (!task) {
      hintEl.textContent = "";
      return;
    }
    const pieces = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(timeBudget)) {
      if (Number.isFinite(estimated) && estimated > 0) {
        const rounded = Math.max(1, Math.round(estimated));
        if (rounded <= timeBudget) {
          pieces.push(`Fits your ${timeBudget}-minute block (est. ${rounded} min)`);
        } else {
          pieces.push(`Stretch past ${timeBudget}-minute block (est. ${rounded} min)`);
        }
      } else {
        pieces.push(`Focus window: ${timeBudget} min`);
      }
    }
    if (Number.isFinite(energyLevel)) {
      const difficulty = clampScale(task?.difficulty, 3);
      if (energyLevel <= 2) {
        if (estimated <= 20) {
          pieces.push("Easiest win for low energy");
        } else {
          pieces.push("Try a 5-min pass‚Äîenergy is low");
        }
      } else if (energyLevel >= 4) {
        if (difficulty >= 4) {
          pieces.push("Perfect for your high energy window");
        } else {
          pieces.push("Use the high energy to bank progress");
        }
      }
    }
    hintEl.textContent = pieces.length ? pieces.join(" ‚Ä¢ ") : "Working the highest-impact task next.";
  }

  function completeTaskById(taskId, options = {}) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (task.completed) return false;
    const nowIso = new Date().toISOString();
    task.completed = true;
    task.completedAt = nowIso;
    updateChartDurationForTask(task);
    if (Array.isArray(task.subTasks)) {
      task.subTasks.forEach(sub => stopTimerForSubTask(sub.id));
    }
    persist();
    recordTaskCompletion(task);
    maybeShowEndOfDayAudit();
    if (!options.skipUI) {
      updateUI();
    }
    return true;
  }

  function markTaskDoneFromPeek(taskId) {
    const completed = completeTaskById(taskId);
    if (!completed) return;
    const wasCurrentFocus = focusQueue.length && focusQueue[0].id === taskId;
    focusQueue = focusQueue.filter(t => t.id !== taskId);
    if (wasCurrentFocus) {
      clearRunningTimers();
      stopFocusTimer();
    }
    const focusSection = $("focus");
    if (focusSection && !focusSection.classList.contains("hidden")) {
      showNextTask();
    }
  }

  function completeTask() {
    if (!focusQueue.length) return;
    const current = focusQueue[0];
    const completed = completeTaskById(current.id, { skipUI: true });
    clearRunningTimers();
    if (completed) {
      updateUI();
    }
    focusQueue.shift();
    showNextTask();
  }

  function backToCapture() {
    clearRunningTimers();
    stopFocusTimer();
    currentFocusTaskIndex = null;
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.add("hidden");
      focusSection.setAttribute("aria-hidden", "true");
    }
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.classList.remove("hidden");
      captureSection.removeAttribute("aria-hidden");
    }
    document.body.classList.remove("focus-overlay-active");
    setSprintVisualState(false);
    setFocusLaunchOpen(false);
    updateUI();
  }

  function reset() {
    if (!confirm("Clear all tasks?")) return;
    cancelEdit();
    tasks = [];
    localStorage.removeItem("tasks");
    updateUI();
  }

  function saveAsTemplate() {
    const name = $("name").value.trim();
    if (!name) return alert("Task name is required");
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const template = {
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1)
    };
    templates.push(template);
    localStorage.setItem("templates", JSON.stringify(templates));
    renderTemplates();
  }

  function renderTemplates() {
    const container = $("templateButtons");
    const selectedCategory = $("taskCategory")?.value || "General";
    const matchingTemplates = templates
      .map((template, index) => ({ template, index }))
      .filter(({ template }) => (template.category || "General") === selectedCategory);

    const useTemplateBtn = $("btn-use-template");
    if (useTemplateBtn) {
      const hasTemplates = matchingTemplates.length > 0;
      useTemplateBtn.disabled = !hasTemplates;
      useTemplateBtn.setAttribute("aria-disabled", hasTemplates ? "false" : "true");
      useTemplateBtn.title = hasTemplates ? "" : "No templates for this category yet";
    }

    updateTemplateModalForCategory(selectedCategory);

    if (!container) return;

    container.innerHTML = "";

    if (!matchingTemplates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      container.appendChild(empty);
      return;
    }

    matchingTemplates.forEach(({ template: t, index: templateIndex }) => {
      const wrapper = document.createElement("div");
      wrapper.className = "template-entry";
      const useBtn = document.createElement("button");
      useBtn.textContent = `üìã ${t.name}`;
      useBtn.onclick = () => {
        applyTemplate(t);
      };
      const editBtn = document.createElement("button");
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.title = "Edit template";
      editBtn.setAttribute("aria-label", "Edit template");
      editBtn.onclick = () => {
        const newName = prompt("Edit template name:", t.name);
        if (!newName) return;
        t.name = newName;
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "üóëÔ∏è";
      deleteBtn.title = "Delete template";
      deleteBtn.setAttribute("aria-label", "Delete template");
      deleteBtn.onclick = () => {
        if (!confirm("Delete this template?")) return;
        templates.splice(templateIndex, 1);
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      [useBtn, editBtn, deleteBtn].forEach(b => {
        b.style.marginRight = "0.3rem";
        b.style.fontSize = "0.9rem";
      });
      wrapper.appendChild(useBtn);
      wrapper.appendChild(editBtn);
      wrapper.appendChild(deleteBtn);
      container.appendChild(wrapper);
    });
  }

  function normalizeBlockBatchProfile(profile = {}) {
    const normalized = {
      category: profile.category || "General",
      authorType: profile.authorType || "attending",
      patientType: normalizePatientType(profile.patientType || "Non-Complex"),
      visitType: normalizeVisitType(profile.visitType || "Follow-Up"),
      clinicSite: normalizeClinicSite(profile.clinicSite || "General Clinic"),
      importance: clampScale(profile.importance, 1),
      urgency: clampScale(profile.urgency, 3),
      novelty: clampScale(profile.novelty, 1),
      interest: clampScale(profile.interest, 1),
      externalPressure: clampScale(profile.externalPressure, 1),
      timeToStart: clampScale(profile.timeToStart, 1),
      difficulty: clampScale(profile.difficulty, 1),
      useChartTemplate: Boolean(profile.useChartTemplate)
    };
    if (Array.isArray(profile.subTasks)) {
      normalized.subTasks = profile.subTasks.map(line => line.trim()).filter(Boolean);
    } else if (typeof profile.subTasks === "string") {
      normalized.subTasks = profile.subTasks
        .split("\n")
        .map(line => line.trim())
        .filter(Boolean);
    } else {
      normalized.subTasks = [];
    }
    return normalized;
  }

  function getBlockBatchDefinition(batchId) {
    return DEFAULT_BLOCK_BATCHES.find(batch => batch.id === batchId) || null;
  }

  function getBlockBatchProfile(batchId) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return null;
    const base = normalizeBlockBatchProfile(definition.defaultProfile);
    const stored = blockBatchProfiles[batchId];
    if (!stored) {
      return { ...base };
    }
    const overrides = normalizeBlockBatchProfile(stored);
    const merged = { ...base, ...overrides };
    merged.subTasks = overrides.subTasks.slice();
    merged.useChartTemplate = overrides.useChartTemplate;
    return merged;
  }

  function loadBlockBatchProfiles() {
    const saved = localStorage.getItem(BLOCK_BATCH_STORAGE_KEY);
    blockBatchProfiles = {};
    if (!saved) return;
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") {
        Object.entries(parsed).forEach(([batchId, profile]) => {
          if (!getBlockBatchDefinition(batchId)) return;
          blockBatchProfiles[batchId] = normalizeBlockBatchProfile(profile);
        });
      }
    } catch (error) {
      console.warn("Block batch profiles could not be parsed", error);
      blockBatchProfiles = {};
    }
  }

  function saveBlockBatchProfiles() {
    localStorage.setItem(BLOCK_BATCH_STORAGE_KEY, JSON.stringify(blockBatchProfiles));
  }

  function renderBlockBatchList() {
    const list = $("blockBatchList");
    if (!list) return;
    list.innerHTML = "";
    const activeId = blockBatchState.activeId || (DEFAULT_BLOCK_BATCHES[0]?.id || null);
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const item = document.createElement("div");
      item.className = "block-batch-item";
      item.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        item.classList.add("is-active");
      }
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "block-batch-item__edit";
      editBtn.setAttribute("aria-label", `Edit ${definition.label} default profile`);
      editBtn.textContent = "‚úèÔ∏è";
      editBtn.addEventListener("click", event => {
        event.preventDefault();
        event.stopPropagation();
        showBlockBatchEditor(definition.id);
      });
      const selectBtn = document.createElement("button");
      selectBtn.type = "button";
      selectBtn.className = "block-batch-item__select";
      selectBtn.textContent = definition.label;
      selectBtn.setAttribute("role", "option");
      selectBtn.setAttribute("aria-selected", definition.id === activeId ? "true" : "false");
      selectBtn.addEventListener("click", () => setActiveBlockBatch(definition.id, { focusInput: true }));
      item.appendChild(editBtn);
      item.appendChild(selectBtn);
      list.appendChild(item);
    });
  }

  function renderBlockBatchCounts() {
    const container = $("blockBatchCounts");
    if (!container) return;
    container.innerHTML = "";
    const activeId = blockBatchState.activeId;
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const label = document.createElement("label");
      label.className = "block-batch-count";
      label.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        label.classList.add("is-active");
      }
      const title = document.createElement("span");
      title.textContent = definition.label;
      const input = document.createElement("input");
      input.type = "number";
      input.id = `blockBatchCount-${definition.id}`;
      input.name = `blockBatchCount-${definition.id}`;
      input.min = "0";
      input.step = "1";
      const current = Number(blockBatchState.counts?.[definition.id] || 0);
      input.value = String(current);
      input.addEventListener("input", () => {
        const parsed = Math.max(0, Math.floor(Number(input.value) || 0));
        input.value = String(parsed);
        blockBatchState.counts[definition.id] = parsed;
      });
      input.addEventListener("focus", () => {
        if (blockBatchState.activeId !== definition.id) {
          setActiveBlockBatch(definition.id);
        } else {
          updateBlockBatchHighlights();
        }
      });
      label.appendChild(title);
      label.appendChild(input);
      container.appendChild(label);
    });
  }

  function updateBlockBatchHighlights({ focusInput = false } = {}) {
    const activeId = blockBatchState.activeId;
    const list = $("blockBatchList");
    if (list) {
      list.querySelectorAll(".block-batch-item").forEach(item => {
        const isActive = item.dataset.batchId === activeId;
        item.classList.toggle("is-active", isActive);
        const optionBtn = item.querySelector(".block-batch-item__select");
        if (optionBtn) {
          optionBtn.setAttribute("aria-selected", isActive ? "true" : "false");
        }
      });
    }
    const countsContainer = $("blockBatchCounts");
    if (countsContainer) {
      countsContainer.querySelectorAll(".block-batch-count").forEach(wrapper => {
        wrapper.classList.toggle("is-active", wrapper.dataset.batchId === activeId);
      });
    }
    if (focusInput) {
      const targetInput = document.getElementById(`blockBatchCount-${activeId}`);
      if (targetInput) {
        window.setTimeout(() => {
          targetInput.focus();
          targetInput.select();
        }, 0);
      }
    }
  }

  function setActiveBlockBatch(batchId, options = {}) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return;
    blockBatchState.activeId = definition.id;
    updateBlockBatchHighlights(options);
  }

  function populateBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    const profile = getBlockBatchProfile(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (!profile || !definition) return;
    editor.dataset.batchId = batchId;
    const title = $("blockBatchEditorTitle");
    if (title) {
      title.textContent = `Edit default profile ¬∑ ${definition.label}`;
    }
    const setValue = (id, value) => {
      const field = $(id);
      if (!field) return;
      field.value = value;
    };
    setValue("blockBatchCategory", profile.category || "General");
    setValue("blockBatchAuthor", profile.authorType || "attending");
    setValue("blockBatchPatient", profile.patientType || "Non-Complex");
    setValue("blockBatchVisit", profile.visitType || "Follow-Up");
    setValue("blockBatchClinic", profile.clinicSite || "General Clinic");
    setValue("blockBatchImportance", String(profile.importance || 1));
    setValue("blockBatchUrgency", String(profile.urgency || 3));
    setValue("blockBatchNovelty", String(profile.novelty || 1));
    setValue("blockBatchInterest", String(profile.interest || 1));
    setValue("blockBatchExternalPressure", String(profile.externalPressure || 1));
    setValue("blockBatchTimeToStart", String(profile.timeToStart || 1));
    setValue("blockBatchDifficulty", String(profile.difficulty || 1));
    const subtasksField = $("blockBatchSubtasks");
    if (subtasksField) {
      subtasksField.value = (profile.subTasks || []).join("\n");
    }
    const templateToggle = $("blockBatchUseChartTemplate");
    if (templateToggle) {
      templateToggle.checked = Boolean(profile.useChartTemplate);
    }
  }

  function showBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    setActiveBlockBatch(batchId);
    populateBlockBatchEditor(batchId);
    editor.classList.remove("hidden");
    const firstField = editor.querySelector("select, textarea, input");
    if (firstField) {
      window.setTimeout(() => firstField.focus(), 0);
    }
  }

  function hideBlockBatchEditor() {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    editor.classList.add("hidden");
    delete editor.dataset.batchId;
  }

  function handleBlockBatchSaveProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    const profile = normalizeBlockBatchProfile({
      category: $("blockBatchCategory")?.value || "General",
      authorType: $("blockBatchAuthor")?.value || "attending",
      patientType: $("blockBatchPatient")?.value || "Non-Complex",
      visitType: $("blockBatchVisit")?.value || "Follow-Up",
      clinicSite: $("blockBatchClinic")?.value || "General Clinic",
      importance: $("blockBatchImportance")?.value || 1,
      urgency: $("blockBatchUrgency")?.value || 3,
      novelty: $("blockBatchNovelty")?.value || 1,
      interest: $("blockBatchInterest")?.value || 1,
      externalPressure: $("blockBatchExternalPressure")?.value || 1,
      timeToStart: $("blockBatchTimeToStart")?.value || 1,
      difficulty: $("blockBatchDifficulty")?.value || 1,
      subTasks: $("blockBatchSubtasks")?.value || "",
      useChartTemplate: $("blockBatchUseChartTemplate")?.checked || false
    });
    blockBatchProfiles[batchId] = profile;
    saveBlockBatchProfiles();
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile saved.`);
    }
    hideBlockBatchEditor();
  }

  function handleBlockBatchResetProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    delete blockBatchProfiles[batchId];
    saveBlockBatchProfiles();
    populateBlockBatchEditor(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile reset to default.`);
    }
  }

  function buildBlockBatchTaskName(prefix, serviceDate, index) {
    const date = serviceDate instanceof Date && !Number.isNaN(serviceDate.getTime()) ? serviceDate : new Date();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${prefix}_${month}_${day}_pt${index + 1}`;
  }

  function buildTaskFromBatchProfile(profile, overrides = {}) {
    if (!profile) return null;
    const normalized = normalizeBlockBatchProfile(profile);
    const nowIso = new Date().toISOString();
    const dateOfService = overrides.dateOfService || null;
    const dueDate = overrides.dueDate || null;
    const task = {
      id: `${Date.now()}-${blockBatchIdCounter++}`,
      name: overrides.name || "Block Batch Task",
      category: normalized.category,
      authorType: normalized.authorType,
      patientType: normalized.patientType,
      visitType: normalized.visitType,
      clinicSite: normalized.clinicSite,
      dateOfService,
      daysSinceVisit: calculateDaysSince(dateOfService),
      importance: normalized.importance,
      urgency: normalized.urgency,
      novelty: normalized.novelty,
      interest: normalized.interest,
      externalPressure: normalized.externalPressure,
      timeToStart: normalized.timeToStart,
      difficulty: normalized.difficulty,
      dueDate,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: Boolean(normalized.useChartTemplate)
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = Array.isArray(normalized.subTasks) ? normalized.subTasks : [];
    task.subTasks = subLines.map(line => createSubTask(line, basePriority));
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    return task;
  }

  function resetBlockBatchCounts() {
    blockBatchState.counts = {};
    const container = $("blockBatchCounts");
    if (container) {
      container.querySelectorAll('input[type="number"]').forEach(input => {
        input.value = "0";
      });
    }
  }

  function handleBlockBatchAdd() {
    const dateField = $("blockBatchDate");
    const rawDate = dateField && dateField.value ? dateField.value : null;
    let serviceDateObj = rawDate ? new Date(rawDate) : new Date();
    if (Number.isNaN(serviceDateObj.getTime())) {
      serviceDateObj = new Date();
    }
    const serviceDate = formatDateForInput(serviceDateObj);
    const dueDate = formatDateForInput(addDays(serviceDateObj, 3));
    const additions = [];
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const count = Math.max(0, Number(blockBatchState.counts?.[definition.id] || 0));
      if (!count) return;
      const profile = getBlockBatchProfile(definition.id);
      for (let index = 0; index < count; index += 1) {
        const name = buildBlockBatchTaskName(definition.prefix, serviceDateObj, index);
        const task = buildTaskFromBatchProfile(profile, {
          name,
          dateOfService: serviceDate,
          dueDate
        });
        if (task) {
          additions.push(task);
        }
      }
    });
    if (!additions.length) {
      showToast("Block Batch", "Set at least one batch count to add tasks.");
      return;
    }
    additions.forEach(task => tasks.push(task));
    showTaskAddedConfirmation(additions.length);
    persist();
    updateUI();
    showToast("Block Batch", `Added ${additions.length} tasks.`);
    resetBlockBatchCounts();
    closeBlockBatchModal();
  }

  function updateBlockBatchModal({ focusActive = false } = {}) {
    renderBlockBatchList();
    renderBlockBatchCounts();
    updateBlockBatchHighlights({ focusInput: focusActive });
  }

  function openBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    loadBlockBatchProfiles();
    if (!blockBatchState.activeId && DEFAULT_BLOCK_BATCHES.length) {
      blockBatchState.activeId = DEFAULT_BLOCK_BATCHES[0].id;
    }
    updateBlockBatchModal({ focusActive: true });
    hideBlockBatchEditor();
    const dateField = $("blockBatchDate");
    if (dateField) {
      const today = formatDateForInput(new Date());
      dateField.value = dateField.value || today;
    }
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    const firstOption = modal.querySelector(".block-batch-item__select");
    if (firstOption) {
      window.setTimeout(() => firstOption.focus(), 0);
    }
  }

  function closeBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    hideBlockBatchEditor();
    resetBlockBatchCounts();
  }

  function initializeBlockBatchModule() {
    const openBtn = $("blockBatchOpen");
    const modal = $("block-batch-modal");
    if (!openBtn || !modal) return;
    openBtn.addEventListener("click", () => openBlockBatchModal());
    const closeBtn = modal.querySelector(".modal__close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeBlockBatchModal());
    }
    modal.addEventListener("click", event => {
      if (event.target === modal) {
        closeBlockBatchModal();
      }
    });
    modal.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        event.stopPropagation();
        closeBlockBatchModal();
      }
    });
    const saveBtn = $("blockBatchSaveProfile");
    if (saveBtn) {
      saveBtn.addEventListener("click", handleBlockBatchSaveProfile);
    }
    const resetBtn = $("blockBatchResetProfile");
    if (resetBtn) {
      resetBtn.addEventListener("click", handleBlockBatchResetProfile);
    }
    const closeEditorBtn = $("blockBatchEditorClose");
    if (closeEditorBtn) {
      closeEditorBtn.addEventListener("click", hideBlockBatchEditor);
    }
    const addBtn = $("blockBatchAdd");
    if (addBtn) {
      addBtn.addEventListener("click", handleBlockBatchAdd);
    }
    loadBlockBatchProfiles();
  }

  function updateHeaderSubtitle() {
    const dateEl = $("headerDate");
    if (!dateEl) return;
    try {
      const formatted = new Date().toLocaleDateString(undefined, {
        weekday: "long",
        month: "short",
        day: "numeric"
      });
      dateEl.textContent = formatted;
    } catch (error) {
      dateEl.textContent = "";
    }
  }

  function updateBillingReminder() {
    const reminder = $("billingReminder");
    if (!reminder) return;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 95);
    const formatted = cutoff.toLocaleDateString(undefined, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
    reminder.innerHTML = `<span class="header-chip"><span class="header-chip__label">Eligibility cutoff</span><span class="header-chip__value">${formatted}</span></span>`;
  }

  function registerFieldListeners() {
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.addEventListener("change", () => {
        updateDerivedFields();
      });
    }
    const categoryField = $("taskCategory");
    if (categoryField) {
      categoryField.addEventListener("change", event => {
        handleCategoryChange(event.target.value);
      });
    }
    const urgencyField = $("urgency");
    if (urgencyField) {
      urgencyField.addEventListener("change", () => {
        urgencyAuto = false;
        updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
      });
    }
  }

  function registerTaskListModeControl() {
    const modeSelect = $("taskViewMode");
    if (!modeSelect) return;
    modeSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_LIST_MODES.ACTIVE).toLowerCase();
      taskListMode = value === TASK_LIST_MODES.COMPLETED ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerTimeBudgetControl() {
    const budgetSelect = $("timeBudget");
    if (!budgetSelect) return;
    budgetSelect.addEventListener("change", () => {
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerCategoryFilterControl() {
    const categorySelect = $("taskCategoryFilter");
    if (!categorySelect) return;
    categorySelect.addEventListener("change", event => {
      const value = (event.target.value || "All").toString();
      activeCategory = categories.includes(value) || value === "All" ? value : "All";
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerTaskSortControl() {
    const sortSelect = $("taskSortMode");
    if (!sortSelect) return;
    sortSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_SORT_MODES.PRIORITY);
      const validValues = Object.values(TASK_SORT_MODES);
      taskSortMode = validValues.includes(value) ? value : TASK_SORT_MODES.PRIORITY;
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerReadyToLaunchControl() {
    const showMoreBtn = $("readyToLaunchMoreBtn");
    if (!showMoreBtn) return;
    showMoreBtn.addEventListener("click", () => {
      showMoreReadyToLaunchTasks();
    });
  }

  function triggerStartReward(button) {
    if (!button) return;
    button.classList.add("start-action");
    button.classList.remove("cta-reward-active");
    void button.offsetWidth;
    button.classList.add("cta-reward-active");
    if (navigator?.vibrate) {
      navigator.vibrate(12);
    }
    window.setTimeout(() => {
      button.classList.remove("cta-reward-active");
    }, 240);
  }

  function markStartRewardButtons() {
    const buttons = document.querySelectorAll("button");
    buttons.forEach(button => {
      if (button.dataset.startReward === "ready") return;
      const label = (button.textContent || button.getAttribute("aria-label") || "")
        .trim()
        .toLowerCase();
      if (!label.startsWith("start")) return;
      button.dataset.startReward = "ready";
      button.classList.add("start-action");
      button.addEventListener("click", () => triggerStartReward(button));
    });
  }

  function setupStartRewardObserver() {
    markStartRewardButtons();
    const observer = new MutationObserver(() => {
      markStartRewardButtons();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }

  window.addEventListener('DOMContentLoaded', () => {
    const nextStepBtn = $("meltdownShieldNext");
    if (nextStepBtn) {
      nextStepBtn.addEventListener("click", completeCurrentMeltdownStep);
    }
    prepareAccordionContainers();
    function showToast(message, duration = 2000) {
  const toast = document.createElement("div");
  toast.textContent = message;
  Object.assign(toast.style, {
    position: "fixed",
    bottom: "90px",
    left: "50%",
    transform: "translateX(-50%)",
    background: "#00bfa5", // teal
    color: "#fff",
    padding: "10px 18px",
    borderRadius: "20px",
    fontSize: "14px",
    boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
    opacity: "0",
    transition: "opacity 0.3s ease",
    zIndex: "9999",
  });
  document.body.appendChild(toast);
  requestAnimationFrame(() => (toast.style.opacity = "1"));
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 300);
  }, duration);
    }
    restoreBriefModePreference();
    setupMomentumZones();
    setupNextBestObserver();
    setupSmartCollapse();
    setupTaskGestures();
    setupFocusOverlay();
    setupLazyMedia();
    initializeChartFields();
    registerFieldListeners();
    registerTaskListModeControl();
    registerTimeBudgetControl();
    registerReadyToLaunchControl();
    setDefaultFieldValues();
    updateHeaderSubtitle();
    updateBillingReminder();
    initializeSoundPreference();
    initializeFirstThreeWizard();
    initializeTaskForm();
    initializeQuickAddMenu();
    initializeQuickTaskShortcut();
    initializeShredTopTaskButton();
    initializeBlockBatchModule();
    initializeAddTaskCardState();
    initializePreflightToggles();
    initializeDueTodayAccordionState();
    initializeAllTasksCardState();
    initializeAllTasksOverlay();
    initializeFocusLaunchSheet();
    initializeQuickCaptureModal();
    initializeSettingsMenu();
    initializeTemplatesOverlay();
    initializeConflictOverlay();

// === START: Accordions ===
// Existing accordion wiring lives in renderDueTodayList and initializeAllTasksCardState.
// Keep the two sections mutually exclusive by collapsing the other when one opens.
// === END: Accordions ===

    initializeResourcesDrawer();
    initializeSosPanel();
    initializeCommandBarAutohide();
    initializeDefuseOverlay();
    initializeCollapsibleModules();
    initializeMorningLaunchModule();
    initializeLaunchPadModule();
    initializeSleepToolkitModule();
    initializeNextBestEngine();
    initializeConflictResolverModule();
    initializeDefuseMode();
    initializeDopamineModule();
    initializeDistractionTools();
    initializeGanttSnapshot();
    initializeWorstDayMode();
    const saved = localStorage.getItem("tasks");
    if (saved) {
      tasks = JSON.parse(saved).map(task => {
        const normalizedTask = {
          ...task,
          authorType: task.authorType || "attending",
          patientType: normalizePatientType(task.patientType),
          visitType: normalizeVisitType(task.visitType),
          clinicSite: normalizeClinicSite(task.clinicSite),
          dateOfService: task.dateOfService || null,
          createdAt: task.createdAt || task.addedAt || new Date().toISOString()
        };
        if (normalizedTask.dateOfService) {
          normalizedTask.daysSinceVisit = calculateDaysSince(normalizedTask.dateOfService);
        }
        return recalcTaskPriority(normalizedTask);
      });
    }
    const savedTemplates = localStorage.getItem("templates");
    if (savedTemplates) {
      templates = JSON.parse(savedTemplates).map(template => ({
        ...template,
        authorType: template.authorType || "attending",
        patientType: normalizePatientType(template.patientType),
        visitType: normalizeVisitType(template.visitType),
        clinicSite: normalizeClinicSite(template.clinicSite)
      }));
    }
    registerCategoryFilterControl();
    registerTaskSortControl();
    setupStartRewardObserver();
    startReminderLoop();
    renderTemplates();
    updateUI();
    updateSleepToolkitUI();
    updateDerivedFields();
  });
  </script>
    <script>
  (function () {
    const root = document.querySelector('.focus-command-deck');
    if (!root) return;

    const fill = root.querySelector('.cm-fill');
    const doneEl = root.querySelector('.cm-done');
    const totalEl = root.querySelector('.cm-total');
    const floatEl = root.querySelector('.cm-float');

    function zone(pct) {
      if (pct >= 1) return 'high';
      if (pct >= 0.3) return 'mid';
      return 'low';
    }

    function setFill(pct) {
      const z = zone(pct);
      fill.dataset.zone = z;
      fill.style.width = (pct * 100).toFixed(0) + '%';
    }

    window.updateChartProgress = function (completed, total) {
      const prev = parseFloat((fill.style.width || '0').replace('%', '')) / 100 || 0;
      const pct = total > 0 ? completed / total : 0;

      doneEl.textContent = completed;
      totalEl.textContent = total;
      setFill(pct);

      floatEl.textContent = Math.round(pct * 100) + '% complete';
      floatEl.style.opacity = '1';
      floatEl.style.transform = 'translateY(-4px)';

      setTimeout(() => {
        floatEl.style.opacity = '0';
        floatEl.style.transform = 'translateY(-10px)';
      }, 700);

      if (pct > prev || pct >= 1) {
        fill.classList.remove('pulse');
        void fill.offsetWidth; // force reflow
        fill.classList.add('pulse');
      }
    };

    // Optional: initialize from any existing DOM values
    const initDone = parseInt(doneEl.textContent, 10) || 0;
    const initTotal = parseInt(totalEl.textContent, 10) || 0;
    setFill(initTotal ? initDone / initTotal : 0);
  })();

  document.addEventListener("DOMContentLoaded", () => {
    // Debugging script for the 2x2 recovery routines grid layout
    const container = document.querySelector(".recovery-routines-container");
    if (!container) {
      console.error("Error: Rounded container for recovery routines is missing.");
      return;
    }

    console.log("Recovery routines container found:", container);

    const containerStyles = getComputedStyle(container);
    if (containerStyles.display !== "grid") {
      console.error(
        "Error: Container is not using grid layout. Current display property:",
        containerStyles.display
      );
    } else {
      console.log("Container is using grid layout.");
    }

    const modules = container.querySelectorAll(".routine-tile");
    if (modules.length !== 4) {
      console.error(`Error: Expected 4 routine modules, found ${modules.length}.`);
    } else {
      console.info("Routine modules found:", modules);
      const expectedTitles = ["üåÖ AM Start", "üöÄ Launch Pad", "üò¥ Sleep Toolkit", "üéµ Dopa-Me"];

      modules.forEach((module, index) => {
        const titleElement = module.querySelector(".routine-tile__title");
        const title = titleElement ? titleElement.textContent.trim() : null;

        if (title !== expectedTitles[index]) {
          console.error(
            `Error: Routine ${index + 1} has incorrect title. Expected: "${expectedTitles[index]}", Found: "${title}".`
          );
        } else {
          console.info(`Routine ${index + 1} title is correct: "${title}".`);
        }
      });
    }

    const outline = containerStyles.border || containerStyles.boxShadow;
    if (!outline || outline === "none") {
      console.error("Error: No outline is applied to the container.");
    } else {
      console.log("Outline applied to the container:", outline);
    }
  });
    </script>
</body>
</html>





