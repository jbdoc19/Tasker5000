<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Task Focus</title>
  <style>
    :root {
      --hero-teal: #2dd4c3;
      --surface: rgba(20, 26, 32, 0.88);
      --surface-elevated: rgba(18, 24, 30, 0.92);
      --text-primary: #e6eef7;
      --text-secondary: #93a0aa;
      --card-radius: 16px;
      --card-border-color: rgba(147, 160, 170, 0.18);
      --page-gutter: clamp(1rem, 4vw, 2.25rem);
      --page-padding-top: clamp(1.5rem, 4vw, 2.5rem);
      --page-padding-bottom: 120px;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html {
      width: 100%;
      max-width: 100vw;
    }

    body {
      background: #0c1117;
      color: var(--text-primary);
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-weight: 400;
      line-height: 1.5;
      margin: 0;
      padding: var(--page-padding-top) 0 var(--page-padding-bottom);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 100vw;
      min-width: 0;
      overflow-x: hidden;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: #fff;
      font-weight: 600;
      line-height: 1.3;
    }
    .billing-reminder {
      color: #ff6b6b;
      font-weight: 600;
      margin: 0.25rem 0 1rem;
      text-align: center;
    }
    .hidden { display: none !important; }
    label { display: block; margin-top: 0.5rem; }
    input[type="text"], select, input[type="date"], textarea {
      background: #222; color: #eee; border: 1px solid #555;
      padding: 0.5rem; width: 100%;
    }
    textarea { resize: vertical; }
    button,
    .btn,
    .icon-button,
    .link-button {
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      padding: 0.6rem 1rem;
      margin: 0.5rem 0.25rem;
      cursor: pointer;
      border-radius: 12px;
      transition: background 150ms ease, color 150ms ease, border-color 150ms ease;
    }

    button:hover,
    .btn:hover,
    .icon-button:hover,
    .link-button:hover {
      background: rgba(35, 46, 58, 0.85);
      color: #f5f9ff;
    }

    button:focus-visible,
    .btn:focus-visible,
    .icon-button:focus-visible,
    .link-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    button:disabled,
    .btn:disabled,
    .icon-button:disabled,
    .link-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }

    .hero-cta:hover {
      background: #27c2b0;
      color: #011c1a;
    }

    .hero-cta:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(45, 212, 195, 0.6);
    }

    button,
    .btn,
    .icon-button,
    .link-button,
    .hero-cta {
      transition: transform 120ms ease, background 150ms ease, color 150ms ease, border-color 150ms ease;
    }

    button:active,
    .btn:active,
    .icon-button:active,
    .link-button:active,
    .hero-cta:active {
      transform: scale(1.02);
    }

    .start-action {
      position: relative;
      overflow: hidden;
    }

    .start-action::after,
    .start-action::before {
      content: "";
      position: absolute;
      pointer-events: none;
      opacity: 0;
    }

    .start-action::after {
      inset: -6px;
      border: 2px solid var(--hero-teal);
      border-radius: inherit;
      transform: scale(0.75);
    }

    .start-action::before {
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      margin: -6px 0 0 -6px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0));
      border-radius: 50%;
      transform: scale(0.5);
    }

    .start-action.cta-reward-active::after {
      animation: cta-ring-fill 200ms ease-out forwards;
    }

    .start-action.cta-reward-active::before {
      animation: cta-sparkle 200ms ease-out forwards;
    }

    @keyframes cta-ring-fill {
      0% {
        opacity: 0.2;
        transform: scale(0.65);
      }
      60% {
        opacity: 0.6;
      }
      100% {
        opacity: 0;
        transform: scale(1.05);
      }
    }

    @keyframes cta-sparkle {
      0% {
        opacity: 0;
        transform: translate(-2px, -4px) scale(0.2);
      }
      50% {
        opacity: 1;
        transform: translate(0, -10px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(2px, -16px) scale(0.4);
      }
    }

    @keyframes button-spin {
      to {
        transform: rotate(360deg);
      }
    }

    .card,
    .peek,
    .task-card,
    .resource-button,
    .worst-day-banner,
    .worst-day-card,
    .distraction-tools,
    .distraction-log li,
    .doorway-reset,
    .gantt-card,
    .chart-summary,
    .subtask-row,
    .routine-block,
    .toast,
    .modal__content,
    .modal-card,
    .wizard-content,
    .audit-card,
    .category-progress .line,
    .category-progress .bar,
    .history-list li,
    .morning-blocks .routine-card,
    .progress-strip,
    .nbt-result-card,
    .task-details,
    .doorway-reset-actions button,
    .next-task-card,
    .due-today-card,
    .status-card,
    .next-best-card {
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      background: var(--surface-elevated);
      max-width: 100%;
      box-sizing: border-box;
    }

    .resource-button,
    .doorway-reset-actions button,
    .card .link-button,
    .next-task-actions button,
    .worst-day-celebrations button,
    .distraction-options button,
    .subtask-actions button,
    .module-inline-actions button,
    .intention-buttons button,
    .card-sticky-actions__primary > *,
    .card-sticky-actions__secondary > * {
      border-radius: 12px;
    }

    .card p,
    .card li,
    .task-card p,
    .task-card .task-descriptors,
    .worst-day-banner p,
    .gantt-card p,
    .doorway-reset p,
    .distraction-log__label,
    .chart-summary li,
    .routine-block p,
    .toast,
    .modal-card p,
    .wizard-content p,
    .next-task-name,
    .next-task-meta,
    .nbt-result-card p,
    .resource-button span,
    .card .score,
    .category-progress .line,
    .next-best-empty,
    .worst-day-hint {
      max-width: 48ch;
    }

    .distraction-tools__header strong,
    .distraction-log__time,
    .worst-day-label,
    .doorway-countdown,
    .card small,
    .chip,
    .score,
    label,
    button,
    input,
    select,
    textarea {
      text-transform: none !important;
      letter-spacing: normal !important;
    }

    .card.collapsed,
    .module-card.collapsed {
      opacity: 0.78;
      filter: saturate(0.85);
    }

    .card.collapsed .card-body,
    .card.collapsed .card-sticky-actions,
    .card.collapsed .next-best-results,
    .card.collapsed .due-today-list,
    .module-card.collapsed .module-body {
      display: none !important;
    }

    .card.collapsed .card-head,
    .module-card.collapsed .module-header {
      border-bottom: none;
    }

    .starter-stack {
      display: grid;
      gap: 0.85rem;
      width: min(100%, 720px);
      position: relative;
      z-index: 10;
    }

    .routine-stack {
      display: grid;
      gap: 1.1rem;
      width: min(100%, 780px);
      margin-top: 1.25rem;
      position: relative;
      z-index: 12;
    }

    .routine-preferences {
      display: flex;
      justify-content: flex-end;
      padding: 0.25rem 0.5rem 0;
    }

    .routine-preferences__toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      background: rgba(12, 20, 30, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
    }

    .routine-preferences__toggle:hover {
      background: rgba(15, 24, 36, 0.75);
      color: var(--text-primary);
    }

    .routine-preferences__toggle input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #38bdf8;
    }

    .routine-preferences__label {
      font-weight: 500;
    }

    .routine-tile {
      position: relative;
      border-radius: 22px;
      overflow: visible;
      isolation: isolate;
    }

    .routine-tile__surface {
      position: relative;
      border-radius: inherit;
      padding: 1.1rem 1.2rem 1.1rem;
      color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 24px 36px rgba(5, 12, 21, 0.45);
      transition: transform 180ms ease, box-shadow 220ms ease;
      overflow: hidden;
      background: linear-gradient(135deg, #1f2937, #111827);
      --routine-context-glow-alpha: 0.18;
    }

    .routine-tile__surface::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: rgba(255, 255, 255, 0.05);
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
    }

    .routine-tile:hover .routine-tile__surface::before {
      opacity: 0.15;
    }

    .routine-tile__surface:focus-within {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.22), 0 26px 40px rgba(6, 10, 20, 0.6);
    }

    .routine-tile__trigger {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      padding: 0;
      text-align: left;
      cursor: pointer;
    }

    .routine-tile__info {
      display: grid;
      gap: 0.35rem;
      flex: 1;
    }

    .routine-tile__title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .routine-tile__prompt {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.85);
    }

    .routine-tile__meta {
      display: grid;
      gap: 0.35rem;
      align-items: center;
      justify-items: end;
      min-width: 2.5rem;
    }

    .routine-info-dot {
      width: 1.6rem;
      height: 1.6rem;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.22);
      color: rgba(255, 255, 255, 0.92);
      font-weight: 600;
      font-size: 0.8rem;
    }

    .routine-tile__chevron {
      display: inline-block;
      width: 0.85rem;
      height: 0.85rem;
      border-right: 2px solid rgba(255, 255, 255, 0.75);
      border-bottom: 2px solid rgba(255, 255, 255, 0.75);
      transform: rotate(-45deg);
      transition: transform 200ms ease;
    }

    .routine-tile--open .routine-tile__chevron {
      transform: rotate(45deg);
    }

    .routine-accent {
      flex-shrink: 0;
      display: grid;
      place-items: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
    }

    .routine-accent__icon {
      font-size: 1.35rem;
      animation: routine-accent-bounce 2.4s infinite ease-in-out;
    }

    @keyframes routine-accent-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .routine-tile__body {
      margin-top: 1rem;
      border-radius: 18px;
      background: rgba(10, 16, 24, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1rem;
      overflow: hidden;
      max-height: 0;
      transition: max-height 240ms ease, padding 240ms ease;
    }

    .routine-tile--open .routine-tile__body {
      padding: 1rem;
    }

    .routine-tile__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.85rem;
    }

    .routine-start-btn {
      background: rgba(255, 255, 255, 0.92);
      color: #0b1520;
      border: none;
      padding: 0.7rem 1.35rem;
      border-radius: 14px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 180ms ease;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
    }

    .routine-start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.4);
    }

    .routine-quick-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .routine-chip {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.15);
      color: rgba(226, 232, 240, 0.95);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .routine-chip:hover {
      background: rgba(148, 163, 184, 0.25);
      transform: translateY(-1px);
    }

    .routine-tile__content {
      display: grid;
      gap: 1rem;
    }

    .routine-tile__surface.routine-theme--morning {
      background: linear-gradient(135deg, #f97316, #facc15);
    }

    .routine-tile__surface.routine-theme--environment {
      background: linear-gradient(135deg, #4ade80, #14b8a6);
    }

    .routine-tile__surface.routine-theme--sleep {
      background: linear-gradient(135deg, #4338ca, #8b5cf6);
    }

    .routine-tile__surface.routine-theme--conflict {
      background: linear-gradient(135deg, #2563eb, #f87171);
    }

    .routine-tile__surface.routine-theme--dopamine {
      background: linear-gradient(135deg, #0ea5e9, #f43f5e);
    }

    .routine-tile__surface.routine-theme--utility {
      background: linear-gradient(135deg, #475569, #94a3b8);
    }

    .routine-tile--context .routine-tile__surface {
      animation: routine-context-glow 3.2s ease-in-out infinite;
    }

    @keyframes routine-context-glow {
      0%,
      100% {
        box-shadow:
          0 26px 36px rgba(7, 13, 24, 0.55),
          0 0 0 0 rgba(255, 255, 255, var(--routine-context-glow-alpha, 0.18));
      }
      50% {
        box-shadow:
          0 28px 40px rgba(7, 13, 24, 0.6),
          0 0 0 14px rgba(255, 255, 255, calc(var(--routine-context-glow-alpha, 0.18) * 0.6));
      }
    }
    .routine-tile__surface.is-pulsing {
      animation: routine-start-pulse 220ms ease;
    }
    @keyframes routine-start-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.01); }
      100% { transform: scale(1); }
    }

    .routine-reminder {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.82);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .routine-quick-overlay {
      position: absolute;
      inset: 0;
      background: rgba(9, 14, 22, 0.75);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: inherit;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    .routine-quick-overlay.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .routine-quick-overlay__content {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 1.1rem;
      width: min(100%, 320px);
      display: grid;
      gap: 0.75rem;
      text-align: left;
      color: #e2e8f0;
      box-shadow: 0 24px 36px rgba(2, 6, 14, 0.55);
    }

    .routine-quick-overlay__title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .routine-quick-overlay__list {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.35rem;
      font-size: 0.9rem;
    }

    .routine-quick-overlay__action {
      background: #38bdf8;
      border: none;
      border-radius: 12px;
      padding: 0.6rem 1rem;
      font-weight: 600;
      color: #03121f;
      cursor: pointer;
    }

    .routine-tile.is-running::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      border: 2px solid rgba(255, 255, 255, 0.65);
      opacity: 0.85;
      animation: routine-running-halo 1.6s linear infinite;
      pointer-events: none;
    }

    @keyframes routine-running-halo {
      0% { transform: scale(0.92); opacity: 0.9; }
      60% { opacity: 0.4; }
      100% { transform: scale(1.05); opacity: 0; }
    }

    .routine-tile--celebrate::after {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      background-image: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.45), transparent 60%), radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.35), transparent 55%), radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.4), transparent 65%);
      opacity: 0;
      animation: routine-celebrate 900ms ease-out forwards;
      pointer-events: none;
    }

    @keyframes routine-celebrate {
      0% { opacity: 0; transform: scale(0.9); }
      20% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.05); }
    }

    .routine-tile__surface.swiping {
      transition: none;
    }

    .routine-sheet {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
    }

    .routine-sheet.is-visible {
      display: grid;
    }

    .routine-sheet__scrim {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 20, 0.65);
      backdrop-filter: blur(4px);
    }

    .routine-sheet__panel {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 24px 24px 0 0;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 1.4rem 1.2rem 1.75rem;
      box-shadow: 0 -22px 45px rgba(2, 6, 14, 0.65);
      transform: translateY(100%);
      transition: transform 240ms ease;
      max-height: 88vh;
      overflow-y: auto;
      display: grid;
      gap: 1rem;
      color: #e2e8f0;
    }

    .routine-sheet.is-visible .routine-sheet__panel {
      transform: translateY(0);
    }

    .routine-sheet__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .routine-sheet__field {
      display: grid;
      gap: 0.35rem;
    }

    .routine-sheet__field input,
    .routine-sheet__field textarea,
    .routine-sheet__field select {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: #e2e8f0;
      padding: 0.55rem 0.65rem;
      font-family: inherit;
    }

    .routine-sheet__actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .routine-sheet__actions button {
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .routine-sheet__save {
      background: #38bdf8;
      border: none;
      color: #04111d;
    }

    .routine-sheet__cancel {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #cbd5f5;
    }

    @media (prefers-reduced-motion: reduce) {
      .routine-tile__surface,
      .routine-tile__body,
      .routine-tile__chevron,
      .routine-accent__icon,
      .routine-tile__surface::before,
      .routine-quick-overlay,
      .routine-sheet__panel {
        transition-duration: 0ms !important;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }
      .routine-tile--context .routine-tile__surface {
        animation: none;
      }
    }

    .routine-stack {
      display: grid;
      gap: 1.1rem;
      width: min(100%, 780px);
      margin-top: 1.25rem;
      position: relative;
      z-index: 12;
    }

    .routine-preferences {
      display: flex;
      justify-content: flex-end;
      padding: 0.25rem 0.5rem 0;
    }

    .routine-preferences__toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      background: rgba(12, 20, 30, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
    }

    .routine-preferences__toggle:hover {
      background: rgba(15, 24, 36, 0.75);
      color: var(--text-primary);
    }

    .routine-preferences__toggle input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #38bdf8;
    }

    .routine-preferences__label {
      font-weight: 500;
    }

    .routine-tile {
      position: relative;
      border-radius: 22px;
      overflow: visible;
      isolation: isolate;
    }

    .routine-tile__surface {
      position: relative;
      border-radius: inherit;
      padding: 1.1rem 1.2rem 1.1rem;
      color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 24px 36px rgba(5, 12, 21, 0.45);
      transition: transform 180ms ease, box-shadow 220ms ease;
      overflow: hidden;
      background: linear-gradient(135deg, #1f2937, #111827);
    }

    .routine-tile__surface::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: rgba(255, 255, 255, 0.05);
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
    }

    .routine-tile:hover .routine-tile__surface::before {
      opacity: 0.15;
    }

    .routine-tile__surface:focus-within {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.22), 0 26px 40px rgba(6, 10, 20, 0.6);
    }

    .routine-tile__trigger {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      padding: 0;
      text-align: left;
      cursor: pointer;
    }

    .routine-tile__info {
      display: grid;
      gap: 0.35rem;
      flex: 1;
    }

    .routine-tile__title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .routine-tile__prompt {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.85);
    }

    .routine-tile__meta {
      display: grid;
      gap: 0.35rem;
      align-items: center;
      justify-items: end;
      min-width: 2.5rem;
    }

    .routine-info-dot {
      width: 1.6rem;
      height: 1.6rem;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.22);
      color: rgba(255, 255, 255, 0.92);
      font-weight: 600;
      font-size: 0.8rem;
    }

    .routine-tile__chevron {
      display: inline-block;
      width: 0.85rem;
      height: 0.85rem;
      border-right: 2px solid rgba(255, 255, 255, 0.75);
      border-bottom: 2px solid rgba(255, 255, 255, 0.75);
      transform: rotate(-45deg);
      transition: transform 200ms ease;
    }

    .routine-tile--open .routine-tile__chevron {
      transform: rotate(45deg);
    }

    .routine-accent {
      flex-shrink: 0;
      display: grid;
      place-items: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
    }

    .routine-accent__icon {
      font-size: 1.35rem;
      animation: routine-accent-bounce 2.4s infinite ease-in-out;
    }

    @keyframes routine-accent-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .routine-tile__body {
      margin-top: 1rem;
      border-radius: 18px;
      background: rgba(10, 16, 24, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1rem;
      overflow: hidden;
      max-height: 0;
      transition: max-height 240ms ease, padding 240ms ease;
    }

    .routine-tile--open .routine-tile__body {
      padding: 1rem;
    }

    .routine-tile__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.85rem;
    }

    .routine-start-btn {
      background: rgba(255, 255, 255, 0.92);
      color: #0b1520;
      border: none;
      padding: 0.7rem 1.35rem;
      border-radius: 14px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 180ms ease;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
    }

    .routine-start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.4);
    }

    .routine-quick-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .routine-chip {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.15);
      color: rgba(226, 232, 240, 0.95);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .routine-chip:hover {
      background: rgba(148, 163, 184, 0.25);
      transform: translateY(-1px);
    }

    .routine-tile__content {
      display: grid;
      gap: 1rem;
    }

    .routine-tile__surface.routine-theme--morning {
      background: linear-gradient(135deg, #f97316, #facc15);
    }

    .routine-tile__surface.routine-theme--environment {
      background: linear-gradient(135deg, #4ade80, #14b8a6);
    }

    .routine-tile__surface.routine-theme--sleep {
      background: linear-gradient(135deg, #4338ca, #8b5cf6);
    }

    .routine-tile__surface.routine-theme--conflict {
      background: linear-gradient(135deg, #2563eb, #f87171);
    }

    .routine-tile__surface.routine-theme--dopamine {
      background: linear-gradient(135deg, #0ea5e9, #f43f5e);
    }

    .routine-tile__surface.routine-theme--utility {
      background: linear-gradient(135deg, #475569, #94a3b8);
    }

    .routine-tile--context .routine-tile__surface {
      animation: routine-context-glow 3.2s ease-in-out infinite;
    }

    @keyframes routine-context-glow {
      0%,
      100% {
        box-shadow:
          0 26px 36px rgba(7, 13, 24, 0.55),
          0 0 0 0 rgba(255, 255, 255, var(--routine-context-glow-alpha, 0.18));
      }
      50% {
        box-shadow:
          0 28px 40px rgba(7, 13, 24, 0.6),
          0 0 0 14px rgba(255, 255, 255, calc(var(--routine-context-glow-alpha, 0.18) * 0.6));
      }
    }
    .routine-tile__surface.is-pulsing {
      animation: routine-start-pulse 220ms ease;
    }
    @keyframes routine-start-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.01); }
      100% { transform: scale(1); }
    }

    .routine-reminder {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.82);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .routine-quick-overlay {
      position: absolute;
      inset: 0;
      background: rgba(9, 14, 22, 0.75);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: inherit;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    .routine-quick-overlay.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .routine-quick-overlay__content {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 1.1rem;
      width: min(100%, 320px);
      display: grid;
      gap: 0.75rem;
      text-align: left;
      color: #e2e8f0;
      box-shadow: 0 24px 36px rgba(2, 6, 14, 0.55);
    }

    .routine-quick-overlay__title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .routine-quick-overlay__list {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.35rem;
      font-size: 0.9rem;
    }

    .routine-quick-overlay__action {
      background: #38bdf8;
      border: none;
      border-radius: 12px;
      padding: 0.6rem 1rem;
      font-weight: 600;
      color: #03121f;
      cursor: pointer;
    }

    .routine-tile.is-running::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      border: 2px solid rgba(255, 255, 255, 0.65);
      opacity: 0.85;
      animation: routine-running-halo 1.6s linear infinite;
      pointer-events: none;
    }

    @keyframes routine-running-halo {
      0% { transform: scale(0.92); opacity: 0.9; }
      60% { opacity: 0.4; }
      100% { transform: scale(1.05); opacity: 0; }
    }

    .routine-tile--celebrate::after {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      background-image: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.45), transparent 60%),
        radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.35), transparent 55%),
        radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.4), transparent 65%);
      opacity: 0;
      animation: routine-celebrate 900ms ease-out forwards;
      pointer-events: none;
    }

    @keyframes routine-celebrate {
      0% { opacity: 0; transform: scale(0.9); }
      20% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.05); }
    }

    .routine-tile__surface.swiping {
      transition: none;
    }

    .routine-sheet {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
    }

    .routine-sheet.is-visible {
      display: grid;
    }

    .routine-sheet__scrim {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 20, 0.65);
      backdrop-filter: blur(4px);
    }

    .routine-sheet__panel {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 24px 24px 0 0;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 1.4rem 1.2rem 1.75rem;
      box-shadow: 0 -22px 45px rgba(2, 6, 14, 0.65);
      transform: translateY(100%);
      transition: transform 240ms ease;
      max-height: 88vh;
      overflow-y: auto;
      display: grid;
      gap: 1rem;
      color: #e2e8f0;
    }

    .routine-sheet.is-visible .routine-sheet__panel {
      transform: translateY(0);
    }

    .routine-sheet__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .routine-sheet__field {
      display: grid;
      gap: 0.35rem;
    }

    .routine-sheet__field input,
    .routine-sheet__field textarea,
    .routine-sheet__field select {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: #e2e8f0;
      padding: 0.55rem 0.65rem;
      font-family: inherit;
    }

    .routine-sheet__actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .routine-sheet__actions button {
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .routine-sheet__save {
      background: #38bdf8;
      border: none;
      color: #04111d;
    }

    .routine-sheet__cancel {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #cbd5f5;
    }

    @media (prefers-reduced-motion: reduce) {
      .routine-tile__surface,
      .routine-tile__body,
      .routine-tile__chevron,
      .routine-accent__icon,
      .routine-tile__surface::before,
      .routine-quick-overlay,
      .routine-sheet__panel {
        transition-duration: 0ms !important;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }
      .routine-tile--context .routine-tile__surface {
        animation: none;
      }
    }

    .starter-micro-header {
      position: sticky;
      top: 0.75rem;
      z-index: 40;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
      padding: 0.4rem 0.6rem;
      border-radius: 999px;
      background: rgba(10, 16, 22, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 18px 34px rgba(2, 8, 18, 0.45);
      backdrop-filter: blur(12px);
    }

    .starter-micro-header .start-action {
      flex-shrink: 0;
    }

    .starter-fit-chips {
      display: flex;
      gap: 0.4rem;
      flex-wrap: nowrap;
      overflow: hidden;
      flex: 1;
      min-height: 1.65rem;
    }

    .starter-fit-chips .chip {
      font-size: 0.78rem;
      white-space: nowrap;
      background: rgba(148, 163, 184, 0.16);
      border: 1px solid rgba(148, 163, 184, 0.22);
    }

    .starter-rescue {
      flex-shrink: 0;
      font-size: 0.85rem;
      padding: 0.35rem 0.85rem;
      background: rgba(239, 68, 68, 0.18);
      border: 1px solid rgba(239, 68, 68, 0.35);
    }

    .stage-strip {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(13, 18, 26, 0.82);
    }

    .stage-strip .preflight-toggles {
      display: inline-flex;
      gap: 0.35rem;
    }

    .starter-micro-header #categoryProgress {
      margin-inline: 0.35rem;
    }

    .next-focus-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .next-focus-head__titles {
      display: grid;
      gap: 0.2rem;
    }

    .next-focus-hint {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .next-best-inline {
      display: grid;
      gap: 0.75rem;
    }

    .next-best-toolbar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .peek { background: #222; margin-top: 1rem; padding: 1rem; border-radius: 6px; max-width: 600px; }
    .peek summary { cursor: pointer; }
    .task-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      width: 100%;
      min-width: 0;
    }

    .task-list-header > * {
      min-width: 0;
    }
    .time-budget-control {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: #a0a0a0;
    }
    .time-budget-control select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .show-all-toggle {
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .task-view-label {
      color: #a0a0a0;
      font-size: 0.85rem;
    }
    .task-view-select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .task-card {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 0.65rem 0.75rem;
      margin-bottom: 0.65rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      touch-action: pan-y;
    }
    .task-card.is-completed {
      background: #161616;
      border: 1px solid #2a2a2a;
    }
    .task-card-header {
      display: block;
      margin-bottom: 0.15rem;
    }
    .task-card-title-group {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1;
      min-width: 0;
    }
    .task-title {
      font-size: clamp(1rem, 3.6vw, 1.1rem);
      font-weight: 600;
      margin: 0;
      line-height: 1.4;
      color: #fff;
      word-break: break-word;
    }
    .task-complete-indicator {
      color: #8fc97a;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .task-card-actions {
      display: flex;
      gap: 0.3rem;
      flex-wrap: nowrap;
      align-items: center;
    }
    .task-card-actions button {
      font-size: 0.9rem;
      padding: 0.2rem 0.4rem;
      line-height: 1;
      min-width: 0;
      margin: 0;
    }
    .task-card-actions button:first-child {
      order: 3;
    }
    .task-card-actions button:first-child:not(:last-child) {
      margin-left: auto;
    }
    .task-card-actions button:nth-child(2) {
      order: 4;
    }
    .task-card-actions button:nth-child(3) {
      order: 1;
    }
    .task-card-actions button:nth-child(4) {
      order: 2;
    }
    .task-descriptors {
      font-size: 0.8rem;
      color: #b0b0b0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .task-descriptors span::before {
      content: "•";
      margin-right: 0.25rem;
      color: #555;
    }
    .task-descriptors span:first-child::before {
      content: "";
      margin: 0;
    }
    .task-progress {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .task-progress-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .task-progress-meter {
      background: rgba(148, 163, 184, 0.22);
      border-radius: 999px;
      overflow: hidden;
      height: 3px;
      width: 100%;
    }
    .task-progress-meter .fill {
      display: block;
      height: 100%;
      background: rgba(45, 212, 195, 0.85);
      width: 0%;
      transition: width 150ms ease-out;
    }
    .task-meta {
      font-size: 0.75rem;
      color: #8f9aa8;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .task-detail-toggle {
      align-self: flex-start;
      background: #2a2a2a;
      font-size: 0.8rem;
      padding: 0.35rem 0.6rem;
    }
    .task-details {
      font-size: 0.8rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.6rem;
      width: 100%;
      box-sizing: border-box;
    }
    .task-details h5 {
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
      color: #eee;
    }
    .task-details ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .task-details li {
      margin: 0.25rem 0;
    }
    .score { font-size: 0.8rem; color: #ccc; }
    #focusFitHint {
      color: #8f9aa8;
      font-size: 0.85rem;
      margin-top: 0.35rem;
      max-width: 100%;
      text-align: left;
    }
    .chart-age, .urgency-hint {
      display: block;
      margin-top: 0.25rem;
      color: #aaa;
      font-size: 0.85rem;
      max-width: 600px;
    }
    .focus {
      font-size: 1.5rem;
      margin: 1rem 0;
      padding: 1.25rem;
      background: rgba(18, 24, 30, 0.88);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(147, 160, 170, 0.18);
    }
    .distraction-tools {
      margin-top: 1rem;
      background: rgba(18, 18, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 0.85rem;
      width: min(100%, 560px);
      display: grid;
      gap: 0.55rem;
    }
    .distraction-tools__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .distraction-tools__header strong {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9aa0a6;
    }
    .distraction-prompt {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.85rem;
      color: #cdd5e0;
    }
    .distraction-prompt span {
      opacity: 0.8;
    }
    .distraction-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .distraction-options button {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    .distraction-log {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.35rem;
      font-size: 0.82rem;
      color: #bfc7d3;
    }
    .distraction-log li {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      background: rgba(12, 18, 24, 0.85);
      border-radius: 8px;
      padding: 0.4rem 0.55rem;
    }
    .distraction-log__time {
      font-weight: 600;
      color: #8ab4ff;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .distraction-log__label {
      flex: 1;
      color: #e4e9f2;
    }
    .distraction-log li.distraction-empty {
      justify-content: center;
      background: rgba(32, 34, 36, 0.65);
      color: #7d8796;
      font-weight: 500;
    }
    .doorway-reset {
      background: rgba(26, 28, 38, 0.85);
      border-radius: 10px;
      border: 1px solid rgba(123, 216, 143, 0.25);
      padding: 0.6rem 0.75rem;
      display: grid;
      gap: 0.4rem;
    }
    .doorway-reset-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      align-items: center;
    }
    .doorway-countdown {
      font-size: 0.85rem;
      color: #7bd88f;
      font-weight: 600;
    }
    .gantt-card {
      background: rgba(15, 18, 26, 0.98);
      border-radius: 14px;
      padding: 1.1rem;
      width: min(92vw, 640px);
      box-shadow: 0 26px 48px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f5f7fb;
    }
    .gantt-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .gantt-intro {
      font-size: 0.85rem;
      color: #9aa0a6;
      margin: 0;
    }
    .gantt-blocks-wrapper {
      position: relative;
      background: rgba(11, 16, 24, 0.9);
      border-radius: 12px;
      padding: 0.85rem;
      overflow: hidden;
    }
    .gantt-blocks {
      display: flex;
      gap: 0.55rem;
      width: 100%;
      min-height: 110px;
      position: relative;
      z-index: 1;
    }
    .gantt-block {
      flex: 1;
      min-width: 100px;
      border-radius: 10px;
      background: linear-gradient(140deg, rgba(10, 132, 255, 0.65), rgba(123, 216, 143, 0.65));
      padding: 0.65rem;
      display: grid;
      gap: 0.35rem;
    }
    .gantt-block strong {
      font-size: 0.95rem;
    }
    .gantt-block small {
      color: rgba(245, 247, 251, 0.8);
      font-size: 0.75rem;
    }
    .gantt-progress {
      position: absolute;
      inset: 0;
      width: 0;
      background: rgba(123, 216, 143, 0.28);
      transition: width 320ms ease;
      z-index: 0;
    }
    .gantt-progress.is-paused {
      background: repeating-linear-gradient(135deg, rgba(123, 216, 143, 0.1), rgba(123, 216, 143, 0.1) 12px, rgba(10, 132, 255, 0.12) 12px, rgba(10, 132, 255, 0.12) 24px);
    }
    .gantt-status {
      font-size: 0.85rem;
      color: #a6b3c5;
      min-height: 1.2em;
    }
    .worst-day-banner {
      background: var(--surface-elevated);
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      padding: 1rem;
      display: grid;
      gap: 0.55rem;
      justify-items: center;
    }
    .worst-day-banner h2 {
      margin: 0;
      font-size: 1.05rem;
      color: #f8f9fb;
    }
    .worst-day-button {
      width: 100%;
      max-width: 520px;
      font-size: 1.05rem;
      font-weight: 600;
      padding: 0.85rem 1.1rem;
      border-radius: 12px;
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      box-shadow: none;
    }
    .worst-day-button.hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }
    .worst-day-button:disabled {
      box-shadow: none;
    }
    .worst-day-hint {
      margin: 0;
      font-size: 0.85rem;
      color: #c4c9d4;
      text-align: center;
    }
    .worst-day-card {
      background: var(--surface-elevated);
      border-radius: var(--card-radius);
      padding: 1.25rem;
      width: min(92vw, 520px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f8f9fb;
      position: relative;
    }
    .worst-day-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .worst-day-subheading {
      margin: 0;
      font-size: 0.9rem;
      color: #aeb7c8;
    }
    .worst-day-focus-line {
      display: flex;
      gap: 0.5rem;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .worst-day-label {
      font-size: 0.8rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #8fa5ff;
    }
    .worst-day-timer {
      font-size: 2.5rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-align: center;
      color: #7bd88f;
    }
    .worst-day-prompt {
      margin: 0;
      font-size: 0.9rem;
      color: #c4cad8;
      text-align: center;
    }
    .worst-day-actions {
      display: grid;
      gap: 0.65rem;
      text-align: center;
    }
    .worst-day-celebrations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      justify-content: center;
    }
    .worst-day-celebrations button {
      font-size: 0.9rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
    }
    .worst-day-celebration {
      min-height: 1.2rem;
      font-size: 0.9rem;
      color: #f4d47c;
    }
    @media (max-width: 600px) {
      .distraction-tools {
        padding: 0.75rem;
      }
      .gantt-block {
        min-width: 80px;
      }
      .worst-day-button {
        font-size: 1rem;
      }
    }

    @media (max-width: 520px) {
      .starter-micro-header {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      .starter-micro-header .start-action,
      .starter-micro-header .starter-rescue {
        width: 100%;
        margin: 0;
      }

      .starter-fit-chips {
        justify-content: center;
        flex-wrap: wrap;
        overflow: visible;
      }
    }

    @media (max-width: 540px) {
      #focus.focus-overlay {
        padding: clamp(0.6rem, 4vw, 1rem);
        align-items: stretch;
      }

      .focus-overlay__sheet {
        width: 100%;
        border-radius: 22px 22px 14px 14px;
      }

      .focus-overlay__body {
        padding-right: 0;
        gap: var(--space-2);
      }

      .focus {
        font-size: 1.35rem;
        padding: 1rem;
      }

      .focus-overlay__summary {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      .focus-overlay__summary .task-counter {
        text-align: left;
      }

      .subtask-row:not(.focus-overlay__task) {
        display: grid;
        grid-template-columns: auto 1fr;
        column-gap: 0.4rem;
        row-gap: 0.35rem;
        align-items: center;
      }

      .subtask-row:not(.focus-overlay__task) > input[type="checkbox"] {
        grid-column: 1;
        grid-row: 1;
      }

      .subtask-row:not(.focus-overlay__task) .subtask-name {
        grid-column: 2;
        grid-row: 1;
        margin-left: 0.15rem;
      }

      .subtask-row:not(.focus-overlay__task) .timer-label {
        grid-column: 2;
        grid-row: 2;
        margin-left: 0;
        justify-self: end;
        min-width: 0;
        font-size: 0.72rem;
      }

      #focus.focus-overlay .focus-overlay__task {
        gap: 0.35rem;
      }
#focus.focus-overlay .focus-overlay__task {
  gap: 0.35rem;
}

#focus.focus-overlay .focus-overlay__task .task-actions {
  justify-content: flex-start;
}

/* INSERT OUR BLOCK RIGHT HERE */
      #focus.focus-overlay .focus-overlay__task .task-actions {
        justify-content: flex-start;
      }

      .distraction-tools {
        width: 100%;
      }
    }
    .distraction-tools {
      margin-top: 1rem;
      background: rgba(18, 18, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 0.85rem;
      width: min(100%, 560px);
      display: grid;
      gap: 0.55rem;
    }
    .distraction-tools__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .distraction-tools__header strong {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9aa0a6;
    }
    .distraction-prompt {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.85rem;
      color: #cdd5e0;
    }
    .distraction-prompt span {
      opacity: 0.8;
    }
    .distraction-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .distraction-options button {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    .distraction-log {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.35rem;
      font-size: 0.82rem;
      color: #bfc7d3;
    }
    .distraction-log li {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      background: rgba(12, 18, 24, 0.85);
      border-radius: 8px;
      padding: 0.4rem 0.55rem;
    }
    .distraction-log__time {
      font-weight: 600;
      color: #8ab4ff;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .distraction-log li.distraction-empty {
      justify-content: center;
      background: rgba(32, 34, 36, 0.65);
      color: #7d8796;
      font-weight: 500;
    }
    .doorway-reset {
      background: rgba(26, 28, 38, 0.85);
      border-radius: 10px;
      border: 1px solid rgba(123, 216, 143, 0.25);
      padding: 0.6rem 0.75rem;
      display: grid;
      gap: 0.4rem;
    }
    .doorway-reset-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      align-items: center;
    }
    .doorway-countdown {
      font-size: 0.85rem;
      color: #7bd88f;
      font-weight: 600;
    }
    .gantt-card {
      background: rgba(15, 18, 26, 0.98);
      border-radius: 14px;
      padding: 1.1rem;
      width: min(92vw, 640px);
      box-shadow: 0 26px 48px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f5f7fb;
    }
    .gantt-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .gantt-intro {
      font-size: 0.85rem;
      color: #9aa0a6;
      margin: 0;
    }
    .gantt-blocks-wrapper {
      position: relative;
      background: rgba(11, 16, 24, 0.9);
      border-radius: 12px;
      padding: 0.85rem;
      overflow: hidden;
    }
    .gantt-blocks {
      display: flex;
      gap: 0.55rem;
      width: 100%;
      min-height: 110px;
      position: relative;
      z-index: 1;
    }
    .gantt-block {
      flex: 1;
      min-width: 100px;
      border-radius: 10px;
      background: linear-gradient(140deg, rgba(10, 132, 255, 0.65), rgba(123, 216, 143, 0.65));
      padding: 0.65rem;
      display: grid;
      gap: 0.35rem;
    }
    .gantt-block strong {
      font-size: 0.95rem;
    }
    .gantt-block small {
      color: rgba(245, 247, 251, 0.8);
      font-size: 0.75rem;
    }
    .gantt-progress {
      position: absolute;
      inset: 0;
      width: 0;
      background: rgba(123, 216, 143, 0.28);
      transition: width 320ms ease;
      z-index: 0;
    }
    .gantt-progress.is-paused {
      background: repeating-linear-gradient(135deg, rgba(123, 216, 143, 0.1), rgba(123, 216, 143, 0.1) 12px, rgba(10, 132, 255, 0.12) 12px, rgba(10, 132, 255, 0.12) 24px);
    }
    .gantt-status {
      font-size: 0.85rem;
      color: #a6b3c5;
      min-height: 1.2em;
    }
    .worst-day-banner {
      background: linear-gradient(120deg, rgba(44, 44, 52, 0.85), rgba(26, 28, 38, 0.85));
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 1rem;
      display: grid;
      gap: 0.55rem;
      justify-items: center;
    }
    .worst-day-banner h2 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.02em;
      color: #f8f9fb;
    }
    .worst-day-button {
      width: 100%;
      max-width: 520px;
      font-size: 1.05rem;
      font-weight: 600;
      padding: 0.85rem 1.1rem;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255, 102, 126, 0.95), rgba(255, 159, 108, 0.9));
      color: #121212;
      border: none;
      cursor: pointer;
      box-shadow: 0 18px 32px rgba(255, 102, 126, 0.25);
    }
    .worst-day-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .worst-day-hint {
      margin: 0;
      font-size: 0.85rem;
      color: #c4c9d4;
      text-align: center;
    }
    .worst-day-card {
      background: rgba(18, 20, 28, 0.97);
      border-radius: 16px;
      padding: 1.25rem;
      width: min(92vw, 520px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f8f9fb;
      position: relative;
    }
    .worst-day-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .worst-day-subheading {
      margin: 0;
      font-size: 0.9rem;
      color: #aeb7c8;
    }
    .worst-day-focus-line {
      display: flex;
      gap: 0.5rem;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .worst-day-label {
      font-size: 0.8rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #8fa5ff;
    }
    .worst-day-timer {
      font-size: 2.5rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-align: center;
      color: #7bd88f;
    }
    .worst-day-prompt {
      margin: 0;
      font-size: 0.9rem;
      color: #c4cad8;
      text-align: center;
    }
    .worst-day-actions {
      display: grid;
      gap: 0.65rem;
      text-align: center;
    }
    .worst-day-celebrations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      justify-content: center;
    }
    .worst-day-celebrations button {
      font-size: 0.9rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
    }
    .worst-day-celebration {
      min-height: 1.2rem;
      font-size: 0.9rem;
      color: #f4d47c;
    }
    @media (max-width: 600px) {
      .distraction-tools {
        padding: 0.75rem;
      }
      .gantt-block {
        min-width: 80px;
      }
      .worst-day-button {
        font-size: 1rem;
      }
    }
    .category-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .category-filter button {
      background: #444;
      color: #fff;
      border: none;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .category-filter button.active {
      background: #666;
    }
    .category-progress {
      position: relative;
      display: grid;
      gap: 0.45rem;
      padding: 0.5rem 0.7rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(8, 16, 24, 0.9);
      box-shadow: 0 14px 28px rgba(2, 8, 18, 0.32);
      flex: 1 0 100%;
      min-height: 48px;
    }
    .category-progress__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .category-progress__title {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(236, 254, 255, 0.92);
    }
    .category-progress__label {
      font-size: 0.82rem;
      color: var(--text-secondary);
      white-space: nowrap;
    }
    .category-progress__meter {
      position: relative;
      width: 100%;
      height: 16px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      overflow: hidden;
    }
    .category-progress__fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #0f766e, #14b8a6);
      box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      transition: width 150ms ease-out, background 220ms ease, box-shadow 220ms ease;
    }
    .category-progress__fill.is-warm {
      background: linear-gradient(90deg, #14b8a6, #5eead4);
    }
    .category-progress__fill.is-complete {
      background: linear-gradient(90deg, #22d3ee, #a7f3d0);
      box-shadow: 0 0 18px rgba(125, 231, 220, 0.55);
    }
    .category-progress__fill.progress-glow {
      animation: chartGlowPulse 620ms ease-out;
    }
    .category-progress__fill.complete-pulse {
      animation: chartCompletePulse 1.5s ease-out;
    }
    .category-progress__floating {
      position: absolute;
      top: -26px;
      right: 0.35rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      font-size: 0.72rem;
      background: rgba(34, 197, 187, 0.18);
      border: 1px solid rgba(125, 231, 220, 0.35);
      color: rgba(203, 255, 250, 0.95);
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 160ms ease, transform 160ms ease;
      pointer-events: none;
    }
    .category-progress__floating.is-visible {
      opacity: 1;
      transform: translateY(-12px);
    }
    @media (max-width: 400px) {
      .category-progress {
        min-height: 60px;
      }
      .category-progress__header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.4rem;
      }
      .category-progress__label {
        white-space: normal;
      }
    }
    @keyframes chartGlowPulse {
      0% {
        box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      }
      45% {
        box-shadow: 0 0 18px rgba(45, 212, 195, 0.48);
      }
      100% {
        box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      }
    }
    @keyframes chartCompletePulse {
      0% {
        box-shadow: 0 0 0 rgba(125, 231, 220, 0.35);
      }
      40% {
        box-shadow: 0 0 22px rgba(125, 231, 220, 0.85);
      }
      100% {
        box-shadow: 0 0 18px rgba(125, 231, 220, 0.55);
      }
    }
    .subtask-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.4rem 0;
      padding: 0.5rem;
      background: #1a1a1a;
      border-radius: 6px;
    }
    .subtask-row.completed {
      opacity: 0.7;
    }
    .subtask-name {
      flex: 1;
      margin-left: 0.35rem;
    }
    .subtask-actions {
      display: flex;
      gap: 0.25rem;
    }
    .subtask-actions button {
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
    }
    .timer-label {
      font-size: 0.75rem;
      color: #9aa0a6;
      min-width: 96px;
      text-align: right;
      margin-left: auto;
    }
    .chart-summary {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #181818;
      border-radius: 6px;
      width: 100%;
      max-width: 600px;
    }
    .chart-summary h4 {
      margin: 0 0 0.5rem;
    }
    .chart-summary ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .chart-summary li {
      margin: 0.25rem 0;
      padding: 0.35rem;
      background: #202020;
      border-radius: 4px;
    }
    .chart-summary li.longest-step {
      border: 1px solid #0a84ff;
      background: #0a1a33;
    }
    .chart-fields {
      width: 100%;
      overflow: hidden;
      max-height: 1000px;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 250ms ease, max-height 250ms ease;
    }
    .chart-fields.is-hidden {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .chart-total {
      margin-top: 0.5rem;
      font-weight: 600;
    }
    .chart-step-controls {
      margin-top: 0.75rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chart-step-controls button {
      font-size: 0.85rem;
    }
    #focusTimer {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #d0dcff;
    }
    #focusTimer.pulse {
      animation: focus-pulse 1s ease-out;
    }
    @keyframes focus-pulse {
      0% { color: #d0dcff; }
      50% { color: #0a84ff; }
      100% { color: #d0dcff; }
    }
    .sound-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
    }
    .sound-toggle input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #0a84ff;
    }
    .audit-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 999;
    }
    .audit-modal {
      background: #151515;
      border-radius: 10px;
      max-width: 520px;
      width: 100%;
      padding: 1.25rem;
      color: #f5f5f5;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }
    .audit-modal h3 {
      margin: 0 0 0.75rem;
    }
    .audit-summary {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #d0dcff;
    }
    .audit-task-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }
    .audit-task-list li {
      background: #1f1f1f;
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 0.85rem;
      color: #e0e0e0;
    }
    .audit-task-list li strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .audit-task-subtasks {
      margin: 0.35rem 0 0;
      padding-left: 1rem;
      color: #b0b0b0;
    }
    .audit-modal button {
      margin-top: 1rem;
    }
    [aria-live] { outline: none; }
    .meltdown-shield {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      width: min(340px, 90vw);
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1rem;
      color: #f5f5f5;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      z-index: 1300;
    }
    .meltdown-shield-header {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 0.75rem;
    }
    .meltdown-shield-prompt {
      font-size: 0.95rem;
      background: rgba(32, 32, 32, 0.85);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      line-height: 1.45;
    }
    .meltdown-shield-prompt strong {
      display: block;
      margin-bottom: 0.35rem;
    }
    .meltdown-shield ul {
      margin: 0 0 0.75rem;
      padding-left: 1.1rem;
      font-size: 0.9rem;
      max-height: 160px;
      overflow-y: auto;
    }
    .meltdown-shield li {
      margin: 0.4rem 0;
      line-height: 1.4;
    }
    .meltdown-shield-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .meltdown-shield button {
      font-size: 0.85rem;
    }
    .meltdown-top-task {
      color: #7bd88f;
      font-weight: 600;
    }
    .module-card {
      width: 100%;
      max-width: 720px;
      background: #181818;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin: 1rem 0;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
    }
    .module-card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.35rem;
    }
    .module-card p {
      margin: 0.25rem 0 0.75rem;
      color: #c9d1d9;
      line-height: 1.45;
    }
    .module-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .module-toggle label {
      margin: 0;
      font-weight: 600;
    }
    .module-toggle input[type="checkbox"],
    .module-toggle input[type="time"] {
      accent-color: #0a84ff;
      background: #111;
      color: #fff;
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      border-radius: 6px;
    }
    .morning-blocks {
      display: grid;
      gap: 0.75rem;
      margin: 0.75rem 0;
    }
    .routine-block {
      background: rgba(12, 12, 12, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.85rem;
      display: grid;
      gap: 0.5rem;
    }
    .routine-block.completed {
      border-color: rgba(123, 216, 143, 0.6);
      background: rgba(18, 40, 20, 0.85);
    }
    .routine-block h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .routine-block small {
      color: #a0aec0;
      display: block;
    }
    .countdown-display {
      font-size: 1.25rem;
      font-weight: 600;
      color: #7bd88f;
    }
    .intention-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .intention-buttons button {
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(34, 34, 34, 0.85);
    }
    .progress-strip {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      position: relative;
      margin: 0.5rem 0;
    }
    .progress-strip span {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #0a84ff, #7bd88f);
      transition: width 200ms ease-out;
    }
    .module-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .history-list {
      margin: 0.5rem 0 0;
      padding: 0;
      list-style: none;
      font-size: 0.85rem;
      color: #aab8c8;
    }
    .history-list li {
      padding: 0.3rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    .history-list li:last-child {
      border-bottom: none;
    }
    .toast-container {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      display: grid;
      gap: 0.75rem;
      z-index: 1500;
    }
    .toast {
      background: rgba(30, 30, 30, 0.95);
      border-left: 4px solid #0a84ff;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      color: #f5f5f5;
      min-width: 220px;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    }
        .toast strong {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.95rem;
    }
    .toast__action {
      margin-top: 0.6rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.45);
      color: #f8fafc;
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      cursor: pointer;
    }
    .toast__action:hover {
      background: rgba(148, 163, 184, 0.2);
    }
    .toast--bottom {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1600;
    }
    .toast--inline {
      border-left-color: #38bdf8;
    }
    .wizard-overlay,
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1400;
    }
    .wizard-content,
    .modal-card {
      background: #121212;
      border-radius: 12px;
      padding: 1.25rem;
      max-width: 520px;
      width: 100%;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      color: #f1f5f9;
    }

    .modal-card--wide {
      max-width: 720px;
    }
    .wizard-content h3,
    .modal-card h3 {
      margin: 0 0 0.75rem;
    }
    .wizard-steps {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .wizard-steps label {
      font-size: 0.85rem;
    }
    .wizard-actions,
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    .launch-pad-settings {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-settings select,
    .launch-pad-settings input[type="text"] {
      background: #222;
      color: #eee;
      border: 1px solid #444;
      padding: 0.45rem;
      border-radius: 6px;
    }
    .launch-pad-list {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-item {
      display: grid;
      grid-template-columns: 1fr minmax(110px, 150px) auto;
      align-items: center;
      gap: 0.5rem;
      background: rgba(20, 20, 20, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    .launch-pad-item small {
      color: #9aa0a6;
      font-size: 0.75rem;
    }
    .sleep-checklist {
      display: grid;
      gap: 0.5rem;
      margin: 0.75rem 0;
    }
    .sleep-checklist label {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      background: rgba(15, 15, 15, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .sleep-checklist input[type="checkbox"] {
      margin-top: 0.1rem;
      accent-color: #7bd88f;
    }
    .sleep-tips {
      display: grid;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: #9aa0a6;
    }
    .sleep-summary {
      font-size: 0.9rem;
      background: rgba(18, 26, 36, 0.85);
      border-radius: 8px;
      padding: 0.6rem;
      margin-top: 0.75rem;
    }
    .sunlight-alert {
      margin-top: 0.75rem;
      padding: 0.65rem;
      border-radius: 8px;
      background: rgba(40, 36, 16, 0.85);
      color: #f8e3a1;
      font-size: 0.85rem;
    }
    .energy-rating {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .energy-rating input[type="range"] {
      flex: 1;
    }
    .celebration {
      background: rgba(14, 48, 22, 0.85);
      border-left: 3px solid #7bd88f;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #d2ffde;
      margin-top: 0.5rem;
    }
    .launch-pad-summary {
      background: rgba(22, 24, 30, 0.9);
      border-radius: 10px;
      padding: 0.75rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .launch-pad-summary strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .routine-affirmation {
      font-size: 0.85rem;
      color: #f0ead6;
      background: rgba(50, 42, 24, 0.6);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      margin-top: 0.5rem;
    }
    .morning-chart-wrapper {
      margin-top: 0.75rem;
      background: #191919;
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 0.75rem;
      border-radius: 10px;
    }
    .chart-canvas {
      width: 100%;
      max-width: 360px;
      height: 160px;
      display: block;
      margin: 0 auto;
    }
    .chart-legend {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: #a5adba;
      margin-top: 0.5rem;
      justify-content: center;
    }
    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 0.35rem;
    }
    .legend-swatch.completion {
      background: #0a84ff;
    }
    .legend-swatch.energy {
      background: #f97316;
    }
    .module-note {
      font-size: 0.78rem;
      color: #9ba6b9;
      margin-top: 0.5rem;
      text-align: center;
    }

    :root {
      --accent: var(--hero-teal);
      --background: #12161a;
      --surface: rgba(18, 24, 30, 0.92);
      --surface-muted: rgba(22, 28, 34, 0.9);
      --border: var(--card-border-color);
      --text-primary: #e6eef7;
      --text-secondary: #93a0aa;
      --text-muted: #6b7280;
      --radius-lg: var(--card-radius);
      --radius-md: 12px;
      --shadow-soft: 0 18px 36px rgba(0, 0, 0, 0.35);
      --space-1: 8px;
      --space-2: 12px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;
      --transition: 200ms ease-in-out;
    }

    body {
      background: var(--background);
      color: var(--text-primary);
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: var(--page-padding-top) 0 var(--page-padding-bottom);
      line-height: 1.5;
      font-weight: 400;
      overflow-x: hidden;
    }

    .app-shell {
      width: min(100%, 1100px);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
      padding-inline: var(--page-gutter);
      box-sizing: border-box;
      min-width: 0;
    }

    @media (max-width: 1024px) {
      .app-shell {
        width: min(100%, 960px);
      }
    }

    @media (max-width: 768px) {
      :root {
        --page-gutter: clamp(0.85rem, 4vw, 1.75rem);
        --page-padding-top: clamp(1.25rem, 5vw, 2rem);
      }

      .app-shell {
        width: min(100%, 720px);
      }
    }

    @media (max-width: 600px) {
      :root {
        --page-gutter: clamp(0.75rem, 5vw, 1.25rem);
        --page-padding-top: clamp(1rem, 6vw, 1.5rem);
        --page-padding-bottom: 100px;
      }

      .card {
        padding: var(--space-3);
        gap: var(--space-2);
      }

      .card-sticky-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .card-sticky-actions__primary,
      .card-sticky-actions__secondary {
        justify-content: stretch;
      }

      .card-sticky-actions__primary > *,
      .card-sticky-actions__secondary > * {
        width: 100%;
      }

      .toast-container {
        left: var(--space-2);
        right: var(--space-2);
      }
    }

    @media (max-width: 480px) {
      .task-card-actions {
        width: 100%;
      }

      .task-card-actions button {
        flex: 0 0 auto;
        width: auto;
      }
    }

    .app-header {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: var(--space-2);
    }

    .app-header__title {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .app-header__title h1 {
      margin: 0;
      font-size: clamp(1.4rem, 3vw, 1.65rem);
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .app-header__subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .header-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.14);
      color: var(--text-primary);
      font-size: 0.8rem;
      font-weight: 500;
    }

    .header-chip__label {
      opacity: 0.7;
    }

    .header-chip__value {
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .momentum-zones {
      display: flex;
      flex-direction: column;
      gap: clamp(1.5rem, 4vw, 2.4rem);
      position: relative;
      width: 100%;
      max-width: 100%;
      min-width: 0;
    }

    .momentum-zone {
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      position: relative;
      min-width: 0;
    }

    .momentum-zone[data-zone="action"] {
      order: 0;
    }

    .momentum-zone[data-zone="launch"] {
      order: 1;
    }

    .momentum-zone[data-zone="recovery"] {
      order: 2;
    }

    .zone-header {
      display: none !important;
    }

    .zone-body {
      display: flex;
      flex-direction: column;
      gap: clamp(1.4rem, 4vw, 2.1rem);
      position: relative;
      min-width: 0;
    }

    .zone-anchor {
      position: relative;
      display: block;
      height: 1px;
      width: 100%;
      pointer-events: none;
      scroll-margin-top: clamp(120px, 15vh, 180px);
    }

    .command-bar {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translate3d(-50%, 0, 0);
      width: min(100%, 680px);
      background: rgba(8, 12, 18, 0.94);
      border-top: 1px solid rgba(147, 160, 170, 0.2);
      box-shadow: 0 -12px 32px rgba(0, 0, 0, 0.5);
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      z-index: 90;
      transition: opacity 200ms ease, transform 220ms ease;
    }

    .command-bar.is-hidden {
      opacity: 0;
      transform: translate3d(-50%, 16px, 0);
      pointer-events: none;
    }

    .command-link {
      padding: 0.65rem 0.5rem 0.4rem;
      text-decoration: none;
      color: rgba(226, 232, 240, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      transition: background 160ms ease, color 160ms ease;
      border: none;
      background: transparent;
      font-family: inherit;
      cursor: pointer;
    }

    .command-link:hover,
    .command-link:focus-visible {
      background: rgba(32, 41, 55, 0.9);
      color: #fff;
    }

    .command-link.is-active {
      background: rgba(41, 51, 68, 0.95);
      color: #fff;
      font-weight: 600;
    }

    .command-link__icon {
      font-size: 1.1rem;
    }

    .primary-action {
      background: var(--surface-elevated);
      border: 1px solid var(--card-border-color);
      border-radius: var(--card-radius);
      width: min(100%, 720px);
      margin: 0 auto clamp(1.5rem, 4vw, 2.2rem);
      padding: clamp(1.25rem, 4vw, 1.7rem);
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      position: relative;
      overflow: hidden;
    }

    .primary-action::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(45, 212, 195, 0.12), rgba(45, 212, 195, 0));
      opacity: 0.6;
      pointer-events: none;
    }

    .primary-action__context h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .primary-action__hint {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
      max-width: 48ch;
    }

    .zone-body > .card {
      width: min(100%, 720px);
      margin: 0 auto;
    }

    .focus-fab {
      position: fixed;
      right: clamp(1.25rem, 5vw, 2.5rem);
      bottom: clamp(5.5rem, 16vh, 7.5rem);
      background: var(--hero-teal);
      color: #022624;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.55rem;
      box-shadow: 0 18px 42px rgba(45, 212, 195, 0.32);
      z-index: 110;
      cursor: pointer;
      transition: transform 180ms ease, box-shadow 220ms ease, background 180ms ease;
    }

    .focus-fab:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 22px 48px rgba(45, 212, 195, 0.36);
      background: #27c2b0;
    }

    .focus-fab:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .focus-fab:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.55), 0 18px 42px rgba(45, 212, 195, 0.32);
    }

    .focus-sheet__backdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.6);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 104;
    }

    .focus-sheet__backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .focus-sheet {
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translate(-50%, 110%);
      width: min(100%, 560px);
      background: rgba(10, 14, 20, 0.96);
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      border: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: 0 -20px 48px rgba(0, 0, 0, 0.55);
      padding: 1.2rem clamp(1rem, 4vw, 1.6rem);
      z-index: 105;
      transition: transform 220ms ease;
    }

    .focus-sheet[aria-hidden="true"] {
      display: none;
    }

    .focus-sheet.is-open {
      transform: translate(-50%, 0);
    }

    .focus-sheet__handle {
      width: 64px;
      height: 6px;
      margin: 0 auto 1rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.35);
      border: none;
      cursor: pointer;
    }

    .focus-sheet__content {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
    }

    .focus-sheet__header h2 {
      margin: 0;
      font-size: 1.15rem;
    }

    .focus-sheet__preview {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .focus-sheet__options {
      display: grid;
      gap: 0.75rem;
    }

    .focus-sheet__option {
      border-radius: 16px;
      border: 1px solid rgba(147, 160, 170, 0.24);
      padding: 0.75rem 1rem;
      background: rgba(20, 26, 34, 0.9);
      color: var(--text-primary);
      font-weight: 500;
      display: grid;
      gap: 0.25rem;
      text-align: left;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .focus-sheet__option:hover:not(:disabled),
    .focus-sheet__option:focus-visible {
      background: rgba(30, 38, 48, 0.95);
      border-color: rgba(45, 212, 195, 0.4);
      transform: translateY(-1px);
      outline: none;
    }

    .focus-sheet__option--primary {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 16px 40px rgba(45, 212, 195, 0.32);
    }

    .focus-sheet__option--primary:hover {
      background: #27c2b0;
    }

    .focus-sheet__option--suggestion {
      background: rgba(15, 22, 30, 0.92);
      border-style: dashed;
    }

    .focus-sheet__option:disabled,
    .focus-sheet__option[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    .focus-sheet__option-label {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .focus-sheet__option-detail {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.55);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 101;
    }

    .drawer-backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .resources-drawer {
      position: fixed;
      top: 0;
      bottom: 0;
      right: 0;
      --drawer-width: min(360px, 86vw);
      --drawer-padding: clamp(1.25rem, 4vw, 1.75rem);
      width: var(--drawer-width);
      padding: var(--drawer-padding);
      background: rgba(10, 14, 20, 0.97);
      border-left: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: -18px 0 42px rgba(0, 0, 0, 0.5);
      z-index: 102;
      display: none;
      flex-direction: column;
      gap: 1.25rem;
      pointer-events: none;
      transform: translateX(1rem);
      opacity: 0;
      transition: transform 220ms ease, opacity 220ms ease;
    }

    .resources-drawer.is-open {
      display: flex;
      pointer-events: auto;
      transform: translateX(0);
      opacity: 1;
    }

    .resources-drawer__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .resources-drawer__header h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .resources-drawer__close {
      border: none;
      background: rgba(148, 163, 184, 0.16);
      border-radius: 999px;
      color: var(--text-primary);
      width: 32px;
      height: 32px;
      cursor: pointer;
    }

    .resources-drawer__body {
      display: grid;
      gap: 0.85rem;
      overflow-y: auto;
      padding-right: 0.35rem;
    }

    .command-link--drawer {
      letter-spacing: 0.05em;
    }

    .meltdown-sos-button {
      position: fixed;
      right: clamp(1.25rem, 5vw, 2.5rem);
      bottom: clamp(8.5rem, 22vh, 11rem);
      background: #ff4d4f;
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.75rem 1.3rem;
      box-shadow: 0 16px 36px rgba(255, 77, 79, 0.4);
      z-index: 120;
      border: none;
      cursor: pointer;
      transition: transform 180ms ease, box-shadow 220ms ease;
    }

    .meltdown-sos-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 42px rgba(255, 77, 79, 0.45);
    }

    .meltdown-sos-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6), 0 18px 42px rgba(255, 77, 79, 0.45);
    }

    .sos-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      padding: clamp(1rem, 5vw, 1.75rem);
      background: rgba(6, 10, 16, 0.7);
      backdrop-filter: blur(10px);
      z-index: 130;
    }

    .sos-card {
      width: min(320px, 92vw);
      background: rgba(10, 14, 20, 0.95);
      border: 1px solid rgba(147, 160, 170, 0.28);
      border-radius: 20px;
      padding: clamp(1rem, 4vw, 1.5rem);
      display: grid;
      gap: 1rem;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
    }

    .sos-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .sos-card__header h2 {
      margin: 0;
      font-size: 1.05rem;
    }

    .sos-card__close {
      border: none;
      background: rgba(148, 163, 184, 0.14);
      color: var(--text-primary);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
    }

    .sos-card__actions {
      display: grid;
      gap: 0.75rem;
    }

    .sos-card__action-group {
      display: grid;
      gap: 0.35rem;
    }

    .sos-card__action {
      border: 1px solid rgba(147, 160, 170, 0.28);
      border-radius: 14px;
      background: rgba(18, 24, 32, 0.92);
      color: var(--text-primary);
      padding: 0.65rem 1rem;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      transition: background 160ms ease, border-color 160ms ease;
    }

    .sos-card__action:hover,
    .sos-card__action:focus-visible {
      background: rgba(28, 38, 48, 0.95);
      border-color: rgba(45, 212, 195, 0.35);
      outline: none;
    }

    .sos-card__detail {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .sos-card__hint {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .defuse-modal {
      width: min(520px, 94vw);
      margin: auto;
      background: rgba(12, 17, 24, 0.96);
      border-radius: 20px;
      border: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: 0 24px 52px rgba(0, 0, 0, 0.6);
      display: grid;
      gap: 1rem;
      padding: clamp(1.25rem, 4vw, 1.75rem);
    }

    .defuse-modal__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .defuse-modal__header h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .defuse-modal__close {
      border: none;
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-primary);
      border-radius: 999px;
      width: 32px;
      height: 32px;
      cursor: pointer;
    }

    .defuse-modal__body {
      display: grid;
      gap: 1rem;
    }

    .sos-overlay.hidden,
    .defuse-overlay.hidden {
      display: none;
    }

    body.is-scrolling .zone-header,
    body.is-scrolling .focus-fab,
    body.is-scrolling .command-link {
      transition-duration: 0s !important;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(12, 16, 21, 0.65);
      opacity: 0;
      transition: opacity 320ms ease-in-out;
      pointer-events: none;
      z-index: 0;
    }

    body.sprint-active::before {
      opacity: 1;
    }

    body.sprint-active .app-shell {
      position: relative;
      z-index: 1;
    }

    body.sprint-active #nextTaskCard:not(.hidden),
    body.sprint-active #focus:not(.hidden) {
      position: relative;
      z-index: 2;
    }

    body.sprint-active #nextTaskCard:not(.hidden),
    body.sprint-active #focus:not(.hidden) .focus {
      border-color: rgba(45, 212, 195, 0.38);
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.35), 0 0 40px rgba(45, 212, 195, 0.22);
      animation: sprint-glow 45s ease-in-out infinite;
    }

    @keyframes sprint-glow {
      0%,
      100% {
        box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.25), 0 0 26px rgba(45, 212, 195, 0.18);
      }
      50% {
        box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.45), 0 0 46px rgba(45, 212, 195, 0.32);
      }
    }

    #focus.focus-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding: clamp(1.25rem, 5vw, 2.25rem);
      background: rgba(8, 12, 18, 0.7);
      backdrop-filter: blur(10px);
      z-index: 140;
      pointer-events: none;
      width: 100vw;
      max-width: 100vw;
      overflow-x: hidden;
      margin: 0 auto;
    }

    body.focus-overlay-active #focus.focus-overlay {
      pointer-events: auto;
    }

    .focus-overlay__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(8, 12, 18, 0.55);
    }

    .focus-overlay__sheet {
      position: relative;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      border-radius: 28px 28px 16px 16px;
      background: rgba(9, 16, 23, 0.98);
      border: 1px solid rgba(148, 163, 184, 0.22);
      box-shadow: 0 -28px 64px rgba(0, 0, 0, 0.45);
      padding: clamp(1.1rem, 4vw, 1.75rem);
      display: grid;
      gap: var(--space-3);
      transform: translateY(0);
      animation: focus-sheet-enter 240ms ease;
      overflow-x: hidden;
    }

    @keyframes focus-sheet-enter {
      from {
        transform: translateY(18px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .focus-overlay__header {
      display: grid;
      gap: 0.5rem;
    }

    .focus-overlay__progress {
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      overflow: hidden;
    }

    .focus-overlay__progress-fill {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, rgba(45, 212, 195, 0.9), rgba(45, 212, 195, 0.2));
      transition: width 180ms ease;
    }

    .focus-overlay__body {
      display: flex;
      flex-direction: column;
      gap: clamp(0.65rem, 2vw, 1rem);
      max-height: clamp(360px, 70vh, 520px);
      overflow-y: auto;
      padding-right: 0.2rem;
      padding-bottom: calc(env(safe-area-inset-bottom) + 5.5rem);
      scroll-padding-bottom: calc(env(safe-area-inset-bottom) + 5.5rem);
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    .focus-overlay__task {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 0.35rem 0.45rem;
      padding: 0.45rem 0.65rem;
      margin: 0.25rem 0;
      border-radius: 14px;
    }

    .focus-overlay__task .task-title {
      display: inline-flex;
      align-items: flex-start;
      gap: 0.35rem;
      margin: 0;
    }

    .focus-overlay__task .task-title input[type="checkbox"] {
      margin-top: 0.2rem;
    }

    .focus-overlay__task .subtask-name {
      margin: 0;
      line-height: 1.35;
    }

    .focus-overlay__task .timer-label {
      justify-self: end;
      margin-left: auto;
      font-size: 0.72rem;
    }

    .focus-overlay__task .task-actions {
      display: inline-flex;
      gap: 0.3rem;
      flex-wrap: wrap;
      justify-self: end;
    }

    .focus-overlay__task .task-actions button,
    .focus-overlay__task .task-actions .icon-button {
      padding: 0.25rem 0.45rem;
      border-radius: 10px;
      font-size: 0.8rem;
      min-height: 0;
    }

    .focus-overlay__actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.65rem;
      position: sticky;
      bottom: calc(env(safe-area-inset-bottom) + 4.25rem);
      background: rgba(9, 16, 23, 0.98);
      padding-bottom: calc(env(safe-area-inset-bottom) + 0.5rem);
      z-index: 2;
    }

    .focus-overlay__actions button {
      border-radius: 14px;
      padding: 0.6rem 0.9rem;
      font-weight: 600;
      font-size: 0.95rem;
    }

    body.focus-overlay-active {
      overflow: hidden;
    }

    body.brief-mode .card .card-body,
    body.brief-mode .card .card-sticky-actions,
    body.brief-mode .module-card .module-body {
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      pointer-events: none;
      transition: max-height 200ms ease, opacity 160ms ease;
    }

    body.brief-mode .card:focus-within .card-body,
    body.brief-mode .card:hover .card-body,
    body.brief-mode .card:focus-within .card-sticky-actions,
    body.brief-mode .card:hover .card-sticky-actions,
    body.brief-mode .module-card:focus-within .module-body,
    body.brief-mode .module-card:hover .module-body {
      max-height: 1200px;
      opacity: 1;
      pointer-events: auto;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition), color var(--transition), border-color var(--transition);
      min-height: 44px;
    }

    a.btn {
      text-decoration: none;
    }

    .icon-button {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-secondary);
      width: 48px;
      height: 48px;
      min-height: 48px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition), color var(--transition), border-color var(--transition);
    }

    .icon-button:hover,
    .btn:hover {
      transform: translateY(-1px);
    }

    .resource-card .card-body {
      gap: var(--space-2);
    }

    .resource-intro {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .resource-links {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-2);
    }

    .resource-button {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      padding: calc(var(--space-2) + 2px) var(--space-2);
      padding-left: calc(var(--space-2) + 18px);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      text-decoration: none;
      color: var(--text-primary);
      background: linear-gradient(135deg, rgba(45, 212, 191, 0.12), rgba(45, 212, 191, 0));
      transition: transform var(--transition), border-color var(--transition), box-shadow var(--transition);
    }

    .resource-button:hover,
    .resource-button:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(45, 212, 191, 0.35);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .resource-button::before {
      content: "";
      position: absolute;
      inset: calc(var(--space-2) + 2px) auto calc(var(--space-2) + 2px) var(--space-2);
      width: 4px;
      border-radius: 999px;
      background: var(--resource-accent, rgba(45, 212, 191, 0.85));
      opacity: 0.9;
    }

    .resource-button strong {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .resource-button span {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .resource-button--planning {
      --resource-accent: rgba(45, 212, 191, 0.85);
      background: linear-gradient(135deg, rgba(45, 212, 191, 0.12), rgba(45, 212, 191, 0));
      border-color: rgba(45, 212, 191, 0.2);
    }

    .resource-button--strategies {
      --resource-accent: rgba(99, 102, 241, 0.9);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.14), rgba(99, 102, 241, 0));
      border-color: rgba(99, 102, 241, 0.22);
    }

    .resource-button--digest {
      --resource-accent: rgba(251, 191, 36, 0.9);
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.14), rgba(251, 191, 36, 0));
      border-color: rgba(251, 191, 36, 0.24);
    }

    .resource-button--vault {
      --resource-accent: rgba(167, 139, 250, 0.92);
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.14), rgba(167, 139, 250, 0));
      border-color: rgba(167, 139, 250, 0.22);
    }

    .resource-button small {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.72);
      text-transform: none;
      letter-spacing: 0.01em;
    }

    .card {
      background: rgba(18, 22, 28, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .card-head h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .card-body {
      display: grid;
      gap: var(--space-2);
    }

    .card--collapsed .card-body {
      display: none;
    }

    .card:not(.card--collapsed) .card-body {
      animation: module-expand var(--transition);
    }

    .card--collapsed .card-sticky-actions {
      display: none;
    }

    .status-card {
      background: rgba(18, 22, 28, 0.85);
    }

    .status-card .category-progress {
      margin-top: 0;
    }

    .preflight-panel {
      display: grid;
      gap: var(--space-2);
    }

    .preflight-toggles {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
    }

    .preflight-toggle {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: transparent;
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: background var(--transition), color var(--transition), border-color var(--transition);
    }

    .preflight-toggle:hover,
    .preflight-toggle:focus-visible {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .preflight-toggle.is-active {
      border-color: rgba(45, 212, 191, 0.55);
      background: rgba(45, 212, 191, 0.12);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.18);
    }

    .task-form-group {
      position: relative;
      display: grid;
      gap: var(--space-2);
      padding-top: var(--space-3);
      border-top: 1px solid rgba(148, 163, 184, 0.16);
    }

    .task-form-group__label {
      position: absolute;
      top: -0.75rem;
      left: 0;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.75);
      padding: 0 0.35rem;
      background: linear-gradient(180deg, rgba(15, 20, 26, 1) 40%, rgba(15, 20, 26, 0));
    }

    .task-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      padding: 0.25rem 0;
    }

    .task-inline-actions .link-button {
      margin: 0;
      font-size: 0.85rem;
      color: var(--accent);
    }

    .section-chip {
      font-size: 0.72rem;
      letter-spacing: 0.08em;
    }

    .card-sticky-actions {
      position: sticky;
      bottom: -12px;
      margin: 0 -12px -12px;
      padding: var(--space-3);
      background: linear-gradient(180deg, rgba(18, 22, 28, 0) 0%, rgba(18, 22, 28, 0.92) 45%, rgba(18, 22, 28, 0.98) 100%);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      justify-content: space-between;
      align-items: center;
      z-index: 2;
      border-bottom-left-radius: 14px;
      border-bottom-right-radius: 14px;
    }

    .card-sticky-actions__primary,
    .card-sticky-actions__secondary {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      align-items: center;
    }

    .btn-quiet {
      background: rgba(20, 28, 36, 0.35);
      border-color: rgba(148, 163, 184, 0.18);
      color: var(--text-secondary);
    }

    .btn-quiet:hover,
    .btn-quiet:focus-visible {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-primary);
    }

    .btn-quiet:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1400;
    }

    .modal.hidden {
      display: none;
    }

    .modal__content {
      width: min(560px, 92vw);
      max-height: 80vh;
      overflow: auto;
      background: #0f141a;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: var(--space-2);
    }

    .modal__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-1);
    }

    .modal__close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.1rem;
      cursor: pointer;
    }

    .template-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 8px;
    }

    .template-card {
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      background: rgba(16, 20, 28, 0.9);
      display: grid;
      gap: 6px;
    }

    .template-card strong {
      font-size: 0.95rem;
    }

    .template-card button {
      justify-self: flex-start;
    }

    .template-module__actions {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1rem;
    }

    .block-batch-layout {
      display: grid;
      grid-template-columns: minmax(180px, 220px) 1fr;
      gap: 1.25rem;
      align-items: start;
      margin-top: 1rem;
    }

    .block-batch-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .block-batch-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.4rem;
      align-items: center;
    }

    .block-batch-item__edit {
      background: rgba(18, 24, 30, 0.92);
      border: 1px solid rgba(147, 160, 170, 0.18);
      border-radius: 10px;
      padding: 0.35rem 0.55rem;
      cursor: pointer;
      color: var(--text-secondary);
    }

    .block-batch-item__edit:hover {
      color: var(--text-primary);
    }

    .block-batch-item__select {
      text-align: left;
      padding: 0.45rem 0.75rem;
      border-radius: 12px;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.02);
      color: var(--text-primary);
      font-weight: 500;
      cursor: pointer;
    }

    .block-batch-item.is-active .block-batch-item__select {
      border-color: rgba(45, 212, 195, 0.45);
      background: rgba(45, 212, 195, 0.12);
      color: var(--hero-teal);
    }

    .block-batch-item__select:focus-visible,
    .block-batch-item__edit:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.55);
    }

    .block-batch-counts {
      display: grid;
      gap: 0.75rem;
    }

    .block-batch-count {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 0.85rem;
      border-radius: 14px;
      border: 1px solid rgba(147, 160, 170, 0.2);
      background: rgba(17, 23, 30, 0.75);
      transition: border-color 120ms ease, background 120ms ease;
    }

    .block-batch-count.is-active {
      border-color: rgba(45, 212, 195, 0.4);
      background: rgba(45, 212, 195, 0.08);
    }

    .block-batch-count span {
      font-weight: 500;
    }

    .block-batch-count input[type="number"] {
      max-width: 80px;
      background: rgba(12, 18, 24, 0.95);
      border-radius: 10px;
      border: 1px solid rgba(147, 160, 170, 0.3);
      color: var(--text-primary);
      padding: 0.4rem 0.6rem;
      text-align: right;
      font-size: 0.95rem;
    }

    .block-batch-editor {
      margin-top: 1.5rem;
      padding: 1.1rem;
      border-radius: 16px;
      border: 1px solid rgba(147, 160, 170, 0.18);
      background: rgba(12, 18, 24, 0.85);
      display: grid;
      gap: 1rem;
    }

    .block-batch-editor.hidden {
      display: none;
    }

    .block-batch-editor__head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .block-batch-editor__grid {
      display: grid;
      gap: 0.85rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .block-batch-editor textarea {
      min-height: 90px;
    }

    .block-batch-editor__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .block-batch-footer {
      margin-top: 1.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
    }

    .block-batch-footer label {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      color: var(--text-secondary);
      gap: 0.35rem;
    }

    .block-batch-footer input[type="date"] {
      min-width: 160px;
    }

    @media (max-width: 768px) {
      .block-batch-layout {
        grid-template-columns: 1fr;
      }

      .block-batch-list {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .block-batch-item {
        grid-template-columns: auto;
        gap: 0.35rem;
      }

      .block-batch-item__edit {
        justify-self: flex-start;
      }

      .block-batch-item__select {
        width: auto;
      }
    }


    .section-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .section-heading__title {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      flex: 1 1 auto;
      min-width: 0;
    }

    .section-heading__title .section-chip {
      margin-left: 0;
    }

    .section-heading h2,
    .next-task-card h2 {
      font-size: clamp(16px, 2.3vw, 18px);
      font-weight: 600;
      margin: 0;
    }

    .link-button {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .next-task-card {
      gap: var(--space-2);
    }

    .next-task-name {
      font-size: 1.05rem;
      font-weight: 600;
      margin: 0;
    }

    .next-task-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .chip {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      padding: 0.35rem 1.1rem;
      font-size: 0.8rem;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    .chip-muted {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-secondary);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .next-task-fit {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .next-task-fit__info {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.25rem;
      height: 1.25rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      color: rgba(226, 232, 240, 0.9);
      font-size: 0.75rem;
      cursor: help;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .next-task-actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      width: 100%;
    }

    .next-task-start {
      width: 100%;
      justify-content: center;
      font-weight: 600;
    }

    .next-task-start.is-long-press {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.45);
    }

    .due-today-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .due-today-accordion {
      display: grid;
      gap: var(--space-2);
    }

    .due-today-summary {
      background: rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: var(--radius-md);
      padding: 0.55rem 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: var(--space-1);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.82rem;
      transition: border-color var(--transition), color var(--transition), background var(--transition);
      flex-shrink: 1;
      width: auto;
      min-width: 0;
      margin-left: auto;
      max-width: 100%;
    }

    .due-today-summary span[data-due-today-summary-text],
    .due-today-summary span[data-all-tasks-summary-text] {
      white-space: nowrap;
      flex: 1 1 auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .due-today-summary:hover,
    .due-today-summary:focus-visible {
      border-color: rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      background: rgba(148, 163, 184, 0.14);
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .due-today-summary__icon {
      font-size: 0.75rem;
      transition: transform var(--transition);
      margin-left: var(--space-1);
      flex-shrink: 0;
    }

    .due-today-accordion[data-open="true"] .due-today-summary__icon {
      transform: rotate(90deg);
    }

    .due-today-item {
      display: grid;
      gap: var(--space-1);
      background: var(--surface-muted);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-md);
      padding: var(--space-2);
    }

    .due-today-item--spotlight {
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.25), 0 0 24px rgba(45, 212, 195, 0.18);
      transition: box-shadow 220ms ease-out;
    }

    .due-today-title {
      font-size: 0.95rem;
      font-weight: 500;
      margin: 0;
      color: var(--text-primary);
    }

    .due-today-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .due-today-pills {
      display: inline-flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .pill {
      font-size: 0.8rem;
      border-radius: 999px;
      padding: 0.35rem 1.1rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .pill-primary {
      background: rgba(45, 212, 191, 0.18);
      color: var(--accent);
      border-color: rgba(45, 212, 191, 0.35);
    }

    .module-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 0;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .module-header {
      width: 100%;
      background: transparent;
      color: var(--text-primary);
      border: none;
      padding: var(--space-3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .module-heading {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .module-heading__text {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
    }

    .module-heading__title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .module-heading__tagline {
      font-size: 0.78rem;
      font-weight: 500;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
    }

    .module-caret {
      display: inline-block;
      transition: transform var(--transition);
      color: var(--text-secondary);
    }

    .module-card.is-open .module-caret {
      transform: rotate(90deg);
    }

    .module-body {
      padding: 0 var(--space-4) var(--space-4);
      display: grid;
      gap: var(--space-3);
      transition: opacity var(--transition), transform var(--transition);
    }

    .module-body[hidden] {
      display: none;
    }

    .module-card.is-open .module-body {
      animation: module-expand var(--transition);
    }

    @keyframes module-expand {
      from {
        opacity: 0;
        transform: translateY(-6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .module-footnote {
      font-size: 0.78rem;
      color: var(--text-secondary);
    }

    .task-form-card {
      gap: var(--space-3);
    }

    .task-form-actions--inline {
      align-items: center;
    }

    .task-form-actions--inline .btn {
      padding: 0.35rem 0.75rem;
      font-size: 0.85rem;
    }

    .task-form-minimal {
      display: grid;
      gap: var(--space-2);
    }

    .task-form-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .task-form-actions {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .task-details-panel {
      display: grid;
      gap: var(--space-2);
    }

    .task-details-panel[data-collapsed="true"] {
      display: none;
    }

    label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    input[type="text"],
    select,
    input[type="date"],
    textarea {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      width: 100%;
      box-sizing: border-box;
    }

    textarea {
      resize: vertical;
      min-height: 96px;
    }

    .category-filter,
    .category-progress,
    .peek {
      margin-top: var(--space-3);
    }

    .peek {
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
    }

    .hidden {
      display: none !important;
    }

    .toast-container {
      position: fixed;
      top: var(--space-4);
      right: var(--space-4);
      z-index: 1500;
    }

    .module-stack {
      display: grid;
      gap: var(--space-3);
    }

    .next-best-card .card-body {
      display: grid;
      gap: var(--space-3);
    }

    .next-best-card.is-highlighted {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.4), 0 0 32px rgba(45, 212, 195, 0.22);
      transition: box-shadow var(--transition), transform var(--transition);
    }

    .next-best-controls {
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: var(--radius-md);
      padding: var(--space-2);
      background: rgba(15, 20, 27, 0.65);
      transition: border-color var(--transition), background var(--transition);
    }

    .next-best-controls:not([hidden]) {
      border-color: rgba(148, 163, 184, 0.28);
      background: rgba(15, 20, 27, 0.8);
    }

    .next-best-controls__form {
      margin-top: var(--space-2);
      display: grid;
      gap: var(--space-2);
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: flex-start;
    }

    .next-best-energy {
      display: grid;
      gap: 0.25rem;
    }

    .nbt-frictions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .nbt-frictions label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.8rem;
      cursor: pointer;
    }

    .nbt-frictions input[type="checkbox"] {
      margin: 0;
    }

    .next-best-results {
      display: flex;
      gap: var(--space-2);
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      padding-bottom: 0.35rem;
      margin: 0 -0.25rem;
      padding-left: 0.25rem;
    }

    .next-best-results::-webkit-scrollbar {
      height: 6px;
    }

    .next-best-results::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
    }

    @media (min-width: 960px) {
      .next-best-results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        overflow: visible;
        margin: 0;
        padding: 0;
      }

      .next-best-option {
        min-width: 0;
        scroll-snap-align: unset;
      }
    }

    .next-best-refresh {
      position: relative;
      font-size: 0.85rem;
      padding: 0.4rem 1.9rem 0.4rem 0.9rem;
      min-width: 110px;
    }

    .next-best-refresh.is-loading {
      color: rgba(226, 232, 240, 0.55);
    }

    .next-best-refresh.is-loading::after {
      content: "";
      position: absolute;
      top: 50%;
      right: 0.75rem;
      width: 14px;
      height: 14px;
      margin-top: -7px;
      border-radius: 50%;
      border: 2px solid currentColor;
      border-right-color: transparent;
      animation: button-spin 0.8s linear infinite;
    }

    .next-best-option {
      position: relative;
      display: grid;
      gap: var(--space-2);
      padding: calc(var(--space-2) + 6px) var(--space-2) var(--space-2);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148, 163, 184, 0.16);
      background: rgba(15, 20, 27, 0.75);
      box-shadow: 0 12px 24px rgba(2, 6, 23, 0.35);
      min-width: clamp(240px, 78vw, 320px);
      scroll-snap-align: center;
    }

    .next-best-option__label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.6);
    }

    .next-best-option__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .next-best-option__payoff {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .next-best-option__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .spec-chip {
      background: rgba(148, 163, 184, 0.16);
      color: rgba(226, 232, 240, 0.78);
    }

    .next-best-meter {
      display: grid;
      gap: 0.4rem;
    }

    .next-best-meter__label {
      font-size: 0.8rem;
      color: rgba(226, 232, 240, 0.75);
      font-weight: 500;
    }

    .next-best-meter__track {
      position: relative;
      height: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      overflow: hidden;
    }

    .next-best-meter__bar {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(45, 212, 191, 0.9), rgba(45, 212, 191, 0.2));
      width: 12%;
      transition: width 220ms ease;
    }

    .next-best-meter__scale {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.6);
    }

    .next-best-ring {
      position: absolute;
      top: var(--space-2);
      right: var(--space-2);
      width: 38px;
      height: 38px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.65);
    }

    .next-best-ring::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: conic-gradient(var(--accent) 0deg, var(--accent) 3.6deg, transparent 3.6deg 360deg);
      opacity: 0.7;
    }

    .next-best-ring::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-radius: 50%;
      background: rgba(12, 17, 23, 0.95);
    }

    .next-best-ring span {
      position: relative;
      z-index: 1;
    }

    .next-best-cta {
      justify-self: flex-start;
      min-width: 150px;
    }

    .next-best-cta--steady {
      background: var(--accent);
      border-color: rgba(45, 212, 191, 0.55);
      color: #041013;
    }

    .next-best-cta--low {
      background: rgba(30, 64, 175, 0.85);
      border-color: rgba(30, 64, 175, 0.6);
      color: #e0e7ff;
      box-shadow: 0 16px 30px rgba(30, 64, 175, 0.35);
    }

    .next-best-cta--high {
      background: rgba(52, 211, 153, 0.95);
      border-color: rgba(52, 211, 153, 0.6);
      color: #022c22;
      box-shadow: 0 16px 30px rgba(52, 211, 153, 0.32);
    }

    .next-best-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .conflict-grid {
      display: grid;
      gap: var(--space-2);
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .conflict-column {
      display: grid;
      gap: var(--space-2);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: var(--radius-md);
      padding: var(--space-2);
    }

    .conflict-column h3 {
      margin: 0;
      font-size: 0.95rem;
    }

    .conflict-list {
      display: grid;
      gap: 0.6rem;
    }

    .conflict-item {
      display: grid;
      gap: 0.35rem;
      padding: 0.55rem 0.65rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.15);
      cursor: grab;
    }

    .conflict-item:active {
      cursor: grabbing;
    }

    .conflict-item strong {
      font-size: 0.9rem;
    }

    .conflict-item span {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .conflict-arena {
      border: 2px dashed rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      min-height: 140px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: var(--space-3);
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.03);
      transition: border-color var(--transition), background var(--transition);
    }

    .conflict-arena.is-ready {
      border-color: var(--accent);
      background: rgba(45, 212, 191, 0.12);
    }

    .conflict-arena .arena-slot {
      font-weight: 600;
      color: var(--text-primary);
    }

    .conflict-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .defuse-grid {
      display: grid;
      gap: var(--space-2);
    }

    .defuse-steps {
      display: grid;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .defuse-progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .defuse-progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #0a84ff, #7bd88f);
      transition: width 180ms ease-out;
    }

    .defuse-locks {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .defuse-locks label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.15);
      font-size: 0.8rem;
    }

    .dopamine-playlist {
      display: grid;
      gap: var(--space-2);
    }

    .dopamine-intervals {
      display: grid;
      gap: 0.5rem;
    }

    .dopamine-interval {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.65rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.85rem;
    }

    .dopamine-progress {
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .dopamine-progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #f97316, #7c3aed);
      transition: width 180ms ease-out;
    }

    .confetti-burst {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: center;
      animation: confetti-pop 900ms ease-out forwards;
      font-size: 2.5rem;
      z-index: 2000;
    }

    @keyframes confetti-pop {
      0% { opacity: 0; transform: scale(0.7); }
      50% { opacity: 1; transform: scale(1.05); }
      100% { opacity: 0; transform: scale(1.2); }
    }

    .due-today-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .next-task-empty {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .quick-pill {
      border: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .quick-pill:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .info-dot {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
    }

    .all-tasks-panel {
      padding: var(--space-3) var(--space-2);
      display: grid;
      gap: var(--space-3);
    }

    .all-tasks-panel.is-highlighted {
      box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.35);
      border-radius: var(--card-radius);
    }

    .task-panel-actions {
      display: flex;
      justify-content: flex-end;
    }

    .info-dot[title] {
      cursor: help;
    }

    button:not(.btn):not(.icon-button):not(.pill):not(.link-button):not(.module-header) {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.5rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    /* --- Final global polish overrides --- */
    body {
      font-weight: 400;
      line-height: 1.5;
      overflow-x: hidden;
    }

    .card,
    .peek,
    .task-card,
    .resource-button,
    .worst-day-banner,
    .worst-day-card,
    .distraction-tools,
    .distraction-log li,
    .doorway-reset,
    .gantt-card,
    .chart-summary,
    .subtask-row,
    .routine-block,
    .toast,
    .modal__content,
    .modal-card,
    .wizard-content,
    .audit-card,
    .category-progress .line,
    .category-progress .bar,
    .history-list li,
    .progress-strip,
    .nbt-result-card,
    .task-details,
    .next-task-card,
    .due-today-card,
    .status-card,
    .next-best-card {
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      background: var(--surface-elevated);
    }

    .btn-primary {
      background: var(--accent);
      color: #041013;
      border: 1px solid rgba(45, 212, 191, 0.55);
      box-shadow: 0 16px 30px rgba(45, 212, 191, 0.28);
      font-weight: 600;
    }

    .btn-secondary {
      background: rgba(148, 163, 184, 0.14);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: var(--text-primary);
      box-shadow: none;
    }

    .btn-ghost,
    .btn-outline,
    .btn-tertiary {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-secondary);
      box-shadow: none;
    }

    .btn-outline {
      border-color: rgba(45, 212, 191, 0.45);
      color: var(--accent);
    }

    .btn-outline:hover,
    .btn-outline:focus-visible {
      background: rgba(45, 212, 191, 0.08);
      color: var(--accent);
    }

    .btn-ghost:hover,
    .btn-tertiary:hover,
    .btn-secondary:hover {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
    }

    .icon-button {
      border-radius: 12px;
      padding: 0.5rem;
    }

    .icon-button:hover,
    .icon-button:focus-visible {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
    }

    .icon-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .resource-button {
      text-decoration: none;
      display: grid;
      gap: 0.25rem;
      padding: 0.85rem 1rem;
      color: var(--text-primary);
      background: rgba(20, 28, 36, 0.82);
    }

    .resource-button strong {
      font-weight: 600;
    }

    .worst-day-button {
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      box-shadow: none;
    }

    .worst-day-button.hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }
  </style>
</head>
<body>
  <div id="toastContainer" class="toast-container" aria-live="polite"></div>

  <section
    id="meltdownShield"
    class="meltdown-shield hidden"
    aria-live="polite"
    aria-label="Meltdown Shield Panel"
    aria-hidden="true"
  >
    <h4 class="meltdown-shield-header">🛡️ Meltdown Shield Activated</h4>
    <div id="meltdownShieldPrompt" class="meltdown-shield-prompt" aria-live="assertive"></div>
    <ul id="meltdownShieldSteps"></ul>
    <div class="meltdown-shield-actions">
      <button id="meltdownShieldNext" type="button">▶️ Next</button>
      <button type="button" onclick="deactivateShield()">❌ Close</button>
    </div>
  </section>

  <section id="capture">
    <div class="app-shell">
      <header class="app-header">
        <div class="app-header__title">
          <h1>Task Focus</h1>
          <p id="headerSubtitle" class="app-header__subtitle"></p>
        </div>
        <p class="billing-reminder" id="billingReminder"></p>
      </header>
<!-- Legacy header block replaced by .focus-command-deck -->
<!--
<div class="starter-stack" id="starterStack">
  <div class="starter-micro-header" role="banner">
    <button
      id="nextTaskActionButton"
      class="btn hero-cta start-action next-task-start"
      type="button"
      aria-describedby="nextTaskActionHint"
    >
      Start 5-min
      <span id="nextTaskActionHint" class="visually-hidden">Long-press for quick capture.</span>
    </button>
    <div id="nextTaskChips" class="starter-fit-chips" aria-live="polite"></div>
    <button
      id="rescueLaunchButton"
      class="btn starter-rescue"
      type="button"
      aria-haspopup="dialog"
      aria-controls="sosOverlay"
      aria-expanded="false"
    >
      🛟 Rescue
    </button>
  </div>
</div>
-->

      <section class="focus-command-deck" aria-label="Focus Command Deck">
  <header class="fcd-head">
    <h1 class="fcd-title">Task Focus</h1>
    <p class="cutoff">Eligibility cutoff <strong>Jul 28, 2025</strong></p>
  </header>

  <button class="start-btn hero-cta" data-action="start-5">Start 5-min</button>

  <div class="status-chips" role="status" aria-live="polite">
    <div class="chip" data-chip="eta">⏱ Est. <span class="eta-val">28</span> min</div>
    <div class="chip" data-chip="energy">⚡ Energy: <span class="energy-val">Steady</span></div>
  </div>

  <div class="chart-momentum" aria-label="Chart Momentum">
    <label class="cm-label">Chart Momentum</label>
    <div class="progress-strip">
      <span class="cm-fill" style="width:21%"></span>
    </div>
    <small class="cm-note">
      <span class="cm-done">12</span> / <span class="cm-total">57</span> complete
    </small>
    <div class="cm-float" aria-hidden="true"></div>
  </div>

  <button class="rescue-btn" data-action="rescue">🛟 Rescue</button>
      </section>

        <section id="nextTaskCard" class="card next-task-card hidden" aria-live="polite">
          <header class="card-head next-focus-head">
            <div class="next-focus-head__titles">
              <h2>Next focus</h2>
              <p class="next-focus-hint">
                Next best: <span id="focusLaunchHint">Add a task to unlock focus.</span>
              </p>
            </div>
            <span id="nextTaskScore" class="chip chip-muted next-task-fit hidden"></span>
          </header>
          <span id="focus-engine" class="zone-anchor" aria-hidden="true"></span>
          <p id="nextTaskName" class="next-task-name"></p>
          <p id="nextTaskSubstep" class="next-task-meta"></p>
          <p id="nextTaskEmpty" class="next-task-empty hidden">You're clear for now. Add what matters next.</p>
          <div class="next-best-inline">
            <div class="next-best-toolbar" role="toolbar" aria-label="Next best options">
              <button id="nextBestRefresh" class="btn btn-ghost next-best-refresh" type="button">Refresh</button>
              <button
                id="nextBestAdjustToggle"
                class="quick-pill"
                type="button"
                aria-expanded="false"
                aria-controls="nextBestControls"
              >
                Adjust
              </button>
              <button id="nextBestStuck" class="quick-pill" type="button">I'm stuck</button>
            </div>
            <div id="nextBestControls" class="next-best-controls" hidden aria-hidden="true">
              <div class="next-best-controls__form">
                <label for="nextBestTime">
                  Time available
                  <select id="nextBestTime">
                    <option value="10">10 minutes</option>
                    <option value="15" selected>15 minutes</option>
                    <option value="20">20 minutes</option>
                    <option value="30">30 minutes</option>
                  </select>
                </label>
                <div class="next-best-energy">
                  <label for="nextBestEnergy">Energy right now</label>
                  <input
                    id="nextBestEnergy"
                    data-field="energy-level"
                    type="range"
                    min="1"
                    max="5"
                    step="1"
                    value="3"
                    aria-label="Energy right now"
                  />
                  <div class="next-best-meter">
                    <div class="next-best-meter__fill" id="nextBestEnergyFill"></div>
                    <div class="next-best-meter__scale">
                      <span aria-hidden="true">low</span>
                      <span aria-hidden="true">max</span>
                    </div>
                  </div>
                </div>
                <label for="nextBestDeadline">
                  Deadline urgency
                  <select id="nextBestDeadline"></select>
                </label>
                <label for="nextBestSize">
                  Task size
                  <select id="nextBestSize">
                    <option value="any" selected>Any size</option>
                    <option value="small">Quick win (&lt; 15 min)</option>
                    <option value="medium">Medium (15–30 min)</option>
                    <option value="large">Deep work (&gt; 30 min)</option>
                  </select>
                </label>
                <fieldset class="nbt-frictions">
                  <legend class="visually-hidden">Friction filters</legend>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="context" />
                    Needs certain location
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="conversation" />
                    Needs another person
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="energy" />
                    Energy heavy
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="startup" />
                    High startup cost
                  </label>
                </fieldset>
              </div>
            </div>
            <div id="nextBestResults" class="next-best-results"></div>
            <p id="nextBestEmpty" class="next-best-empty hidden">Add a task to see your next best options.</p>
          </div>
        </section>

        <div class="stage-strip" role="group" aria-label="Stage prep toggles">
          <div class="preflight-toggles" role="group" aria-label="Pre-flight toggles">
            <button
              type="button"
              class="preflight-toggle"
              data-preflight-toggle="focusMusic"
              aria-pressed="false"
              title="Focus music"
            >
              🎧
            </button>
            <button
              type="button"
              class="preflight-toggle"
              data-preflight-toggle="dnd"
              aria-pressed="false"
              title="Do not disturb"
            >
              🔕
            </button>
            <button
              type="button"
              class="preflight-toggle"
              data-preflight-toggle="timer"
              aria-pressed="false"
              title="Timer length"
            >
              ⏱️
            </button>
          </div>
        </div>
      </div>

      <div class="momentum-zones">
        <section id="actionZone" class="momentum-zone" data-zone="action">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">⚡</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Action Zone</h2>
              <p class="zone-header__subtitle">Next best focus, active tasks, and due-today radar</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="tasks-zone" class="zone-anchor" aria-hidden="true"></span>
      <section class="card due-today-card hidden" aria-live="polite" data-due-today-section>
        <div class="section-heading">
          <h2>Due today</h2>
          <span class="chip chip-muted section-chip">Ready today</span>
        </div>
        <div class="due-today-accordion" data-open="false" data-accordion="dueToday">
          <button class="due-today-summary" type="button" aria-expanded="false" data-accordion-summary>
            <span data-due-today-summary-text>0 ready • est —</span>
            <span class="due-today-summary__icon" aria-hidden="true">▸</span>
          </button>
          <div class="due-today-list" hidden data-accordion-panel data-due-today-list></div>
        </div>
        <p class="due-today-empty hidden" data-due-today-empty>Nothing due today. You're caught up.</p>
      </section>


      <section class="card all-tasks-card" aria-live="polite" data-all-tasks-card>
        <div class="section-heading">
          <h2 data-all-tasks-title>All Tasks</h2>
          <span class="chip chip-muted section-chip hidden" data-all-tasks-summary-chip></span>
        </div>
        <div class="due-today-accordion" data-open="false" data-accordion="allTasks">
          <button class="due-today-summary" type="button" aria-expanded="false" data-accordion-summary>
            <span data-all-tasks-summary-text>0 active</span>
            <span class="due-today-summary__icon" aria-hidden="true">▸</span>
          </button>
          <div class="all-tasks-panel" hidden data-accordion-panel data-all-tasks-panel>
            <div class="task-panel-actions">
              <button id="openAddTaskPanel" class="btn btn-primary" type="button">Add task</button>
            </div>
            <div class="task-list-header" id="taskListHeader">
              <label class="task-view-label" for="taskViewMode">View</label>
              <select id="taskViewMode" class="task-view-select">
                <option value="active" selected>Active Tasks</option>
                <option value="completed">Completed Tasks</option>
              </select>
              <label class="task-view-label" for="taskCategoryFilter">Category</label>
              <select id="taskCategoryFilter" class="task-view-select"></select>
              <label class="time-budget-control" for="timeBudget">
                I have
                <select id="timeBudget" data-field="time-budget">
                  <option value="">--</option>
                  <option value="15">15</option>
                  <option value="30">30</option>
                  <option value="60">60</option>
                </select>
                minutes
              </label>
              <button id="showAllToggle" class="show-all-toggle hidden" type="button" onclick="toggleShowAllActive()">Show All</button>
            </div>
            <div id="taskList"></div>
          </div>
        </div>
      </section>

          </div>
        </section>
        <section id="recoveryZone" class="momentum-zone" data-zone="recovery">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">🌙</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Recovery Zone</h2>
              <p class="zone-header__subtitle">Resolve conflicts, reset your nervous system, refuel dopamine</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="reset-zone" class="zone-anchor" aria-hidden="true"></span>
      <div class="routine-stack" id="routineTileStack">
        <div class="routine-preferences" aria-label="Routine preferences">
          <label class="routine-preferences__toggle" for="routineHapticsToggle">
            <input type="checkbox" id="routineHapticsToggle" />
            <span class="routine-preferences__label">Enable haptic nudges</span>
          </label>
        </div>

        <article
          id="morningLaunchModule"
          class="routine-tile"
          data-module-id="morningLaunchModule"
          data-routine-id="morning"
          role="group"
          aria-label="Morning Launch Sequence"
        >
          <div class="routine-tile__surface routine-theme--morning" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>🌅</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>🌅 Morning Launch Sequence</span>
                <span class="routine-tile__prompt" data-routine-prompt>Ready for takeoff? Start your day ritual.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Prime your brain for dopamine, cortisol, and clarity with a 60-minute guided ramp into the day." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Morning Launch Preview</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Morning Launch quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="module-toggle">
                    <label for="morningLaunchToggle">Enable Morning Launch</label>
                    <input type="checkbox" id="morningLaunchToggle" />
                  </div>
                  <div class="routine-affirmation">No-phone pledge: leave your device in another room overnight and wake up with an analog alarm.</div>
                  <div id="morningLaunchContent" class="hidden" aria-hidden="true">
                    <div class="progress-strip" aria-hidden="true">
                      <span id="morningLaunchProgress"></span>
                    </div>
                    <div id="morningLaunchStatus" class="score"></div>
                    <div class="module-inline-actions">
                      <button id="morningLaunchResetBtn" type="button">Reset morning blocks</button>
                      <button id="morningLaunchSkipBtn" type="button">Skip today</button>
                    </div>
                    <div class="morning-blocks">
                      <article class="routine-block" data-block="move">
                        <h3>MOVE — Light Aerobic + Sunlight</h3>
                        <small>Take a brisk walk, 50 jumping jacks, and soak in 5 minutes of direct sunlight.</small>
                        <div class="countdown-display" id="moveCountdown">20:00</div>
                        <div class="module-inline-actions">
                          <button id="moveStartBtn" type="button">Start 20-min timer</button>
                          <button id="moveCompleteBtn" type="button">Mark MOVE complete</button>
                        </div>
                      </article>
                      <article class="routine-block" data-block="reflect">
                        <h3>REFLECT — Cold Splash + Intention</h3>
                        <small>Reset with a cold rinse, then name the tone for your day.</small>
                        <div class="intention-buttons">
                          <button type="button" data-intention="Calm &amp; steady">Calm &amp; steady</button>
                          <button type="button" data-intention="Playful &amp; connected">Playful &amp; connected</button>
                          <button type="button" data-intention="Focused craftsmanship">Focused craftsmanship</button>
                        </div>
                        <label for="morningIntention" style="margin:0;">
                          <textarea id="morningIntention" rows="2" placeholder="How do I want today to feel? What would make it meaningful?" style="margin-top:0.35rem;"></textarea>
                        </label>
                        <div class="module-inline-actions">
                          <button id="reflectCompleteBtn" type="button">Save intention</button>
                        </div>
                      </article>
                      <article class="routine-block" data-block="plan">
                        <h3>PLAN — Process Anchors</h3>
                        <small>Lock in process-based actions and block time before the day takes over.</small>
                        <textarea id="morningPlanNotes" rows="2" placeholder="Ex: Draft progress notes for 2 patients before noon."></textarea>
                        <div class="module-inline-actions">
                          <button id="planCompleteBtn" type="button">Plan locked in</button>
                        </div>
                      </article>
                    </div>
                    <div class="energy-rating">
                      <label for="morningEnergy" style="margin:0;">Energy check-in</label>
                      <input id="morningEnergy" data-field="energy-level" type="range" min="1" max="5" step="1" value="3" />
                      <span id="morningEnergyLabel">--</span>
                      <button id="morningEnergySave" type="button">Log energy</button>
                    </div>
                    <div class="morning-chart-wrapper">
                      <canvas
                        id="morningLaunchChart"
                        class="chart-canvas"
                        width="360"
                        height="160"
                        role="img"
                        aria-label="Line chart of morning launch completion and energy trends"
                      ></canvas>
                      <div class="chart-legend" aria-hidden="true">
                        <span><span class="legend-swatch completion"></span>Ready progress</span>
                        <span><span class="legend-swatch energy"></span>Energy (1–5 scaled)</span>
                      </div>
                      <div id="morningLaunchChartSummary" class="module-note"></div>
                    </div>
                    <ul id="morningLaunchHistory" class="history-list" aria-live="polite"></ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article
          id="launchPadModule"
          class="routine-tile"
          data-module-id="launchPadModule"
          data-routine-id="environment"
          role="group"
          aria-label="Environmental Reminders and Launch Pads"
        >
          <div class="routine-tile__surface routine-theme--environment" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>🚀</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>🚀 Environmental Reminders &amp; Launch Pads</span>
                <span class="routine-tile__prompt" data-routine-prompt>Tap to reset your surroundings.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Curate a nightly launch pad so tomorrow starts calm, stocked, and on time." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Environmental Reset Preview</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Environmental routine quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="module-toggle">
                    <label for="launchPadReminderTime">Reminder time</label>
                    <input type="time" id="launchPadReminderTime" />
                  </div>
                  <div class="launch-pad-summary" id="launchPadSummary"></div>
                  <div class="module-inline-actions">
                    <button id="openLaunchPadModal" type="button">Evening checklist</button>
                    <button id="launchPadMorningReview" type="button">Morning review</button>
                  </div>
                  <div class="launch-pad-settings">
                    <label for="launchPadSiteSelect">Clinic / environment
                      <select id="launchPadSiteSelect"></select>
                    </label>
                    <div class="module-inline-actions">
                      <input type="text" id="launchPadNewItem" placeholder="Add launch pad item" />
                      <button id="launchPadAddItem" type="button">Add Item</button>
                      <button id="launchPadLoadPreset" type="button">Reset to preset</button>
                    </div>
                    <div id="launchPadItemList" class="launch-pad-list" aria-live="polite"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article
          id="sleepToolkitModule"
          class="routine-tile"
          data-module-id="sleepToolkitModule"
          data-routine-id="sleep"
          role="group"
          aria-label="Sleep and Circadian Rhythm Toolkit"
        >
          <div class="routine-tile__surface routine-theme--sleep" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>😴</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>😴 Sleep &amp; Circadian Rhythm Toolkit</span>
                <span class="routine-tile__prompt" data-routine-prompt>Wind down mode is ready.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Stabilize melatonin and cortisol rhythms with gentle wind-down and light cues." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Sleep Toolkit Preview</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Sleep routine quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="module-toggle">
                    <label for="sleepToolkitToggle">Enable toolkit</label>
                    <input type="checkbox" id="sleepToolkitToggle" />
                  </div>
                  <div id="sleepToolkitContent" class="hidden" aria-hidden="true">
                    <div class="sleep-checklist" id="sleepChecklist"></div>
                    <div id="sleepCompletionSummary" class="sleep-summary"></div>
                    <div class="module-inline-actions">
                      <label for="melatoninReminderToggle" style="flex:1;">
                        <input type="checkbox" id="melatoninReminderToggle" /> Melatonin reminder
                      </label>
                      <label for="melatoninReminderTime" style="margin:0;">Time
                        <input type="time" id="melatoninReminderTime" />
                      </label>
                    </div>
                    <div class="module-inline-actions">
                      <label for="sunlightReminderToggle" style="flex:1;">
                        <input type="checkbox" id="sunlightReminderToggle" /> Morning sunlight alert
                      </label>
                      <label for="sunlightReminderTime" style="margin:0;">Time
                        <input type="time" id="sunlightReminderTime" />
                      </label>
                    </div>
                    <div id="sunlightAlert" class="sunlight-alert hidden" aria-live="polite"></div>
                    <div id="sleepMorningRating" class="energy-rating"></div>
                    <div id="sleepCorrelationSummary" class="sleep-summary"></div>
                    <div class="sleep-tips" id="sleepTips"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article
          id="templateModule"
          class="routine-tile routine-tile--utility"
          data-module-id="templateModule"
          data-routine-id="templates"
          role="group"
          aria-label="Templates"
        >
          <div class="routine-tile__surface routine-theme--utility" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>🧩</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>🧩 Templates</span>
                <span class="routine-tile__prompt" data-routine-prompt>Quick launch your best blueprints.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Pull in proven task blueprints without rewriting every field." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Template Shortcut</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Template quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="template-module__actions">
                    <button id="blockBatchOpen" class="btn btn-secondary" type="button">Block Batch</button>
                  </div>
                  <div id="templateButtons"></div>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article
          id="conflictResolverModule"
          class="routine-tile"
          data-module-id="conflictResolverModule"
          data-routine-id="conflict"
          role="group"
          aria-label="3-v-3 Conflict Resolver"
        >
          <div class="routine-tile__surface routine-theme--conflict" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>🥊</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>🥊 3-v-3 Conflict Resolver</span>
                <span class="routine-tile__prompt" data-routine-prompt>Reframe your mind in 3x3 steps.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Drag one should-do and one want-to into the arena to settle the debate." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Conflict Resolver Preview</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Conflict resolver quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="conflict-grid">
                    <div class="conflict-column">
                      <h3>Top 3 should-do</h3>
                      <div id="conflictShouldList" class="conflict-list" aria-live="polite"></div>
                    </div>
                    <div class="conflict-column">
                      <h3>Top 3 want-to</h3>
                      <div id="conflictWantList" class="conflict-list" aria-live="polite"></div>
                    </div>
                  </div>
                  <div
                    id="conflictArena"
                    class="conflict-arena"
                    role="application"
                    aria-live="polite"
                    aria-label="Drag contenders here"
                  >
                    <div id="conflictArenaPrompt">Drag a contender from each side into the arena.</div>
                  </div>
                  <div class="conflict-actions">
                    <button id="conflictReset" type="button" class="btn btn-ghost">Reset arena</button>
                  </div>
                  <div id="conflictResult" class="score" aria-live="polite"></div>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article
          id="dopamineModule"
          class="routine-tile"
          data-module-id="dopamineModule"
          data-routine-id="dopamine"
          role="group"
          aria-label="Dopamine Retrainer"
        >
          <div class="routine-tile__surface routine-theme--dopamine" data-routine-surface>
            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
              <span class="routine-accent" aria-hidden="true">
                <span class="routine-accent__icon" data-accent-icon>🎵</span>
              </span>
              <div class="routine-tile__info">
                <span class="routine-tile__title" data-routine-title>🎵 Dopamine Retrainer</span>
                <span class="routine-tile__prompt" data-routine-prompt>Train focus with a 5-min win.</span>
              </div>
              <div class="routine-tile__meta">
                <span class="routine-info-dot" title="Stretch reward intervals with a playlist of micro-celebrations." aria-hidden="true">i</span>
                <span class="routine-reminder" data-routine-reminder></span>
                <span class="routine-tile__chevron" aria-hidden="true"></span>
              </div>
            </button>
            <div class="routine-quick-overlay" data-routine-quick-overlay>
              <div class="routine-quick-overlay__content">
                <h3 class="routine-quick-overlay__title">Dopamine Retrainer Preview</h3>
                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
              </div>
            </div>
            <div class="routine-tile__body" data-routine-body hidden>
              <div class="routine-tile__actions">
                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                <div class="routine-quick-actions" role="group" aria-label="Dopamine retrainer quick actions">
                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                </div>
              </div>
              <div class="routine-tile__content">
                <div class="module-body" data-routine-content>
                  <div class="dopamine-playlist">
                    <label for="dopamineReward">Reward style
                      <select id="dopamineReward">
                        <option value="music">Music stinger</option>
                        <option value="confetti">GIF confetti</option>
                        <option value="coin">Coin sound</option>
                        <option value="stretch">Stretch cue</option>
                      </select>
                    </label>
                    <div class="dopamine-intervals" id="dopamineIntervals" aria-live="polite"></div>
                    <div class="dopamine-progress" aria-hidden="true">
                      <span id="dopamineProgressFill"></span>
                    </div>
                    <div class="conflict-actions">
                      <button id="dopamineStart" type="button" class="btn btn-primary">Start playlist</button>
                      <button id="dopamineStop" type="button" class="btn btn-ghost" disabled>Stop</button>
                    </div>
                    <div id="dopamineStatus" class="score" aria-live="polite"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </article>
      </div>      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>
      </div>

  <div id="template-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="templateModalTitle">
    <div class="modal__content">
      <div class="modal__head"><strong id="templateModalTitle">Choose a template</strong><button class="modal__close" type="button">✕</button></div>
      <div class="template-grid" id="template-grid"></div>
    </div>
  </div>

  <div
    id="block-batch-modal"
    class="modal hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="blockBatchModalTitle"
  >
    <div class="modal__content">
      <div class="modal__head">
        <strong id="blockBatchModalTitle">Block Batch Menu</strong>
        <button class="modal__close" type="button">✕</button>
      </div>
      <div class="block-batch-layout">
        <div class="block-batch-list" id="blockBatchList" role="listbox" aria-label="Batch types"></div>
        <div>
          <div class="block-batch-counts" id="blockBatchCounts"></div>
          <div id="blockBatchEditor" class="block-batch-editor hidden" aria-live="polite">
            <div class="block-batch-editor__head">
              <h3 id="blockBatchEditorTitle">Edit default profile</h3>
              <button type="button" class="link-button" id="blockBatchEditorClose">Done</button>
            </div>
            <div class="block-batch-editor__grid">
              <label for="blockBatchCategory">Category
                <select id="blockBatchCategory">
                  <option value="General">General</option>
                  <option value="Admin">Admin</option>
                  <option value="Chart">Chart</option>
                  <option value="Inbox">Inbox</option>
                  <option value="Calls">Calls</option>
                  <option value="Teaching">Teaching</option>
                  <option value="Personal">Personal</option>
                </select>
              </label>
              <label for="blockBatchAuthor">Chart Author
                <select id="blockBatchAuthor">
                  <option value="attending">Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="blockBatchPatient">Patient Type
                <select id="blockBatchPatient">
                  <option value="Non-Complex">Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="blockBatchVisit">Visit Type
                <select id="blockBatchVisit">
                  <option value="Follow-Up">Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="blockBatchClinic">Clinic Site
                <select id="blockBatchClinic">
                  <option value="General Clinic">General Clinic</option>
                  <option value="St PJ’s Shelter">St PJ’s Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="blockBatchImportance">Importance (1–5)
                <select id="blockBatchImportance">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchUrgency">Urgency (1–5)
                <select id="blockBatchUrgency">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchNovelty">Novelty (1–5)
                <select id="blockBatchNovelty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchInterest">Interest (1–5)
                <select id="blockBatchInterest">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchExternalPressure">External Pressure (1–5)
                <select id="blockBatchExternalPressure">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchTimeToStart">Time to Start (1–5)
                <select id="blockBatchTimeToStart">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchDifficulty">Difficulty (1–5)
                <select id="blockBatchDifficulty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
            </div>
            <label for="blockBatchSubtasks">Default subtasks
              <textarea id="blockBatchSubtasks" placeholder="One subtask per line"></textarea>
            </label>
            <label class="sound-toggle" for="blockBatchUseChartTemplate">
              <input type="checkbox" id="blockBatchUseChartTemplate" /> Use chart smart defaults
            </label>
            <div class="block-batch-editor__actions">
              <button id="blockBatchResetProfile" type="button" class="btn btn-ghost">Reset to default</button>
              <button id="blockBatchSaveProfile" type="button" class="btn btn-primary">Save profile</button>
            </div>
          </div>
        </div>
      </div>
      <div class="block-batch-footer">
        <label for="blockBatchDate">Service date
          <input type="date" id="blockBatchDate" />
        </label>
        <button id="blockBatchAdd" class="btn btn-primary" type="button">Add</button>
      </div>
    </div>
  </div>

  <div id="firstThreeWizard" class="wizard-overlay hidden" aria-hidden="true">
    <div class="wizard-content" role="dialog" aria-modal="true" aria-labelledby="firstThreeTitle">
      <h3 id="firstThreeTitle">🪜 First-Three-Steps Wizard</h3>
      <p>Break the project into tiny, guaranteed-win actions to get moving.</p>
      <div class="wizard-steps">
        <label>Step 1
          <input type="text" id="firstThreeStep1" placeholder="Open patient chart" />
        </label>
        <label>Step 2
          <input type="text" id="firstThreeStep2" placeholder="Skim last visit notes" />
        </label>
        <label>Step 3
          <input type="text" id="firstThreeStep3" placeholder="Draft first paragraph" />
        </label>
      </div>
      <div class="wizard-actions">
        <button id="firstThreeSkip" type="button">Skip for this task</button>
        <button id="firstThreeCancel" type="button">Cancel</button>
        <button id="firstThreeSave" type="button">Save steps</button>
      </div>
    </div>
  </div>

  <div id="launchPadModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="launchPadModalTitle">
      <h3 id="launchPadModalTitle">🚀 Prep Tomorrow's Launch Pad</h3>
      <p>Gather items tonight so future-you can walk out the door calm.</p>
      <div id="launchPadModalList" class="sleep-checklist" aria-live="polite"></div>
      <div class="modal-actions">
        <button id="launchPadModalClose" type="button">Done</button>
      </div>
    </div>
  </div>

  <div id="quickCaptureOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="quickCaptureTitle">
      <h3 id="quickCaptureTitle">✍️ Quick capture</h3>
      <label for="quickCaptureInput">Task name
        <input id="quickCaptureInput" type="text" placeholder="What's the very next action?" />
      </label>
      <div class="modal-actions">
        <button id="quickCaptureCancel" type="button" class="btn btn-ghost">Cancel</button>
        <button id="quickCaptureSave" type="button" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <div id="addTaskOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card modal-card--wide" role="dialog" aria-modal="true" aria-labelledby="addTaskTitle">
      <button id="addTaskClose" class="modal__close" type="button" aria-label="Close task builder">✕</button>
      <h3 id="addTaskTitle">Add task</h3>
      <div class="card-body" id="addTaskCardBody" aria-hidden="false">
        <div class="task-form-group">
          <span class="task-form-group__label">New task</span>
          <label for="name">Task name
            <input id="name" type="text" placeholder="3/14 – J.M. – Complex Care Follow-Up (Resident)" />
          </label>
          <label for="taskCategory">Category
            <select id="taskCategory">
              <option value="General" selected>General</option>
              <option value="Admin">Admin</option>
              <option value="Chart">Chart</option>
              <option value="Inbox">Inbox</option>
              <option value="Calls">Calls</option>
              <option value="Teaching">Teaching</option>
              <option value="Personal">Personal</option>
            </select>
          </label>
          <div class="task-inline-actions" aria-label="Task helpers">
            <button type="button" class="link-button" id="btn-use-template">Use template</button>
            <button type="button" class="link-button" id="btn-save-template">Add as template</button>
            <button
              type="button"
              class="link-button"
              id="expandTaskDetailsButton"
              aria-controls="taskDetails"
              aria-expanded="false"
            >
              Show details
            </button>
          </div>
          <div id="taskDetails" class="task-details-panel" data-collapsed="true">
            <div id="chartFields" class="chart-fields is-hidden" aria-hidden="true">
              <label for="authorType">Chart Author
                <select id="authorType">
                  <option value="attending" selected>Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="patientType" title="Complex = medically fragile, multi-specialty, or DME-dependent.">Patient Type
                <select id="patientType">
                  <option value="Non-Complex" selected>Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="visitType" title="Determines estimated chart complexity and time to complete.">Visit Type
                <select id="visitType">
                  <option value="Follow-Up" selected>Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="clinicSite" title="Same-day notes from St PJ’s or Craniofacial automatically rise to the top.">Clinic Site
                <select id="clinicSite">
                  <option value="General Clinic" selected>General Clinic</option>
                  <option value="St PJ’s Shelter">St PJ’s Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="dateOfService" title="Select the date of the encounter; defaults to today.">Date of Service
                <input type="date" id="dateOfService" />
              </label>
              <small id="chartAgeDisplay" class="chart-age"></small>
            </div>
            <label for="importance">Importance (1–5) <select id="importance"></select></label>
            <label for="urgency">Urgency (1–5)
              <select id="urgency"></select>
            </label>
            <small id="urgencyHint" class="urgency-hint"></small>
            <label for="novelty">Novelty (1–5) <select id="novelty"></select></label>
            <label for="interest">Interest (1–5) <select id="interest"></select></label>
            <label for="externalPressure">External Pressure (1–5)
              <select id="externalPressure"></select>
            </label>
            <label for="timeToStart">Time to Start (1–5) <select id="timeToStart"></select></label>
            <label for="difficulty">Difficulty (1–5) <select id="difficulty"></select></label>
            <label for="dueDate" title="Optional specific target date; used for personal scheduling.">Due Date (Optional)
              <input type="date" id="dueDate" />
            </label>
            <label for="initialSubTasks">Subtasks
              <textarea id="initialSubTasks" rows="3" placeholder="One subtask per line."></textarea>
            </label>
            <label class="sound-toggle" for="focusSoundToggle">
              <input type="checkbox" id="focusSoundToggle" checked />
              Enable focus mode ping
            </label>
          </div>
        </div>
      </div>
      <div class="card-sticky-actions" aria-hidden="false">
        <div class="card-sticky-actions__primary">
          <button id="addTaskBtn" class="btn btn-primary" type="button" onclick="addTask()">Add Task</button>
          <button id="saveUpdateBtn" class="btn btn-primary hidden" type="button" onclick="saveTaskUpdate()">Save Update</button>
          <button id="cancelEditBtn" class="btn btn-ghost hidden" type="button" onclick="cancelEdit()">Cancel</button>
        </div>
        <div class="card-sticky-actions__secondary">
          <button type="button" class="btn btn-secondary" onclick="startFiveMinuteSprint()" id="startBtn" disabled>Start 5-min</button>
          <button type="button" class="btn btn-ghost" onclick="reset()">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <div id="focusLaunchBackdrop" class="focus-sheet__backdrop" hidden></div>
  <section
    id="focusLaunchSheet"
    class="focus-sheet"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="focusLaunchTitle"
  >
    <button id="focusLaunchHandle" class="focus-sheet__handle" type="button" aria-label="Close focus launcher"></button>
    <div class="focus-sheet__content">
      <header class="focus-sheet__header">
        <h2 id="focusLaunchTitle">Start Focus</h2>
        <p class="focus-sheet__preview">
          Next suggested: <span id="focusSuggestionText">Add a task to unlock focus.</span>
        </p>
      </header>
      <div class="focus-sheet__options">
        <button
          type="button"
          class="focus-sheet__option focus-sheet__option--primary start-action"
          data-focus-mode="sprint"
        >
          5-min Sprint
        </button>
        <button type="button" class="focus-sheet__option" data-focus-mode="session">Full Session</button>
        <button
          type="button"
          id="focusSuggestionButton"
          class="focus-sheet__option focus-sheet__option--suggestion"
          data-focus-mode="suggestion"
          disabled
          aria-disabled="true"
        >
          <span class="focus-sheet__option-label">Next Suggested Task</span>
          <span id="focusSuggestionDetail" class="focus-sheet__option-detail">Add a task to unlock focus.</span>
        </button>
      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>

  <div id="resourcesBackdrop" class="drawer-backdrop" hidden></div>
  <aside
    id="resourcesDrawer"
    class="resources-drawer"
    aria-hidden="true"
    aria-labelledby="resourcesTitle"
    tabindex="-1"
  >
    <header class="resources-drawer__header">
      <h2 id="resourcesTitle">Quick Access Partners</h2>
      <button id="resourcesClose" class="resources-drawer__close" type="button" aria-label="Close resources">✕</button>
    </header>
    <div class="resources-drawer__body">
      <a
        class="resource-button resource-button--planning"
        href="https://chatgpt.com/g/g-p-68feee841e7081919a28fe9b3083e9f0-karl/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>planning ally</small>
        <strong>Chat with Karl</strong>
        <span>ADHD-tailored task partner ready to map out your day.</span>
      </a>
      <a
        class="resource-button resource-button--strategies"
        href="https://chatgpt.com/g/g-p-6836a5682d0481918484506cbc1f3082-epic-companion/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>strategies</small>
        <strong>EPIC Companion</strong>
        <span>Brainstorm workflows to move faster inside the EHR.</span>
      </a>
      <a
        class="resource-button resource-button--digest"
        href="https://notebooklm.google.com/"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>digest</small>
        <strong>NotebookLM</strong>
        <span>Summarize research and notes in a focused workspace.</span>
      </a>
      <a
        class="resource-button resource-button--vault"
        href="https://www.notion.so/Assessments-and-Plans-28131b26f81f803088bad074ee0e00fb?source=copy_link"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>vault</small>
        <strong>Assessments &amp; Plans</strong>
        <span>Review ready-made assessment and plan examples.</span>
      </a>
      <a
        class="resource-button resource-button--vault"
        href="https://chatgpt.com/g/g-p-68feff1f73ac819189dcf556e573c912-assessments-plans/project"
        target="_blank"
        rel="noopener noreferrer"
      >
        <small>document builder</small>
        <strong>Create Assessments &amp; Plans</strong>
        <span>Draft new assessments from your history and physical notes.</span>
      </a>
    </div>
  </aside>

  <div
    id="sosOverlay"
    class="sos-overlay hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="sosOverlayTitle"
  >
    <div class="sos-card">
      <header class="sos-card__header">
        <h2 id="sosOverlayTitle">Crisis Support</h2>
        <button id="sosOverlayClose" class="sos-card__close" type="button" aria-label="Close crisis support">✕</button>
      </header>
      <div class="sos-card__actions">
        <div class="sos-card__action-group">
          <button id="worstDayButton" class="sos-card__action start-action" type="button">😵‍💫 Worst-Day Mode</button>
          <p id="worstDayHint" class="sos-card__detail"></p>
        </div>
        <button id="sosDefuse" class="sos-card__action" type="button">🧘 DEFUSE Mode</button>
        <button id="sosShield" class="sos-card__action" type="button">🛡️ Meltdown Shield</button>
      </div>
      <p class="sos-card__hint">Need a reset? These stay ready until you close them.</p>
    </div>
  </div>

  <!-- Focus mode -->
  <div id="ganttSnapshotOverlay" class="modal-overlay hidden" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="ganttSnapshotTitle">
    <div class="gantt-card">
      <div class="gantt-card__header">
        <h3 id="ganttSnapshotTitle">⏳ Next 3-hour snapshot</h3>
        <button id="ganttCloseButton" class="modal__close" type="button" aria-label="Close snapshot">✕</button>
      </div>
      <p class="gantt-intro">Blocks sized by estimated minutes so you can see what will actually fit.</p>
      <div class="gantt-blocks-wrapper">
        <div id="ganttProgressBar" class="gantt-progress"></div>
        <div id="ganttBlocks" class="gantt-blocks" role="list"></div>
      </div>
      <div id="ganttStatus" class="gantt-status"></div>
    </div>
  </div>

  <div id="worstDayOverlay" class="modal-overlay hidden worst-day-overlay" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="worstDayHeading">
    <div class="worst-day-card">
      <button id="worstDayClose" class="modal__close" type="button" aria-label="Close Worst-Day mode">✕</button>
      <h3 id="worstDayHeading">😵‍💫 Worst-Day Mode</h3>
      <p class="worst-day-subheading">One soft five-minute pass on your most meaningful project.</p>
      <div class="worst-day-focus-line">
        <span class="worst-day-label">Focus</span>
        <strong id="worstDayFocus"></strong>
      </div>
      <div id="worstDayTimer" class="worst-day-timer">05:00</div>
      <p id="worstDayPrompt" class="worst-day-prompt">Move gently. Drift happens — we'll reset together.</p>
      <div id="worstDayActions" class="worst-day-actions hidden">
        <p class="worst-day-complete">Sprint complete! Pick your next micro-reward.</p>
        <div class="worst-day-celebrations" role="group" aria-label="Worst-Day celebration choices">
          <button type="button" data-worst-day-choice="laugh">😂 Laugh</button>
          <button type="button" data-worst-day-choice="stretch">🙆 Stretch</button>
          <button type="button" data-worst-day-choice="stop">🛑 Stop proudly</button>
        </div>
        <div id="worstDayCelebration" class="worst-day-celebration" aria-live="polite"></div>
      </div>
      <button id="worstDayExit" class="link-button" type="button">Leave Worst-Day Mode</button>
    </div>
  </div>

  <div
    id="defuseOverlay"
    class="modal-overlay hidden defuse-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="defuseOverlayTitle"
  >
    <div class="defuse-modal">
      <header class="defuse-modal__header">
        <h3 id="defuseOverlayTitle">🧘 DEFUSE Mode</h3>
        <button id="defuseClose" class="defuse-modal__close" type="button" aria-label="Close DEFUSE mode">✕</button>
      </header>
      <div id="defuseModule" class="defuse-modal__body" data-module-id="defuseModule">
        <div class="defuse-grid">
          <div class="defuse-steps">
            <strong>Preflight (90s)</strong>
            <div id="defusePrompt">Feeling ≠ instruction. You can feel tired and still send the email.</div>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseProgressFill"></span>
            </div>
            <div class="score">Countdown: <span id="defuseCountdown">90s</span></div>
          </div>
          <div>
            <strong>Fake it action</strong>
            <div class="intention-buttons">
              <button type="button" data-defuse-action="Open the doc & type the title">Open doc + type title</button>
              <button type="button" data-defuse-action="Write one bullet in the note">Draft one bullet</button>
              <button type="button" data-defuse-action="Send the 2-sentence update">Send the 2-sentence update</button>
            </div>
            <p id="defuseActionPreview" class="score">Action picked: Open the doc & type the title</p>
          </div>
          <div>
            <strong>Zone locks</strong>
            <div id="defuseLocks" class="defuse-locks">
              <label><input type="checkbox" value="Messages" /> Messages</label>
              <label><input type="checkbox" value="Email" /> Email</label>
              <label><input type="checkbox" value="Instagram" /> Instagram</label>
              <label><input type="checkbox" value="YouTube" /> YouTube</label>
            </div>
          </div>
          <div>
            <strong>Uptime sprint</strong>
            <p id="defuseUptime" class="score">Next sprint: 10 minutes</p>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseUptimeFill"></span>
            </div>
          </div>
          <div class="conflict-actions">
            <button id="defuseStart" type="button" class="btn btn-primary">Start DEFUSE</button>
            <button id="defuseCancel" type="button" class="btn btn-ghost" disabled>Cancel</button>
          </div>
          <div id="defuseStatus" class="score" aria-live="polite"></div>
        </div>
      </div>
    </div>
  </div>

  <section id="focus" class="focus-overlay hidden" aria-hidden="true">
    <div class="focus-overlay__backdrop" data-focus-dismiss></div>
    <div class="focus-overlay__sheet" role="dialog" aria-modal="true" aria-labelledby="focusTimer" tabindex="-1">
      <header class="focus-overlay__header">
        <div id="focusTimer" aria-live="polite">🧭 Focus Time: 0:00</div>
        <div class="focus-overlay__progress" aria-hidden="true">
          <span id="focusProgressFill" class="focus-overlay__progress-fill"></span>
        </div>
      </header>
      <div class="focus-overlay__body">
        <div class="focus-overlay__summary" id="focusTaskSummary">
          <div class="focus" tabindex="0" aria-live="polite"></div>
          <div class="score task-counter" id="scoreView"></div>
        </div>
        <div id="focusFitHint" class="focus-overlay__hint" aria-live="polite"></div>
        <div id="subTaskView"></div>
        <div id="distractionTools" class="distraction-tools">
          <div class="distraction-tools__header">
            <strong>Distraction cheat sheet</strong>
            <button id="caughtMeButton" type="button" disabled aria-disabled="true">“Caught me”</button>
          </div>
          <div id="distractionPrompt" class="distraction-prompt hidden">
            <span>What pulled you off course?</span>
            <div class="distraction-options" role="group" aria-label="Distraction triggers">
              <button type="button" data-distraction-trigger="tab">Tab hop</button>
              <button type="button" data-distraction-trigger="ping">Notification ping</button>
              <button type="button" data-distraction-trigger="thought">Thought spiral</button>
            </div>
          </div>
          <ul id="distractionLog" class="distraction-log" aria-live="polite" aria-label="Logged distractions"></ul>
          <div id="doorwayReset" class="doorway-reset hidden" aria-live="polite">
            <p id="doorwayResetMessage"></p>
            <div class="doorway-reset-actions">
              <button id="doorwayStartButton" type="button">Start 60-second reset</button>
              <button id="doorwaySkipButton" type="button" class="link-button">Not now</button>
            </div>
            <div id="doorwayCountdown" class="doorway-countdown hidden"></div>
          </div>
        </div>
      </div>
      <footer class="focus-overlay__actions">
        <button id="focusExtendButton" type="button" class="btn btn-secondary">Add 5 more min</button>
        <button id="focusAbortButton" type="button" class="btn btn-ghost">Abort</button>
        <button id="focusCompleteButton" type="button" class="btn hero-cta">Task complete</button>
      </footer>
    </div>
  </section>

  <nav class="command-bar" aria-label="Momentum shortcuts">
    <a href="#focus-engine" class="command-link">
      <span class="command-link__icon" aria-hidden="true">⚡</span>
      <span>Focus</span>
    </a>
    <a href="#tasks-zone" class="command-link">
      <span class="command-link__icon" aria-hidden="true">🩺</span>
      <span>Tasks</span>
    </a>
    <button
      id="resourcesToggle"
      class="command-link command-link--drawer"
      type="button"
      aria-haspopup="dialog"
      aria-controls="resourcesDrawer"
    >
      <span class="command-link__icon" aria-hidden="true">📁</span>
      <span>Resources</span>
    </button>
    <a href="#reset-zone" class="command-link">
      <span class="command-link__icon" aria-hidden="true">🌙</span>
      <span>Reset</span>
    </a>
  </nav>

  <script>
  const $ = id => document.getElementById(id);

  const categories = ["General","Admin","Chart","Inbox","Calls","Teaching","Personal"];
  let activeCategory = "All";
  const TASK_LIST_MODES = { ACTIVE: "active", COMPLETED: "completed" };
  let taskListMode = TASK_LIST_MODES.ACTIVE;
  let showAllActiveTasks = false;
  let derivedDaysSinceVisit = null;
  let urgencyAuto = true;
  const runningTimers = new Map();
  let sprintDurationMinutes = null;
  let sprintEndTime = null;
  let nextTaskId = null;
  let lastFocusedBeforeTemplateModal = null;
  const MODULE_STATE_PREFIX = "moduleState_";
  const ADD_TASK_CARD_STATE_KEY = "ui.addTask.collapsed";
  const LEGACY_ADD_TASK_CARD_STATE_KEY = "addTaskCardState";
  const ALL_TASKS_CARD_STATE_KEY = "ui.allTasks.collapsed";
  const COLLAPSIBLE_MODULE_IDS = [];
  const ROUTINE_STATE_KEY = "ui.routines.metadata";
  const ROUTINE_HAPTIC_KEY = "ui.routines.haptics";
  const ROUTINE_REMINDER_TIMERS = new Map();
  const ROUTINE_CONTEXT_RECENT_MS = 2 * 60 * 60 * 1000;
  const ROUTINE_DEFINITIONS = [
    {
      id: "morning",
      moduleId: "morningLaunchModule",
      title: "Morning Launch Sequence",
      emoji: "🌅",
      microPrompt: "Ready for takeoff? Start your day ritual.",
      defaultSteps: [
        "Move — Light aerobic + sunlight",
        "Reflect — Cold splash + intention",
        "Plan — Process anchors"
      ],
      previewSteps: [
        "Move — Light aerobic + sunlight",
        "Reflect — Cold splash + intention"
      ],
      quickLaunchRef: "moveStartBtn",
      category: "morning",
      reminderBody: "Ready for takeoff?",
      stuckMessage: "Take a sunrise peek and breathe for four counts — then try the first step."
    },
    {
      id: "environment",
      moduleId: "launchPadModule",
      title: "Environmental Reminders & Launch Pads",
      emoji: "🚀",
      microPrompt: "Tap to reset your surroundings.",
      defaultSteps: [
        "Stage tomorrow's essentials",
        "Reset work surface",
        "Preview morning checklist"
      ],
      previewSteps: [
        "Stage tomorrow's essentials",
        "Preview morning checklist"
      ],
      quickLaunchRef: "openLaunchPadModal",
      category: "environment",
      reminderBody: "Tap to reset your surroundings.",
      stuckMessage: "Focus on just one surface — toss clutter into a quick bin sprint."
    },
    {
      id: "sleep",
      moduleId: "sleepToolkitModule",
      title: "Sleep & Circadian Rhythm Toolkit",
      emoji: "😴",
      microPrompt: "Wind down mode is ready.",
      defaultSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch",
        "Morning sunlight reminder"
      ],
      previewSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch"
      ],
      quickLaunchRef: "sleepToolkitToggle",
      category: "sleep",
      reminderBody: "Wind down mode is ready.",
      stuckMessage: "Try a 2-minute legs-up-the-wall reset before continuing."
    },
    {
      id: "conflict",
      moduleId: "conflictResolverModule",
      title: "3-v-3 Conflict Resolver",
      emoji: "🥊",
      microPrompt: "Reframe your mind in 3x3 steps.",
      defaultSteps: [
        "List top 3 should-do",
        "List top 3 want-to",
        "Drag contenders into the arena"
      ],
      previewSteps: [
        "List top 3 should-do",
        "List top 3 want-to"
      ],
      quickLaunchRef: null,
      category: "conflict",
      reminderBody: "Reframe with a quick 3x3.",
      stuckMessage: "Limit the duel to one should-do vs one want-to — jot both before deciding."
    },
    {
      id: "dopamine",
      moduleId: "dopamineModule",
      title: "Dopamine Retrainer",
      emoji: "🎵",
      microPrompt: "Train focus with a 5-min win.",
      defaultSteps: [
        "Pick a reward style",
        "Start the playlist timer",
        "Stretch the victory window"
      ],
      previewSteps: [
        "Pick a reward style",
        "Start the playlist timer"
      ],
      quickLaunchRef: "dopamineStart",
      category: "dopamine",
      reminderBody: "Train focus with a 5-min win.",
      stuckMessage: "Take one song-length pause, then restart the timer with a micro goal."
    },
    {
      id: "templates",
      moduleId: "templateModule",
      title: "Templates",
      emoji: "🧩",
      microPrompt: "Quick launch your best blueprints.",
      defaultSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      previewSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      quickLaunchRef: "blockBatchOpen",
      category: "utility",
      allowReminder: false,
      reminderBody: "Blueprints are ready.",
      stuckMessage: "Pick the template that covers 80% and tweak only the edges."
    }
  ];
  let routineState = {};
  let routineHapticsEnabled = true;
  const routineTiles = new Map();
  let openRoutineId = null;
  let routineContextIntervalId = null;

  function getRoutineDefinition(id) {
    return ROUTINE_DEFINITIONS.find(def => def.id === id) || null;
  }

  function loadRoutineState() {
    let stored = {};
    try {
      const raw = localStorage.getItem(ROUTINE_STATE_KEY);
      if (raw) {
        stored = JSON.parse(raw);
      }
    } catch (error) {
      stored = {};
    }
    const state = {};
    ROUTINE_DEFINITIONS.forEach(def => {
      const data = stored && typeof stored === "object" ? stored[def.id] : null;
      const storedSteps = Array.isArray(data?.steps) ? data.steps.filter(Boolean).map(step => String(step)) : [];
      const steps = storedSteps.length ? storedSteps : [...def.defaultSteps];
      state[def.id] = {
        id: def.id,
        title: typeof data?.title === "string" && data.title.trim() ? data.title.trim() : def.title,
        lastUsed: typeof data?.lastUsed === "string" ? data.lastUsed : null,
        usageCount: Number.isFinite(data?.usageCount) ? Number(data.usageCount) : 0,
        streak: Number.isFinite(data?.streak) ? Number(data.streak) : 0,
        reminderTime: typeof data?.reminderTime === "string" ? data.reminderTime : null,
        steps,
        quickLaunch: typeof data?.quickLaunch === "string" && steps.includes(data.quickLaunch)
          ? data.quickLaunch
          : steps[0] || null
      };
    });
    return state;
  }

  function saveRoutineState() {
    try {
      localStorage.setItem(ROUTINE_STATE_KEY, JSON.stringify(routineState));
    } catch (error) {
      // ignore persistence errors
    }
  }

  function formatRoutineTimeAgo(iso) {
    const date = new Date(iso);
    if (!iso || Number.isNaN(date.getTime())) {
      return "just now";
    }
    const diff = Date.now() - date.getTime();
    if (diff < 0) return "just now";
    const minute = 60000;
    const hour = 3600000;
    const day = 86400000;
    if (diff < minute) {
      return "just now";
    }
    if (diff < hour) {
      const mins = Math.max(1, Math.round(diff / minute));
      return `${mins} min${mins === 1 ? "" : "s"} ago`;
    }
    if (diff < day) {
      const hours = Math.max(1, Math.round(diff / hour));
      return `${hours} hour${hours === 1 ? "" : "s"} ago`;
    }
    const days = Math.max(1, Math.round(diff / day));
    return `${days} day${days === 1 ? "" : "s"} ago`;
  }

  function computeRoutinePrompt(def, meta) {
    if (!meta) return def.microPrompt;
    if (Number(meta.streak) >= 3) {
      return `${meta.streak}-day streak — keep it going!`;
    }
    if (meta.lastUsed) {
      return `Last used: ${formatRoutineTimeAgo(meta.lastUsed)}. Ready again?`;
    }
    return def.microPrompt;
  }

  function populateRoutineOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (!overlay) return;
    const list = overlay.querySelector('[data-quick-preview]');
    const button = overlay.querySelector('[data-quick-launch]');
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (list) {
      list.innerHTML = "";
      const steps = (meta?.steps && meta.steps.length ? meta.steps : def.defaultSteps).slice(0, 2);
      steps.forEach(step => {
        const li = document.createElement("li");
        li.textContent = step;
        list.appendChild(li);
      });
    }
    if (button) {
      button.textContent = `Quick launch ${meta?.title || def.title}`;
    }
  }

  function updateRoutineTile(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    const titleEl = tile.querySelector('[data-routine-title]');
    const promptEl = tile.querySelector('[data-routine-prompt]');
    const reminderEl = tile.querySelector('[data-routine-reminder]');
    const startBtn = tile.querySelector('[data-routine-start]');
    if (titleEl) {
      titleEl.textContent = `${def.emoji} ${meta.title || def.title}`;
    }
    if (promptEl) {
      promptEl.textContent = computeRoutinePrompt(def, meta);
    }
    if (reminderEl) {
      reminderEl.textContent = meta.reminderTime && def.allowReminder !== false ? `Reminder • ${meta.reminderTime}` : "";
    }
    if (startBtn && tile.dataset.running !== "true") {
      startBtn.textContent = "Start Routine";
    }
    populateRoutineOverlay(id);
  }

  function toggleRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    if (tile.classList.contains("routine-tile--open")) {
      closeRoutineTile(id);
    } else {
      openRoutineTile(id);
    }
  }

  function openRoutineTile(id, options = {}) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    if (openRoutineId && openRoutineId !== id) {
      closeRoutineTile(openRoutineId);
    }
    openRoutineId = id;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    body.hidden = false;
    const targetHeight = body.scrollHeight;
    body.style.maxHeight = `${targetHeight}px`;
    tile.classList.add("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "true");
    }
    window.setTimeout(() => {
      if (tile.classList.contains("routine-tile--open")) {
        body.style.maxHeight = "none";
      }
    }, 260);
    if (options.scrollIntoView !== false) {
      tile.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
  }

  function closeRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    tile.classList.remove("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "false");
    }
    const currentHeight = body.scrollHeight;
    body.style.maxHeight = `${currentHeight}px`;
    requestAnimationFrame(() => {
      body.style.maxHeight = "0px";
    });
    window.setTimeout(() => {
      if (!tile.classList.contains("routine-tile--open")) {
        body.hidden = true;
      }
    }, 260);
    if (openRoutineId === id) {
      openRoutineId = null;
    }
  }

  function closeRoutineQuickOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (overlay) {
      overlay.classList.remove("is-visible");
    }
  }

  function quickLaunchRoutine(id) {
    const def = getRoutineDefinition(id);
    if (!def) return;
    if (def.quickLaunchRef) {
      const target = document.getElementById(def.quickLaunchRef);
      if (target) {
        target.click();
      }
    }
    startRoutine(id, { source: "quickLaunch" });
    closeRoutineQuickOverlay(id);
  }

  function attachRoutineGestures(tile, def) {
    const surface = tile.querySelector('[data-routine-surface]');
    if (!surface) return;
    const LONG_PRESS_MS = 600;
    let pointerId = null;
    let startX = 0;
    let startY = 0;
    let isSwipe = false;
    let longPressTimer = null;
    let longPressTriggered = false;

    const clearTimers = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    surface.addEventListener("pointerdown", event => {
      if (event.button !== 0) return;
      pointerId = event.pointerId;
      startX = event.clientX;
      startY = event.clientY;
      isSwipe = false;
      longPressTriggered = false;
      tile.dataset.ignoreNextClick = "false";
      surface.setPointerCapture(pointerId);
      clearTimers();
      longPressTimer = window.setTimeout(() => {
        longPressTriggered = true;
        tile.dataset.ignoreNextClick = "true";
        populateRoutineOverlay(def.id);
        const overlay = tile.querySelector('[data-routine-quick-overlay]');
        if (overlay) {
          overlay.classList.add("is-visible");
        }
        triggerRoutineHaptic([10]);
      }, LONG_PRESS_MS);
    });

    surface.addEventListener("pointermove", event => {
      if (event.pointerId !== pointerId) return;
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      if (Math.abs(dy) > 10) {
        clearTimers();
      }
      if (!isSwipe && Math.abs(dx) > 18 && Math.abs(dx) > Math.abs(dy)) {
        isSwipe = true;
        clearTimers();
        surface.classList.add("swiping");
      }
      if (isSwipe) {
        event.preventDefault();
        const clamped = Math.max(-120, Math.min(120, dx));
        surface.style.transform = `translateX(${clamped}px)`;
      }
    });

    const release = event => {
      if (event.pointerId !== pointerId) return;
      surface.releasePointerCapture(pointerId);
      clearTimers();
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      surface.classList.remove("swiping");
      surface.style.transform = "";
      pointerId = null;
      if (isSwipe) {
        if (dx > 80) {
          tile.dataset.ignoreNextClick = "true";
          startRoutine(def.id, { source: "swipe" });
        } else if (dx < -80) {
          tile.dataset.ignoreNextClick = "true";
          openRoutineEdit(def.id);
        }
        return;
      }
      if (longPressTriggered) {
        return;
      }
    };

    surface.addEventListener("pointerup", release);
    surface.addEventListener("pointercancel", release);
    surface.addEventListener("pointerleave", event => {
      if (event.pointerId === pointerId) {
        clearTimers();
      }
    });
  }

  function triggerRoutineHaptic(pattern = [12]) {
    if (!routineHapticsEnabled) return;
    if (navigator?.vibrate) {
      try {
        navigator.vibrate(pattern);
      } catch (error) {
        // ignore vibration errors
      }
    }
  }

  function startRoutine(id, options = {}) {
    const def = getRoutineDefinition(id);
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!def || !tile || !meta) return;
    closeRoutineQuickOverlay(id);
    const shouldExpand = !options.source || options.source === "tap";
    if (shouldExpand) {
      openRoutineTile(id, { scrollIntoView: options.source !== "quickLaunch" });
    }
    const previous = {
      lastUsed: meta.lastUsed,
      usageCount: meta.usageCount,
      streak: meta.streak
    };
    const now = new Date();
    const todayKey = getDateKey(now);
    const previousKey = meta.lastUsed ? getDateKey(new Date(meta.lastUsed)) : null;
    meta.lastUsed = now.toISOString();
    meta.usageCount = (meta.usageCount || 0) + 1;
    if (previousKey === todayKey) {
      meta.streak = meta.streak || 1;
    } else if (previousKey === getOffsetDateKey(todayKey, -1)) {
      meta.streak = (meta.streak || 0) + 1;
    } else {
      meta.streak = 1;
    }
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "true";
    tile.classList.add("is-running");
    const surface = tile.querySelector('[data-routine-surface]');
    if (surface) {
      surface.classList.add("is-pulsing");
      window.setTimeout(() => surface.classList.remove("is-pulsing"), 250);
    }
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Mark complete";
    }
    triggerRoutineHaptic();
    if (typeof playFocusPing === "function") {
      playFocusPing();
    }
    window.setTimeout(() => tile.classList.remove("is-running"), 1800);
    const message = options.source === "swipe"
      ? `${def.emoji} ${meta.title || def.title} started — undo?`
      : `${def.emoji} Routine started.`;
    const toastOptions = options.source === "swipe"
      ? {
          action: {
            label: "Undo",
            onClick: () => undoRoutineStart(id, previous)
          },
          position: "bottom",
          timeout: 4000
        }
      : { timeout: 3500 };
    showToast(meta.title || def.title, message, toastOptions);
    updateRoutineContextGlow();
  }

  function undoRoutineStart(id, previous) {
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!tile || !meta) return;
    meta.lastUsed = previous.lastUsed || null;
    meta.usageCount = Number.isFinite(previous.usageCount) ? previous.usageCount : 0;
    meta.streak = Number.isFinite(previous.streak) ? previous.streak : 0;
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    updateRoutineContextGlow();
  }

  function completeRoutine(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    tile.classList.add("routine-tile--celebrate");
    window.setTimeout(() => tile.classList.remove("routine-tile--celebrate"), 900);
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    triggerRoutineHaptic([16, 32, 16]);
    showToast(meta.title || def.title, "Routine done — nice work!", { timeout: 4200 });
    updateRoutineContextGlow();
  }

  function handleRoutineQuickAction(id, action) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    switch (action) {
      case "refresh":
        meta.lastUsed = null;
        meta.streak = 0;
        saveRoutineState();
        updateRoutineTile(id);
        showToast(meta.title || def.title, "Micro prompt refreshed.", { timeout: 2500 });
        updateRoutineContextGlow();
        break;
      case "adjust":
        openRoutineEdit(id);
        break;
      case "stuck":
        showToast(meta.title || def.title, def.stuckMessage || "Take one tiny step toward the next action.", { timeout: 4000 });
        break;
      default:
        break;
    }
  }

  let activeRoutineEditId = null;

  function openRoutineEdit(id) {
    const sheet = document.getElementById("routineEditSheet");
    const meta = routineState[id];
    const def = getRoutineDefinition(id);
    if (!sheet || !meta || !def) return;
    closeRoutineQuickOverlay(id);
    activeRoutineEditId = id;
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    if (nameField) nameField.value = meta.title || def.title;
    if (stepsField) stepsField.value = meta.steps.join("\n");
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
      if (meta.quickLaunch && meta.steps.includes(meta.quickLaunch)) {
        quickSelect.value = meta.quickLaunch;
      }
    }
    if (reminderField) {
      reminderField.value = meta.reminderTime || "";
      reminderField.disabled = def.allowReminder === false;
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.checked = routineHapticsEnabled;
    }
    sheet.classList.add("is-visible");
    const panel = sheet.querySelector('.routine-sheet__panel');
    if (panel) {
      panel.setAttribute("tabindex", "-1");
      panel.focus({ preventScroll: true });
    }
  }

  function closeRoutineEdit() {
    const sheet = document.getElementById("routineEditSheet");
    if (!sheet) return;
    sheet.classList.remove("is-visible");
    activeRoutineEditId = null;
  }

  function setRoutineHaptics(enabled) {
    routineHapticsEnabled = Boolean(enabled);
    try {
      localStorage.setItem(ROUTINE_HAPTIC_KEY, routineHapticsEnabled ? "true" : "false");
    } catch (error) {
      // ignore
    }
    const toggle = document.getElementById("routineHapticsToggle");
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (toggle) toggle.checked = routineHapticsEnabled;
    if (sheetToggle) sheetToggle.checked = routineHapticsEnabled;
  }

  async function saveRoutineEdit() {
    if (!activeRoutineEditId) {
      closeRoutineEdit();
      return;
    }
    const def = getRoutineDefinition(activeRoutineEditId);
    const meta = routineState[activeRoutineEditId];
    if (!def || !meta) {
      closeRoutineEdit();
      return;
    }
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    meta.title = nameField?.value?.trim() || def.title;
    const steps = (stepsField?.value || "")
      .split(/\n+/)
      .map(step => step.trim())
      .filter(Boolean);
    meta.steps = steps.length ? steps : [...def.defaultSteps];
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
    }
    const selectedQuick = quickSelect?.value && meta.steps.includes(quickSelect.value) ? quickSelect.value : meta.steps[0] || null;
    meta.quickLaunch = selectedQuick;
    if (def.allowReminder !== false && reminderField) {
      const timeValue = reminderField.value || null;
      meta.reminderTime = timeValue;
      if (timeValue) {
        const granted = await ensureNotificationPermission();
        if (!granted) {
          meta.reminderTime = null;
          reminderField.value = "";
          showToast(meta.title, "Notifications blocked. Reminder cleared.", { timeout: 3500 });
        }
      }
      scheduleRoutineReminder(activeRoutineEditId);
    }
    saveRoutineState();
    updateRoutineTile(activeRoutineEditId);
    closeRoutineEdit();
    showToast(meta.title, "Routine updated", { timeout: 2600 });
    updateRoutineContextGlow();
  }

  function syncRoutineReminderDisplays() {
    ROUTINE_DEFINITIONS.forEach(def => updateRoutineTile(def.id));
  }

  async function ensureNotificationPermission() {
    if (!("Notification" in window)) return false;
    if (Notification.permission === "granted") return true;
    if (Notification.permission === "denied") return false;
    try {
      const result = await Notification.requestPermission();
      return result === "granted";
    } catch (error) {
      return false;
    }
  }

  function cancelRoutineReminder(id) {
    const timer = ROUTINE_REMINDER_TIMERS.get(id);
    if (timer) {
      window.clearTimeout(timer);
      ROUTINE_REMINDER_TIMERS.delete(id);
    }
  }

  function scheduleRoutineReminder(id) {
    cancelRoutineReminder(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta || def.allowReminder === false || !meta.reminderTime) return;
    const [hours, minutes] = meta.reminderTime.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return;
    const now = new Date();
    const next = new Date();
    next.setHours(hours, minutes, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    const delay = Math.max(0, next.getTime() - now.getTime());
    const timerId = window.setTimeout(() => {
      deliverRoutineReminder(id);
      ROUTINE_REMINDER_TIMERS.delete(id);
      scheduleRoutineReminder(id);
    }, delay);
    ROUTINE_REMINDER_TIMERS.set(id, timerId);
  }

  async function deliverRoutineReminder(id) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    const title = `${def.emoji} ${meta.title || def.title}`;
    const body = def.reminderBody || def.microPrompt;
    if (document.visibilityState !== "hidden") {
      openRoutineTile(id, { scrollIntoView: true });
      showToast(title, body, {
        action: { label: "Open", onClick: () => openRoutineTile(id) },
        timeout: 5000,
        className: "toast--inline"
      });
      return;
    }
    if (!("serviceWorker" in navigator)) return;
    try {
      const registration = await navigator.serviceWorker.ready;
      if (Notification.permission === "granted") {
        registration.showNotification(title, {
          body,
          tag: `routine-${id}`,
          data: { routineId: id },
          renotify: true
        });
      }
    } catch (error) {
      // ignore notification failures
    }
  }

  function updateRoutineContextGlow() {
    const priority = computeRoutinePriority();
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = routineTiles.get(def.id);
      if (!tile) return;
      const surface = tile.querySelector('[data-routine-surface]');
      if (priority === def.id) {
        tile.classList.add("routine-tile--context");
        const meta = routineState[def.id];
        const alpha = computeRoutineGlowAlpha(meta);
        if (surface) {
          surface.style.setProperty("--routine-context-glow-alpha", alpha.toFixed(2));
        }
      } else {
        tile.classList.remove("routine-tile--context");
        if (surface) {
          surface.style.removeProperty("--routine-context-glow-alpha");
        }
      }
    });
  }

  function computeRoutinePriority() {
    const hour = new Date().getHours();
    if (hour >= 6 && hour <= 11) return "morning";
    if (hour >= 19 || hour <= 23) return "sleep";
    const conflict = routineState.conflict;
    if (conflict?.lastUsed) {
      const last = new Date(conflict.lastUsed).getTime();
      if (!Number.isNaN(last) && Date.now() - last < ROUTINE_CONTEXT_RECENT_MS) {
        return "conflict";
      }
    }
    return null;
  }

  function computeRoutineGlowAlpha(meta) {
    const base = 0.18;
    if (!meta) return base;
    const now = Date.now();
    const hour = 60 * 60 * 1000;
    const day = 24 * hour;
    let alpha = base;
    if (!meta.lastUsed) {
      alpha = 0.26;
    } else {
      const last = new Date(meta.lastUsed).getTime();
      if (!Number.isNaN(last)) {
        const diff = Math.max(0, now - last);
        if (diff < 3 * hour) {
          alpha = 0.14;
        } else if (diff < 12 * hour) {
          alpha = 0.18;
        } else if (diff < day) {
          alpha = 0.22;
        } else {
          alpha = 0.26;
        }
      } else {
        alpha = 0.22;
      }
    }
    if (Number(meta.streak) >= 3) {
      alpha = Math.max(0.12, alpha - 0.02);
    }
    return Math.min(0.28, Math.max(0.12, alpha));
  }

  function initializeRoutineTiles() {
    routineState = loadRoutineState();
    try {
      const storedHaptics = localStorage.getItem(ROUTINE_HAPTIC_KEY);
      if (storedHaptics !== null) {
        routineHapticsEnabled = storedHaptics === "true";
      }
    } catch (error) {
      routineHapticsEnabled = true;
    }
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = document.querySelector(`[data-routine-id="${def.id}"]`);
      if (!tile) return;
      routineTiles.set(def.id, tile);
      tile.dataset.running = "false";
      const trigger = tile.querySelector('[data-routine-trigger]');
      const startBtn = tile.querySelector('[data-routine-start]');
      const quickActions = tile.querySelectorAll('[data-quick-action]');
      const overlay = tile.querySelector('[data-routine-quick-overlay]');
      if (trigger) {
        trigger.setAttribute("role", "button");
        trigger.setAttribute("aria-expanded", "false");
        trigger.addEventListener("click", () => {
          if (tile.dataset.ignoreNextClick === "true") {
            tile.dataset.ignoreNextClick = "false";
            return;
          }
          toggleRoutineTile(def.id);
        });
      }
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          if (tile.dataset.running === "true") {
            completeRoutine(def.id);
          } else {
            startRoutine(def.id, { source: "tap" });
          }
        });
      }
      quickActions.forEach(button => {
        button.addEventListener("click", () => handleRoutineQuickAction(def.id, button.getAttribute("data-quick-action")));
      });
      if (overlay) {
        const quickLaunchBtn = overlay.querySelector('[data-quick-launch]');
        if (quickLaunchBtn) {
          quickLaunchBtn.addEventListener("click", () => quickLaunchRoutine(def.id));
        }
        overlay.addEventListener("click", event => {
          if (event.target === overlay) {
            closeRoutineQuickOverlay(def.id);
          }
        });
      }
      attachRoutineGestures(tile, def);
      updateRoutineTile(def.id);
      if (def.allowReminder !== false) {
        scheduleRoutineReminder(def.id);
      }
    });
    setRoutineHaptics(routineHapticsEnabled);
    const hapticsToggle = document.getElementById("routineHapticsToggle");
    if (hapticsToggle) {
      hapticsToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheet = document.getElementById("routineEditSheet");
    if (sheet) {
      const scrim = sheet.querySelector('[data-routine-sheet-dismiss]');
      const cancelBtn = sheet.querySelector('[data-routine-sheet-cancel]');
      const saveBtn = sheet.querySelector('[data-routine-sheet-save]');
      if (scrim) scrim.addEventListener("click", () => closeRoutineEdit());
      if (cancelBtn) cancelBtn.addEventListener("click", () => closeRoutineEdit());
      if (saveBtn) saveBtn.addEventListener("click", () => saveRoutineEdit());
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.getElementById("routineEditSheet")?.classList.contains("is-visible")) {
        closeRoutineEdit();
      }
    });
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js").catch(() => {});
    }
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener("message", event => {
        const data = event.data || {};
        if (data.type === "routine-reminder" && data.routineId) {
          openRoutineTile(data.routineId, { scrollIntoView: true });
        }
      });
    }
    const hashMatch = window.location.hash && window.location.hash.match(/^#routine-(.+)$/);
    if (hashMatch && routineTiles.has(hashMatch[1])) {
      openRoutineTile(hashMatch[1], { scrollIntoView: true });
    }
    updateRoutineContextGlow();
    if (routineContextIntervalId) {
      window.clearInterval(routineContextIntervalId);
    }
    routineContextIntervalId = window.setInterval(updateRoutineContextGlow, 60 * 1000);
  }

  const chartFieldIds = ["authorType", "patientType", "visitType", "clinicSite", "dateOfService"];
  let storedChartFieldValues = null;
  let currentScaleDescriptorCategory = "general";
  const FOCUS_PING_INTERVAL_MS = 10 * 60 * 1000;
  const DISTRACTION_TRIGGER_OPTIONS = [
    { value: "tab", label: "Tab hop" },
    { value: "ping", label: "Notification ping" },
    { value: "thought", label: "Thought spiral" }
  ];
  const DOORWAY_RESET_THRESHOLD = 2;
  const DOORWAY_RESET_DURATION_MS = 60 * 1000;
  const GANTT_WINDOW_MINUTES = 180;
  const WORST_DAY_DURATION_MS = 5 * 60 * 1000;
  const WORST_DAY_LAUGHS = [
    "You just taught your nervous system a new party trick.",
    "That five-minute win still counts on your CV.",
    "Future-you is slow clapping right now."
  ];
  const WORST_DAY_STRETCHES = [
    "Shake out wrists, roll shoulders, slow neck circles.",
    "Stand tall, inhale for four, exhale for six.",
    "Touch the door frame, feel the reset, come back in."
  ];
  const AUDIT_STORAGE_PREFIX = "audit_";
  const AUDIT_SHOWN_SUFFIX = "_shown";
  const MORNING_LAUNCH_KEY = "morningLaunchState";
  const LAUNCH_PAD_KEY = "launchPadState";
  const SLEEP_TOOLKIT_KEY = "sleepToolkitState";
  let lastFocusEnergyLevel = null;
  let lastFocusTimeBudget = null;
  let syncingEnergySliders = false;
  let conflictArenaSelection = { should: null, want: null };
  const DEFUSE_MINUTES_MIN = 10;
  const DEFUSE_MINUTES_MAX = 30;
  const DEFAULT_DEFUSE_ACTION = "Open the doc & type the title";
  let defuseState = {
    active: false,
    countdown: 90,
    intervalId: null,
    uptime: DEFUSE_MINUTES_MIN,
    uptimeIntervalId: null,
    selectedAction: DEFAULT_DEFUSE_ACTION
  };
  let dopamineState = null;
  const FIRST_THREE_KEYWORDS = [
    "report",
    "project",
    "backlog",
    "chart",
    "presentation",
    "summary",
    "documentation",
    "analysis",
    "panel",
    "prep"
  ];
  const FIRST_THREE_WORD_THRESHOLD = 5;
  const DEFAULT_MORNING_TIMER_MINUTES = 20;
  const MORNING_BLOCKS = ["move", "reflect", "plan"];
  const MORNING_CHART_LIMIT = 10;
  const MORNING_CHART_COLORS = {
    completion: "#0a84ff",
    energy: "#f97316",
    grid: "rgba(148, 163, 184, 0.25)",
    axis: "rgba(148, 163, 184, 0.4)"
  };
  const DEFAULT_LAUNCH_PAD_REMINDER = "20:00";
  const DEFAULT_MELATONIN_TIME = "21:30";
  const DEFAULT_SUNLIGHT_TIME = "08:00";
  const DEFAULT_LAUNCH_PAD_SITE = "General Clinic";
  const NEXT_BEST_STORAGE_KEY = "nextBest.inputs";
  const PREFLIGHT_TOGGLES_KEY = "preflight.toggles";
  const DEFUSE_BASE_MINUTES_KEY = "defuse.baseMinutes";
  const DEFUSE_ACTION_KEY = "defuse.action";
  const DEFUSE_LOCKS_KEY = "defuse.locks";
  const DOPAMINE_REWARD_KEY = "dopamine.reward";
  const DOPAMINE_INTERVALS = [2, 6, 12];
  const BLOCK_BATCH_STORAGE_KEY = "blockBatch.profiles";
  const LAST_ZONE_STORAGE_KEY = "momentum.lastZone";
  const BRIEF_MODE_STORAGE_KEY = "momentum.briefMode";

  let latestNextBestPicks = {};
  let nextBestUpdatePending = false;
  let lastActiveZoneId = null;
  let focusLaunchOpen = false;
  let scrollCalmTimer = null;
  let taskGestureObserver = null;
  let lastDefuseOpener = null;
  let lastSosTrigger = null;

  function isElementMostlyInView(element, ratio = 0.3) {
    if (!element) return false;
    const rect = element.getBoundingClientRect();
    const viewHeight = window.innerHeight || document.documentElement.clientHeight;
    if (rect.height <= 0 || rect.bottom <= 0 || rect.top >= viewHeight) return false;
    const visibleTop = Math.max(0, -rect.top);
    const visibleBottom = Math.max(0, Math.min(viewHeight, rect.bottom) - Math.max(0, rect.top));
    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
    return visibleHeight / rect.height >= ratio;
  }

  function scrollToZone(zoneId, options = {}) {
    if (!zoneId) return;
    const target = document.getElementById(zoneId);
    if (!target) return;
    const behavior = options.behavior || "smooth";
    target.scrollIntoView({ behavior, block: "start" });
  }

  function applyBriefMode(enabled, { silent = false } = {}) {
    document.body.classList.toggle("brief-mode", Boolean(enabled));
    try {
      localStorage.setItem(BRIEF_MODE_STORAGE_KEY, enabled ? "1" : "0");
    } catch (error) {
      console.warn("Unable to persist brief mode", error);
    }
    if (!silent) {
      showToast("Brief mode", enabled ? "Minimal view on." : "Full detail restored.");
    }
  }

  function toggleBriefMode() {
    const nextState = !document.body.classList.contains("brief-mode");
    applyBriefMode(nextState);
  }

  function restoreBriefModePreference() {
    try {
      const stored = localStorage.getItem(BRIEF_MODE_STORAGE_KEY);
      if (stored === "1") {
        applyBriefMode(true, { silent: true });
      }
    } catch (error) {
      console.warn("Unable to load brief mode preference", error);
    }
  }

  function setFocusLaunchOpen(open) {
    focusLaunchOpen = Boolean(open);
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    if (fab) {
      fab.setAttribute("aria-expanded", focusLaunchOpen ? "true" : "false");
    }
    if (sheet) {
      sheet.classList.toggle("is-open", focusLaunchOpen);
      sheet.setAttribute("aria-hidden", focusLaunchOpen ? "false" : "true");
    }
    if (backdrop) {
      if (focusLaunchOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!focusLaunchOpen) {
            backdrop.hidden = true;
          }
        }, 220);
      }
    }
    if (!focusLaunchOpen && fab) {
      fab.focus();
    }
  }

  function updateCommandLinkStates(activeZoneId) {
    const links = document.querySelectorAll(".command-bar .command-link");
    links.forEach(link => {
      const hash = link.getAttribute("href") || "";
      const targetId = hash.startsWith("#") ? hash.slice(1) : null;
      const anchor = targetId ? document.getElementById(targetId) : null;
      const zone = anchor ? anchor.closest(".momentum-zone") : null;
      const isActive = Boolean(zone && zone.id === activeZoneId);
      link.classList.toggle("is-active", isActive);
      if (isActive) {
        link.setAttribute("aria-current", "true");
      } else {
        link.removeAttribute("aria-current");
      }
    });
  }

  function persistLastActiveZone(zoneId) {
    if (!zoneId) return;
    lastActiveZoneId = zoneId;
    try {
      localStorage.setItem(LAST_ZONE_STORAGE_KEY, zoneId);
    } catch (error) {
      console.warn("Unable to persist last active zone", error);
    }
  }

  function handleActiveZoneChange(zoneId) {
    if (!zoneId) return;
    persistLastActiveZone(zoneId);
    updateCommandLinkStates(zoneId);
  }

  function setupMomentumZones() {
    const zones = Array.from(document.querySelectorAll(".momentum-zone"));
    if (!zones.length) return;

    let storedZoneId = null;
    try {
      storedZoneId = localStorage.getItem(LAST_ZONE_STORAGE_KEY);
    } catch (error) {
      console.warn("Unable to read last zone", error);
    }

    const fallbackZone =
      document.getElementById("actionZone") ||
      document.getElementById("launchZone") ||
      zones[0];
    const initialZone = zones.find(zone => zone.id === storedZoneId) || fallbackZone;
    if (initialZone) {
      handleActiveZoneChange(initialZone.id);
    }

    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              handleActiveZoneChange(entry.target.id);
            }
          });
        },
        { threshold: 0.35 }
      );
      zones.forEach(zone => observer.observe(zone));
    }

    const commandLinks = document.querySelectorAll(".command-bar .command-link");
    commandLinks.forEach(link => {
      link.addEventListener("click", event => {
        const hash = link.getAttribute("href") || "";
        if (!hash.startsWith("#")) return;
        event.preventDefault();
        const targetId = hash.slice(1);
        if (!targetId) return;
        scrollToZone(targetId);
        const anchor = document.getElementById(targetId);
        const zone = anchor ? anchor.closest(".momentum-zone") : null;
        if (zone) {
          handleActiveZoneChange(zone.id);
        }
      });
    });

    const handleScrollEffects = () => {
      document.body.classList.add("is-scrolling");
      if (scrollCalmTimer) {
        window.clearTimeout(scrollCalmTimer);
      }
      scrollCalmTimer = window.setTimeout(() => {
        document.body.classList.remove("is-scrolling");
      }, 180);
    };

    window.addEventListener("scroll", handleScrollEffects, { passive: true });
    window.addEventListener("resize", handleScrollEffects);
    handleScrollEffects();
  }

  function setupNextBestObserver() {
    const target = $("nextBestEngineCard");
    if (!target || typeof IntersectionObserver === "undefined") return;
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting && nextBestUpdatePending) {
            updateNextBestOptions({ force: true });
          }
        });
      },
      { threshold: 0.3 }
    );
    observer.observe(target);
  }

  function setupSmartCollapse() {
    if (!window.matchMedia) return;
    const media = window.matchMedia("(max-width: 768px)");

    const resetCards = () => {
      document.querySelectorAll('.card[data-smart-collapsed="true"]').forEach(card => {
        card.classList.remove("collapsed");
        card.removeAttribute("data-smart-collapsed");
      });
    };

    const evaluateCards = () => {
      if (!media.matches) {
        resetCards();
        return;
      }
      const cards = document.querySelectorAll(".card");
      cards.forEach(card => {
        if (!card.isConnected) return;
        const rect = card.getBoundingClientRect();
        if (rect.height <= 0) return;
        if (rect.top < -100) {
          if (card.getAttribute("data-smart-collapsed") !== "true") {
            card.classList.add("collapsed");
            card.setAttribute("data-smart-collapsed", "true");
          }
        } else if (card.getAttribute("data-smart-collapsed") === "true" && rect.top > -80) {
          card.classList.remove("collapsed");
          card.removeAttribute("data-smart-collapsed");
        }
      });
    };

    let scheduled = false;
    const scheduleEvaluation = () => {
      if (!media.matches) return;
      if (scheduled) return;
      scheduled = true;
      window.requestAnimationFrame(() => {
        scheduled = false;
        evaluateCards();
      });
    };

    const handleMediaChange = event => {
      if (event.matches) {
        evaluateCards();
      } else {
        resetCards();
      }
    };

    if (typeof media.addEventListener === "function") {
      media.addEventListener("change", handleMediaChange);
    } else if (typeof media.addListener === "function") {
      media.addListener(handleMediaChange);
    }

    window.addEventListener("scroll", scheduleEvaluation, { passive: true });
    window.addEventListener("resize", scheduleEvaluation);
    evaluateCards();

    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(scheduleEvaluation);
      observer.observe(document.body, { childList: true, subtree: true });
    }
  }

  function refreshTaskGestureTargets() {
    const list = $("taskList");
    if (!list) return;
    const cards = list.querySelectorAll(".task-card[data-task-id]");
    cards.forEach(card => {
      const mode = card.classList.contains("is-completed") ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      attachTaskGestureHandlers(card, card.dataset.taskId, mode);
    });
  }

  function attachTaskGestureHandlers(card, taskId, mode = TASK_LIST_MODES.ACTIVE) {
    if (!card || !taskId || mode !== TASK_LIST_MODES.ACTIVE) return;
    if (!window.PointerEvent) return;
    if (card.dataset.gesturesAttached === "true") return;
    card.dataset.gesturesAttached = "true";

    const normalizedId = String(taskId);
    let pointerActive = false;
    let startX = 0;
    let startY = 0;
    let pointerId = null;
    let handled = false;
    let longPressTimer = null;
    const LONG_PRESS_MS = 550;
    const SWIPE_THRESHOLD = 56;
    const MAX_VERTICAL_DRIFT = 28;

    const clearLongPress = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    const resetState = () => {
      pointerActive = false;
      handled = false;
      pointerId = null;
      clearLongPress();
    };

    const handlePointerDown = event => {
      if (!event.isPrimary || event.button !== 0) return;
      if (event.target.closest("button") || event.target.closest("a")) return;
      pointerActive = true;
      handled = false;
      startX = event.clientX;
      startY = event.clientY;
      pointerId = event.pointerId;
      clearLongPress();
      longPressTimer = window.setTimeout(() => {
        handled = true;
        startEditTask(normalizedId);
        showToast("Task details", "Opening task editor.");
      }, LONG_PRESS_MS);
      if (card.setPointerCapture) {
        card.setPointerCapture(pointerId);
      }
    };

    const handlePointerMove = event => {
      if (!pointerActive || pointerId !== event.pointerId) return;
      const dx = event.clientX - startX;
      const dy = Math.abs(event.clientY - startY);
      if (dy > MAX_VERTICAL_DRIFT) {
        clearLongPress();
        return;
      }
      if (!handled && Math.abs(dx) >= SWIPE_THRESHOLD) {
        handled = true;
        clearLongPress();
        if (card.releasePointerCapture && pointerId !== null) {
          card.releasePointerCapture(pointerId);
        }
        pointerActive = false;
        if (dx > 0) {
          startFiveMinuteSprint(normalizedId);
          showToast("Sprint", "Starting a 5-minute focus pass.");
        } else {
          markTaskDoneFromPeek(normalizedId);
          showToast("Task complete", "Marked as done.");
        }
      }
    };

    const handlePointerEnd = event => {
      if (pointerActive && pointerId === event.pointerId && card.releasePointerCapture) {
        card.releasePointerCapture(pointerId);
      }
      resetState();
    };

    card.addEventListener("pointerdown", handlePointerDown);
    card.addEventListener("pointermove", handlePointerMove);
    card.addEventListener("pointerup", handlePointerEnd);
    card.addEventListener("pointerleave", handlePointerEnd);
    card.addEventListener("pointercancel", handlePointerEnd);
  }

  function setupTaskGestures() {
    if (!window.PointerEvent) return;
    const list = $("taskList");
    if (!list) return;
    refreshTaskGestureTargets();
    if (typeof MutationObserver === "undefined") return;
    if (taskGestureObserver) {
      taskGestureObserver.disconnect();
    }
    taskGestureObserver = new MutationObserver(() => refreshTaskGestureTargets());
    taskGestureObserver.observe(list, { childList: true });
  }

  function setupFocusOverlay() {
    const extendBtn = $("focusExtendButton");
    if (extendBtn) {
      extendBtn.addEventListener("click", () => extendSprintBy(5));
    }

    const abortBtn = $("focusAbortButton");
    if (abortBtn) {
      abortBtn.addEventListener("click", () => {
        backToCapture();
        setFocusLaunchOpen(false);
      });
    }

    const completeBtn = $("focusCompleteButton");
    if (completeBtn) {
      completeBtn.addEventListener("click", () => completeTask());
    }

    const overlay = $("focus");
    if (overlay) {
      overlay.addEventListener("click", event => {
        const dismissTarget = event.target.closest("[data-focus-dismiss]");
        if (dismissTarget) {
          backToCapture();
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.body.classList.contains("focus-overlay-active")) {
        backToCapture();
      }
    });
  }

  function setupLazyMedia() {
    const nodes = document.querySelectorAll('img:not([loading]), iframe:not([loading])');
    nodes.forEach(node => {
      node.setAttribute("loading", "lazy");
    });
  }

  const DEFAULT_BLOCK_BATCHES = [
    {
      id: "complex-care",
      label: "Complex Care",
      prefix: "CLX",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "General Clinic",
        importance: 4,
        urgency: 4,
        novelty: 2,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Review vitals and growth chart",
          "Summarize specialty updates",
          "Draft plan and follow-up steps"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "st-pjs",
      label: "St. PJ’s Shelter",
      prefix: "SPJ",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "St PJ’s Shelter",
        importance: 4,
        urgency: 5,
        novelty: 3,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Confirm shelter coordination notes",
          "Capture social work updates",
          "List pending referrals"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "craniofacial",
      label: "Craniofacial Clinic",
      prefix: "CRN",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "Craniofacial Clinic",
        importance: 5,
        urgency: 4,
        novelty: 3,
        interest: 4,
        externalPressure: 4,
        timeToStart: 3,
        difficulty: 3,
        subTasks: [
          "Pull imaging summary",
          "Outline surgical recommendations",
          "Document caregiver education"
        ],
        useChartTemplate: true
      }
    }
  ];
  let blockBatchProfiles = {};
  let blockBatchState = {
    activeId: DEFAULT_BLOCK_BATCHES.length ? DEFAULT_BLOCK_BATCHES[0].id : null,
    counts: {}
  };
  let blockBatchIdCounter = 0;
  const ENERGY_LABELS = {
    1: "Foggy",
    2: "Sleepy",
    3: "Steady",
    4: "Energized",
    5: "Lit up"
  };
  const SLEEP_RATING_LABELS = {
    1: "Exhausted",
    2: "Restless",
    3: "Adequate",
    4: "Rested",
    5: "Recharged"
  };
  const NEXT_BEST_FRICTION_RULES = {
    start: task => (Number(task.timeToStart) || 3) <= 3,
    perfection: task => estimateTaskMinutes(task) <= 25,
    social: task => !["Calls", "Inbox"].includes(task.category || ""),
    focus: task => {
      const remaining = Array.isArray(task.subTasks) ? task.subTasks.filter(sub => !sub.completed).length : 0;
      return remaining <= 4;
    }
  };
  const DEFUSE_PROMPTS = [
    { threshold: 60, message: "Feeling ≠ instruction. You can feel tired and still send the email." },
    { threshold: 30, message: "Fake it: open the doc, type the title, breathe." },
    { threshold: 0, message: "Zone check: distractions locked. You're cleared for takeoff." }
  ];
  const MMP_MIN_MINUTES = 10;
  const MMP_MAX_MINUTES = 20;
  const CONFLICT_DEFAULT_SPRINT = 12;
  const LAUNCH_PAD_PRESETS = {
    "General Clinic": [
      "Stethoscope",
      "Laptop + charger",
      "Clinic badge",
      "Progress note templates",
      "Snacks / water"
    ],
    "St PJ’s Shelter": [
      "ID badge",
      "Warm layers",
      "Resource handouts",
      "Portable charger",
      "Snacks"
    ],
    "Craniofacial Clinic": [
      "Care plan binders",
      "Growth charts",
      "Camera / tablet",
      "Consent forms",
      "Comfort items"
    ]
  };
  const SLEEP_CHECKLIST_ITEMS = [
    {
      id: "warmShower",
      label: "Warm shower or bath 1–2 hours before bed",
      tip: "Warm water triggers a cooling rebound that cues melatonin."
    },
    {
      id: "blueLight",
      label: "Blue-light blocker on screens",
      tip: "Filtering blue light reduces melatonin suppression from devices."
    },
    {
      id: "activity",
      label: "Light physical activity earlier today",
      tip: "Daytime movement builds sleep pressure for smoother nights."
    },
    {
      id: "caffeine",
      label: "Caffeine curfew observed (last sip by 2 PM)",
      tip: "Caffeine has a ~6 hour half-life—curbing it prevents bedtime jitters."
    },
    {
      id: "magnesium",
      label: "Optional magnesium or electrolytes",
      tip: "Magnesium calms the nervous system and supports muscle recovery."
    }
  ];
  const WEEKDAY_OPTIONS = [
    { label: "Any day", value: "any" },
    { label: "Weekdays", value: "weekdays" },
    { label: "Monday", value: "1" },
    { label: "Tuesday", value: "2" },
    { label: "Wednesday", value: "3" },
    { label: "Thursday", value: "4" },
    { label: "Friday", value: "5" },
    { label: "Saturday", value: "6" },
    { label: "Sunday", value: "0" }
  ];

  function getChartFields() {
    return chartFieldIds
      .map(id => $(id))
      .filter(Boolean);
  }

  function setChartFieldsDisabled(isDisabled) {
    getChartFields().forEach(field => {
      field.disabled = isDisabled;
    });
  }

  function storeChartFieldValues() {
    storedChartFieldValues = {};
    chartFieldIds.forEach(id => {
      const field = $(id);
      if (field) {
        storedChartFieldValues[id] = field.value;
      }
    });
  }

  function restoreChartFieldValues() {
    if (!storedChartFieldValues) return;
    chartFieldIds.forEach(id => {
      if (Object.prototype.hasOwnProperty.call(storedChartFieldValues, id)) {
        const field = $(id);
        if (field) {
          field.value = storedChartFieldValues[id];
        }
      }
    });
    storedChartFieldValues = null;
  }

  function showChartFields() {
    const container = $("chartFields");
    if (!container) return;
    container.classList.remove("is-hidden");
    container.setAttribute("aria-hidden", "false");
    setChartFieldsDisabled(false);
    restoreChartFieldValues();
    updateDerivedFields();
  }

  function hideChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storeChartFieldValues();
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  function getToastContainer() {
    return $("toastContainer");
  }

  function showToast(title, message, options = {}) {
    const container = getToastContainer();
    const useContainer = options.position !== "bottom";
    if (useContainer && !container) return;
    const toast = document.createElement("div");
    toast.className = `toast${options.className ? ` ${options.className}` : ""}`;
    if (options.position === "bottom") {
      toast.classList.add("toast--bottom");
    }
    toast.setAttribute("role", "status");
    if (typeof title === "string" && title.trim()) {
      const heading = document.createElement("strong");
      heading.textContent = title;
      toast.appendChild(heading);
    }
    const body = document.createElement("div");
    body.textContent = message;
    toast.appendChild(body);
    if (options.action && typeof options.action.onClick === "function") {
      const actionBtn = document.createElement("button");
      actionBtn.type = "button";
      actionBtn.className = "toast__action";
      actionBtn.textContent = options.action.label || "Action";
      actionBtn.addEventListener("click", () => {
        options.action.onClick();
        toast.remove();
      });
      toast.appendChild(actionBtn);
    }
    if (useContainer) {
      container.appendChild(toast);
    } else {
      document.body.appendChild(toast);
    }
    const timeout = Number.isFinite(options.timeout) ? options.timeout : 6000;
    const hide = () => {
      toast.classList.add("hidden");
      window.setTimeout(() => toast.remove(), 350);
      if (typeof options.onClose === "function") {
        options.onClose();
      }
    };
    if (timeout > 0) {
      window.setTimeout(hide, timeout);
    }
    return toast;
  }

  function getDateKey(date = new Date()) {
    const dt = new Date(date);
    dt.setHours(0, 0, 0, 0);
    const year = dt.getFullYear();
    const month = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function getTodayKey() {
    return getDateKey(new Date());
  }

  function getTomorrowKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() + 1);
    return getDateKey(dt);
  }

  function getOffsetDateKey(dateKey, offsetDays = 0) {
    if (!dateKey || typeof dateKey !== "string") return null;
    const parts = dateKey.split("-").map(part => Number(part));
    if (parts.length !== 3) return null;
    const [year, month, day] = parts;
    if (![year, month, day].every(Number.isFinite)) return null;
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return null;
    const offset = Number(offsetDays);
    if (Number.isFinite(offset) && offset !== 0) {
      dt.setDate(dt.getDate() + offset);
    }
    return getDateKey(dt);
  }

  function getYesterdayKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() - 1);
    return getDateKey(dt);
  }

  function formatFriendlyDate(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function formatShortDateLabel(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  function getDateKeyFromIso(isoString) {
    if (!isoString) return null;
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) return null;
    return getDateKey(date);
  }

  function getDefaultMorningEntry() {
    return {
      completed: {
        move: false,
        reflect: false,
        plan: false
      },
      intention: "",
      planNotes: "",
      energy: null,
      skip: false,
      countdownBlock: null,
      countdownEnd: null,
      celebrated: false,
      lastUpdated: null
    };
  }

  function getDefaultMorningState() {
    return {
      enabled: false,
      entries: {}
    };
  }

  function loadMorningLaunchState() {
    if (morningLaunchState) return morningLaunchState;
    try {
      const raw = localStorage.getItem(MORNING_LAUNCH_KEY);
      if (!raw) {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const state = { ...getDefaultMorningState(), ...parsed };
      if (!state.entries || typeof state.entries !== "object") {
        state.entries = {};
      }
      Object.keys(state.entries).forEach(key => {
        state.entries[key] = { ...getDefaultMorningEntry(), ...state.entries[key] };
      });
      morningLaunchState = state;
    } catch (error) {
      console.error("Unable to load morning launch state", error);
      morningLaunchState = getDefaultMorningState();
    }
    return morningLaunchState;
  }

  function persistMorningLaunchState() {
    if (!morningLaunchState) return;
    try {
      if (morningLaunchState.entries) {
        const keys = Object.keys(morningLaunchState.entries).sort();
        if (keys.length > 60) {
          const toRemove = keys.slice(0, keys.length - 60);
          toRemove.forEach(key => delete morningLaunchState.entries[key]);
        }
      }
      const serialized = JSON.stringify(morningLaunchState);
      localStorage.setItem(MORNING_LAUNCH_KEY, serialized);
    } catch (error) {
      console.error("Unable to persist morning launch state", error);
    }
  }

  function getMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    if (!state.entries) state.entries = {};
    if (!state.entries[dateKey]) {
      state.entries[dateKey] = getDefaultMorningEntry();
    }
    return state.entries[dateKey];
  }

  function resetMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    state.entries[dateKey] = getDefaultMorningEntry();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function setMorningSkip(dateKey = getTodayKey(), skip = true) {
    const entry = getMorningEntry(dateKey);
    entry.skip = skip;
    if (skip) {
      MORNING_BLOCKS.forEach(block => {
        entry.completed[block] = false;
      });
      entry.celebrated = false;
    }
    clearMorningCountdown(entry);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function clearMorningCountdown(entry) {
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = null;
    if (entry) {
      entry.countdownBlock = null;
      entry.countdownEnd = null;
    }
  }

  function formatCountdown(msRemaining) {
    if (!Number.isFinite(msRemaining) || msRemaining <= 0) {
      return "00:00";
    }
    const totalSeconds = Math.ceil(msRemaining / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }

  function updateMoveCountdownDisplay(remainingMs) {
    const display = $("moveCountdown");
    if (!display) return;
    if (!Number.isFinite(remainingMs) || remainingMs <= 0) {
      display.textContent = "20:00";
      return;
    }
    display.textContent = formatCountdown(remainingMs);
  }

  function resumeMorningCountdown(entry) {
    if (!entry || !entry.countdownBlock || !entry.countdownEnd) {
      updateMoveCountdownDisplay(null);
      return;
    }
    const remaining = entry.countdownEnd - Date.now();
    if (remaining <= 0) {
      clearMorningCountdown(entry);
      updateMoveCountdownDisplay(null);
      showToast("MOVE timer", "20 minutes are up. Celebrate the endorphins!");
      return;
    }
    updateMoveCountdownDisplay(remaining);
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = {
      block: entry.countdownBlock,
      intervalId: setInterval(() => {
        const nowRemaining = entry.countdownEnd - Date.now();
        if (nowRemaining <= 0) {
          clearMorningCountdown(entry);
          updateMoveCountdownDisplay(null);
          showToast("MOVE timer", "20 minutes are up. Nice job getting sunlight and motion!");
        } else {
          updateMoveCountdownDisplay(nowRemaining);
        }
      }, 1000)
    };
  }

  function startMorningCountdown(block = "move") {
    const entry = getMorningEntry();
    entry.skip = false;
    entry.countdownBlock = block;
    entry.countdownEnd = Date.now() + DEFAULT_MORNING_TIMER_MINUTES * 60 * 1000;
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    resumeMorningCountdown(entry);
  }

  function setMorningBlockCompleted(block, data = {}) {
    const entry = getMorningEntry();
    entry.skip = false;
    if (!entry.completed) {
      entry.completed = { move: false, reflect: false, plan: false };
    }
    entry.completed[block] = true;
    if (block === "reflect" && data.intention !== undefined) {
      entry.intention = data.intention;
    }
    if (block === "plan" && data.planNotes !== undefined) {
      entry.planNotes = data.planNotes;
    }
    if (block === "move") {
      clearMorningCountdown(entry);
    }
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    showToast("Morning Launch", `Nice momentum! ${block.toUpperCase()} locked in.`);
  }

  function logMorningEnergy(value) {
    const entry = getMorningEntry();
    entry.energy = Number(value);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    if (Number.isFinite(entry.energy)) {
      const label = ENERGY_LABELS[entry.energy] || entry.energy;
      showToast("Energy logged", `Morning energy set to ${label}.`);
    }
  }

  function getMorningHistory(limit = 10) {
    const state = loadMorningLaunchState();
    const entries = Object.entries(state.entries || {});
    return entries
      .sort((a, b) => (a[0] > b[0] ? -1 : 1))
      .slice(0, limit)
      .map(([dateKey, entry]) => ({ dateKey, entry }));
  }

  function buildMorningStatus(entry) {
    if (entry.skip) {
      return "Launch skipped today. Reset whenever you’re ready.";
    }
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed[block]);
    if (!completedBlocks.length) {
      return "Start with MOVE to flood dopamine and sunlight cues.";
    }
    if (completedBlocks.length === MORNING_BLOCKS.length) {
      if (!entry.celebrated) {
        entry.celebrated = true;
        persistMorningLaunchState();
        showToast("Morning Launch", "All three blocks complete. Notice your focus surge later today.");
      }
      return "🌟 All three blocks complete. Anchor this momentum into your next action.";
    }
    if (completedBlocks.length === 1) {
      return `Great job completing ${completedBlocks[0].toUpperCase()}! Next up: ${completedBlocks[0] === "move" ? "REFLECT" : "PLAN"}.`;
    }
    return "Great job completing MOVE and REFLECT! Lock in a process-based PLAN next.";
  }

  function updateMorningHistoryList() {
    const list = $("morningLaunchHistory");
    if (!list) return;
    const history = getMorningHistory(7);
    list.innerHTML = "";
    if (!history.length) {
      const item = document.createElement("li");
      item.textContent = "No mornings logged yet.";
      list.appendChild(item);
      return;
    }
    history.forEach(({ dateKey, entry }) => {
      const item = document.createElement("li");
      const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
      const energyLabel = entry.energy ? ENERGY_LABELS[entry.energy] || entry.energy : "--";
      item.textContent = `${formatFriendlyDate(dateKey)} — ${completedCount}/${MORNING_BLOCKS.length} blocks • Energy: ${energyLabel}`;
      list.appendChild(item);
    });
  }

  function calculateMorningCompletionPercent(entry) {
    if (!entry || entry.skip) return 0;
    const totalBlocks = MORNING_BLOCKS.length || 1;
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    return Math.round((completedBlocks / totalBlocks) * 100);
  }

  function renderMorningLaunchChart(limit = MORNING_CHART_LIMIT) {
    const canvas = $("morningLaunchChart");
    const summaryEl = $("morningLaunchChartSummary");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const width = canvas.clientWidth || canvas.width || 360;
    const height = canvas.clientHeight || canvas.height || 160;
    canvas.width = width;
    canvas.height = height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const history = getMorningHistory(limit);
    if (!history.length) {
      ctx.fillStyle = "#6b7280";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Complete your morning launch to unlock insights.", canvas.width / 2, canvas.height / 2);
      if (summaryEl) {
        summaryEl.textContent = "Complete your morning launch to unlock momentum and energy trends.";
      }
      return;
    }
    const chronological = [...history].reverse();
    const padding = 28;
    const graphWidth = canvas.width - padding * 2;
    const graphHeight = canvas.height - padding * 2;
    const xStep = chronological.length > 1 ? graphWidth / (chronological.length - 1) : 0;
    const completionPoints = [];
    const energyPoints = [];
    chronological.forEach((item, index) => {
      const { entry, dateKey } = item;
      completionPoints.push({
        index,
        value: calculateMorningCompletionPercent(entry),
        dateKey
      });
      const energy = Number(entry.energy);
      energyPoints.push({
        index,
        value: Number.isFinite(energy) ? Math.round(Math.max(0, Math.min(100, ((energy - 1) / 4) * 100))) : null,
        energy: Number.isFinite(energy) ? energy : null,
        dateKey
      });
    });
    const project = value => {
      const safeValue = Math.max(0, Math.min(100, Number(value) || 0));
      return canvas.height - padding - (safeValue / 100) * graphHeight;
    };
    ctx.strokeStyle = MORNING_CHART_COLORS.axis;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    const gridValues = [25, 50, 75, 100];
    ctx.setLineDash([4, 4]);
    gridValues.forEach(value => {
      const y = project(value);
      ctx.strokeStyle = MORNING_CHART_COLORS.grid;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      ctx.fillStyle = "#7f8a9c";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      ctx.fillText(`${value}%`, padding - 6, y + 3);
    });
    ctx.setLineDash([]);
    ctx.fillStyle = "#9aa6b8";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    chronological.forEach((item, index) => {
      const x = padding + xStep * index;
      ctx.fillText(formatShortDateLabel(item.dateKey), x, canvas.height - padding + 14);
    });
    ctx.fillStyle = "#8893a5";
    ctx.textAlign = "left";
    ctx.fillText("Energy line scaled so top = level 5", padding, padding - 10);
    const drawLine = (points, color, dashed = false) => {
      const valid = points.filter(point => Number.isFinite(point.value));
      if (!valid.length) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dashed ? [6, 4] : []);
      ctx.beginPath();
      valid.forEach((point, idx) => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);
      valid.forEach(point => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });
      ctx.restore();
    };
    drawLine(completionPoints, MORNING_CHART_COLORS.completion, false);
    drawLine(energyPoints, MORNING_CHART_COLORS.energy, true);
    if (summaryEl) {
      const completionSum = completionPoints.reduce((sum, point) => sum + (Number.isFinite(point.value) ? point.value : 0), 0);
      const completionAvg = completionPoints.length
        ? Math.round(completionSum / completionPoints.length)
        : 0;
      const energyValid = energyPoints.filter(point => Number.isFinite(point.energy));
      let summary = `Last ${chronological.length}-day average completion: ${completionAvg}%`;
      if (energyValid.length) {
        const avgEnergy = energyValid.reduce((sum, point) => sum + point.energy, 0) / energyValid.length;
        const label = ENERGY_LABELS[Math.round(avgEnergy)] || "";
        summary += ` • Energy ≈ ${avgEnergy.toFixed(1)}${label ? ` (${label})` : ""}`;
      } else {
        summary += " • Log energy to compare how rested mornings drive completion";
      }
      summaryEl.textContent = `${summary}.`;
    }
  }

  function updateMorningLaunchUI() {
    const state = loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    const content = $("morningLaunchContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      clearMorningCountdown(getMorningEntry());
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const summary = $("morningLaunchChartSummary");
      if (summary) {
        summary.textContent = "Enable Morning Launch to start tracking your morning momentum.";
      }
      const chart = $("morningLaunchChart");
      if (chart) {
        const ctx = chart.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, chart.width, chart.height);
        }
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    const entry = getMorningEntry();
    const intentionField = $("morningIntention");
    const planField = $("morningPlanNotes");
    if (intentionField) {
      intentionField.value = entry.intention || "";
    }
    if (planField) {
      planField.value = entry.planNotes || "";
    }
    const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    const progress = $("morningLaunchProgress");
    if (progress) {
      const width = Math.round((completedCount / MORNING_BLOCKS.length) * 100);
      progress.style.width = `${width}%`;
    }
    const status = $("morningLaunchStatus");
    if (status) {
      status.textContent = buildMorningStatus(entry);
    }
    MORNING_BLOCKS.forEach(block => {
      const blockEl = document.querySelector(`.routine-block[data-block="${block}"]`);
      if (blockEl) {
        blockEl.classList.toggle("completed", Boolean(entry.completed?.[block]));
      }
    });
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      const value = Number.isFinite(entry.energy) ? entry.energy : 3;
      energySlider.value = String(value);
      if (energyLabel) {
        const label = ENERGY_LABELS[value] || value;
        energyLabel.textContent = `${label}`;
      }
      alignEnergySliders(value, "morning");
    }
    resumeMorningCountdown(entry);
    updateMorningHistoryList();
    renderMorningLaunchChart();
  }

  function initializeMorningLaunchModule() {
    loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadMorningLaunchState();
        state.enabled = event.target.checked;
        persistMorningLaunchState();
        updateMorningLaunchUI();
      });
    }
    const resetBtn = $("morningLaunchResetBtn");
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        if (confirm("Reset today's launch blocks?")) {
          resetMorningEntry();
        }
      });
    }
    const skipBtn = $("morningLaunchSkipBtn");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => setMorningSkip(getTodayKey(), true));
    }
    const moveStart = $("moveStartBtn");
    if (moveStart) {
      moveStart.addEventListener("click", () => startMorningCountdown("move"));
    }
    const moveComplete = $("moveCompleteBtn");
    if (moveComplete) {
      moveComplete.addEventListener("click", () => setMorningBlockCompleted("move"));
    }
    const reflectSave = $("reflectCompleteBtn");
    if (reflectSave) {
      reflectSave.addEventListener("click", () => {
        const intention = $("morningIntention")?.value.trim() || "";
        setMorningBlockCompleted("reflect", { intention });
      });
    }
    const planSave = $("planCompleteBtn");
    if (planSave) {
      planSave.addEventListener("click", () => {
        const planNotes = $("morningPlanNotes")?.value.trim() || "";
        setMorningBlockCompleted("plan", { planNotes });
      });
    }
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || 3);
        if (energyLabel) {
          const label = ENERGY_LABELS[value] || value;
          energyLabel.textContent = label;
        }
        alignEnergySliders(value, "morning");
      });
    }
    const energySave = $("morningEnergySave");
    if (energySave) {
      energySave.addEventListener("click", () => {
        const value = Number($("morningEnergy")?.value || 3);
        logMorningEnergy(value);
      });
    }
    const intentionButtons = document.querySelectorAll(".intention-buttons button[data-intention]");
    if (intentionButtons.length) {
      intentionButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const intention = btn.getAttribute("data-intention") || "";
          const field = $("morningIntention");
          if (field) {
            field.value = intention;
            field.focus();
          }
        });
      });
    }
    updateMorningLaunchUI();
  }

  function generateLaunchPadItemId() {
    return `lp_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`;
  }

  function getDefaultLaunchPadState() {
    return {
      reminderTime: DEFAULT_LAUNCH_PAD_REMINDER,
      activeSite: DEFAULT_LAUNCH_PAD_SITE,
      items: {},
      status: {},
      lastReminderDate: null,
      lastMorningNudge: null
    };
  }

  function normalizeLaunchPadState(state) {
    const base = { ...getDefaultLaunchPadState(), ...state };
    if (!base.items || typeof base.items !== "object") {
      base.items = {};
    }
    if (!base.status || typeof base.status !== "object") {
      base.status = {};
    }
    Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
      if (!Array.isArray(base.items[site]) || !base.items[site].length) {
        base.items[site] = LAUNCH_PAD_PRESETS[site].map(name => ({
          id: generateLaunchPadItemId(),
          name,
          dayRule: "any",
          isCustom: false
        }));
      } else {
        base.items[site] = base.items[site].map(item => ({
          id: item.id || generateLaunchPadItemId(),
          name: item.name || "Item",
          dayRule: item.dayRule || "any",
          isCustom: Boolean(item.isCustom)
        }));
      }
    });
    if (!base.items[base.activeSite]) {
      base.activeSite = DEFAULT_LAUNCH_PAD_SITE;
    }
    return base;
  }

  function loadLaunchPadState() {
    if (launchPadState) return launchPadState;
    try {
      const raw = localStorage.getItem(LAUNCH_PAD_KEY);
      if (!raw) {
        launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
        return launchPadState;
      }
      const parsed = JSON.parse(raw);
      launchPadState = normalizeLaunchPadState(parsed || {});
    } catch (error) {
      console.error("Unable to load launch pad state", error);
      launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
    }
    return launchPadState;
  }

  function persistLaunchPadState() {
    if (!launchPadState) return;
    try {
      if (launchPadState.status) {
        const keys = Object.keys(launchPadState.status).sort();
        if (keys.length > 90) {
          const toRemove = keys.slice(0, keys.length - 90);
          toRemove.forEach(key => delete launchPadState.status[key]);
        }
      }
      localStorage.setItem(LAUNCH_PAD_KEY, JSON.stringify(launchPadState));
    } catch (error) {
      console.error("Unable to persist launch pad state", error);
    }
    updateLaunchPadSummary();
  }

  function ensureLaunchPadSite(site) {
    const state = loadLaunchPadState();
    if (!state.items[site]) {
      const preset = LAUNCH_PAD_PRESETS[site] || [];
      state.items[site] = preset.map(name => ({
        id: generateLaunchPadItemId(),
        name,
        dayRule: "any",
        isCustom: false
      }));
    }
    return state.items[site];
  }

  function setLaunchPadActiveSite(site) {
    const state = loadLaunchPadState();
    state.activeSite = site;
    ensureLaunchPadSite(site);
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function loadPresetForActiveSite() {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const preset = LAUNCH_PAD_PRESETS[site] || [];
    state.items[site] = preset.map(name => ({
      id: generateLaunchPadItemId(),
      name,
      dayRule: "any",
      isCustom: false
    }));
    persistLaunchPadState();
    renderLaunchPadSettings();
    showToast("Launch pad reset", `${site} preset restored.`);
  }

  function addLaunchPadItem(name) {
    const trimmed = (name || "").trim();
    if (!trimmed) return;
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    ensureLaunchPadSite(site);
    state.items[site].push({
      id: generateLaunchPadItemId(),
      name: trimmed,
      dayRule: "any",
      isCustom: true
    });
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function removeLaunchPadItem(itemId) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const next = list.filter(item => item.id !== itemId);
    state.items[site] = next;
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function updateLaunchPadDayRule(itemId, dayRule) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const item = list.find(entry => entry.id === itemId);
    if (item) {
      item.dayRule = dayRule;
      persistLaunchPadState();
    }
  }

  function shouldIncludeLaunchPadItemOnDate(item, dateKey) {
    if (!item || !dateKey) return false;
    if (!item.dayRule || item.dayRule === "any") return true;
    const dt = new Date(`${dateKey}T00:00:00`);
    if (Number.isNaN(dt.getTime())) return true;
    const weekday = dt.getDay();
    if (item.dayRule === "weekdays") {
      return weekday >= 1 && weekday <= 5;
    }
    return String(weekday) === String(item.dayRule);
  }

  function getLaunchPadStatus(dateKey) {
    const state = loadLaunchPadState();
    if (!state.status[dateKey]) {
      state.status[dateKey] = {};
    }
    return state.status[dateKey];
  }

  function setLaunchPadItemReady(dateKey, itemId, ready) {
    const status = getLaunchPadStatus(dateKey);
    status[itemId] = Boolean(ready);
    persistLaunchPadState();
    updateLaunchPadSummary();
  }

  function computeLaunchPadReadiness(dateKey) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const relevant = list.filter(item => shouldIncludeLaunchPadItemOnDate(item, dateKey));
    const status = getLaunchPadStatus(dateKey);
    const readyCount = relevant.filter(item => status[item.id]).length;
    return {
      total: relevant.length,
      ready: readyCount,
      items: relevant,
      status
    };
  }

  function updateLaunchPadSummary() {
    const summary = $("launchPadSummary");
    if (!summary) return;
    const todayKey = getTodayKey();
    const readiness = computeLaunchPadReadiness(todayKey);
    if (readiness.total === 0) {
      summary.textContent = "No launch pad items scheduled for today.";
      return;
    }
    summary.innerHTML = "";
    const header = document.createElement("strong");
    header.textContent = `Launch Pad: ${readiness.ready}/${readiness.total} items ready`;
    summary.appendChild(header);
    const hint = document.createElement("div");
    if (readiness.ready === readiness.total) {
      hint.textContent = "Everything is staged — future you says thanks!";
    } else {
      const remaining = readiness.total - readiness.ready;
      hint.textContent = `${remaining} item(s) still need attention before heading out.`;
    }
    summary.appendChild(hint);
  }

  function renderLaunchPadSettings() {
    const state = loadLaunchPadState();
    const siteSelect = $("launchPadSiteSelect");
    if (siteSelect) {
      siteSelect.innerHTML = "";
      Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
        const option = document.createElement("option");
        option.value = site;
        option.textContent = site;
        if (site === state.activeSite) {
          option.selected = true;
        }
        siteSelect.appendChild(option);
      });
      siteSelect.onchange = event => {
        setLaunchPadActiveSite(event.target.value);
      };
    }
    const timeInput = $("launchPadReminderTime");
    if (timeInput) {
      timeInput.value = state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER;
      timeInput.onchange = event => {
        state.reminderTime = event.target.value || DEFAULT_LAUNCH_PAD_REMINDER;
        persistLaunchPadState();
      };
    }
    const listContainer = $("launchPadItemList");
    if (listContainer) {
      listContainer.innerHTML = "";
      const items = ensureLaunchPadSite(state.activeSite || DEFAULT_LAUNCH_PAD_SITE);
      if (!items.length) {
        const empty = document.createElement("p");
        empty.className = "score";
        empty.textContent = "No launch pad items yet.";
        listContainer.appendChild(empty);
      } else {
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "launch-pad-item";
          const name = document.createElement("div");
          name.textContent = item.name;
          if (item.isCustom) {
            const custom = document.createElement("small");
            custom.textContent = "custom";
            name.appendChild(document.createElement("br"));
            name.appendChild(custom);
          }
          const select = document.createElement("select");
          WEEKDAY_OPTIONS.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            if (option.value === item.dayRule) {
              opt.selected = true;
            }
            select.appendChild(opt);
          });
          select.addEventListener("change", event => {
            updateLaunchPadDayRule(item.id, event.target.value);
          });
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "🗑";
          removeBtn.title = "Remove item";
          removeBtn.addEventListener("click", () => {
            if (confirm(`Remove ${item.name}?`)) {
              removeLaunchPadItem(item.id);
            }
          });
          row.appendChild(name);
          row.appendChild(select);
          row.appendChild(removeBtn);
          listContainer.appendChild(row);
        });
      }
    }
    updateLaunchPadSummary();
  }

  function renderLaunchPadModalList(targetDateKey) {
    const container = $("launchPadModalList");
    if (!container) return;
    container.innerHTML = "";
    const readiness = computeLaunchPadReadiness(targetDateKey);
    if (!readiness.total) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No items needed for that day.";
      container.appendChild(empty);
      return;
    }
    readiness.items.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(readiness.status[item.id]);
      checkbox.addEventListener("change", event => {
        setLaunchPadItemReady(targetDateKey, item.id, event.target.checked);
      });
      const span = document.createElement("span");
      span.textContent = item.name;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function setModalVisibility(modalId, isVisible) {
    const overlay = $(modalId);
    if (!overlay) return;
    if (isVisible) {
      overlay.classList.remove("hidden");
      overlay.setAttribute("aria-hidden", "false");
    } else {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
  }

  function openLaunchPadModal(options = {}) {
    const { targetDateKey = getTomorrowKey() } = options;
    renderLaunchPadModalList(targetDateKey);
    const overlay = $("launchPadModal");
    if (!overlay) return;
    overlay.dataset.targetDate = targetDateKey;
    setModalVisibility("launchPadModal", true);
  }

  function closeLaunchPadModal() {
    setModalVisibility("launchPadModal", false);
  }

  function initializeLaunchPadModule() {
    loadLaunchPadState();
    renderLaunchPadSettings();
    const addBtn = $("launchPadAddItem");
    if (addBtn) {
      addBtn.addEventListener("click", () => {
        const field = $("launchPadNewItem");
        addLaunchPadItem(field?.value || "");
        if (field) field.value = "";
      });
    }
    const presetBtn = $("launchPadLoadPreset");
    if (presetBtn) {
      presetBtn.addEventListener("click", () => {
        if (confirm("Reset this site's launch pad to the curated preset?")) {
          loadPresetForActiveSite();
        }
      });
    }
    const openEvening = $("openLaunchPadModal");
    if (openEvening) {
      openEvening.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTomorrowKey() }));
    }
    const morningReview = $("launchPadMorningReview");
    if (morningReview) {
      morningReview.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTodayKey() }));
    }
    const modalClose = $("launchPadModalClose");
    if (modalClose) {
      modalClose.addEventListener("click", () => {
        closeLaunchPadModal();
      });
    }
    const overlay = $("launchPadModal");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeLaunchPadModal();
        }
      });
    }
    updateLaunchPadSummary();
  }

  function getDefaultSleepState() {
    return {
      enabled: false,
      checklist: {},
      melatonin: {
        enabled: false,
        time: DEFAULT_MELATONIN_TIME,
        lastPrompt: null
      },
      sunlight: {
        enabled: false,
        time: DEFAULT_SUNLIGHT_TIME,
        lastPrompt: null
      },
      restRatings: {}
    };
  }

  function loadSleepToolkitState() {
    if (sleepToolkitState) return sleepToolkitState;
    try {
      const raw = localStorage.getItem(SLEEP_TOOLKIT_KEY);
      if (!raw) {
        sleepToolkitState = getDefaultSleepState();
        return sleepToolkitState;
      }
      const parsed = JSON.parse(raw);
      sleepToolkitState = { ...getDefaultSleepState(), ...parsed };
      if (!sleepToolkitState.checklist || typeof sleepToolkitState.checklist !== "object") {
        sleepToolkitState.checklist = {};
      }
      if (!sleepToolkitState.restRatings || typeof sleepToolkitState.restRatings !== "object") {
        sleepToolkitState.restRatings = {};
      }
    } catch (error) {
      console.error("Unable to load sleep toolkit state", error);
      sleepToolkitState = getDefaultSleepState();
    }
    return sleepToolkitState;
  }

  function persistSleepToolkitState() {
    if (!sleepToolkitState) return;
    try {
      if (sleepToolkitState.checklist) {
        const keys = Object.keys(sleepToolkitState.checklist).sort();
        if (keys.length > 120) {
          const toRemove = keys.slice(0, keys.length - 120);
          toRemove.forEach(key => delete sleepToolkitState.checklist[key]);
        }
      }
      if (sleepToolkitState.restRatings) {
        const ratingKeys = Object.keys(sleepToolkitState.restRatings).sort();
        if (ratingKeys.length > 180) {
          const prune = ratingKeys.slice(0, ratingKeys.length - 180);
          prune.forEach(key => delete sleepToolkitState.restRatings[key]);
        }
      }
      localStorage.setItem(SLEEP_TOOLKIT_KEY, JSON.stringify(sleepToolkitState));
    } catch (error) {
      console.error("Unable to persist sleep toolkit state", error);
    }
  }

  function getSleepChecklistEntry(dateKey = getTodayKey()) {
    const state = loadSleepToolkitState();
    if (!state.checklist[dateKey]) {
      const entry = {};
      SLEEP_CHECKLIST_ITEMS.forEach(item => {
        entry[item.id] = false;
      });
      state.checklist[dateKey] = entry;
    }
    return state.checklist[dateKey];
  }

  function toggleSleepChecklistItem(itemId, value, dateKey = getTodayKey()) {
    const checklist = getSleepChecklistEntry(dateKey);
    if (!Object.prototype.hasOwnProperty.call(checklist, itemId)) return;
    checklist[itemId] = Boolean(value);
    persistSleepToolkitState();
    updateSleepToolkitUI();
  }

  function computeSleepCompletionFromChecklist(checklist) {
    const total = SLEEP_CHECKLIST_ITEMS.length;
    if (!checklist) {
      return { total, completed: 0, percent: 0 };
    }
    const completed = SLEEP_CHECKLIST_ITEMS.filter(item => checklist[item.id]).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function computeSleepCompletion(dateKey = getTodayKey(), options = {}) {
    const { createIfMissing = true } = options || {};
    let checklist;
    if (createIfMissing) {
      checklist = getSleepChecklistEntry(dateKey);
    } else {
      const state = loadSleepToolkitState();
      checklist = state.checklist?.[dateKey];
    }
    return computeSleepCompletionFromChecklist(checklist);
  }

  function renderSleepChecklist(dateKey = getTodayKey()) {
    const container = $("sleepChecklist");
    if (!container) return;
    const checklist = getSleepChecklistEntry(dateKey);
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(checklist[item.id]);
      checkbox.addEventListener("change", event => {
        toggleSleepChecklistItem(item.id, event.target.checked, dateKey);
      });
      const span = document.createElement("div");
      const title = document.createElement("strong");
      title.textContent = item.label;
      const tip = document.createElement("div");
      tip.textContent = item.tip;
      tip.style.fontSize = "0.78rem";
      tip.style.color = "#9aa0a6";
      span.appendChild(title);
      span.appendChild(tip);
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function updateSleepCompletionSummary(dateKey = getTodayKey()) {
    const summary = $("sleepCompletionSummary");
    if (!summary) return;
    const { total, completed, percent } = computeSleepCompletion(dateKey);
    summary.textContent = `You set ${completed}/${total} sleep steps ready – ${percent}% of the plan primed.`;
  }

  function renderSleepTips() {
    const container = $("sleepTips");
    if (!container) return;
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const tip = document.createElement("div");
      tip.textContent = `• ${item.tip}`;
      container.appendChild(tip);
    });
  }

  function recordSleepRating(dateKey, rating) {
    const state = loadSleepToolkitState();
    state.restRatings[dateKey] = Number(rating);
    persistSleepToolkitState();
    updateSleepToolkitUI();
    const label = SLEEP_RATING_LABELS[rating] || rating;
    showToast("Sleep logged", `Restfulness marked as ${label}.`);
  }

  function countChartTasksCompletedOn(dateKey) {
    if (!dateKey) return 0;
    return tasks.filter(task => {
      if (!isChartTask(task)) return false;
      const completionKey = getDateKeyFromIso(task.completedAt);
      return completionKey === dateKey;
    }).length;
  }

  function updateSleepCorrelationSummary() {
    const summary = $("sleepCorrelationSummary");
    if (!summary) return;
    const state = loadSleepToolkitState();
    const fragments = [];

    const ratingEntries = Object.entries(state.restRatings || {});
    if (!ratingEntries.length) {
      fragments.push("Log rest ratings to see how sleep fuels charting momentum.");
    } else {
      let highCount = 0;
      let highCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      ratingEntries.forEach(([dateKey, rating]) => {
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (Number(rating) >= 4) {
          highCount += 1;
          highCharts += charts;
        } else {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      const restedAvgValue = highCount ? highCharts / highCount : null;
      const draggyAvgValue = lowCount ? lowCharts / lowCount : null;
      const restedAvg = restedAvgValue !== null ? restedAvgValue.toFixed(1) : "—";
      const draggyAvg = draggyAvgValue !== null ? draggyAvgValue.toFixed(1) : "—";
      let ratingText = `Rest rating impact → Rested mornings (≥4) yielded ${restedAvg} next-day chart(s); low-energy mornings (≤3) managed ${draggyAvg}.`;
      if (restedAvgValue !== null && draggyAvgValue !== null) {
        const delta = restedAvgValue - draggyAvgValue;
        if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
          ratingText += ` (≈${delta > 0 ? "+" : ""}${delta.toFixed(1)} boost when you're rested)`;
        }
      } else {
        ratingText += " Keep logging a mix of scores to sharpen this insight.";
      }
      fragments.push(ratingText);
    }

    const checklistEntries = Object.entries(state.checklist || {});
    if (!checklistEntries.length) {
      fragments.push("Check off sleep steps to measure how consistency drives next-day charting.");
    } else {
      let strongCount = 0;
      let strongCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      checklistEntries.forEach(([dateKey, checklist]) => {
        const { percent } = computeSleepCompletionFromChecklist(checklist);
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (percent >= 80) {
          strongCount += 1;
          strongCharts += charts;
        } else if (percent <= 40) {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      if (!strongCount && !lowCount) {
        fragments.push("Track both dialed-in and skipped nights to see how the checklist nudges tomorrow's throughput.");
      } else {
        const strongAvgValue = strongCount ? strongCharts / strongCount : null;
        const lowAvgValue = lowCount ? lowCharts / lowCount : null;
        const strongAvg = strongAvgValue !== null ? strongAvgValue.toFixed(1) : "—";
        const lowAvg = lowAvgValue !== null ? lowAvgValue.toFixed(1) : "—";
        let checklistText = `Sleep steps impact → Nights hitting ≥80% of steps led to ${strongAvg} chart(s) the next day; nights under 40% slid to ${lowAvg}.`;
        if (strongAvgValue !== null && lowAvgValue !== null) {
          const delta = strongAvgValue - lowAvgValue;
          if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
            checklistText += ` (≈${delta > 0 ? "+" : ""}${delta.toFixed(1)} chart swing when you protect the routine)`;
          }
        } else {
          checklistText += " Keep collecting data on both ends to firm up the comparison.";
        }
        fragments.push(checklistText);
      }
    }

    if (fragments.length === 0) {
      fragments.push("Log sleep data to let the system prove that care rituals beat pushing through fatigue.");
    } else {
      fragments.push("Let these cues remind you: honoring circadian rhythms outruns brute-force catch-up.");
    }

    summary.innerHTML = fragments.join("<br/>");
  }

  function renderSleepMorningRating() {
    const container = $("sleepMorningRating");
    if (!container) return;
    container.innerHTML = "";
    const state = loadSleepToolkitState();
    const targetKey = getYesterdayKey();
    if (!targetKey) return;
    const existing = state.restRatings[targetKey];
    const label = document.createElement("label");
    label.style.margin = "0";
    label.textContent = `How rested do you feel this morning (${formatFriendlyDate(targetKey)})?`;
    container.appendChild(label);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "1";
    slider.max = "5";
    slider.step = "1";
    slider.value = String(existing || 3);
    slider.style.flex = "1";
    const valueLabel = document.createElement("span");
    valueLabel.textContent = SLEEP_RATING_LABELS[slider.value] || slider.value;
    slider.addEventListener("input", event => {
      const val = Number(event.target.value);
      valueLabel.textContent = SLEEP_RATING_LABELS[val] || val;
    });
    const save = document.createElement("button");
    save.textContent = existing ? "Update rating" : "Log rating";
    save.addEventListener("click", () => {
      recordSleepRating(targetKey, Number(slider.value));
    });
    container.appendChild(slider);
    container.appendChild(valueLabel);
    container.appendChild(save);
  }

  function updateSleepToolkitUI() {
    const state = loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    const content = $("sleepToolkitContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const alert = $("sunlightAlert");
      if (alert) {
        alert.classList.add("hidden");
        alert.setAttribute("aria-hidden", "true");
      }
      if (sunlightAlertTimeoutId) {
        clearTimeout(sunlightAlertTimeoutId);
        sunlightAlertTimeoutId = null;
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    renderSleepChecklist();
    updateSleepCompletionSummary();
    renderSleepTips();
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.checked = Boolean(state.melatonin?.enabled);
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.value = state.melatonin?.time || DEFAULT_MELATONIN_TIME;
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.checked = Boolean(state.sunlight?.enabled);
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.value = state.sunlight?.time || DEFAULT_SUNLIGHT_TIME;
    }
    renderSleepMorningRating();
    updateSleepCorrelationSummary();
  }

  function initializeSleepToolkitModule() {
    loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.enabled = event.target.checked;
        persistSleepToolkitState();
        updateSleepToolkitUI();
      });
    }
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.time = event.target.value || DEFAULT_MELATONIN_TIME;
        persistSleepToolkitState();
      });
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.time = event.target.value || DEFAULT_SUNLIGHT_TIME;
        persistSleepToolkitState();
      });
    }
    updateSleepToolkitUI();
  }

  function getMinutesFromTimeString(timeString) {
    if (!timeString || typeof timeString !== "string") return null;
    const [hours, minutes] = timeString.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    return hours * 60 + minutes;
  }

  function showSunlightBanner(message) {
    const alert = $("sunlightAlert");
    if (!alert) return;
    alert.textContent = message;
    alert.classList.remove("hidden");
    alert.setAttribute("aria-hidden", "false");
    if (sunlightAlertTimeoutId) {
      clearTimeout(sunlightAlertTimeoutId);
    }
    sunlightAlertTimeoutId = setTimeout(() => {
      alert.classList.add("hidden");
      alert.setAttribute("aria-hidden", "true");
    }, 5 * 60 * 1000);
  }

  function checkLaunchPadReminder() {
    const state = loadLaunchPadState();
    const timeMinutes = getMinutesFromTimeString(state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.lastReminderDate !== todayKey) {
      state.lastReminderDate = todayKey;
      persistLaunchPadState();
      showToast("Launch pad", "Prepare tomorrow's kit? Check your evening checklist.");
    }
  }

  function checkMelatoninReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.melatonin?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.melatonin.time || DEFAULT_MELATONIN_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.melatonin.lastPrompt !== todayKey) {
      state.melatonin.lastPrompt = todayKey;
      persistSleepToolkitState();
      showToast("Melatonin reminder", "Dim the lights and consider your melatonin routine.");
    }
  }

  function checkSunlightReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.sunlight?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.sunlight.time || DEFAULT_SUNLIGHT_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.sunlight.lastPrompt !== todayKey) {
      state.sunlight.lastPrompt = todayKey;
      persistSleepToolkitState();
      showSunlightBanner("Sunlight exposure due — step outside for 10 minutes to halt melatonin.");
      showToast("Sunlight cue", "Morning light = cortisol boost + melatonin shutoff.");
    }
  }

  function checkAllReminders() {
    checkLaunchPadReminder();
    checkMelatoninReminder();
    checkSunlightReminder();
  }

  function startReminderLoop() {
    if (reminderIntervalId) {
      clearInterval(reminderIntervalId);
    }
    checkAllReminders();
    reminderIntervalId = setInterval(checkAllReminders, 60 * 1000);
  }

  function handleCategoryChange(value) {
    const resolvedCategory = (value ?? $("taskCategory")?.value ?? "").toString();
    populateScalesForCategory(resolvedCategory);
    if (resolvedCategory.toLowerCase() === "chart") {
      showChartFields();
    } else {
      hideChartFields();
    }
    renderTemplates();
  }

  function initializeChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storedChartFieldValues = null;
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  const NUMERIC_SCALE_FIELDS = ["importance","novelty","interest","timeToStart","difficulty"];
  const SCALE_FIELDS = [...NUMERIC_SCALE_FIELDS, "urgency", "externalPressure"];
  const BASIC_NUMERIC_DESCRIPTORS = [1, 2, 3, 4, 5].map(value => ({
    value,
    text: String(value)
  }));

  const DEFAULT_DESCRIPTOR_SET = {
    importance: BASIC_NUMERIC_DESCRIPTORS,
    urgency: [
      { value: 5, text: "5 – Critical Billing Window or Immediate Patient Need" },
      { value: 4, text: "4 – High Priority – Near-Term Deadline" },
      { value: 3, text: "3 – Moderate Priority – Monthly Closure" },
      { value: 2, text: "2 – Low Billing Value – Ready today" },
      { value: 1, text: "1 – Routine Follow-Up Work" }
    ],
    novelty: BASIC_NUMERIC_DESCRIPTORS,
    interest: BASIC_NUMERIC_DESCRIPTORS,
    externalPressure: [
      { value: 1, text: "1 – Solo responsibility" },
      { value: 2, text: "2 – Soft deadline / courtesy check" },
      { value: 3, text: "3 – Peer or team waiting" },
      { value: 4, text: "4 – Leadership expectation" },
      { value: 5, text: "5 – Patient or compliance critical" }
    ],
    timeToStart: BASIC_NUMERIC_DESCRIPTORS,
    difficulty: BASIC_NUMERIC_DESCRIPTORS
  };

  const CATEGORY_DESCRIPTOR_SETS = {
    chart: {
      importance: [
        { value: 1, text: "1 – Chart adds minimal new information or duplicates an existing note." },
        { value: 2, text: "2 – Routine follow-up with limited clinical or legal relevance." },
        { value: 3, text: "3 – Contains moderate clinical content or affects internal workflow (e.g., continuity documentation)." },
        { value: 4, text: "4 – Impacts care coordination, billing, or orders being released." },
        { value: 5, text: "5 – Critical legal or clinical documentation—such as a new complex care note, DME letter, or therapy order summary." }
      ],
      urgency: [
        { value: 1, text: "1 – No immediate consequence if delayed more than a week." },
        { value: 2, text: "2 – Should be completed within five to seven days to keep the workflow moving." },
        { value: 3, text: "3 – Approaching the expected three-day chart completion window." },
        { value: 4, text: "4 – Actively holding up orders, referrals, or communication with other providers." },
        { value: 5, text: "5 – Must be completed within 24 hours—blocking patient care, billing, or compliance." }
      ],
      novelty: [
        { value: 1, text: "1 – Repetitive, nearly identical to prior encounters—mental autopilot work." },
        { value: 2, text: "2 – Familiar patient with predictable updates." },
        { value: 3, text: "3 – Some variation or new findings but overall routine." },
        { value: 4, text: "4 – Clearly different or updated scenario (new comorbidity, new specialist input)." },
        { value: 5, text: "5 – Entirely new case or patient; requires full synthesis and high cognitive effort." }
      ],
      interest: [
        { value: 1, text: "1 – Emotionally draining, tedious, or disengaging." },
        { value: 2, text: "2 – Slightly more tolerable but still repetitive." },
        { value: 3, text: "3 – Neutral—acceptable task without resistance or enthusiasm." },
        { value: 4, text: "4 – Personally engaging or meaningful (e.g., rewarding outcome, interesting complexity)." },
        { value: 5, text: "5 – Highly interesting or affirming—feels worth your energy investment." }
      ],
      externalPressure: [
        { value: 1, text: "1 – No one waiting on this; purely internal backlog." },
        { value: 2, text: "2 – Minimal outside awareness—perhaps a resident awaiting co-signature." },
        { value: 3, text: "3 – Family or administrative team may soon follow up." },
        { value: 4, text: "4 – Directly affects nursing, therapy, or resident progress if left undone." },
        { value: 5, text: "5 – Leadership, family, or compliance risk if not completed immediately." }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major prep—multiple subspecialty notes or context review needed." },
        { value: 2, text: "2 – Some setup required; moderate amount of data gathering first." },
        { value: 3, text: "3 – Ready to begin with basic template or SmartPhrase already open." },
        { value: 4, text: "4 – Mostly drafted or pre-filled by a resident." },
        { value: 5, text: "5 – One click from completion—review and sign only." }
      ],
      difficulty: [
        { value: 1, text: "1 – Very complex visit—multiple specialists, high stakes." },
        { value: 2, text: "2 – High cognitive load—multiple notes or CareEverywhere data to merge." },
        { value: 3, text: "3 – Moderate effort—some review of orders, results, or medication changes." },
        { value: 4, text: "4 – Small amount of synthesis or clean-up work." },
        { value: 5, text: "5 – Straightforward chart; minimal thought required." }
      ]
    },
    admin: {
      importance: [
        { value: 1, text: "1: Low-value clerical item — informational only, not linked to care or billing (e.g., generic record release)." },
        { value: 2, text: "2: Routine paperwork (e.g., school letter, general clearance) with limited medical impact." },
        { value: 3, text: "3: Moderately important — ensures continuity of services or avoids family confusion." },
        { value: 4, text: "4: Affects patient function, equipment use, or continuity of home health/therapy services." },
        { value: 5, text: "5: Legally, financially, or clinically critical (e.g., DME or home nursing orders, time-sensitive medical necessity forms)." }
      ],
      urgency: [
        { value: 1, text: "1: No time constraint; backlog cleanup or batch task." },
        { value: 2, text: "2: Preferred within a week to prevent workflow pileup." },
        { value: 3, text: "3: Due soon — flagged or requested multiple times (within 72 hours)." },
        { value: 4, text: "4: Time-sensitive — blocking care, equipment renewal, or external agency action." },
        { value: 5, text: "5: Immediate deadline — service interruption or patient safety risk if not completed today." }
      ],
      novelty: [
        { value: 1, text: "1: Routine, repetitive — identical to previous letters or forms." },
        { value: 2, text: "2: Minor variation (same patient, slightly different form)." },
        { value: 3, text: "3: Moderate variation — new formatting or service type but same structure." },
        { value: 4, text: "4: Requires rethinking or rewriting — new medical justification or appeal." },
        { value: 5, text: "5: Entirely new or unusual form requiring research, collaboration, or creative framing." }
      ],
      interest: [
        { value: 1, text: "1: Utterly draining paperwork with no personal reward." },
        { value: 2, text: "2: Mildly tolerable — repetitive but manageable." },
        { value: 3, text: "3: Neutral task; emotionally flat but not difficult." },
        { value: 4, text: "4: Slightly satisfying — clear, finite, ‘box checked’ gratification." },
        { value: 5, text: "5: Emotionally rewarding — high-impact document that feels meaningful or helps a deserving family." }
      ],
      externalPressure: [
        { value: 1, text: "1: No one waiting; background task only." },
        { value: 2, text: "2: Requested once, no follow-up." },
        { value: 3, text: "3: Family, therapist, or vendor has followed up once or twice." },
        { value: 4, text: "4: Repeated requests or escalating frustration from external partner." },
        { value: 5, text: "5: Time-sensitive escalation — multiple stakeholders involved, risk of complaint or service disruption." }
      ],
      timeToStart: [
        { value: 1, text: "1: Fully prepped or pre-filled — literally one click to sign, fax, or send." },
        { value: 2, text: "2: Nearly complete — requires signatures or minor edits." },
        { value: 3, text: "3: Ready to draft — information accessible, no major digging needed." },
        { value: 4, text: "4: Some setup required — gathering diagnostic codes, reviewing notes." },
        { value: 5, text: "5: Requires locating old versions or supporting documents (e.g., past forms, letters)." }
      ],
      difficulty: [
        { value: 1, text: "1: Straightforward — fill in basic info, minimal judgment." },
        { value: 2, text: "2: Simple but tedious — multiple checkboxes or sign-offs." },
        { value: 3, text: "3: Moderate — requires referencing recent visits or clinical notes." },
        { value: 4, text: "4: High cognitive effort — must summarize complex clinical picture concisely." },
        { value: 5, text: "5: Very complex — appeals, multidisciplinary coordination, or justification requiring clinical precision." }
      ]
    },
    personal: {
      importance: [
        { value: 1, text: "1 – Trivial — doesn’t really matter if done" },
        { value: 2, text: "2 – Mildly useful — minor quality-of-life improvement" },
        { value: 3, text: "3 – Helpful — meaningful progress toward a goal" },
        { value: 4, text: "4 – Significant — affects well-being or relationships" },
        { value: 5, text: "5 – Critical — has serious emotional, financial, or health consequences" }
      ],
      urgency: [
        { value: 1, text: "1 – No time pressure — can wait indefinitely" },
        { value: 2, text: "2 – Slight — would be good to do soon" },
        { value: 3, text: "3 – Moderate — needs attention within a few days" },
        { value: 4, text: "4 – High — needs to be done today" },
        { value: 5, text: "5 – Immediate — must be addressed now" }
      ],
      interest: [
        { value: 1, text: "1 – Dreaded — pure avoidance energy" },
        { value: 2, text: "2 – Unpleasant but tolerable" },
        { value: 3, text: "3 – Neutral — neither appealing nor aversive" },
        { value: 4, text: "4 – Mildly engaging" },
        { value: 5, text: "5 – Genuinely energizing or rewarding" }
      ],
      difficulty: [
        { value: 1, text: "1 – Very hard — high resistance, many steps, or emotionally draining" },
        { value: 2, text: "2 – Challenging — mentally or logistically demanding" },
        { value: 3, text: "3 – Moderate — manageable with steady focus" },
        { value: 4, text: "4 – Mild effort — easy, straightforward, minimal resistance" },
        { value: 5, text: "5 – Simple — effortless, can be done on autopilot" }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major setup or emotional readiness" },
        { value: 2, text: "2 – Some prep work before starting" },
        { value: 3, text: "3 – Can start with minimal prep" },
        { value: 4, text: "4 – Ready to begin immediately" },
        { value: 5, text: "5 – Already in motion / one click from done" }
      ]
    }
  };

  function getCategoryDescriptorKey(category) {
    const normalized = (category || "").toString().trim().toLowerCase();
    return normalized || "general";
  }

  function getScaleOptions(fieldId, categoryKey) {
    const key = categoryKey || "general";
    const descriptorSet = CATEGORY_DESCRIPTOR_SETS[key];
    if (descriptorSet && Array.isArray(descriptorSet[fieldId])) {
      return descriptorSet[fieldId];
    }
    const defaults = DEFAULT_DESCRIPTOR_SET[fieldId];
    if (defaults) {
      return defaults;
    }
    return BASIC_NUMERIC_DESCRIPTORS;
  }

  function populateScaleSelect(fieldId, categoryKey) {
    const select = $(fieldId);
    if (!select) return;
    const previousValue = select.value;
    const options = getScaleOptions(fieldId, categoryKey);
    select.innerHTML = "";
    options.forEach(option => {
      const opt = document.createElement("option");
      opt.value = String(option.value);
      opt.textContent = option.text || String(option.value);
      select.appendChild(opt);
    });
    const previous = previousValue !== undefined && previousValue !== null
      ? String(previousValue)
      : "";
    const hasPrevious = options.some(option => String(option.value) === previous);
    if (hasPrevious) {
      select.value = previous;
    } else if (options.length > 0) {
      select.value = String(options[0].value);
    }
  }

  function populateScalesForCategory(category) {
    const key = getCategoryDescriptorKey(category);
    currentScaleDescriptorCategory = key;
    SCALE_FIELDS.forEach(fieldId => populateScaleSelect(fieldId, key));
    updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
  }

  const BASE_CHART_STEPS = [
    "Load Abridge (dictation)",
    "Review/modify HPI",
    "Review/modify PE",
    "Review/modify A/P",
    "Review/submit orders",
    "Enter billing code",
    "Sign off"
  ];
  const RESIDENT_ATTESTATION_STEP = "Add Attestation";
  let currentFocusTaskIndex = null;

  function generateSubTaskId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  }

  function isChartTask(task) {
    return task && String(task.category).toLowerCase() === "chart";
  }

  function buildChartSteps(authorType) {
    const steps = [...BASE_CHART_STEPS];
    if (String(authorType).toLowerCase() === "resident") {
      const billingIndex = steps.indexOf("Enter billing code");
      const insertIndex = billingIndex === -1 ? steps.length - 1 : billingIndex;
      steps.splice(insertIndex, 0, RESIDENT_ATTESTATION_STEP);
    }
    return steps;
  }

  function calculateDurationMinutes(start, end) {
    if (!start || !end) return null;
    const startDate = new Date(start);
    const endDate = new Date(end);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Number((diff / (1000 * 60)).toFixed(2));
  }

  function isTaskCompleted(task) {
    if (!task) return false;
    return Boolean(task.completed || task.completedAt);
  }

  function getCompletionTimestamp(task) {
    if (!task) return null;
    return task.completedAt || task.completionTime || null;
  }

  function formatDateTime(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  }

  function formatDuration(minutes) {
    if (minutes === null || minutes === undefined) return "--";
    const num = Number(minutes);
    if (!Number.isFinite(num)) return "--";
    return `${num.toFixed(2)} min`;
  }

  function formatElapsedMs(ms) {
    if (!Number.isFinite(ms) || ms < 0) return "--";
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
  }

  function estimateTaskMinutes(task) {
    if (!task) return 0;
    const subTasks = Array.isArray(task.subTasks) ? task.subTasks : [];
    const remaining = subTasks.filter(sub => !sub.completed);
    const remainingCount = remaining.length > 0 ? remaining.length : 1;
    const recordedDurations = subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value) && value > 0);
    if (recordedDurations.length) {
      const avg = recordedDurations.reduce((sum, value) => sum + value, 0) / recordedDurations.length;
      return Math.max(1, Math.ceil(avg * remainingCount));
    }
    const n = subTasks.length;
    const difficulty = Number(task.difficulty || 3);
    const startFriction = Number(task.timeToStart || 3);
    const estimate = Math.round((10 + 2 * n) * (0.7 + 0.15 * difficulty) + (startFriction - 3) * 2);
    return Math.max(5, estimate);
  }

  function getEnergyLevel() {
    const el = document.querySelector('[data-field="energy-level"]');
    if (el) {
      const value = Number(el.value || el.getAttribute('data-value'));
      if (Number.isFinite(value)) return value;
    }
    return 3;
  }

  function getTimeBudgetMinutes() {
    const el = document.querySelector('[data-field="time-budget"]');
    if (!el) return Infinity;
    const value = Number(el.value);
    return Number.isFinite(value) && value > 0 ? value : Infinity;
  }

  function alignEnergySliders(value, source = "next") {
    const resolved = clampScale(value, 3);
    if (syncingEnergySliders) {
      return resolved;
    }
    syncingEnergySliders = true;
    const nextSlider = $("nextBestEnergy");
    if (nextSlider && source !== "next" ) {
      nextSlider.value = String(resolved);
      nextSlider.setAttribute("data-value", String(resolved));
    }
    const nextLabel = $("nextBestEnergyLabel");
    if (nextLabel) {
      const label = ENERGY_LABELS[resolved] || resolved;
      nextLabel.textContent = label;
    }
    const morningSlider = $("morningEnergy");
    if (morningSlider && source !== "morning") {
      morningSlider.value = String(resolved);
      const morningLabel = $("morningEnergyLabel");
      if (morningLabel) {
        const label = ENERGY_LABELS[resolved] || resolved;
        morningLabel.textContent = label;
      }
    }
    const nextField = document.querySelector('#nextBestEnergy');
    if (nextField) {
      nextField.setAttribute('data-value', String(resolved));
    }
    syncingEnergySliders = false;
    return resolved;
  }

  function energyFit(task, energyLevel) {
    if (!Number.isFinite(energyLevel)) return 1;
    const est = estimateTaskMinutes(task);
    const difficulty = Number(task?.difficulty || 3);
    const lowEnergyWeight = energyLevel <= 2 ? (est > 20 ? 0.85 : 1) * (difficulty >= 4 ? 0.85 : 1) : 1;
    const highEnergyWeight = energyLevel >= 4 ? 1.05 : 1;
    return lowEnergyWeight * highEnergyWeight;
  }

  function timeFit(task, budgetMinutes) {
    if (!Number.isFinite(budgetMinutes)) return 1;
    const est = estimateTaskMinutes(task);
    if (!Number.isFinite(est) || est <= 0) return 1;
    if (est <= budgetMinutes) {
      const ratio = est / (budgetMinutes * 0.85);
      return Math.max(0.85, Math.min(1.05, 1.05 - Math.abs(1 - ratio) * 0.3));
    }
    const overRatio = est / budgetMinutes;
    return Math.max(0.55, 1 - (overRatio - 1) * 0.6);
  }


  function getEffectiveEnergyLevel() {
    let level = null;
    try {
      if (typeof getMorningEntry === "function") {
        const entry = getMorningEntry();
        if (entry && Number.isFinite(Number(entry.energy))) {
          level = clampScale(entry.energy, 3);
        }
      }
    } catch (error) {
      console.warn("Unable to read morning energy entry", error);
    }
    if (!Number.isFinite(level)) {
      const slider = $("morningEnergy");
      if (slider) {
        const sliderValue = Number(slider.value);
        if (Number.isFinite(sliderValue)) {
          level = clampScale(sliderValue, 3);
        }
      }
    }
    if (!Number.isFinite(level)) {
      level = 3;
    }
    return level;
  }

  function computeEnergyFit(task, energyLevel) {
    return energyFit(task, energyLevel);
  }

  function computeTimeFit(task, budgetMinutes) {
    return timeFit(task, budgetMinutes);
  }

  function createSubTask(name, priority, options = {}) {
    return {
      id: generateSubTaskId(),
      name,
      completed: false,
      priority,
      startTime: null,
      completionTime: null,
      durationMinutes: null,
      activeDurationMs: 0,
      lastResumedAt: null,
      isPaused: false,
      isFirstThree: Boolean(options.isFirstThree),
      deferredUntilUnlock: Boolean(options.deferredUntilUnlock)
    };
  }

  function normalizeSubTask(sub, basePriority) {
    if (!sub) {
      return createSubTask("Step", basePriority);
    }
    const normalized = {
      id: sub.id || generateSubTaskId(),
      name: sub.name || "Step",
      completed: Boolean(sub.completed),
      priority: toNumber(sub.priority, basePriority),
      startTime: sub.startTime || null,
      completionTime: sub.completionTime || null,
      durationMinutes: sub.durationMinutes !== undefined && sub.durationMinutes !== null && Number.isFinite(Number(sub.durationMinutes))
        ? Number(sub.durationMinutes)
        : null,
      activeDurationMs: Number.isFinite(Number(sub.activeDurationMs)) ? Number(sub.activeDurationMs) : 0,
      lastResumedAt: sub.lastResumedAt || null,
      isPaused: Boolean(sub.isPaused),
      isFirstThree: Boolean(sub.isFirstThree),
      deferredUntilUnlock: Boolean(sub.deferredUntilUnlock)
    };
    if (normalized.durationMinutes === null && normalized.startTime && normalized.completionTime) {
      normalized.durationMinutes = calculateDurationMinutes(normalized.startTime, normalized.completionTime);
    }
    if (normalized.completed) {
      normalized.isPaused = false;
      normalized.lastResumedAt = null;
    }
    return normalized;
  }

  function shouldTriggerFirstThreeWizard(taskName, subLines, category) {
    const normalizedName = (taskName || "").toLowerCase();
    const wordCount = normalizedName.split(/\s+/).filter(Boolean).length;
    const hasKeyword = FIRST_THREE_KEYWORDS.some(keyword => normalizedName.includes(keyword));
    const isChart = (category || "").toLowerCase() === "chart";
    if (Array.isArray(subLines) && subLines.length > 0) {
      return false;
    }
    return wordCount >= FIRST_THREE_WORD_THRESHOLD || hasKeyword || isChart;
  }

  function applyFirstThreeSteps(task, steps, basePriority) {
    if (!task) return;
    const trimmed = Array.isArray(steps)
      ? steps.map(step => step.trim()).filter(Boolean)
      : [];
    while (trimmed.length < 3) {
      const defaults = ["Open workspace", "Outline first move", "Start five-minute draft"];
      trimmed.push(defaults[trimmed.length] || `Micro step ${trimmed.length + 1}`);
    }
    task.firstThreeMode = true;
    task.firstThreeUnlocked = Boolean(task.firstThreeUnlocked);
    task.firstThreeSteps = trimmed.slice(0, 3);
    const firstThreeSubs = trimmed.slice(0, 3).map(step => createSubTask(step, basePriority, { isFirstThree: true }));
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const deferred = !task.firstThreeUnlocked;
    const remainder = existingSubs.map(sub => ({
      ...sub,
      deferredUntilUnlock: deferred && !sub.isFirstThree
    }));
    task.subTasks = [...firstThreeSubs, ...remainder];
  }

  function getVisibleSubTasks(task) {
    if (!task || !Array.isArray(task.subTasks)) return [];
    if (!task.firstThreeMode || task.firstThreeUnlocked) {
      return task.subTasks;
    }
    return task.subTasks.filter(sub => sub.isFirstThree || !sub.deferredUntilUnlock);
  }

  function maybeUnlockFirstThree(task, { silent = false } = {}) {
    if (!task || !task.firstThreeMode) return;
    const subs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const firstThreeSubs = subs.filter(sub => sub.isFirstThree);
    if (firstThreeSubs.length === 0) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      return;
    }
    const allComplete = firstThreeSubs.every(sub => sub.completed);
    if (allComplete && !task.firstThreeUnlocked) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      if (!silent) {
        showToast("Momentum!", "Nice momentum! Here's what's next.");
      }
    }
  }

  function computeTotalChartDuration(subTasks) {
    if (!Array.isArray(subTasks) || subTasks.length === 0) return 0;
    return Number(subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0).toFixed(2));
  }

  function getTaskTotalDuration(task) {
    if (!task) return null;
    if (isChartTask(task)) {
      const value = Number(task.chartDurationMinutes);
      return Number.isFinite(value) && value > 0 ? value : null;
    }
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);
    if (total <= 0) return null;
    return Number(total.toFixed(2));
  }

  function updateChartDurationForTask(task) {
    if (!isChartTask(task)) {
      delete task.chartDurationMinutes;
      return;
    }
    task.chartDurationMinutes = computeTotalChartDuration(task.subTasks);
  }

  function clearRunningTimers() {
    runningTimers.forEach(intervalId => clearInterval(intervalId));
    runningTimers.clear();
  }

  function stopTimerForSubTask(subId) {
    const intervalId = runningTimers.get(subId);
    if (intervalId) {
      clearInterval(intervalId);
      runningTimers.delete(subId);
    }
  }

  function getSubTaskElapsedMs(sub, includeRunning = true) {
    if (!sub) return 0;
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    if (!includeRunning) {
      return base;
    }
    if (!sub.startTime || sub.completed || sub.isPaused) {
      return base;
    }
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    if (Number.isNaN(resumeDate.getTime())) {
      return base;
    }
    return base + Math.max(0, Date.now() - resumeDate.getTime());
  }

  function dispatchFocusStepEvent(eventName, detail) {
    const target = $("focus") || document;
    target.dispatchEvent(new CustomEvent(eventName, { bubbles: true, detail }));
  }

  function trackTimer(sub, timerEl) {
    if (!timerEl) return;
    stopTimerForSubTask(sub.id);
    if (sub.completed) {
      timerEl.textContent = `Completed – ${formatDuration(sub.durationMinutes)}`;
      return;
    }
    if (!sub.startTime) {
      timerEl.textContent = "Timer: --";
      return;
    }
    if (sub.isPaused) {
      const pausedElapsed = getSubTaskElapsedMs(sub, false);
      timerEl.textContent = `Paused – ${formatElapsedMs(pausedElapsed)}`;
      return;
    }
    const update = () => {
      const elapsedMs = getSubTaskElapsedMs(sub);
      if (!Number.isFinite(elapsedMs) || elapsedMs < 0) {
        timerEl.textContent = "Timer: --";
        return;
      }
      timerEl.textContent = `Timer: ${formatElapsedMs(elapsedMs)}`;
    };
    update();
    const intervalId = setInterval(update, 1000);
    runningTimers.set(sub.id, intervalId);
  }

  function setSprintVisualState(active) {
    const bodyEl = document.body;
    if (!bodyEl) return;
    bodyEl.classList.toggle("sprint-active", Boolean(active));
  }

  function stopFocusTimer(resetDisplay = true) {
    if (focusTimerId) {
      clearInterval(focusTimerId);
      focusTimerId = null;
    }
    focusTimerStart = null;
    focusTimerLastPing = null;
    sprintEndTime = null;
    if (resetDisplay) {
      sprintDurationMinutes = null;
      resetDistractionTracking();
      setSprintVisualState(false);
    }
    setCaughtMeEnabled(false);
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    timerEl.classList.remove("pulse");
    if (resetDisplay) {
      timerEl.textContent = "🧭 Focus Time: 0:00";
      setFocusProgress(0);
    }
  }

  function setFocusProgress(percent) {
    const fill = $("focusProgressFill");
    if (!fill) return;
    const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
    fill.style.width = `${clamped}%`;
  }

  function updateFocusTimerDisplay(elapsedMs) {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0 && sprintEndTime) {
      const remaining = Math.max(0, sprintEndTime - Date.now());
      if (remaining > 0) {
        const minutesLeft = Math.floor(remaining / 60000);
        const secondsLeft = Math.floor((remaining % 60000) / 1000);
        timerEl.textContent = `⏱️ Sprint: ${minutesLeft}:${String(secondsLeft).padStart(2, "0")}`;
        const total = sprintDurationMinutes * 60000;
        const elapsed = Math.max(0, total - remaining);
        setFocusProgress(total > 0 ? (elapsed / total) * 100 : 0);
        return;
      }
      sprintDurationMinutes = null;
      sprintEndTime = null;
      timerEl.textContent = "✅ Sprint complete";
      setFocusProgress(100);
      triggerFocusPing();
      return;
    }
    const minutes = Math.floor(elapsedMs / 60000);
    const seconds = Math.floor((elapsedMs % 60000) / 1000);
    timerEl.textContent = `🧭 Focus Time: ${minutes}:${String(seconds).padStart(2, "0")}`;
    const gentlePercent = Math.min(100, (elapsedMs / (25 * 60000)) * 100);
    setFocusProgress(gentlePercent);
  }

  function playFocusPing() {
    if (!focusSoundEnabled) return;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor) return;
    if (!focusAudioContext) {
      try {
        focusAudioContext = new AudioContextCtor();
      } catch (error) {
        focusAudioContext = null;
        return;
      }
    }
    if (focusAudioContext.state === "suspended") {
      focusAudioContext.resume().catch(() => {});
    }
    const duration = 0.4;
    const oscillator = focusAudioContext.createOscillator();
    const gain = focusAudioContext.createGain();
    oscillator.type = "sine";
    oscillator.frequency.setValueAtTime(880, focusAudioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, focusAudioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, focusAudioContext.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, focusAudioContext.currentTime + duration);
    oscillator.connect(gain);
    gain.connect(focusAudioContext.destination);
    oscillator.start();
    oscillator.stop(focusAudioContext.currentTime + duration);
  }

  function triggerFocusPing() {
    const timerEl = $("focusTimer");
    if (timerEl) {
      timerEl.classList.add("pulse");
      setTimeout(() => timerEl.classList.remove("pulse"), 1000);
    }
    playFocusPing();
  }

  function startFocusTimer() {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    stopFocusTimer(false);
    focusTimerStart = Date.now();
    focusTimerLastPing = focusTimerStart;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0) {
      sprintEndTime = focusTimerStart + sprintDurationMinutes * 60000;
    } else {
      sprintEndTime = null;
    }
    updateFocusTimerDisplay(0);
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0) {
      setFocusProgress(0);
    }
    focusTimerId = setInterval(() => {
      if (focusTimerStart === null) return;
      const now = Date.now();
      const elapsed = now - focusTimerStart;
      updateFocusTimerDisplay(elapsed);
      if (!focusTimerLastPing || now - focusTimerLastPing >= FOCUS_PING_INTERVAL_MS) {
        triggerFocusPing();
        focusTimerLastPing = now;
      }
    }, 1000);
    setCaughtMeEnabled(true);
  }

  function setCaughtMeEnabled(enabled) {
    const button = $("caughtMeButton");
    if (!button) return;
    button.disabled = !enabled;
    button.setAttribute("aria-disabled", enabled ? "false" : "true");
    if (!enabled) {
      hideDistractionPrompt();
    }
  }

  function hideDistractionPrompt() {
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.classList.add("hidden");
    }
  }

  function toggleDistractionPrompt() {
    if (!focusTimerStart) return;
    const prompt = $("distractionPrompt");
    if (!prompt) return;
    prompt.classList.toggle("hidden");
  }

  function resetDistractionTracking() {
    focusDistractionLog = [];
    distractionTriggersSinceReset = 0;
    updateDistractionLogUI();
    hideDistractionPrompt();
    clearDoorwayResetState({ hidePrompt: true });
  }

  function updateDistractionLogUI() {
    const list = $("distractionLog");
    if (!list) return;
    list.innerHTML = "";
    if (!focusDistractionLog.length) {
      const empty = document.createElement("li");
      empty.className = "distraction-empty";
      empty.textContent = "Clear runway. Keep cruising.";
      list.appendChild(empty);
      return;
    }
    const entries = focusDistractionLog.slice().reverse();
    entries.forEach(entry => {
      const item = document.createElement("li");
      const time = document.createElement("span");
      time.className = "distraction-log__time";
      if (Number.isFinite(entry.offset)) {
        time.textContent = formatElapsedMs(entry.offset);
      } else {
        time.textContent = new Date(entry.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
      const label = document.createElement("div");
      label.className = "distraction-log__label";
      label.textContent = entry.label;
      item.appendChild(time);
      item.appendChild(label);
      list.appendChild(item);
    });
  }

  function logDistractionTrigger(triggerValue) {
    if (!focusTimerStart) return;
    const option = DISTRACTION_TRIGGER_OPTIONS.find(entry => entry.value === triggerValue);
    const label = option ? option.label : String(triggerValue || "Trigger");
    const timestamp = Date.now();
    const offset = focusTimerStart ? Math.max(0, timestamp - focusTimerStart) : null;
    focusDistractionLog.push({ label, timestamp, offset });
    if (focusDistractionLog.length > 8) {
      focusDistractionLog = focusDistractionLog.slice(focusDistractionLog.length - 8);
    }
    distractionTriggersSinceReset += 1;
    updateDistractionLogUI();
    hideDistractionPrompt();
    maybePromptDoorwayReset();
  }

  function maybePromptDoorwayReset() {
    if (doorwayResetState.active || doorwayResetState.pending) return;
    if (distractionTriggersSinceReset < DOORWAY_RESET_THRESHOLD) return;
    showDoorwayResetPrompt();
  }

  function showDoorwayResetPrompt() {
    const container = $("doorwayReset");
    const message = $("doorwayResetMessage");
    if (!container || !message) return;
    container.classList.remove("hidden");
    message.textContent = "Two distractions logged. Take a 60-second doorway reset?";
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: true, endTime: null, countdownId: null };
    showToast("Doorway reset", "Stand, walk to the doorway, clear the mental cache, then glide back.");
  }

  function startDoorwayResetCountdown() {
    const container = $("doorwayReset");
    if (!container) return;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Stand, walk to the doorway, and let the reset happen.";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: true, pending: false, endTime: Date.now() + DOORWAY_RESET_DURATION_MS, countdownId: null };
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Reset running…";
      startBtn.disabled = true;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Skip reset";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.classList.remove("hidden");
    }
    updateDoorwayCountdownUI();
    doorwayResetState.countdownId = setInterval(updateDoorwayCountdownUI, 250);
  }

  function updateDoorwayCountdownUI() {
    if (!doorwayResetState.active) return;
    const countdown = $("doorwayCountdown");
    if (!countdown) return;
    const remaining = Math.max(0, doorwayResetState.endTime - Date.now());
    const seconds = Math.ceil(remaining / 1000);
    countdown.textContent = `⏳ ${seconds}s remaining`;
    if (remaining <= 0) {
      completeDoorwayReset();
    }
  }

  function completeDoorwayReset() {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    distractionTriggersSinceReset = 0;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Doorway reset complete. Notice what feels lighter.";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "✅ Reset done";
      countdown.classList.remove("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Do it again";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Close";
    }
    setTimeout(() => clearDoorwayResetState({ hidePrompt: true }), 6000);
  }

  function clearDoorwayResetState({ hidePrompt = false } = {}) {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    const container = $("doorwayReset");
    if (!container) return;
    if (hidePrompt) {
      container.classList.add("hidden");
    }
    const message = $("doorwayResetMessage");
    if (message && hidePrompt) {
      message.textContent = "";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
  }

  function skipDoorwayResetPrompt() {
    clearDoorwayResetState({ hidePrompt: true });
    distractionTriggersSinceReset = 0;
  }

  function initializeDistractionTools() {
    const button = $("caughtMeButton");
    if (button) {
      button.addEventListener("click", () => {
        if (button.disabled) return;
        toggleDistractionPrompt();
      });
    }
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.addEventListener("click", event => {
        const target = event.target.closest('[data-distraction-trigger]');
        if (!target) return;
        const value = target.getAttribute('data-distraction-trigger');
        if (value) {
          logDistractionTrigger(value);
        }
      });
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.addEventListener("click", startDoorwayResetCountdown);
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipDoorwayResetPrompt);
    }
    updateDistractionLogUI();
    setCaughtMeEnabled(false);
  }

  function setFocusSoundPreference(enabled) {
    focusSoundEnabled = Boolean(enabled);
    localStorage.setItem("focusSoundEnabled", focusSoundEnabled ? "true" : "false");
  }

  function getAuditStorageKey(date = new Date()) {
    return `${AUDIT_STORAGE_PREFIX}${date.toISOString().split("T")[0]}`;
  }

  function getAuditShownKey(storageKey) {
    return `${storageKey}${AUDIT_SHOWN_SUFFIX}`;
  }

  function loadAuditEntries(storageKey) {
    if (!storageKey) return [];
    const raw = localStorage.getItem(storageKey);
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  }

  function recordTaskCompletion(task) {
    if (!task) return;
    const storageKey = getAuditStorageKey();
    const entries = loadAuditEntries(storageKey);
    const subDetails = Array.isArray(task.subTasks)
      ? task.subTasks.map(sub => {
          const rawDuration = Number(sub?.durationMinutes);
          const normalizedDuration = Number.isFinite(rawDuration) && rawDuration > 0
            ? Number(rawDuration.toFixed(2))
            : null;
          return {
            name: sub?.name || "Step",
            duration: normalizedDuration
          };
        })
      : [];
    let totalDuration = getTaskTotalDuration(task);
    if (Number.isFinite(totalDuration) && totalDuration > 0) {
      totalDuration = Number(totalDuration.toFixed(2));
    } else {
      const fallbackTotal = subDetails.reduce((sum, sub) => {
        return Number.isFinite(sub.duration) ? sum + sub.duration : sum;
      }, 0);
      totalDuration = fallbackTotal > 0 ? Number(fallbackTotal.toFixed(2)) : null;
    }
    entries.push({
      name: task.name || "Task",
      subDetails,
      totalDuration,
      completedAt: getCompletionTimestamp(task) || new Date().toISOString()
    });
    localStorage.setItem(storageKey, JSON.stringify(entries));
  }

  function showEndOfDayAudit(entries = null, shownKeyOverride = null) {
    const storageKey = getAuditStorageKey();
    const auditEntries = entries || loadAuditEntries(storageKey);
    if (!auditEntries.length) return;
    const shownKey = shownKeyOverride || getAuditShownKey(storageKey);

    const overlay = document.createElement("div");
    overlay.className = "audit-backdrop";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.setAttribute("aria-labelledby", "auditModalTitle");

    const modal = document.createElement("div");
    modal.className = "audit-modal";

    const title = document.createElement("h3");
    title.id = "auditModalTitle";
    title.textContent = "End of Day Audit";
    modal.appendChild(title);

    const totalMinutes = auditEntries.reduce((sum, entry) => {
      const value = Number(entry?.totalDuration);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);

    let longestSubtask = null;
    auditEntries.forEach(entry => {
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      details.forEach(sub => {
        const duration = Number(sub?.duration);
        if (!Number.isFinite(duration)) return;
        if (!longestSubtask || duration > longestSubtask.duration) {
          longestSubtask = {
            taskName: entry?.name || "Task",
            name: sub?.name || "Step",
            duration
          };
        }
      });
    });

    const summary = document.createElement("div");
    summary.className = "audit-summary";
    const summaryLines = [
      `Tasks completed: ${auditEntries.length}`,
      `Productive minutes: ${formatDuration(totalMinutes)}`,
      longestSubtask
        ? `Longest subtask: ${longestSubtask.name} (${formatDuration(longestSubtask.duration)}) — ${longestSubtask.taskName}`
        : "Longest subtask: --"
    ];
    summaryLines.forEach(text => {
      const line = document.createElement("div");
      line.textContent = text;
      summary.appendChild(line);
    });
    modal.appendChild(summary);

    const list = document.createElement("ul");
    list.className = "audit-task-list";
    auditEntries.forEach(entry => {
      const item = document.createElement("li");
      const header = document.createElement("strong");
      header.textContent = `${entry?.name || "Task"} — ${formatDuration(entry?.totalDuration)}`;
      item.appendChild(header);
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      if (details.length) {
        const subList = document.createElement("ul");
        subList.className = "audit-task-subtasks";
        details.forEach(sub => {
          const subItem = document.createElement("li");
          subItem.textContent = `${sub?.name || "Step"}: ${formatDuration(sub?.duration)}`;
          subList.appendChild(subItem);
        });
        item.appendChild(subList);
      }
      list.appendChild(item);
    });
    modal.appendChild(list);

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "Close";

    const closeModal = () => {
      overlay.remove();
      document.removeEventListener("keydown", onKeyDown);
    };

    const onKeyDown = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeModal();
      }
    };

    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeModal();
      }
    });
    document.addEventListener("keydown", onKeyDown);

    modal.appendChild(closeBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    requestAnimationFrame(() => closeBtn.focus());
    if (shownKey) {
      localStorage.setItem(shownKey, "true");
    }
  }

  function maybeShowEndOfDayAudit() {
    const remainingActive = tasks.filter(task => !isTaskCompleted(task)).length;
    if (remainingActive > 0) return;
    const storageKey = getAuditStorageKey();
    const shownKey = getAuditShownKey(storageKey);
    if (localStorage.getItem(shownKey) === "true") return;
    const entries = loadAuditEntries(storageKey);
    if (!entries.length) return;
    showEndOfDayAudit(entries, shownKey);
  }

  function initializeSoundPreference() {
    const saved = localStorage.getItem("focusSoundEnabled");
    if (saved !== null) {
      focusSoundEnabled = saved === "true";
    }
    const toggle = $("focusSoundToggle");
    if (!toggle) return;
    toggle.checked = focusSoundEnabled;
    toggle.addEventListener("change", event => {
      setFocusSoundPreference(event.target.checked);
      if (focusSoundEnabled && focusAudioContext && focusAudioContext.state === "suspended") {
        focusAudioContext.resume().catch(() => {});
      }
    });
  }

  function ensureChartSubTasks(task, options = {}) {
    if (!isChartTask(task)) return false;
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    const basePriority = options.basePriority !== undefined
      ? options.basePriority
      : computePriority({ ...task, subTasks: [] });
    if (task.useChartTemplate === false) {
      task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      return false;
    }
    const defaults = buildChartSteps(task.authorType);
    const lowerDefaults = defaults.map(step => step.toLowerCase());
    const requiredSet = new Set(lowerDefaults);
    const attestationKey = RESIDENT_ATTESTATION_STEP.toLowerCase();
    let changed = false;

    if (!requiredSet.has(attestationKey)) {
      const filtered = task.subTasks.filter(sub => String(sub?.name || "").toLowerCase() !== attestationKey);
      if (filtered.length !== task.subTasks.length) {
        task.subTasks = filtered;
        changed = true;
      }
    }

    const existingByName = new Map();
    task.subTasks.forEach((sub, index) => {
      const key = String(sub?.name || "").toLowerCase();
      if (!existingByName.has(key)) {
        existingByName.set(key, { sub, index });
      }
    });

    const orderedDefaults = defaults.map(step => {
      const key = step.toLowerCase();
      const existing = existingByName.get(key);
      if (existing) {
        existingByName.delete(key);
        return existing.sub;
      }
      changed = true;
      return createSubTask(step, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    const extras = task.subTasks.filter(sub => {
      const key = String(sub?.name || "").toLowerCase();
      return !requiredSet.has(key);
    });

    const nextSubTasks = [...orderedDefaults, ...extras];
    const sameOrder = nextSubTasks.length === task.subTasks.length
      && nextSubTasks.every((sub, idx) => sub === task.subTasks[idx]);
    if (!sameOrder) {
      task.subTasks = nextSubTasks;
      if (!changed) changed = true;
    }

    task.subTasks.forEach(sub => {
      if (sub.priority !== basePriority) {
        sub.priority = basePriority;
        changed = true;
      }
      if (task.firstThreeMode) {
        sub.deferredUntilUnlock = !task.firstThreeUnlocked && !sub.isFirstThree;
      } else if (sub.deferredUntilUnlock) {
        sub.deferredUntilUnlock = false;
      }
    });

    return changed;
  }

  function resolveTaskAndSub(taskIndex, subIndex, options = {}) {
    let resolvedIndex = taskIndex;
    let task = tasks[resolvedIndex];
    if ((!task || resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && options.taskId) {
      resolvedIndex = tasks.findIndex(t => t.id === options.taskId);
      task = tasks[resolvedIndex];
    }
    if (!task) {
      return { task: null, taskIndex: -1, sub: null, subIndex: -1 };
    }
    let resolvedSubIndex = subIndex;
    let sub = Array.isArray(task.subTasks) ? task.subTasks[resolvedSubIndex] : undefined;
    if ((!sub || resolvedSubIndex === undefined || resolvedSubIndex === null || resolvedSubIndex < 0) && options.subId && Array.isArray(task.subTasks)) {
      resolvedSubIndex = task.subTasks.findIndex(s => s.id === options.subId);
      sub = task.subTasks[resolvedSubIndex];
    }
    return { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex };
  }

  function renderChartSummary(task) {
    const container = document.createElement("div");
    container.className = "chart-summary";
    const heading = document.createElement("h4");
    heading.textContent = "Chart Summary";
    container.appendChild(heading);
    const list = document.createElement("ul");
    const durations = task.subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value));
    const longest = durations.length ? Math.max(...durations) : null;
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      item.textContent = `${sub.name}: ${formatDuration(sub.durationMinutes)}`;
      if (longest !== null && Number(sub.durationMinutes) === longest) {
        item.classList.add("longest-step");
      }
      list.appendChild(item);
    });
    container.appendChild(list);
    const total = Number.isFinite(Number(task.chartDurationMinutes))
      ? Number(task.chartDurationMinutes)
      : computeTotalChartDuration(task.subTasks);
    const totalLabel = document.createElement("div");
    totalLabel.className = "chart-total";
    totalLabel.textContent = `Total duration: ${formatDuration(total)}`;
    container.appendChild(totalLabel);
    return container;
  }

  function refreshAfterSubTaskChange(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    persist();
    const focusActive = !$("focus").classList.contains("hidden");
    if (focusActive) {
      const currentFocusTask = focusQueue[0];
      if ((resolvedIndex !== -1 && currentFocusTaskIndex === resolvedIndex)
        || (options.taskId && currentFocusTask && currentFocusTask.id === options.taskId)) {
        renderFocusTask(task, resolvedIndex);
      }
    }
    if (!focusActive && !options.focusOnly) {
      updateUI();
    }
  }

  function startSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const nowIso = new Date().toISOString();
    sub.startTime = nowIso;
    sub.lastResumedAt = nowIso;
    sub.activeDurationMs = 0;
    sub.isPaused = false;
    sub.completed = false;
    sub.completionTime = null;
    sub.durationMinutes = null;
    stopTimerForSubTask(sub.id);
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function pauseSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || !sub.startTime || sub.completed || sub.isPaused) return;
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    const now = Date.now();
    const additional = Number.isNaN(resumeDate.getTime()) ? 0 : Math.max(0, now - resumeDate.getTime());
    sub.activeDurationMs = base + additional;
    sub.lastResumedAt = null;
    sub.isPaused = true;
    stopTimerForSubTask(sub.id);
    dispatchFocusStepEvent("focus:step-paused", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function resumeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || sub.completed) return;
    const nowIso = new Date().toISOString();
    if (!sub.startTime) {
      sub.startTime = nowIso;
      sub.activeDurationMs = Math.max(0, Number(sub.activeDurationMs) || 0);
    }
    sub.lastResumedAt = nowIso;
    sub.isPaused = false;
    dispatchFocusStepEvent("focus:step-resumed", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function toggleSubTaskCompletion(taskIndex, subIndex, isCompleted, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    if (isCompleted) {
      if (!sub.startTime) {
        const nowIso = new Date().toISOString();
        sub.startTime = nowIso;
        sub.lastResumedAt = nowIso;
        sub.activeDurationMs = 0;
      }
      const completionTimestamp = new Date().toISOString();
      const elapsedMs = getSubTaskElapsedMs(sub);
      sub.completed = true;
      sub.completionTime = completionTimestamp;
      sub.durationMinutes = Number.isFinite(elapsedMs) && elapsedMs > 0 ? Number((elapsedMs / 60000).toFixed(2)) : 0;
      sub.activeDurationMs = Math.max(0, elapsedMs);
      sub.lastResumedAt = null;
      sub.isPaused = false;
      stopTimerForSubTask(sub.id);
      if (task.firstThreeMode) {
        maybeUnlockFirstThree(task);
      }
    } else {
      sub.completed = false;
      sub.completionTime = null;
      sub.durationMinutes = null;
      sub.isPaused = false;
      sub.lastResumedAt = null;
      if (task.firstThreeMode && sub.isFirstThree) {
        task.firstThreeUnlocked = false;
        task.subTasks.forEach(step => {
          if (!step.isFirstThree) {
            step.deferredUntilUnlock = true;
          }
        });
      }
      stopTimerForSubTask(sub.id);
    }
    const nextOptions = { ...options, taskId: task.id, subId: sub.id };
    refreshAfterSubTaskChange(resolvedIndex, nextOptions);
  }

  function editSubTaskName(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const newName = prompt("Rename step", sub.name);
    if (!newName) return;
    sub.name = newName.trim();
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function removeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !Array.isArray(task.subTasks)) return;
    if (!confirm("Remove this step?")) return;
    const removed = task.subTasks.splice(resolvedSubIndex, 1);
    if (removed.length) {
      stopTimerForSubTask(removed[0].id);
    }
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function addSubTaskToTask(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    const name = prompt("New step name");
    if (!name) return;
    const base = computePriority({ ...task, subTasks: [] });
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.subTasks.push(createSubTask(name.trim(), base, {
      deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
    }));
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function renderChartTask(task, taskIndex) {
    const container = document.createElement("div");
    container.style.width = "100%";
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No steps configured.";
      container.appendChild(empty);
      return container;
    }
    const progressElement = createProgressElement(task);
    if (progressElement) {
      container.appendChild(progressElement);
    }
    const visibleSubs = getVisibleSubTasks(task);
    const hiddenCount = task.firstThreeMode && !task.firstThreeUnlocked
      ? task.subTasks.length - visibleSubs.length
      : 0;
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row focus-overlay__task";
      if (sub.completed) row.classList.add("completed");

      const titleWrapper = document.createElement("label");
      titleWrapper.className = "task-title";

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { focusOnly: true, taskId: task.id, subId: sub.id });

      const nameSpan = document.createElement("span");
      nameSpan.className = "subtask-name";
      nameSpan.textContent = sub.name;

      titleWrapper.appendChild(chk);
      titleWrapper.appendChild(nameSpan);

      const actions = document.createElement("div");
      actions.className = "subtask-actions task-actions";

      const startBtn = document.createElement("button");
      startBtn.type = "button";
      startBtn.textContent = sub.startTime ? "🔁" : "▶️";
      startBtn.title = "Start or restart timer";
      startBtn.setAttribute("aria-label", sub.startTime ? "Restart timer" : "Start timer");
      startBtn.onclick = () => startSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(startBtn);

      const pauseBtn = document.createElement("button");
      pauseBtn.type = "button";
      const updatePauseButton = () => {
        const paused = Boolean(sub.isPaused);
        pauseBtn.textContent = paused ? "Resume" : "Pause";
        pauseBtn.title = paused ? "Resume step timer" : "Pause step timer";
        pauseBtn.setAttribute("aria-label", paused ? "Resume step timer" : "Pause step timer");
        pauseBtn.setAttribute("aria-pressed", paused ? "true" : "false");
        pauseBtn.disabled = !sub.startTime || sub.completed;
      };
      pauseBtn.onclick = () => {
        if (!sub.startTime || sub.completed) {
          return;
        }
        if (sub.isPaused) {
          resumeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        } else {
          pauseSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        }
      };
      updatePauseButton();
      actions.appendChild(pauseBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Rename step";
      editBtn.setAttribute("aria-label", "Rename step");
      editBtn.onclick = () => editSubTaskName(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Remove step";
      deleteBtn.setAttribute("aria-label", "Remove step");
      deleteBtn.onclick = () => removeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(deleteBtn);

      const timer = document.createElement("span");
      timer.className = "timer-label task-counter";
      trackTimer(sub, timer);

      row.appendChild(titleWrapper);
      row.appendChild(timer);
      row.appendChild(actions);
      row.dataset.paused = sub.isPaused ? "true" : "false";
      container.appendChild(row);
    });

    if (hiddenCount > 0) {
      const gate = document.createElement("div");
      gate.className = "celebration";
      gate.textContent = "Complete the first three micro-steps to reveal the rest of the chart flow.";
      container.appendChild(gate);
    }

    const controls = document.createElement("div");
    controls.className = "chart-step-controls";

    const addBtn = document.createElement("button");
    addBtn.textContent = "➕ Add Step";
    addBtn.onclick = () => addSubTaskToTask(taskIndex, { taskId: task.id });
    controls.appendChild(addBtn);

    const resetTimersBtn = document.createElement("button");
    resetTimersBtn.textContent = "⏱️ Reset Timers";
    resetTimersBtn.onclick = () => {
      task.subTasks.forEach(sub => {
        stopTimerForSubTask(sub.id);
        sub.startTime = null;
        sub.completionTime = null;
        sub.durationMinutes = null;
        sub.completed = false;
        sub.activeDurationMs = 0;
        sub.lastResumedAt = null;
        sub.isPaused = false;
      });
      refreshAfterSubTaskChange(taskIndex, { focusOnly: true, taskId: task.id });
    };
    controls.appendChild(resetTimersBtn);

    container.appendChild(controls);

    if (task.subTasks.every(sub => sub.completed)) {
      container.appendChild(renderChartSummary(task));
    }

    return container;
  }

  function renderSimpleSubTasks(task, taskIndex) {
    const container = document.createElement("div");
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      container.textContent = "No sub-tasks for this task.";
      return container;
    }
    const completedCount = task.subTasks.filter(sub => sub.completed).length;
    const progressSummary = document.createElement("div");
    progressSummary.className = "task-progress";
    progressSummary.textContent = `${completedCount}/${task.subTasks.length} steps done`;
    container.appendChild(progressSummary);
    const visibleSubs = getVisibleSubTasks(task);
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");
      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { taskId: task.id, subId: sub.id });
      const label = document.createElement("span");
      label.className = "subtask-name";
      label.textContent = sub.name;
      row.appendChild(chk);
      row.appendChild(label);
      container.appendChild(row);
    });
    if (task.firstThreeMode && !task.firstThreeUnlocked) {
      const hint = document.createElement("div");
      hint.className = "celebration";
      hint.textContent = "Unlock the remaining steps by completing your first three micro-actions.";
      container.appendChild(hint);
    }
    return container;
  }

  function renderFocusTask(task, taskIndex) {
    const subTaskView = $("subTaskView");
    if (!subTaskView) return;
    let resolvedIndex = taskIndex;
    if ((resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && task) {
      resolvedIndex = tasks.findIndex(t => t.id === task.id);
    }
    const referenceTask = (resolvedIndex !== undefined && resolvedIndex !== null && resolvedIndex >= 0)
      ? tasks[resolvedIndex]
      : task;
    currentFocusTaskIndex = resolvedIndex;
    subTaskView.innerHTML = "";
    clearRunningTimers();
    let createdDefaults = false;
    if (isChartTask(referenceTask)) {
      createdDefaults = ensureChartSubTasks(referenceTask);
    }
    if (createdDefaults) {
      updateChartDurationForTask(referenceTask);
      referenceTask.priority = computePriority(referenceTask);
      persist();
    }
    const content = isChartTask(referenceTask)
      ? renderChartTask(referenceTask, resolvedIndex)
      : renderSimpleSubTasks(referenceTask, resolvedIndex);
    subTaskView.appendChild(content);
  }

  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function addDays(date, amount) {
    const base = date instanceof Date && !Number.isNaN(date.getTime()) ? new Date(date) : new Date();
    const offset = Number.isFinite(Number(amount)) ? Number(amount) : 0;
    base.setDate(base.getDate() + offset);
    return base;
  }

  function calculateDaysSince(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = today.getTime() - parsed.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  }

  function calculateDaysUntil(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = parsed.getTime() - today.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  }

  function isDateInCurrentMonth(dateString) {
    if (!dateString) return false;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return false;
    const today = new Date();
    return parsed.getFullYear() === today.getFullYear()
      && parsed.getMonth() === today.getMonth();
  }

  function getUrgencyDescriptor(value) {
    const options = getScaleOptions("urgency", currentScaleDescriptorCategory);
    const option = options.find(opt => Number(opt.value) === Number(value));
    return option ? option.text : null;
  }

  function getSuggestedUrgency(days) {
    if (days === null || days === undefined || Number.isNaN(days)) return 3;
    if (days < 0) return 3;
    if (days >= 90 && days <= 95) return 5;
    if (days > 95) return 2;
    if (days >= 30 && days < 90) return 1;
    if (days >= 2 && days <= 4) return 4;
    if (days < 30) return 3;
    return 3;
  }

  function updateChartAgeDisplay(days) {
    const display = $("chartAgeDisplay");
    if (!display) return;
    if (days === null || days === undefined) {
      display.textContent = "";
      return;
    }
    if (days < 0) {
      display.textContent = `Service date is ${Math.abs(days)} day(s) in the future.`;
      return;
    }
    display.textContent = `Chart age: ${days} day(s) since visit.`;
  }

  function updateUrgencyHint(suggested) {
    const hint = $("urgencyHint");
    const urgencyField = $("urgency");
    if (!hint || !urgencyField) return;
    const current = Number(urgencyField.value || 3);
    const suggestedDescriptor = getUrgencyDescriptor(suggested);
    const currentDescriptor = getUrgencyDescriptor(current);
    if (!suggestedDescriptor) {
      hint.textContent = currentDescriptor ? `Urgency set to ${currentDescriptor}.` : "";
      return;
    }
    if (current !== suggested) {
      hint.textContent = `Suggested: ${suggestedDescriptor}. (Current: ${currentDescriptor || current})`;
    } else {
      hint.textContent = `Suggested: ${suggestedDescriptor}.`;
    }
  }

  function updateDerivedFields() {
    const dateField = $("dateOfService");
    if (!dateField) return;
    const value = dateField.value;
    const days = calculateDaysSince(value);
    derivedDaysSinceVisit = days;
    updateChartAgeDisplay(days);
    const suggested = getSuggestedUrgency(days);
    const urgencyField = $("urgency");
    if (urgencyField && (urgencyAuto || !urgencyField.value)) {
      urgencyField.value = String(suggested);
    }
    updateUrgencyHint(suggested);
  }

  function setDefaultFieldValues() {
    const nameField = $("name");
    if (nameField) nameField.value = "";
    const categoryField = $("taskCategory");
    if (categoryField) categoryField.value = "General";
    const authorField = $("authorType");
    if (authorField) authorField.value = "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = "Non-Complex";
    const visitField = $("visitType");
    if (visitField) visitField.value = "Follow-Up";
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = "General Clinic";
    NUMERIC_SCALE_FIELDS.forEach(id => {
      const field = $(id);
      if (field) field.value = "1";
    });
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = "3";
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = "1";
    const dueDateField = $("dueDate");
    if (dueDateField) dueDateField.value = "";
    const subField = $("initialSubTasks");
    if (subField) subField.value = "";
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.value = formatDateForInput(new Date());
    }
    derivedDaysSinceVisit = calculateDaysSince($("dateOfService")?.value || null);
    urgencyAuto = true;
    updateDerivedFields();
    handleCategoryChange($("taskCategory")?.value);
  }

  let tasks = [];
  let templates = [];
  let focusQueue = [];
  let editingTaskId = null;
  let focusTimerId = null;
  let focusTimerStart = null;
  let focusTimerLastPing = null;
  let focusDistractionLog = [];
  let distractionTriggersSinceReset = 0;
  let doorwayResetState = { active: false, pending: false, countdownId: null, endTime: null };
  let ganttPlanState = { entries: [], totalMinutes: 0 };
  let ganttOverlayStartTime = null;
  let ganttProgressIntervalId = null;
  let worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
  let focusSoundEnabled = true;
  let focusAudioContext = null;
  let morningLaunchState = null;
  let launchPadState = null;
  let sleepToolkitState = null;
  let morningCountdown = null;
  let reminderIntervalId = null;
  let pendingTaskDraft = null;
  let sunlightAlertTimeoutId = null;

  const meltdownShieldState = {
    stepIndex: 0
  };

  const MELTDOWN_STEPS = [
    {
      title: "Noise Reduction",
      description: "Close all other browser tabs to eliminate competing stimuli."
    },
    {
      title: "4–4–4 Breathing",
      description: "Take three cycles: inhale for four seconds, hold for four, exhale for four."
    },
    {
      title: "Verbal Grounding",
      description: "Say aloud: ‘I am safe. I can pick one thing.’"
    },
    {
      title: "Task Narrowing",
      descriptionBuilder: () => {
        const topTaskName = getTopTaskName();
        const fragment = document.createDocumentFragment();
        const intro = document.createElement("span");
        intro.textContent = "Remember there is just one next step. Top priority task:";
        const nameEl = document.createElement("span");
        nameEl.className = "meltdown-top-task";
        nameEl.textContent = topTaskName || "No active tasks available.";
        fragment.appendChild(intro);
        fragment.appendChild(document.createElement("br"));
        fragment.appendChild(nameEl);
        return fragment;
      }
    },
    {
      title: "5-Minute Action Timer",
      description: "Set a five-minute timer and commit to only the first subtask for this session."
    },
    {
      title: "Body Movement",
      description: "Stand up, shake out your arms, and loosen your shoulders."
    },
    {
      title: "Music Cue",
      description: "Play a favorite upbeat song to pair with your movement."
    },
    {
      title: "Re-entry",
      description: "Slide back into Focus Mode ready to attack the task with reduced anxiety."
    }
  ];

  function resolvePriorityValue(value) {
    const num = Number(value);
    return Number.isFinite(num) ? num : 0;
  }

  function getTopTaskName() {
    const sourceTasks = Array.isArray(tasks) ? tasks : [];
    const activeTasks = sourceTasks
      .filter(task => !isTaskCompleted(task))
      .sort((a, b) => resolvePriorityValue(b.priority) - resolvePriorityValue(a.priority));

    if (activeTasks.length > 0) {
      return activeTasks[0]?.name || null;
    }

    try {
      const saved = localStorage.getItem("tasks");
      if (!saved) return null;
      const parsed = JSON.parse(saved);
      if (!Array.isArray(parsed)) return null;
      const fallbackActive = parsed
        .filter(task => task && !isTaskCompleted(task))
        .map(task => ({
          ...task,
          priority: resolvePriorityValue(task?.priority)
        }))
        .sort((a, b) => b.priority - a.priority);
      return fallbackActive.length > 0 ? (fallbackActive[0].name || null) : null;
    } catch (error) {
      console.error("Unable to parse saved tasks for Meltdown Shield.", error);
      return null;
    }
  }

  function buildMeltdownDescription(step) {
    if (typeof step.descriptionBuilder === "function") {
      return step.descriptionBuilder();
    }
    const span = document.createElement("span");
    span.textContent = step.description;
    return span;
  }

  function resetMeltdownShieldProgress() {
    meltdownShieldState.stepIndex = 0;
    const list = $("meltdownShieldSteps");
    if (list) {
      list.innerHTML = "";
    }
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.textContent = "▶️ Next";
    }
    updateMeltdownPrompt();
  }

  function updateMeltdownPrompt() {
    const prompt = $("meltdownShieldPrompt");
    const nextBtn = $("meltdownShieldNext");
    if (!prompt || !nextBtn) return;

    prompt.innerHTML = "";

    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      const finalMessage = document.createElement("strong");
      finalMessage.textContent = "System stabilized. Ready for Focus Mode.";
      prompt.appendChild(finalMessage);
      nextBtn.disabled = true;
      nextBtn.textContent = "Complete";
      return;
    }

    const currentStep = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const heading = document.createElement("strong");
    heading.textContent = `Step ${meltdownShieldState.stepIndex + 1}: ${currentStep.title}`;
    const description = buildMeltdownDescription(currentStep);
    prompt.appendChild(heading);
    prompt.appendChild(description);
    nextBtn.disabled = false;
    nextBtn.textContent = "▶️ Next";
  }

  function activateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.remove("hidden");
    panel.setAttribute("aria-hidden", "false");
    resetMeltdownShieldProgress();
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.focus();
    }
  }

  function deactivateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.add("hidden");
    panel.setAttribute("aria-hidden", "true");
    resetMeltdownShieldProgress();
    const focusTarget =
      lastSosTrigger ||
      $("rescueLaunchButton") ||
      $("meltdownSosButton");
    if (focusTarget) {
      window.requestAnimationFrame(() => focusTarget.focus());
    }
  }

  function completeCurrentMeltdownStep() {
    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      updateMeltdownPrompt();
      return;
    }

    const list = $("meltdownShieldSteps");
    if (!list) return;

    const step = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const listItem = document.createElement("li");
    const stepLabel = document.createElement("strong");
    stepLabel.textContent = `${step.title}`;
    listItem.appendChild(stepLabel);
    listItem.appendChild(document.createElement("br"));
    listItem.appendChild(buildMeltdownDescription(step));
    list.appendChild(listItem);

    meltdownShieldState.stepIndex += 1;
    updateMeltdownPrompt();
  }

  function clearFormFields() {
    setDefaultFieldValues();
  }

  function toggleEditMode(isEditing) {
    const addBtn = $("addTaskBtn");
    const saveBtn = $("saveUpdateBtn");
    const cancelBtn = $("cancelEditBtn");
    if (!addBtn || !saveBtn || !cancelBtn) return;
    addBtn.classList.toggle("hidden", isEditing);
    saveBtn.classList.toggle("hidden", !isEditing);
    cancelBtn.classList.toggle("hidden", !isEditing);
  }

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function clampScale(value, fallback = 1) {
    const base = toNumber(value, fallback);
    return Math.min(5, Math.max(1, base));
  }

  function normalizePatientType(value) {
    const normalized = (value || "").toString().toLowerCase();
    return normalized === "complex" ? "Complex" : "Non-Complex";
  }

  function getPatientTypeWeight(patientType) {
    return normalizePatientType(patientType) === "Complex" ? 1.2 : 1;
  }

  function normalizeVisitType(value) {
    const normalized = (value || "").toString().toLowerCase();
    if (normalized === "establish" || normalized === "establish care") return "Establish Care";
    if (normalized === "well-child" || normalized === "well child visit") return "Well Child Visit";
    if (normalized === "acute" || normalized === "acute visit") return "Acute Visit";
    return "Follow-Up";
  }

  function getVisitTypeWeight(visitType) {
    const normalized = normalizeVisitType(visitType);
    if (normalized === "Establish Care") return 1.3;
    if (normalized === "Well Child Visit") return 1.1;
    if (normalized === "Acute Visit") return 0.9;
    return 1;
  }

  function normalizeClinicSite(value) {
    const normalized = (value || "").toString().toLowerCase().replace(/[’]/g, "'").trim();
    if (normalized.includes("cranio")) return "Craniofacial Clinic";
    if (normalized.includes("pj")) return "St PJ’s Shelter";
    if (normalized.includes("general")) return "General Clinic";
    return "General Clinic";
  }

  function isSameLocalDay(dateA, dateB) {
    if (!(dateA instanceof Date) || !(dateB instanceof Date)) return false;
    if (Number.isNaN(dateA.getTime()) || Number.isNaN(dateB.getTime())) return false;
    return dateA.getFullYear() === dateB.getFullYear()
      && dateA.getMonth() === dateB.getMonth()
      && dateA.getDate() === dateB.getDate();
  }

  function getSameDayBonus(clinicSite, createdAt) {
    const normalizedClinic = normalizeClinicSite(clinicSite);
    if (normalizedClinic !== "St PJ’s Shelter" && normalizedClinic !== "Craniofacial Clinic") {
      return 1;
    }
    if (!createdAt) return 1;
    const createdDate = new Date(createdAt);
    if (Number.isNaN(createdDate.getTime())) return 1;
    const now = new Date();
    return isSameLocalDay(createdDate, now) ? 2 : 1;
  }

  function computeRawPriorityScore(t) {
    const importance = clampScale(t.importance, 1);
    const urgency = clampScale(t.urgency, 3);
    const novelty = clampScale(t.novelty, 1);
    const interest = clampScale(t.interest, 1);
    const pressure = clampScale(t.externalPressure, 1);
    const timeToStart = clampScale(t.timeToStart, 1);
    const difficulty = clampScale(t.difficulty, 1);
    const dopamine = novelty + interest;
    const friction = (6 - timeToStart) + (6 - difficulty);
    const baseScore = (importance * 2)
         + (urgency * 2)
         + (dopamine * 2)
         + (pressure * 5)
         + (friction * 1.5);
    const patientWeight = getPatientTypeWeight(t.patientType);
    const visitWeight = getVisitTypeWeight(t.visitType);
    const sameDayBonus = getSameDayBonus(t.clinicSite, t.createdAt);
    return baseScore * patientWeight * visitWeight * sameDayBonus;
  }

  function computeTimeWeight(task) {
    if (!task) return 1;
    const isChart = isChartTask(task);
    const parsedDays = Number(task.daysSinceVisit);
    const daysSince = Number.isFinite(parsedDays)
      ? parsedDays
      : (task.dateOfService ? calculateDaysSince(task.dateOfService) : null);
    const daysUntilDue = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
    const currentMonth = isDateInCurrentMonth(task.dateOfService)
      || isDateInCurrentMonth(task.dueDate);

    if (!isChart) {
      if (daysUntilDue !== null && Number.isFinite(daysUntilDue) && daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.2;
      }
      return 1.0;
    }

    if (daysSince !== null && Number.isFinite(daysSince)) {
      if (daysSince > 95) return 0.5;
      if (daysSince >= 90 && daysSince <= 95) return 2.0;
      if (daysSince >= 0 && daysSince < 3) return 1.8;
      if (daysSince >= 3 && currentMonth) return 1.3;
    }

    if (daysUntilDue !== null && Number.isFinite(daysUntilDue)) {
      if (daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.8;
      }
      if (daysUntilDue < 0 && daysSince === null) {
        return currentMonth ? 1.3 : 1.0;
      }
      if (currentMonth) {
        return 1.3;
      }
    }

    return 1.0;
  }

  function computePriority(t) {
    const weightedBase = computeRawPriorityScore(t) * computeTimeWeight(t);
    if (Array.isArray(t.subTasks) && t.subTasks.length) {
      const remaining = t.subTasks.filter(s => !s.completed);
      if (remaining.length === 0) return 0;
      const total = remaining.reduce((sum, s) => {
        const value = Number(s.priority);
        return Number.isFinite(value) ? sum + value : sum + weightedBase;
      }, 0);
      return total / remaining.length;
    }
    return weightedBase;
  }

  function recalcTaskPriority(task) {
    if (!task) return task;
    task.authorType = task.authorType || "attending";
    task.patientType = normalizePatientType(task.patientType);
    task.visitType = normalizeVisitType(task.visitType);
    task.clinicSite = normalizeClinicSite(task.clinicSite);
    task.dateOfService = task.dateOfService || null;
    task.createdAt = task.createdAt || task.addedAt || new Date().toISOString();
    if (task.category === "Charts") task.category = "Chart";
    task.firstThreeMode = Boolean(task.firstThreeMode);
    if (!Array.isArray(task.firstThreeSteps)) {
      task.firstThreeSteps = [];
    }
    if (!task.firstThreeMode) {
      task.firstThreeUnlocked = true;
      task.firstThreeSteps = [];
    } else if (task.firstThreeUnlocked === undefined) {
      task.firstThreeUnlocked = false;
    }
    if (task.dateOfService) {
      task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    } else {
      const parsedDays = Number(task.daysSinceVisit);
      task.daysSinceVisit = (task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === "" || !Number.isFinite(parsedDays))
        ? null
        : parsedDays;
    }
    task.urgency = clampScale(task.urgency, 3);
    task.importance = clampScale(task.importance, 1);
    task.novelty = clampScale(task.novelty, 1);
    task.interest = clampScale(task.interest, 1);
    task.externalPressure = clampScale(task.externalPressure, 1);
    task.timeToStart = clampScale(task.timeToStart, 1);
    task.difficulty = clampScale(task.difficulty, 1);
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.completedAt = task.completedAt || null;
    if (task.completed && !task.completedAt) {
      task.completedAt = null;
    }
    if (task.completedAt && !task.completed) {
      task.completed = true;
    } else {
      task.completed = Boolean(task.completed);
    }
    if (isChartTask(task) && task.useChartTemplate === undefined) {
      const defaults = new Set(buildChartSteps(task.authorType).map(step => step.toLowerCase()));
      const hasCustomSteps = Array.isArray(task.subTasks)
        ? task.subTasks.some(sub => !defaults.has(String(sub?.name || "").toLowerCase()))
        : false;
      task.useChartTemplate = !hasCustomSteps;
    }
    const baseRaw = computeRawPriorityScore({ ...task, subTasks: [] });
    const timeWeight = computeTimeWeight(task);
    task.timeWeight = timeWeight;
    const base = baseRaw * timeWeight;
    if (isChartTask(task)) {
      ensureChartSubTasks(task, { basePriority: base });
    }
    if (task.subTasks.length) {
      task.subTasks = task.subTasks.map(sub => {
        const normalizedSub = normalizeSubTask(sub, base);
        normalizedSub.priority = base;
        return normalizedSub;
      });
      if (task.firstThreeMode) {
        if (!task.firstThreeSteps.length) {
          task.firstThreeSteps = task.subTasks.slice(0, 3).map(sub => sub.name);
        } else {
          task.firstThreeSteps = task.firstThreeSteps.slice(0, 3);
        }
        task.subTasks.forEach((sub, index) => {
          const isFirst = index < 3;
          sub.isFirstThree = isFirst;
          sub.deferredUntilUnlock = !task.firstThreeUnlocked && !isFirst;
        });
        maybeUnlockFirstThree(task, { silent: true });
      } else {
        task.subTasks.forEach(sub => {
          sub.isFirstThree = false;
          sub.deferredUntilUnlock = false;
        });
      }
    }
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    return task;
  }

  function persist() {
    try {
      localStorage.setItem("tasks", JSON.stringify(tasks));
    } catch (error) {
      console.warn("Unable to persist tasks", error);
    }
  }

  function buildTaskDraftFromForm() {
    const nameField = $("name");
    if (!nameField) return null;
    const name = nameField.value.trim();
    if (!name) return null;
    const category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const dateField = $("dateOfService");
    const dateOfService = dateField && dateField.value ? dateField.value : null;
    const daysSinceVisit = calculateDaysSince(dateOfService);
    const task = {
      id: Date.now().toString(),
      name,
      category,
      authorType,
      patientType,
      visitType,
      clinicSite,
      dateOfService,
      daysSinceVisit,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1),
      dueDate: $("dueDate").value || null,
      completed: false,
      completedAt: null,
      createdAt: new Date().toISOString(),
      addedAt: new Date().toISOString(),
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: []
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);
    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    }
    return { task, basePriority, subLines };
  }

  function finalizeNewTask(draft, options = {}) {
    if (!draft) return;
    const { task, basePriority, subLines } = draft;
    const firstThreeSteps = Array.isArray(options.firstThreeSteps) ? options.firstThreeSteps : null;
    const deferred = task.firstThreeMode && !task.firstThreeUnlocked;
    task.subTasks = Array.isArray(subLines)
      ? subLines.map(line => createSubTask(line, basePriority, {
          deferredUntilUnlock: deferred
        }))
      : [];
    if (firstThreeSteps && firstThreeSteps.length) {
      task.firstThreeMode = true;
      task.firstThreeUnlocked = false;
      applyFirstThreeSteps(task, firstThreeSteps, basePriority);
    } else {
      if (!task.firstThreeMode) {
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
      }
    }
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    persist();
    clearFormFields();
    toggleEditMode(false);
    editingTaskId = null;
    updateUI();
  }

  // create a new task with optional sub‑tasks from textarea
  function addTask() {
    const draft = buildTaskDraftFromForm();
    if (!draft) return;
    const triggerWizard = shouldTriggerFirstThreeWizard(
      draft.task.name,
      draft.subLines,
      draft.task.category
    );
    if (triggerWizard) {
      pendingTaskDraft = draft;
      openFirstThreeWizard();
      return;
    }
    finalizeNewTask(draft);
  }

  function generateFirstThreeSuggestions(taskName) {
    const anchor = (taskName || "").split(/[–—:-]/)[0].trim() || "this work";
    return [
      `Open materials for ${anchor}`,
      "List three micro-actions in your notebook",
      "Start a 5-minute draft or outline"
    ];
  }

  function setFirstThreeInputs(values) {
    const ids = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"];
    ids.forEach((id, index) => {
      const field = $(id);
      if (field) {
        field.value = values[index] || "";
      }
    });
  }

  function openFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    const suggestions = generateFirstThreeSuggestions(pendingTaskDraft?.task?.name);
    setFirstThreeInputs(suggestions);
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const firstInput = $("firstThreeStep1");
    if (firstInput) {
      firstInput.focus();
      firstInput.select();
    }
  }

  function closeFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }

  function submitFirstThreeWizard() {
    if (!pendingTaskDraft) {
      closeFirstThreeWizard();
      return;
    }
    const steps = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"]
      .map(id => $(id)?.value || "")
      .map(value => value.trim())
      .filter(Boolean);
    finalizeNewTask(pendingTaskDraft, { firstThreeSteps: steps });
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function skipFirstThreeWizard() {
    if (pendingTaskDraft) {
      pendingTaskDraft.task.firstThreeMode = false;
      pendingTaskDraft.task.firstThreeUnlocked = true;
      pendingTaskDraft.task.firstThreeSteps = [];
      finalizeNewTask(pendingTaskDraft);
      pendingTaskDraft = null;
    }
    closeFirstThreeWizard();
  }

  function cancelFirstThreeWizard() {
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function initializeFirstThreeWizard() {
    const saveBtn = $("firstThreeSave");
    if (saveBtn) {
      saveBtn.addEventListener("click", submitFirstThreeWizard);
    }
    const skipBtn = $("firstThreeSkip");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipFirstThreeWizard);
    }
    const cancelBtn = $("firstThreeCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelFirstThreeWizard);
    }
    const overlay = $("firstThreeWizard");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          cancelFirstThreeWizard();
        }
      });
    }
  }

  function startEditTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    editingTaskId = taskId;
    $("name").value = task.name;
    $("taskCategory").value = task.category || "General";
    handleCategoryChange(task.category || "General");
    $("importance").value = String(task.importance || 1);
    $("urgency").value = String(task.urgency || 3);
    $("novelty").value = String(task.novelty || 1);
    $("interest").value = String(task.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = task.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(task.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(task.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(task.clinicSite);
    const dateField = $("dateOfService");
    if (dateField) {
      if (task.dateOfService) {
        dateField.value = task.dateOfService;
      } else {
        dateField.value = formatDateForInput(new Date());
      }
    }
    urgencyAuto = false;
    derivedDaysSinceVisit = task.daysSinceVisit ?? calculateDaysSince($("dateOfService")?.value || null);
    updateDerivedFields();
    const pressureField = $("externalPressure");
    if (pressureField) {
      const pressureValue = task.externalPressure;
      pressureField.value = String(pressureValue || 1);
    }
    $("timeToStart").value = String(task.timeToStart || 1);
    $("difficulty").value = String(task.difficulty || 1);
    $("dueDate").value = task.dueDate || "";
    const subs = Array.isArray(task.subTasks) ? task.subTasks.map(sub => sub.name).join("\n") : "";
    $("initialSubTasks").value = subs;
    toggleEditMode(true);
    $("name").focus();
  }

  function saveTaskUpdate() {
    if (!editingTaskId) return;
    const idx = tasks.findIndex(t => t.id === editingTaskId);
    if (idx === -1) return;
    const name = $("name").value.trim();
    if (!name) return;

    const task = tasks[idx];
    task.name = name;
    task.category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    task.authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    task.patientType = normalizePatientType(patientField ? patientField.value : task.patientType);
    const visitField = $("visitType");
    task.visitType = normalizeVisitType(visitField ? visitField.value : task.visitType);
    const clinicField = $("clinicSite");
    task.clinicSite = normalizeClinicSite(clinicField ? clinicField.value : task.clinicSite);
    const dateField = $("dateOfService");
    task.dateOfService = dateField && dateField.value ? dateField.value : null;
    task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    task.importance = clampScale($("importance").value, 1);
    task.urgency = clampScale($("urgency").value, 3);
    task.novelty = clampScale($("novelty").value, 1);
    task.interest = clampScale($("interest").value, 1);
    task.externalPressure = clampScale($("externalPressure").value, 1);
    task.timeToStart = clampScale($("timeToStart").value, 1);
    task.difficulty = clampScale($("difficulty").value, 1);
    task.dueDate = $("dueDate").value || null;
    task.updatedAt = new Date().toISOString();

    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);

    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    } else if (task.useChartTemplate !== undefined) {
      delete task.useChartTemplate;
    }

    const basePriority = computePriority({ ...task, subTasks: [] });
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks.slice() : [];
    const newSubTasks = subLines.map(line => {
      const matchIndex = existingSubs.findIndex(sub => sub.name === line);
      if (matchIndex !== -1) {
        const existing = existingSubs.splice(matchIndex, 1)[0];
        const normalizedExisting = normalizeSubTask(existing, basePriority);
        normalizedExisting.name = line;
        normalizedExisting.priority = basePriority;
        return normalizedExisting;
      }
      return createSubTask(line, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    task.subTasks = newSubTasks;
    if (task.firstThreeMode) {
      const firstThreeSubset = task.subTasks.slice(0, 3);
      if (firstThreeSubset.length < 3) {
        task.firstThreeMode = false;
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
        task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
      } else {
        task.firstThreeSteps = firstThreeSubset.map(sub => sub.name);
        task.subTasks = task.subTasks.map((sub, index) => {
          const isFirst = index < 3;
          return {
            ...sub,
            isFirstThree: isFirst,
            deferredUntilUnlock: !task.firstThreeUnlocked && !isFirst
          };
        });
        maybeUnlockFirstThree(task, { silent: true });
      }
    } else {
      task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
    }
    if (isChartTask(task)) {
      const defaultsChanged = ensureChartSubTasks(task, { basePriority });
      if (defaultsChanged) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    if (task.firstThreeMode) {
      maybeUnlockFirstThree(task, { silent: true });
    }
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    persist();

    toggleEditMode(false);
    clearFormFields();
    editingTaskId = null;
    updateUI();
  }

  function cancelEdit() {
    editingTaskId = null;
    toggleEditMode(false);
    clearFormFields();
  }

  // render filter bar
  function renderCategoryFilter() {
    const select = $("taskCategoryFilter");
    if (!select) return;
    const options = ["All", ...categories];
    if (!options.includes(activeCategory)) {
      activeCategory = "All";
    }
    const previous = select.value;
    select.innerHTML = "";
    options.forEach(cat => {
      const option = document.createElement("option");
      option.value = cat;
      option.textContent = cat;
      select.appendChild(option);
    });
    const targetValue = options.includes(activeCategory) ? activeCategory : "All";
    select.value = options.includes(previous) ? previous : targetValue;
    if (select.value !== targetValue) {
      select.value = targetValue;
    }
  }

  // render chart-specific momentum progress
  function renderCategoryProgress() {
    const cont = $("categoryProgress");
    if (!cont) return;

    const labelEl = cont.querySelector('[data-chart-label]');
    const fillEl = cont.querySelector('[data-chart-fill]');
    const floatingEl = cont.querySelector('[data-chart-floating]');
    if (!labelEl || !fillEl) return;

    const chartTasks = tasks.filter(t => t.category === "Chart");
    const total = chartTasks.length;
    const done = chartTasks.filter(t => isTaskCompleted(t)).length;
    const percent = total === 0 ? 0 : (done / total) * 100;
    const clamped = Math.max(0, Math.min(100, percent));

    labelEl.textContent = `Chart: ${done}/${total} complete`;

    const previous = Number.parseFloat(cont.dataset.percent || "0");
    const progressIncreased = clamped > (Number.isFinite(previous) ? previous : 0);

    fillEl.style.width = `${clamped}%`;
    fillEl.classList.remove("is-warm", "is-complete");
    if (total > 0 && done === total) {
      fillEl.classList.add("is-complete");
    } else if (clamped > 50) {
      fillEl.classList.add("is-warm");
    }

    if (!fillEl.dataset.listened) {
      fillEl.addEventListener("animationend", event => {
        if (event.animationName === "chartGlowPulse") {
          fillEl.classList.remove("progress-glow");
        }
        if (event.animationName === "chartCompletePulse") {
          fillEl.classList.remove("complete-pulse");
        }
      });
      fillEl.dataset.listened = "true";
    }

    if (progressIncreased) {
      fillEl.classList.remove("progress-glow");
      void fillEl.offsetWidth;
      fillEl.classList.add("progress-glow");
      if (floatingEl) {
        floatingEl.textContent = `${Math.round(clamped)}% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1200);
      }
    } else if (floatingEl) {
      floatingEl.classList.remove("is-visible");
    }

    if (clamped >= 100 && (Number.isFinite(previous) ? previous : 0) < 100 && total > 0) {
      fillEl.classList.remove("complete-pulse");
      void fillEl.offsetWidth;
      fillEl.classList.add("complete-pulse");
      if (floatingEl) {
        floatingEl.textContent = `100% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1500);
      }
    }

    cont.dataset.percent = clamped;
  }

  function buildTaskDescriptors(task) {
    const descriptors = [];
    if (task.patientType) descriptors.push(`Patient: ${task.patientType}`);
    if (task.visitType) descriptors.push(`Visit: ${task.visitType}`);
    if (task.clinicSite) descriptors.push(task.clinicSite);
    if (task.urgency) descriptors.push(`Urgency ${task.urgency}`);
    return descriptors;
  }

  function getSubTaskProgress(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.length;
    const completed = task.subTasks.filter(sub => sub.completed).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function createProgressElement(task) {
    const progressData = getSubTaskProgress(task);
    if (!progressData) return null;
    const container = document.createElement("div");
    container.className = "task-progress-group";

    const label = document.createElement("div");
    label.className = "task-progress";
    const stepsLabel = `${progressData.total} ${progressData.total === 1 ? "step" : "steps"}`;
    let statusText;
    if (progressData.completed === 0) {
      statusText = "first step ready.";
    } else if (progressData.completed >= progressData.total) {
      statusText = "plan complete.";
    } else {
      statusText = `${progressData.completed} done.`;
    }
    label.textContent = `${stepsLabel} • ${statusText}`;
    container.appendChild(label);

    const meter = document.createElement("div");
    meter.className = "task-progress-meter";
    const fill = document.createElement("span");
    fill.className = "fill";
    const fillPercent = progressData.percent <= 0 ? 1 : Math.max(progressData.percent, 1);
    fill.style.width = `${fillPercent}%`;
    meter.appendChild(fill);
    container.appendChild(meter);

    return container;
  }

  function createMetaItem(text) {
    const span = document.createElement("span");
    span.textContent = text;
    return span;
  }

  function createTaskDetails(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const details = document.createElement("div");
    details.className = "task-details hidden";
    const heading = document.createElement("h5");
    heading.textContent = "Subtasks";
    details.appendChild(heading);
    const list = document.createElement("ul");
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      const marker = sub.completed ? "✓" : "•";
      item.textContent = `${marker} ${sub.name}`;
      list.appendChild(item);
    });
    details.appendChild(list);
    return details;
  }

  function renderTaskListCard(task, mode, timeBudgetMinutes = null) {
    const card = document.createElement("article");
    card.className = "task-card";
    if (task?.id) {
      card.dataset.taskId = String(task.id);
    }
    if (mode === TASK_LIST_MODES.COMPLETED) {
      card.classList.add("is-completed");
    }
    if (mode === TASK_LIST_MODES.ACTIVE && task?.id) {
      attachTaskGestureHandlers(card, task.id, mode);
    }

    const header = document.createElement("div");
    header.className = "task-card-header";

    const titleGroup = document.createElement("div");
    titleGroup.className = "task-card-title-group";

    const title = document.createElement("h4");
    title.className = "task-title";
    title.textContent = task.name;
    titleGroup.appendChild(title);

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const indicator = document.createElement("span");
      indicator.className = "task-complete-indicator";
      indicator.textContent = "✓ Completed";
      titleGroup.appendChild(indicator);
    }

    header.appendChild(titleGroup);

    const actions = document.createElement("div");
    actions.className = "task-card-actions";

    if (mode === TASK_LIST_MODES.ACTIVE) {
      const startNowBtn = document.createElement("button");
      startNowBtn.type = "button";
      startNowBtn.textContent = "🚀";
      startNowBtn.title = "Focus on this task";
      startNowBtn.setAttribute("aria-label", "Start task");
      startNowBtn.onclick = () => startFocus(task.id);
      actions.appendChild(startNowBtn);

      const completeBtn = document.createElement("button");
      completeBtn.type = "button";
      completeBtn.textContent = "✅";
      completeBtn.title = "Complete task";
      completeBtn.setAttribute("aria-label", "Complete task");
      completeBtn.onclick = () => markTaskDoneFromPeek(task.id);
      actions.appendChild(completeBtn);

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "✏️";
      editBtn.title = "Edit task";
      editBtn.onclick = () => startEditTask(task.id);
      actions.appendChild(editBtn);
    }

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.textContent = "🗑️";
    deleteBtn.title = "Delete task";
    deleteBtn.onclick = () => {
      if (!confirm("Delete this task?")) return;
      const idx = tasks.findIndex(t => t.id === task.id);
      if (idx !== -1) {
        if (editingTaskId === task.id) {
          cancelEdit();
        }
        tasks.splice(idx, 1);
        persist();
        updateUI();
      }
    };
    actions.appendChild(deleteBtn);

    card.appendChild(header);
    card.appendChild(actions);

    const descriptors = buildTaskDescriptors(task);
    if (descriptors.length) {
      const descriptorContainer = document.createElement("div");
      descriptorContainer.className = "task-descriptors";
      descriptors.forEach(text => {
        const span = document.createElement("span");
        span.textContent = text;
        descriptorContainer.appendChild(span);
      });
      card.appendChild(descriptorContainer);
    }

    if (task.firstThreeMode && !task.firstThreeUnlocked && mode === TASK_LIST_MODES.ACTIVE) {
      const nudge = document.createElement("div");
      nudge.className = "score";
      nudge.textContent = "Start with the first three micro-steps to unlock the rest.";
      card.appendChild(nudge);
    }

    const progress = createProgressElement(task);
    if (progress) {
      card.appendChild(progress);
    }

    const meta = document.createElement("div");
    meta.className = "task-meta";
    const metaItems = [];

    if (mode === TASK_LIST_MODES.ACTIVE) {
      metaItems.push(`Score ${task.priority.toFixed(1)}`);
      if (Number.isFinite(timeBudgetMinutes) && timeBudgetMinutes > 0) {
        const estimatedMinutes = estimateTaskMinutes(task);
        metaItems.push(`Est ${estimatedMinutes} min`);
      }
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
      if (task.addedAt) {
        const formatted = formatDateTime(task.addedAt);
        if (formatted) metaItems.push(`Added ${formatted}`);
      }
      const age = task.dateOfService ? calculateDaysSince(task.dateOfService) : (
        task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === ""
          ? null
          : Number(task.daysSinceVisit)
      );
      if (age !== null && Number.isFinite(age)) {
        const ageLabel = age < 0 ? `${Math.abs(age)} day(s) until visit` : `${age} day(s) since visit`;
        metaItems.push(ageLabel);
      }
      if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
        metaItems.push(`Chart time ${formatDuration(Number(task.chartDurationMinutes))}`);
      }
    } else {
      const completedAt = formatDateTime(getCompletionTimestamp(task));
      metaItems.push(`Completed ${completedAt || "--"}`);
      const totalDuration = getTaskTotalDuration(task);
      metaItems.push(`Duration ${formatDuration(totalDuration)}`);
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
    }

    metaItems.forEach(text => meta.appendChild(createMetaItem(text)));
    if (metaItems.length) {
      card.appendChild(meta);
    }

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const details = createTaskDetails(task);
      if (details) {
        const toggle = document.createElement("button");
        toggle.className = "task-detail-toggle";
        toggle.textContent = "View details";
        toggle.onclick = () => {
          const isHidden = details.classList.contains("hidden");
          if (isHidden) {
            details.classList.remove("hidden");
            toggle.textContent = "Hide details";
          } else {
            details.classList.add("hidden");
            toggle.textContent = "View details";
          }
        };
        card.appendChild(toggle);
        card.appendChild(details);
      }
    }

    return card;
  }

  function computeFocusScore(task, energyLevel, timeBudget) {
    if (!task) return 0;
    const base = Number(task?.priority || 0);
    if (!Number.isFinite(base) || base <= 0) {
      return base || 0;
    }
    const energyWeight = computeEnergyFit(task, energyLevel);
    const timeWeight = computeTimeFit(task, timeBudget);
    return base * energyWeight * timeWeight;
  }

  function buildNextTaskInsights(task, energyLevel, timeBudget) {
    const insights = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(estimated) && estimated > 0) {
      insights.push(`Est. ${Math.max(1, Math.round(estimated))} min`);
    }
    if (Number.isFinite(timeBudget)) {
      const timeScore = timeFit(task, timeBudget);
      if (!Number.isFinite(estimated) || estimated <= 0) {
        insights.push(`${timeBudget}-min window`);
      } else if (timeScore > 1) {
        insights.push(`Fits ${timeBudget}-min`);
      } else if (estimated > timeBudget) {
        insights.push(`Stretch past ${timeBudget} min`);
      }
    }
    const energyScore = energyFit(task, energyLevel);
    if (energyScore < 1) {
      insights.push('Easy win');
    } else if (Number.isFinite(energyLevel) && ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
      insights.push(`Energy: ${ENERGY_LABELS[energyLevel]}`);
    }
    if (isChartTask(task) && Number.isFinite(Number(task.daysSinceVisit)) && Number(task.daysSinceVisit) > 0) {
      insights.push(`${task.daysSinceVisit}d since visit`);
    }
    if (task.category) {
      insights.push(task.category);
    }
    return insights.filter(Boolean).slice(0, 3);
  }

  function updateNextTaskCard() {
    const card = $("nextTaskCard");
    if (!card) return;
    const nameEl = $("nextTaskName");
    const substepEl = $("nextTaskSubstep");
    const chipsEl = $("nextTaskChips");
    const scoreEl = $("nextTaskScore");
    const emptyEl = $("nextTaskEmpty");
    const startActionBtn = $("nextTaskActionButton");

    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();

    const candidates = tasks
      .filter(task => !isTaskCompleted(task) && (activeCategory === "All" || task.category === activeCategory))
      .sort((a, b) => computeFocusScore(b, energyLevel, timeBudget) - computeFocusScore(a, energyLevel, timeBudget));

    const topTask = candidates[0] || null;
    nextTaskId = topTask ? topTask.id : null;

    card.classList.remove("hidden");
    if (!topTask) {
      if (nameEl) nameEl.textContent = "";
      if (substepEl) substepEl.textContent = "";
      if (chipsEl) chipsEl.innerHTML = "";
      if (scoreEl) {
        scoreEl.textContent = "";
        scoreEl.classList.add("hidden");
      }
      if (emptyEl) emptyEl.classList.remove("hidden");
      if (startActionBtn) startActionBtn.disabled = true;
      return;
    }

    if (emptyEl) emptyEl.classList.add("hidden");
    if (nameEl) nameEl.textContent = topTask.name;
    const firstSub = Array.isArray(topTask.subTasks)
      ? topTask.subTasks.find(sub => !sub.completed)
      : null;
    if (substepEl) {
      substepEl.textContent = firstSub
        ? `Next substep: ${firstSub.name}`
        : "Set your first micro-step.";
    }
    if (chipsEl) {
      chipsEl.innerHTML = "";
      buildNextTaskInsights(topTask, energyLevel, timeBudget).forEach(text => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = text;
        chipsEl.appendChild(chip);
      });
    }
    if (scoreEl) {
      scoreEl.innerHTML = "";
      const scoreText = document.createElement("span");
      const rawScore = Number(topTask.priority);
      const displayScore = Number.isFinite(rawScore) ? Math.round(rawScore) : 0;
      scoreText.textContent = `Fit ${displayScore}`;
      const info = document.createElement("span");
      info.className = "next-task-fit__info";
      info.textContent = "i";
      info.title = "Just a nudge, not a grade.";
      info.setAttribute("aria-label", "Just a nudge, not a grade.");
      scoreEl.appendChild(scoreText);
      scoreEl.appendChild(info);
      const srOnly = document.createElement("span");
      srOnly.className = "visually-hidden";
      srOnly.textContent = "Fit guidance. Just a nudge, not a grade.";
      scoreEl.appendChild(srOnly);
      scoreEl.classList.remove("hidden");
    }
    if (startActionBtn) startActionBtn.disabled = false;
  }

  const DEFAULT_NEXT_BEST_INPUTS = {
    time: 15,
    energy: 3,
    deadline: 3,
    size: "any",
    frictions: []
  };
  const DEFAULT_PREFLIGHT_TOGGLES = {
    focusMusic: false,
    dnd: false,
    timer: false
  };

  function loadPreflightToggles() {
    try {
      const stored = JSON.parse(localStorage.getItem(PREFLIGHT_TOGGLES_KEY) || "null");
      if (stored && typeof stored === "object") {
        return { ...DEFAULT_PREFLIGHT_TOGGLES, ...stored };
      }
    } catch (error) {
      console.warn("Unable to load pre-flight toggles", error);
    }
    return { ...DEFAULT_PREFLIGHT_TOGGLES };
  }

  function savePreflightToggles(state) {
    try {
      localStorage.setItem(PREFLIGHT_TOGGLES_KEY, JSON.stringify(state));
    } catch (error) {
      console.warn("Unable to save pre-flight toggles", error);
    }
  }

  function initializePreflightToggles() {
    const buttons = document.querySelectorAll('[data-preflight-toggle]');
    if (!buttons.length) return;
    const state = loadPreflightToggles();
    buttons.forEach(button => {
      const key = button.getAttribute("data-preflight-toggle");
      if (!key) return;
      const active = Boolean(state[key]);
      button.classList.toggle("is-active", active);
      button.setAttribute("aria-pressed", active ? "true" : "false");
      button.addEventListener("click", () => {
        const next = !button.classList.contains("is-active");
        state[key] = next;
        button.classList.toggle("is-active", next);
        button.setAttribute("aria-pressed", next ? "true" : "false");
        savePreflightToggles(state);
      });
    });
  }

  function clampMmpMinutes(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) return MMP_MIN_MINUTES;
    return Math.max(MMP_MIN_MINUTES, Math.min(MMP_MAX_MINUTES, Math.round(numeric)));
  }

  function loadNextBestInputs() {
    try {
      const stored = JSON.parse(localStorage.getItem(NEXT_BEST_STORAGE_KEY) || "null");
      if (stored && typeof stored === "object") {
        const frictions = Array.isArray(stored.frictions)
          ? Array.from(new Set(stored.frictions.map(String)))
          : [];
        return {
          ...DEFAULT_NEXT_BEST_INPUTS,
          ...stored,
          time: Number(stored.time) || DEFAULT_NEXT_BEST_INPUTS.time,
          energy: clampScale(stored.energy, DEFAULT_NEXT_BEST_INPUTS.energy),
          deadline: clampScale(stored.deadline, DEFAULT_NEXT_BEST_INPUTS.deadline),
          size: stored.size || DEFAULT_NEXT_BEST_INPUTS.size,
          frictions
        };
      }
    } catch (error) {
      console.warn("Unable to load Next Best inputs", error);
    }
    return { ...DEFAULT_NEXT_BEST_INPUTS };
  }

  function saveNextBestInputs(inputs) {
    try {
      localStorage.setItem(NEXT_BEST_STORAGE_KEY, JSON.stringify(inputs));
    } catch (error) {
      console.warn("Unable to save Next Best inputs", error);
    }
  }

  function applyNextBestInputs(inputs) {
    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.value = String(inputs.time);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.value = String(inputs.energy);
      energySlider.setAttribute("data-value", String(inputs.energy));
    }
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect) {
      deadlineSelect.value = String(inputs.deadline);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.value = inputs.size || "any";
    }
    const checkboxes = document.querySelectorAll('input[name="nextBestFriction"]');
    checkboxes.forEach(box => {
      box.checked = inputs.frictions.includes(box.value);
    });
    alignEnergySliders(inputs.energy, "next");
  }

  function getSelectedFrictionTags() {
    return Array.from(document.querySelectorAll('input[name="nextBestFriction"]:checked'))
      .map(input => input.value)
      .filter(Boolean);
  }

  function getNextBestInputs() {
    const defaults = loadNextBestInputs();
    const timeSelect = $("nextBestTime");
    const energySlider = $("nextBestEnergy");
    const deadlineSelect = $("nextBestDeadline");
    const sizeSelect = $("nextBestSize");
    const timeValue = Number(timeSelect?.value || defaults.time);
    const energyValue = Number(energySlider?.value || defaults.energy);
    const deadlineValue = Number(deadlineSelect?.value || defaults.deadline);
    const frictions = getSelectedFrictionTags();
    const resolvedEnergy = alignEnergySliders(energyValue, "next");
    return {
      time: Number.isFinite(timeValue) && timeValue > 0 ? timeValue : defaults.time,
      energy: resolvedEnergy,
      deadline: clampScale(deadlineValue, defaults.deadline),
      size: sizeSelect?.value || defaults.size,
      frictions
    };
  }

  function estimateSubTaskMinutes(task, sub) {
    if (!sub) return null;
    const recorded = Number(sub.durationMinutes);
    if (Number.isFinite(recorded) && recorded > 0) {
      return clampMmpMinutes(recorded);
    }
    const total = estimateTaskMinutes(task);
    const remainingCount = Array.isArray(task.subTasks) && task.subTasks.length
      ? task.subTasks.filter(step => !step.completed).length || 1
      : 1;
    const approx = Number.isFinite(total)
      ? Math.max(6, total / Math.max(1, remainingCount))
      : 15;
    return clampMmpMinutes(approx);
  }

  function deriveMmpChunk(task) {
    if (!task) return null;
    const remainingSubs = Array.isArray(task.subTasks)
      ? task.subTasks.filter(sub => !sub.completed)
      : [];
    if (remainingSubs.length) {
      const prioritized = remainingSubs.map(sub => ({ sub, minutes: estimateSubTaskMinutes(task, sub) }));
      const candidate = prioritized.find(entry => entry.minutes <= MMP_MAX_MINUTES) || prioritized[0];
      if (candidate) {
        return {
          label: candidate.sub.name,
          minutes: clampMmpMinutes(candidate.minutes),
          subId: candidate.sub.id || null
        };
      }
    }
    const fallback = estimateTaskMinutes(task);
    const sprint = Number.isFinite(fallback) ? Math.max(fallback * 0.5, MMP_MIN_MINUTES) : MMP_MIN_MINUTES;
    const minutes = clampMmpMinutes(sprint);
    return {
      label: `First ${minutes} minutes on ${task.name}`,
      minutes,
      subId: null
    };
  }

  function isEasyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    return difficulty <= 3 && evaluation.chunk.minutes <= 15;
  }

  function isBuddyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    const category = evaluation.task?.category || "";
    return difficulty >= 4 || evaluation.chunk.minutes >= 18 || ["Calls", "Teaching"].includes(category);
  }

  function evaluateTaskForNextBest(task, inputs) {
    if (!task || isTaskCompleted(task)) return null;
    const chunk = deriveMmpChunk(task);
    if (!chunk) return null;
    const timeBudget = Number.isFinite(inputs.time) ? inputs.time : Infinity;
    const energyLevel = clampScale(inputs.energy, 3);
    let score = computeFocusScore(task, energyLevel, timeBudget);
    if (!Number.isFinite(score)) score = 0;
    (inputs.frictions || []).forEach(tag => {
      const rule = NEXT_BEST_FRICTION_RULES[tag];
      if (typeof rule === "function") {
        score *= rule(task) ? 1.08 : 0.78;
      }
    });
    const deadlineLevel = clampScale(inputs.deadline, 3);
    if (deadlineLevel !== 3) {
      const daysUntil = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
      const overdue = Number.isFinite(daysUntil) && daysUntil < 0;
      const dueSoon = Number.isFinite(daysUntil) && daysUntil >= 0 && daysUntil <= 2;
      const daysSince = Number(task.daysSinceVisit);
      if (deadlineLevel > 3) {
        const boost = 1 + (deadlineLevel - 3) * 0.12;
        if (overdue || dueSoon || (Number.isFinite(daysSince) && daysSince >= 5)) {
          score *= boost;
        } else {
          score *= 1 + (deadlineLevel - 3) * 0.05;
        }
      } else {
        score *= Math.max(0.6, 1 - (3 - deadlineLevel) * 0.06);
      }
    }
    const estimate = estimateTaskMinutes(task);
    const effectiveEstimate = Number.isFinite(estimate) && estimate > 0 ? estimate : chunk.minutes;
    if (inputs.size === "small") {
      score *= effectiveEstimate <= 20 ? 1.1 : 0.82;
    } else if (inputs.size === "medium") {
      score *= effectiveEstimate >= 15 && effectiveEstimate <= 40 ? 1.08 : 0.88;
    } else if (inputs.size === "large") {
      score *= effectiveEstimate >= 30 ? 1.12 : 0.85;
    }
    const impact = Number(task.priority || 0);
    const impactPerMinute = chunk.minutes > 0 ? impact / chunk.minutes : impact;
    const insights = buildNextTaskInsights(task, energyLevel, timeBudget);
    return {
      task,
      score,
      chunk,
      impactPerMinute,
      estimate: effectiveEstimate,
      insights
    };
  }

  function launchNextBestOption(label, evaluation) {
    if (!evaluation || !evaluation.task) return;
    const minutes = Number.isFinite(evaluation.chunk?.minutes)
      ? evaluation.chunk.minutes
      : MMP_MIN_MINUTES;
    showToast("Next Best Thing", `${label}: ${evaluation.chunk?.label || evaluation.task.name}`);
    startFocus(evaluation.task.id, { sprintMinutes: minutes });
  }

  function setActivationSuggestion(evaluation) {
    const suggestionBtn = $("focusSuggestionButton");
    const detailEl = $("focusSuggestionDetail");
    const previewEl = $("focusSuggestionText");
    const heroHint = $("focusLaunchHint");
    if (!suggestionBtn || !detailEl || !previewEl || !heroHint) return;
    const hasActiveTasks = tasks.some(task => !isTaskCompleted(task));
    if (evaluation && evaluation.task) {
      const message = evaluation.chunk?.label || evaluation.task.name;
      detailEl.textContent = message;
      previewEl.textContent = message;
      heroHint.textContent = message;
      suggestionBtn.disabled = false;
      suggestionBtn.setAttribute("aria-disabled", "false");
      suggestionBtn.dataset.pickKey = "now";
      suggestionBtn.dataset.taskId = evaluation.task.id || "";
    } else {
      const fallback = hasActiveTasks
        ? "Refresh Next Best to see a top pick."
        : "Add a task to unlock focus.";
      detailEl.textContent = fallback;
      previewEl.textContent = fallback;
      heroHint.textContent = fallback;
      suggestionBtn.disabled = true;
      suggestionBtn.setAttribute("aria-disabled", "true");
      delete suggestionBtn.dataset.pickKey;
      delete suggestionBtn.dataset.taskId;
    }
  }

  function createNextBestCard(config) {
    const { label, payoff, cta, evaluation, inputs } = config;
    if (!evaluation) return null;

    const energyValue = Number(inputs?.energy) || DEFAULT_NEXT_BEST_INPUTS.energy;
    const energyLabelRaw = ENERGY_LABELS && ENERGY_LABELS[energyValue] ? ENERGY_LABELS[energyValue] : "Current";
    const energyLabel = typeof energyLabelRaw === "string" ? energyLabelRaw : String(energyLabelRaw);
    const energyMode = energyValue <= 2 ? "low" : energyValue >= 4 ? "high" : "steady";
    const minutesWindow = Number.isFinite(inputs?.time) ? `${inputs.time}m` : `${Math.max(5, evaluation.chunk?.minutes || DEFAULT_NEXT_BEST_INPUTS.time)}m`;

    const card = document.createElement("article");
    card.className = "next-best-option";
    card.dataset.energyMode = energyMode;

    const ring = document.createElement("div");
    ring.className = "next-best-ring";
    const ringLabel = document.createElement("span");
    ringLabel.textContent = "Primed";
    ring.appendChild(ringLabel);
    card.appendChild(ring);

    const labelEl = document.createElement("span");
    labelEl.className = "next-best-option__label";
    labelEl.textContent = label;
    card.appendChild(labelEl);

    const heading = document.createElement("h3");
    heading.className = "next-best-option__title";
    heading.textContent = evaluation.task.name;
    card.appendChild(heading);

    if (payoff) {
      const payoffLine = document.createElement("p");
      payoffLine.className = "next-best-option__payoff";
      payoffLine.textContent = `${payoff} for ${minutesWindow} + ${energyLabel.toLowerCase()} energy`;
      card.appendChild(payoffLine);
    }

    const chips = document.createElement("div");
    chips.className = "next-best-option__chips";

    const addChip = text => {
      if (!text) return;
      const chip = document.createElement("span");
      chip.className = "chip spec-chip";
      chip.textContent = text;
      chips.appendChild(chip);
    };

    const estimatedMinutes = Math.max(1, Math.round(evaluation.estimate || evaluation.chunk?.minutes || inputs?.time || DEFAULT_NEXT_BEST_INPUTS.time));
    addChip(`Est. time • ${estimatedMinutes}m`);
    if (evaluation.chunk?.label) {
      addChip(`Stretch • ${evaluation.chunk.label}`);
    }
    addChip(`Energy • ${energyLabel}`);

    if (chips.childElementCount) {
      card.appendChild(chips);
    }

    const meter = document.createElement("div");
    meter.className = "next-best-meter";
    const meterLabel = document.createElement("div");
    meterLabel.className = "next-best-meter__label";
    meterLabel.textContent = "Impact/min";
    meter.appendChild(meterLabel);

    const track = document.createElement("div");
    track.className = "next-best-meter__track";
    const bar = document.createElement("div");
    bar.className = "next-best-meter__bar";
    const normalizedImpact = Number.isFinite(evaluation.impactPerMinute)
      ? Math.max(4, Math.min(100, (evaluation.impactPerMinute / 10) * 100))
      : 4;
    bar.style.width = `${normalizedImpact}%`;
    track.appendChild(bar);
    meter.appendChild(track);

    const scale = document.createElement("div");
    scale.className = "next-best-meter__scale";
    const startTick = document.createElement("span");
    startTick.textContent = "0";
    const endTick = document.createElement("span");
    endTick.textContent = "≥10";
    scale.appendChild(startTick);
    scale.appendChild(endTick);
    meter.appendChild(scale);
    card.appendChild(meter);

    const button = document.createElement("button");
    button.type = "button";
    button.className = `btn next-best-cta next-best-cta--${energyMode}`;
    button.textContent = cta || "Start";
    button.addEventListener("click", () => launchNextBestOption(label, evaluation));
    card.appendChild(button);

    return card;
  }

  function handleNextBestRefresh(event) {
    if (event) event.preventDefault();
    const button = event?.currentTarget || $("nextBestRefresh");
    if (button) {
      button.classList.add("is-loading");
      button.disabled = true;
    }
    try {
      updateNextBestOptions({ force: true });
    } finally {
      if (button) {
        window.setTimeout(() => {
          button.classList.remove("is-loading");
          button.disabled = false;
        }, 320);
      }
    }
  }

  function updateNextBestOptions(options = {}) {
    const forceUpdate = Boolean(options.force);
    const results = $("nextBestResults");
    const empty = $("nextBestEmpty");
    if (!results || !empty) return;

    if (!forceUpdate && !isElementMostlyInView(results, 0.25)) {
      nextBestUpdatePending = true;
      return;
    }

    nextBestUpdatePending = false;
    setActivationSuggestion(null);
    const inputs = getNextBestInputs();
    saveNextBestInputs(inputs);

    results.innerHTML = "";
    empty.classList.add("hidden");
    latestNextBestPicks = {};

    const candidates = tasks.filter(task => !isTaskCompleted(task));
    if (!candidates.length) {
      empty.textContent = "Add a task to see your next best options.";
      empty.classList.remove("hidden");
      return;
    }

    const evaluations = candidates
      .map(task => evaluateTaskForNextBest(task, inputs))
      .filter(Boolean)
      .sort((a, b) => b.score - a.score);

    if (!evaluations.length) {
      empty.textContent = "No tasks match this window. Adjust your filters.";
      empty.classList.remove("hidden");
      return;
    }

    const used = new Set();
    const picks = {};
    const assignCandidate = (key, predicate = null) => {
      const match = evaluations.find(entry => !used.has(entry.task.id) && (!predicate || predicate(entry)));
      if (match) {
        used.add(match.task.id);
        picks[key] = match;
      }
    };

    assignCandidate("now");
    assignCandidate("easy", isEasyNextBest);
    assignCandidate("buddy", isBuddyNextBest);

    ["easy", "buddy"].forEach(key => {
      if (!picks[key]) {
        const fallback = evaluations.find(entry => !used.has(entry.task.id));
        if (fallback) {
          used.add(fallback.task.id);
          picks[key] = fallback;
        }
      }
    });

    const configs = [
      { key: "now", label: "Do now", payoff: "Highest ROI", cta: "Start" },
      { key: "easy", label: "Do if easy", payoff: "Low friction win", cta: "Start easy" },
      { key: "buddy", label: "Do with buddy", payoff: "Accountability boost", cta: "Start with buddy" }
    ];

    setActivationSuggestion(picks.now || null);

    configs.forEach(config => {
      const evaluation = picks[config.key];
      if (evaluation) {
        const card = createNextBestCard({ ...config, evaluation, inputs });
        if (card) results.appendChild(card);
      }
    });
    latestNextBestPicks = { ...picks };
  }

  function initializeNextBestEngine() {
    const results = $("nextBestResults");
    if (!results) return;
    const storedRaw = localStorage.getItem(NEXT_BEST_STORAGE_KEY);
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect && deadlineSelect.options.length === 0) {
      for (let i = 1; i <= 5; i += 1) {
        const option = document.createElement("option");
        option.value = String(i);
        option.textContent = String(i);
        deadlineSelect.appendChild(option);
      }
    }
    const stored = loadNextBestInputs();
    applyNextBestInputs(stored);

    const controlsPanel = $("nextBestControls");
    const adjustToggle = $("nextBestAdjustToggle");
    const stuckBtn = $("nextBestStuck");
    const setControlsOpen = open => {
      if (!controlsPanel || !adjustToggle) return;
      controlsPanel.hidden = !open;
      controlsPanel.setAttribute("aria-hidden", open ? "false" : "true");
      adjustToggle.setAttribute("aria-expanded", open ? "true" : "false");
      adjustToggle.classList.toggle("is-active", open);
    };
    if (controlsPanel) {
      setControlsOpen(!storedRaw);
    }
    if (adjustToggle) {
      adjustToggle.addEventListener("click", () => {
        const nextOpen = controlsPanel ? controlsPanel.hidden : false;
        setControlsOpen(nextOpen);
      });
    }
    if (stuckBtn) {
      stuckBtn.addEventListener("click", () => {
        setControlsOpen(true);
        const firstFriction = controlsPanel?.querySelector('input[name="nextBestFriction"]');
        if (firstFriction) {
          firstFriction.focus();
        }
      });
    }

    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.addEventListener("change", updateNextBestOptions);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || stored.energy);
        alignEnergySliders(value, "next");
        updateNextBestOptions();
      });
    }
    if (deadlineSelect) {
      deadlineSelect.addEventListener("change", updateNextBestOptions);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.addEventListener("change", updateNextBestOptions);
    }
    const frictionBoxes = document.querySelectorAll('input[name="nextBestFriction"]');
    frictionBoxes.forEach(box => {
      box.addEventListener("change", updateNextBestOptions);
    });
    const refreshBtn = $("nextBestRefresh");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", handleNextBestRefresh);
    }
    updateNextBestOptions();
  }

  function prepareAccordionContainers() {
    const counters = {};
    document.querySelectorAll('[data-accordion]').forEach(container => {
      const name = container.dataset.accordion || "accordion";
      const index = counters[name] || 0;
      counters[name] = index + 1;
      const summary = container.querySelector('[data-accordion-summary]');
      const panel = container.querySelector('[data-accordion-panel]');
      if (!summary || !panel) return;
      const suffix = index === 0 ? "" : `-${index}`;
      const panelId = `${name}Panel${suffix}`;
      panel.id = panelId;
      summary.setAttribute("aria-controls", panelId);
    });
  }

  function getDueTodaySections() {
    return Array.from(document.querySelectorAll('[data-due-today-section]'))
      .map(section => {
        const accordion = section.querySelector('[data-accordion="dueToday"]');
        const summaryBtn = accordion?.querySelector('[data-accordion-summary]');
        const summaryText = accordion?.querySelector('[data-due-today-summary-text]');
        const listEl = section.querySelector('[data-due-today-list]');
        const emptyEl = section.querySelector('[data-due-today-empty]');
        return { section, accordion, summaryBtn, summaryText, listEl, emptyEl };
      })
      .filter(instance => instance.section && instance.accordion && instance.summaryBtn && instance.summaryText && instance.listEl && instance.emptyEl);
  }

  function initializeDueTodayAccordionState() {
    const sections = getDueTodaySections();
    if (!sections.length) return;

    sections.forEach(({ accordion, summaryBtn, listEl }) => {
      if (!accordion || !summaryBtn || !listEl) return;

      // Set initial state to CLOSED
      accordion.dataset.open = "false";
      summaryBtn.setAttribute("aria-expanded", "false");
      listEl.hidden = true;

      // Attach click listener once during initialization
      if (!summaryBtn.dataset.listenerBound) {
        summaryBtn.dataset.listenerBound = "true";
        summaryBtn.addEventListener("click", () => {
          const nextOpen = accordion.dataset.open !== "true";
          setDueTodayAccordionOpen(nextOpen, { highlight: nextOpen, source: accordion });
        });
      }
    });
  }

  function createDueTodayItem(entry) {
    const item = document.createElement("div");
    item.className = "due-today-item";

    const title = document.createElement("p");
    title.className = "due-today-title";
    title.textContent = entry.task.name;
    item.appendChild(title);

    const meta = document.createElement("div");
    meta.className = "due-today-meta";
    const metaBits = ["Due today"];
    if (entry.fallback && entry.task.dateOfService) {
      metaBits.push(`Visit ${entry.task.dateOfService}`);
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" • ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" • ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready • est —";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready • est —";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    if (!entries.length) {
      return;
    }

    const readyLabel = entries.length === 1 ? "1 ready" : `${entries.length} ready`;
    const estimatedMinutes = entries.reduce((sum, entry) => {
      const minutes = estimateTaskMinutes(entry.task);
      return Number.isFinite(minutes) ? sum + minutes : sum;
    }, 0);
    const hasEstimate = Number.isFinite(estimatedMinutes) && estimatedMinutes > 0;
    const estimateText = hasEstimate ? `est ${Math.max(1, Math.round(estimatedMinutes))} min` : "est —";

    instances.forEach(({ accordion, summaryBtn, summaryText, listEl }) => {
      summaryText.textContent = `${readyLabel} • ${estimateText}`;
      entries.forEach(entry => {
        listEl.appendChild(createDueTodayItem(entry));
      });
      const isOpen = accordion.dataset.open === "true";
      summaryBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
      listEl.hidden = !isOpen;
    });
  }

  function setDueTodayAccordionOpen(open, options = {}) {
    const { highlight = true, focusSummary = false, skipSync = false, source = null } = options;
    const instances = getDueTodaySections();
    if (!instances.length) return;
    instances.forEach(({ accordion, summaryBtn, listEl, section }) => {
      const nextState = open ? "true" : "false";
      accordion.dataset.open = nextState;
      summaryBtn.setAttribute("aria-expanded", open ? "true" : "false");
      listEl.hidden = !open;
      if (open && highlight !== false && (!source || source === section || source === accordion)) {
        window.requestAnimationFrame(() => {
          const firstCard = listEl.querySelector(".due-today-item");
          if (firstCard) {
            firstCard.classList.add("due-today-item--spotlight");
            window.setTimeout(() => firstCard.classList.remove("due-today-item--spotlight"), 900);
          }
        });
      }
      if (open && focusSummary && (!source || source === section || source === accordion)) {
        summaryBtn.focus();
      }
    });
    if (open && !skipSync) {
      setAllTasksAccordionOpen(false, { skipSync: true });
    }
  }

  function computeWantScore(task) {
    const interest = Number(task?.interest || 3);
    const novelty = Number(task?.novelty || 3);
    const difficulty = Number(task?.difficulty || 3);
    const est = estimateTaskMinutes(task);
    const ease = Number.isFinite(est) && est <= 20 ? 1.15 : 0.95;
    return (interest + novelty) * ease - difficulty * 0.2;
  }

  function renderConflictList(candidates, container, type) {
    if (!container) return;
    container.innerHTML = "";
    if (!candidates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No tasks available.";
      container.appendChild(empty);
      return;
    }
    candidates.slice(0, 3).forEach(({ task, descriptor }) => {
      const item = document.createElement("div");
      item.className = "conflict-item";
      item.setAttribute("draggable", "true");
      item.setAttribute("role", "button");
      item.setAttribute("tabindex", "0");
      item.dataset.type = type;
      item.dataset.taskId = task.id;
      const title = document.createElement("strong");
      title.textContent = task.name;
      const meta = document.createElement("span");
      meta.textContent = descriptor;
      item.appendChild(title);
      item.appendChild(meta);
      item.addEventListener("dragstart", event => {
        if (!event.dataTransfer) return;
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", JSON.stringify({ type, taskId: task.id }));
      });
      item.addEventListener("click", () => setConflictSelection(type, task.id));
      item.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          setConflictSelection(type, task.id);
        }
      });
      container.appendChild(item);
    });
  }

  function getActiveTaskById(taskId) {
    return tasks.find(task => task.id === taskId && !isTaskCompleted(task));
  }

  function renderConflictArena() {
    const arena = $("conflictArena");
    if (!arena) return;
    arena.innerHTML = "";
    const selections = [];
    if (conflictArenaSelection.should) {
      selections.push({ label: "Should-do", task: conflictArenaSelection.should });
    }
    if (conflictArenaSelection.want) {
      selections.push({ label: "Want-to", task: conflictArenaSelection.want });
    }
    if (!selections.length) {
      const prompt = document.createElement("div");
      prompt.id = "conflictArenaPrompt";
      prompt.textContent = "Drag a contender from each side into the arena.";
      arena.appendChild(prompt);
      arena.classList.remove("is-ready");
      return;
    }
    selections.forEach(selection => {
      const slot = document.createElement("div");
      slot.className = "arena-slot";
      slot.textContent = `${selection.label}: ${selection.task.name}`;
      arena.appendChild(slot);
    });
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      arena.classList.add("is-ready");
    } else {
      arena.classList.remove("is-ready");
    }
  }

  function setConflictSelection(type, taskId) {
    const task = getActiveTaskById(taskId);
    if (!task) return;
    conflictArenaSelection = {
      ...conflictArenaSelection,
      [type]: task
    };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      evaluateConflictArena();
    }
  }

  function resetConflictArena() {
    conflictArenaSelection = { should: null, want: null };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
  }

  function handleConflictDrop(event) {
    event.preventDefault();
    if (!event.dataTransfer) return;
    try {
      const payload = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (payload?.type && payload?.taskId) {
        setConflictSelection(payload.type, payload.taskId);
      }
    } catch (error) {
      console.warn("Unable to parse dropped conflict item", error);
    }
  }

  function evaluateConflictArena() {
    const shouldTask = conflictArenaSelection.should;
    const wantTask = conflictArenaSelection.want;
    if (!shouldTask || !wantTask) return;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldChunk = deriveMmpChunk(shouldTask);
    const wantChunk = deriveMmpChunk(wantTask);
    const shouldScore = computeFocusScore(shouldTask, energy, timeBudget) * 0.6
      + (Number(shouldTask.importance) || 1) * 2
      + (shouldChunk.minutes <= 15 ? 1.1 : 1);
    const wantScore = computeFocusScore(wantTask, energy, timeBudget) * 0.45
      + (Number(wantTask.interest) || 3) + (Number(wantTask.novelty) || 3)
      + (wantChunk.minutes <= 15 ? 1.05 : 0.9);
    const recommended = shouldScore >= wantScore
      ? { task: shouldTask, chunk: shouldChunk, label: "Should-do" }
      : { task: wantTask, chunk: wantChunk, label: "Want-to" };
    const sprintMinutes = Number.isFinite(recommended.chunk?.minutes)
      ? recommended.chunk.minutes
      : CONFLICT_DEFAULT_SPRINT;
    showToast("Conflict resolved", `${recommended.label} wins: ${recommended.task.name}`);
    const result = $("conflictResult");
    if (result) {
      result.textContent = `${recommended.label} wins – ${sprintMinutes} minute sprint queued.`;
    }
    startFocus(recommended.task.id, { sprintMinutes });
    resetConflictArena();
    updateConflictResolver();
  }

  function updateConflictResolver() {
    const shouldList = $("conflictShouldList");
    const wantList = $("conflictWantList");
    if (!shouldList || !wantList) return;
    const activeTasks = tasks.filter(task => !isTaskCompleted(task));
    conflictArenaSelection.should = conflictArenaSelection.should
      ? getActiveTaskById(conflictArenaSelection.should.id)
      : null;
    conflictArenaSelection.want = conflictArenaSelection.want
      ? getActiveTaskById(conflictArenaSelection.want.id)
      : null;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Focus score ${computeFocusScore(task, energy, timeBudget).toFixed(1)}`
      }))
      .sort((a, b) => computeFocusScore(b.task, energy, timeBudget) - computeFocusScore(a.task, energy, timeBudget));
    const wantCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Spark score ${computeWantScore(task).toFixed(1)}`
      }))
      .sort((a, b) => computeWantScore(b.task) - computeWantScore(a.task));
    renderConflictList(shouldCandidates, shouldList, "should");
    renderConflictList(wantCandidates, wantList, "want");
    renderConflictArena();
  }

  function initializeConflictResolverModule() {
    const module = $("conflictResolverModule");
    if (!module) return;
    const arena = $("conflictArena");
    if (arena) {
      arena.addEventListener("dragover", event => {
        event.preventDefault();
        arena.classList.add("is-ready");
      });
      arena.addEventListener("dragleave", () => {
        if (!conflictArenaSelection.should || !conflictArenaSelection.want) {
          arena.classList.remove("is-ready");
        }
      });
      arena.addEventListener("drop", handleConflictDrop);
    }
    const resetBtn = $("conflictReset");
    if (resetBtn) {
      resetBtn.addEventListener("click", resetConflictArena);
    }
    updateConflictResolver();
  }

  function getDefuseBaseMinutes() {
    const stored = Number(localStorage.getItem(DEFUSE_BASE_MINUTES_KEY));
    if (Number.isFinite(stored) && stored >= DEFUSE_MINUTES_MIN) {
      return Math.min(DEFUSE_MINUTES_MAX, Math.max(DEFUSE_MINUTES_MIN, Math.round(stored)));
    }
    return DEFUSE_MINUTES_MIN;
  }

  function setDefuseBaseMinutes(value) {
    const clamped = Math.max(DEFUSE_MINUTES_MIN, Math.min(DEFUSE_MINUTES_MAX, Math.round(value)));
    try {
      localStorage.setItem(DEFUSE_BASE_MINUTES_KEY, String(clamped));
    } catch (error) {
      console.warn("Unable to store DEFUSE base minutes", error);
    }
    defuseState.uptime = clamped;
    updateDefuseUptimeUI();
  }

  function getDefuseLocks() {
    try {
      const raw = JSON.parse(localStorage.getItem(DEFUSE_LOCKS_KEY) || "[]");
      return Array.isArray(raw) ? raw.map(String) : [];
    } catch (error) {
      console.warn("Unable to parse DEFUSE locks", error);
      return [];
    }
  }

  function saveDefuseLocks(values) {
    try {
      localStorage.setItem(DEFUSE_LOCKS_KEY, JSON.stringify(values));
    } catch (error) {
      console.warn("Unable to save DEFUSE locks", error);
    }
  }

  function loadDefuseAction() {
    try {
      const stored = localStorage.getItem(DEFUSE_ACTION_KEY);
      return stored || DEFAULT_DEFUSE_ACTION;
    } catch (error) {
      console.warn("Unable to load DEFUSE action", error);
      return DEFAULT_DEFUSE_ACTION;
    }
  }

  function saveDefuseAction(action) {
    try {
      if (!action) {
        localStorage.removeItem(DEFUSE_ACTION_KEY);
      } else {
        localStorage.setItem(DEFUSE_ACTION_KEY, action);
      }
    } catch (error) {
      console.warn("Unable to store DEFUSE action", error);
    }
  }

  function getSelectedDefuseLocks() {
    return Array.from(document.querySelectorAll('#defuseLocks input[type="checkbox"]:checked'))
      .map(box => box.value)
      .filter(Boolean);
  }

  function updateDefuseLocksUI() {
    const stored = getDefuseLocks();
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    boxes.forEach(box => {
      box.checked = stored.includes(box.value);
    });
  }

  function updateDefuseUptimeUI() {
    const base = defuseState.uptime || getDefuseBaseMinutes();
    const uptime = $("defuseUptime");
    if (uptime) {
      uptime.textContent = `Next sprint: ${base} minutes`;
    }
    const fill = $("defuseUptimeFill");
    if (fill) {
      const ratio = (base - DEFUSE_MINUTES_MIN) / (DEFUSE_MINUTES_MAX - DEFUSE_MINUTES_MIN);
      fill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
  }

  function updateDefuseCountdownUI() {
    const countdownEl = $("defuseCountdown");
    if (countdownEl) {
      countdownEl.textContent = `${Math.max(0, defuseState.countdown)}s`;
    }
    const progress = $("defuseProgressFill");
    if (progress) {
      const ratio = defuseState.active ? (1 - defuseState.countdown / 90) : 0;
      progress.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
    if (defuseState.active) {
      const prompt = DEFUSE_PROMPTS.find(entry => defuseState.countdown <= entry.threshold);
      const promptEl = $("defusePrompt");
      if (prompt && promptEl) {
        promptEl.textContent = prompt.message;
      }
    } else {
      const promptEl = $("defusePrompt");
      if (promptEl) {
        promptEl.textContent = DEFUSE_PROMPTS[0].message;
      }
    }
  }

  function setDefuseStatus(message) {
    const status = $("defuseStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function selectDefuseAction(action) {
    defuseState.selectedAction = action || DEFAULT_DEFUSE_ACTION;
    saveDefuseAction(defuseState.selectedAction);
    const preview = $("defuseActionPreview");
    if (preview) {
      preview.textContent = `Action picked: ${defuseState.selectedAction}`;
    }
  }

  function autoLockDefuseApps() {
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    const values = [];
    boxes.forEach(box => {
      box.checked = true;
      values.push(box.value);
    });
    saveDefuseLocks(values);
  }

  function startDefusePreflight() {
    if (defuseState.active) return;
    defuseState.active = true;
    defuseState.countdown = 90;
    defuseState.selectedAction = defuseState.selectedAction || DEFAULT_DEFUSE_ACTION;
    autoLockDefuseApps();
    updateDefuseCountdownUI();
    setDefuseStatus("Preflight running… stay with the prompt.");
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = true;
    if (cancelBtn) cancelBtn.disabled = false;
    defuseState.intervalId = setInterval(() => {
      defuseState.countdown -= 1;
      if (defuseState.countdown <= 0) {
        completeDefusePreflight();
      } else {
        updateDefuseCountdownUI();
      }
    }, 1000);
    updateDefuseModeUI();
  }

  function cancelDefusePreflight() {
    if (!defuseState.active) return;
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    setDefuseStatus("Preflight cancelled.");
    updateDefuseModeUI();
  }

  function completeDefusePreflight() {
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    const sprintMinutes = getDefuseBaseMinutes();
    setDefuseStatus(`Launching ${sprintMinutes}-minute DEFUSE sprint.`);
    showToast("DEFUSE Mode", `${defuseState.selectedAction}. Sprinting for ${sprintMinutes} minutes.`);
    const nextBase = Math.min(DEFUSE_MINUTES_MAX, sprintMinutes + 2);
    setDefuseBaseMinutes(nextBase);
    startFocus(null, { sprintMinutes });
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    updateDefuseModeUI();
  }

  function updateDefuseModeUI() {
    updateDefuseLocksUI();
    updateDefuseUptimeUI();
    updateDefuseCountdownUI();
    selectDefuseAction(defuseState.selectedAction || DEFAULT_DEFUSE_ACTION);
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = defuseState.active;
    if (cancelBtn) cancelBtn.disabled = !defuseState.active;
  }

  function initializeDefuseMode() {
    const module = $("defuseModule");
    if (!module) return;
    defuseState.selectedAction = loadDefuseAction();
    defuseState.uptime = getDefuseBaseMinutes();
    updateDefuseModeUI();
    const actionButtons = document.querySelectorAll('[data-defuse-action]');
    actionButtons.forEach(button => {
      button.addEventListener("click", () => selectDefuseAction(button.getAttribute("data-defuse-action")));
    });
    const lockBoxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    lockBoxes.forEach(box => {
      box.addEventListener("change", () => saveDefuseLocks(getSelectedDefuseLocks()));
    });
    const startBtn = $("defuseStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDefusePreflight);
    }
    const cancelBtn = $("defuseCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelDefusePreflight);
    }
  }

  function loadDopamineReward() {
    const stored = localStorage.getItem(DOPAMINE_REWARD_KEY);
    return stored || "music";
  }

  function saveDopamineReward(value) {
    try {
      localStorage.setItem(DOPAMINE_REWARD_KEY, value);
    } catch (error) {
      console.warn("Unable to save dopamine reward preference", error);
    }
  }

  function updateDopamineStatus(message) {
    const status = $("dopamineStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function renderDopamineIntervals() {
    const container = $("dopamineIntervals");
    if (!container) return;
    container.innerHTML = "";
    DOPAMINE_INTERVALS.forEach((minutes, index) => {
      const row = document.createElement("div");
      row.className = "dopamine-interval";
      const label = document.createElement("span");
      label.textContent = `${minutes} min`;
      const status = document.createElement("span");
      if (dopamineState?.currentIntervalIndex > index) {
        status.textContent = "✅ complete";
      } else if (dopamineState?.active && dopamineState.currentIntervalIndex === index) {
        status.textContent = "▶️ now";
      } else {
        status.textContent = "… pending";
      }
      row.appendChild(label);
      row.appendChild(status);
      container.appendChild(row);
    });
  }

  function updateDopamineProgress() {
    const progress = $("dopamineProgressFill");
    if (!progress) return;
    if (!dopamineState || !dopamineState.active) {
      const completed = dopamineState?.currentIntervalIndex >= DOPAMINE_INTERVALS.length;
      progress.style.width = completed ? "100%" : "0%";
      updateGanttOverlayProgress();
      return;
    }
    const totalMinutes = DOPAMINE_INTERVALS[DOPAMINE_INTERVALS.length - 1];
    const totalMs = Math.max(1, totalMinutes * 60 * 1000);
    const elapsed = Date.now() - dopamineState.startTime;
    const ratio = Math.max(0, Math.min(1, elapsed / totalMs));
    progress.style.width = `${Math.round(ratio * 100)}%`;
    updateGanttOverlayProgress();
  }

  function spawnConfetti() {
    const burst = document.createElement("div");
    burst.className = "confetti-burst";
    const icons = ["🎉", "✨", "🪄", "🎊", "💫"];
    burst.textContent = icons[Math.floor(Math.random() * icons.length)];
    document.body.appendChild(burst);
    setTimeout(() => {
      if (burst.parentNode) {
        burst.parentNode.removeChild(burst);
      }
    }, 900);
  }

  function playTone(frequency, durationMs = 320) {
    try {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) return;
      const context = new AudioContextClass();
      const oscillator = context.createOscillator();
      const gain = context.createGain();
      oscillator.type = "sine";
      oscillator.frequency.value = frequency;
      gain.gain.setValueAtTime(0.2, context.currentTime);
      oscillator.connect(gain);
      gain.connect(context.destination);
      oscillator.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + durationMs / 1000);
      oscillator.stop(context.currentTime + durationMs / 1000);
      setTimeout(() => context.close(), durationMs + 120);
    } catch (error) {
      console.warn("Tone playback unavailable", error);
    }
  }

  function triggerDopamineReward(index) {
    if (!dopamineState) return;
    dopamineState.currentIntervalIndex = Math.max(dopamineState.currentIntervalIndex, index + 1);
    renderDopamineIntervals();
    updateDopamineProgress();
    const minutes = DOPAMINE_INTERVALS[index];
    if (dopamineState.rewardType === "music") {
      playTone(440, 320);
      setTimeout(() => playTone(660, 200), 180);
    } else if (dopamineState.rewardType === "coin") {
      playTone(880, 200);
      setTimeout(() => playTone(660, 180), 180);
    } else if (dopamineState.rewardType === "confetti") {
      spawnConfetti();
    } else {
      showToast("Stretch cue", "Stand, reach tall, breathe for 10 seconds.");
    }
    if (index >= DOPAMINE_INTERVALS.length - 1) {
      updateDopamineStatus("Intervals complete. Ride the momentum!");
      stopDopaminePlaylist({ completed: true });
    } else {
      const next = DOPAMINE_INTERVALS[index + 1] - minutes;
      updateDopamineStatus(`Nice! Next reward in ${next} min.`);
    }
  }

  function stopDopaminePlaylist(options = {}) {
    if (!dopamineState) return;
    (dopamineState.timers || []).forEach(timerId => clearTimeout(timerId));
    if (dopamineState.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    const completed = Boolean(options.completed);
    const rewardType = dopamineState.rewardType || loadDopamineReward();
    const currentIndex = completed ? DOPAMINE_INTERVALS.length : (dopamineState.currentIntervalIndex || 0);
    dopamineState = {
      active: false,
      rewardType,
      currentIntervalIndex: currentIndex,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    if (!completed) {
      updateDopamineStatus("Playlist stopped.");
    }
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = false;
    if (stopBtn) stopBtn.disabled = true;
  }

  function startDopaminePlaylist() {
    if (dopamineState?.active) return;
    const select = $("dopamineReward");
    const rewardType = select?.value || loadDopamineReward();
    saveDopamineReward(rewardType);
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = true;
    if (stopBtn) stopBtn.disabled = false;
    const timers = DOPAMINE_INTERVALS.map((minutes, index) =>
      setTimeout(() => triggerDopamineReward(index), minutes * 60 * 1000)
    );
    if (dopamineState?.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    dopamineState = {
      active: true,
      rewardType,
      timers,
      startTime: Date.now(),
      tickIntervalId: setInterval(updateDopamineProgress, 1000),
      currentIntervalIndex: 0
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    updateDopamineStatus("Playlist started – settle in.");
  }

  function initializeDopamineModule() {
    const module = $("dopamineModule");
    if (!module) return;
    const stored = loadDopamineReward();
    dopamineState = {
      active: false,
      rewardType: stored,
      currentIntervalIndex: 0,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    const select = $("dopamineReward");
    if (select) {
      select.value = stored;
      select.addEventListener("change", event => {
        const value = event.target.value || "music";
        saveDopamineReward(value);
        if (dopamineState) {
          dopamineState.rewardType = value;
        }
      });
    }
    const startBtn = $("dopamineStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDopaminePlaylist);
    }
    const stopBtn = $("dopamineStop");
    if (stopBtn) {
      stopBtn.addEventListener("click", () => stopDopaminePlaylist({ completed: false }));
      stopBtn.disabled = true;
    }
    renderDopamineIntervals();
    updateDopamineProgress();
    updateDopamineStatus("Stretch rewards from 2 → 6 → 12 minutes.");
  }

  function buildAdaptiveGanttPlan(windowMinutes = GANTT_WINDOW_MINUTES) {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const available = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({
        task,
        score: computeFocusScore(task, energyLevel, timeBudget),
        minutes: Math.max(5, Math.round(estimateTaskMinutes(task) || 15))
      }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    const entries = [];
    let remaining = Number.isFinite(windowMinutes) && windowMinutes > 0 ? windowMinutes : GANTT_WINDOW_MINUTES;
    available.forEach(entry => {
      if (remaining <= 0) return;
      const blockMinutes = Math.min(entry.minutes, remaining);
      entries.push({
        task: entry.task,
        minutes: blockMinutes,
        fullMinutes: entry.minutes
      });
      remaining -= blockMinutes;
    });
    const totalMinutes = entries.reduce((sum, entry) => sum + entry.minutes, 0);
    return { entries, totalMinutes };
  }

  function renderGanttSnapshot(plan) {
    ganttPlanState = plan;
    const container = $("ganttBlocks");
    const status = $("ganttStatus");
    if (container) {
      container.innerHTML = "";
      if (!plan.entries.length) {
        const empty = document.createElement("div");
        empty.className = "score";
        empty.textContent = "Add a task to see your next blocks.";
        container.appendChild(empty);
      } else {
        plan.entries.forEach((entry, index) => {
          const block = document.createElement("div");
          block.className = "gantt-block";
          block.style.flex = String(Math.max(1, entry.minutes));
          const title = document.createElement("strong");
          title.textContent = entry.task.name || "Task";
          const detail = document.createElement("small");
          const startOffset = plan.entries.slice(0, index).reduce((sum, current) => sum + current.minutes, 0);
          const start = new Date(Date.now() + startOffset * 60000);
          detail.textContent = `${entry.minutes} min • starts ${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
          block.appendChild(title);
          block.appendChild(detail);
          container.appendChild(block);
        });
      }
    }
    if (status) {
      status.textContent = plan.entries.length
        ? `Covers ${plan.totalMinutes} min. Playlist progress will sweep across.`
        : "";
    }
  }

    function updateGanttOverlayProgress() {
    const bar = $("ganttProgressBar");
    const status = $("ganttStatus");
    if (!bar || !ganttPlanState) return;
    const total = ganttPlanState.totalMinutes || 0;
    if (!ganttOverlayStartTime || total <= 0) {
      bar.style.width = "0%";
      bar.classList.add("is-paused");
      if (status && status.textContent === "") {
        status.textContent = "Hit play on the playlist to animate your time.";
      }
      return;
    }
    if (!dopamineState || !dopamineState.active) {
      bar.classList.add("is-paused");
      if (status) {
        status.textContent = "Playlist paused — progress holds until you press play.";
      }
      return;
    }
    bar.classList.remove("is-paused");
    const elapsed = Math.max(0, Date.now() - ganttOverlayStartTime);
    const ratio = Math.min(1, elapsed / (total * 60000));
    bar.style.width = `${Math.round(ratio * 100)}%`;
    if (status) {
      status.textContent = `Playlist pacing ${Math.round(ratio * 100)}% of this snapshot.`;
    }
  }

    function openGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    updateGanttOverlayProgress();
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
    }
    ganttProgressIntervalId = setInterval(updateGanttOverlayProgress, 1000);
  }

    function closeGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
      ganttProgressIntervalId = null;
    }
    ganttOverlayStartTime = null;
  }

    function refreshGanttSnapshotIfOpen() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    updateGanttOverlayProgress();
  }

    function initializeGanttSnapshot() {
    const trigger = $("ganttSnapshotAction");
    if (trigger) {
      trigger.addEventListener("click", openGanttSnapshot);
    }
    const closeBtn = $("ganttCloseButton");
    if (closeBtn) {
      closeBtn.addEventListener("click", closeGanttSnapshot);
    }
    const overlay = $("ganttSnapshotOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeGanttSnapshot();
        }
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        closeGanttSnapshot();
      }
    });
  }

  function setAddTaskCardCollapsed(collapsed, options = {}) {
    const overlay = $("addTaskOverlay");
    const body = $("addTaskCardBody");
    if (!overlay || !body) return;
    const { skipFocus = false, skipPersist = false, focusTarget = null } = options;
    const open = !collapsed;
    overlay.classList.toggle("hidden", collapsed);
    overlay.setAttribute("aria-hidden", collapsed ? "true" : "false");
    if (!skipPersist) {
      localStorage.setItem(ADD_TASK_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
    if (!open) {
      return;
    }
    window.setTimeout(() => {
      if (skipFocus) return;
      if (focusTarget === "dueDate") {
        if (!focusDueDateField()) {
          focusFirstEditableField();
        }
        return;
      }
      focusFirstEditableField();
    }, 120);
  }

  function toggleAddTaskCard() {
    const overlay = $("addTaskOverlay");
    const collapsed = !overlay || overlay.classList.contains("hidden") ? true : false;
    setAddTaskCardCollapsed(!collapsed);
  }

  function initializeAddTaskCardState() {
    let stored = localStorage.getItem(ADD_TASK_CARD_STATE_KEY);
    if (!stored) {
      const legacy = localStorage.getItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      if (legacy) {
        stored = legacy;
        localStorage.setItem(ADD_TASK_CARD_STATE_KEY, legacy);
        localStorage.removeItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      }
    }
    const collapsed = stored ? stored !== "expanded" : true;
    setAddTaskCardCollapsed(collapsed, { skipFocus: true, skipPersist: true });
  }


  function getAllTasksCards() {
    return Array.from(document.querySelectorAll('[data-all-tasks-card]'))
      .map(card => {
        const accordion = card.querySelector('[data-accordion="allTasks"]');
        const summaryBtn = accordion?.querySelector('[data-accordion-summary]');
        const summaryText = card.querySelector('[data-all-tasks-summary-text]');
        const summaryChip = card.querySelector('[data-all-tasks-summary-chip]');
        const panel = card.querySelector('[data-all-tasks-panel]');
        const title = card.querySelector('[data-all-tasks-title]');
        return { card, accordion, summaryBtn, summaryText, summaryChip, panel, title };
      })
      .filter(instance => instance.card && instance.accordion && instance.summaryBtn && instance.summaryText && instance.panel);
  }

  function initializeAllTasksCardState() {
    const cards = getAllTasksCards();
    if (!cards.length) return;
    cards.forEach(({ accordion, summaryBtn, card }) => {
      if (!summaryBtn.dataset.listenerBound) {
        summaryBtn.dataset.listenerBound = "true";
        summaryBtn.addEventListener("click", () => {
          const nextOpen = accordion.dataset.open !== "true";
          setAllTasksAccordionOpen(nextOpen, { highlight: nextOpen, source: card });
        });
      }
    });
    let storedState = null;
    try {
      storedState = localStorage.getItem(ALL_TASKS_CARD_STATE_KEY);
      if (storedState !== "collapsed") {
        localStorage.setItem(ALL_TASKS_CARD_STATE_KEY, "collapsed");
      }
    } catch (error) {
      console.warn("Unable to access stored All Tasks state", error);
    }
    setAllTasksAccordionOpen(false, { skipPersist: true });
  }

  function focusFirstEditableField() {
    const nameField = $("name");
    if (nameField) {
      window.requestAnimationFrame(() => {
        nameField.focus();
        if (typeof nameField.select === "function") {
          nameField.select();
        }
      });
    }
  }

  function focusDueDateField() {
    const dueField = $("dueDate");
    if (dueField) {
      window.requestAnimationFrame(() => dueField.focus());
      return true;
    }
    const serviceField = $("dateOfService");
    if (serviceField) {
      window.requestAnimationFrame(() => serviceField.focus());
      return true;
    }
    return false;
  }

  function scrollCardHeaderIntoView(card) {
    if (!card) return;
    const target = card.querySelector(".card-head") || card;
    window.requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const offset = Math.max(0, window.scrollY + rect.top - 24);
      window.scrollTo({ top: offset, behavior: "smooth" });
    });
  }

  function handleTemplateModalKeydown(event) {
    if (event.key === "Escape") {
      closeTemplateModal();
    }
  }

  function closeTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    document.removeEventListener("keydown", handleTemplateModalKeydown);
    if (lastFocusedBeforeTemplateModal && typeof lastFocusedBeforeTemplateModal.focus === "function") {
      lastFocusedBeforeTemplateModal.focus();
    }
    lastFocusedBeforeTemplateModal = null;
  }

  function renderTemplateCards(list) {
    const grid = $("template-grid");
    if (!grid) return;
    grid.innerHTML = "";
    if (!list || !list.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      grid.appendChild(empty);
      return;
    }
    list.forEach(template => {
      const card = document.createElement("div");
      card.className = "template-card";
      const title = document.createElement("strong");
      title.textContent = template.name;
      card.appendChild(title);
      const meta = document.createElement("p");
      meta.className = "score";
      const categoryLabel = template.category || "General";
      meta.textContent = `Category: ${categoryLabel}`;
      card.appendChild(meta);
      const stats = document.createElement("p");
      stats.className = "score";
      stats.textContent = `Imp ${template.importance || 1} • Urg ${template.urgency || 3} • Diff ${template.difficulty || 3}`;
      card.appendChild(stats);
      const applyBtn = document.createElement("button");
      applyBtn.type = "button";
      applyBtn.className = "btn btn-primary";
      applyBtn.textContent = "Apply";
      applyBtn.addEventListener("click", () => applyTemplate(template));
      card.appendChild(applyBtn);
      grid.appendChild(card);
    });
  }

  function openTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    lastFocusedBeforeTemplateModal = document.activeElement;
    const category = $("taskCategory")?.value || "General";
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    document.addEventListener("keydown", handleTemplateModalKeydown);
    const firstButton = modal.querySelector(".template-card button") || modal.querySelector(".modal__close");
    if (firstButton) {
      firstButton.focus();
    }
  }

  function fillTaskFormFromTemplate(template, options = {}) {
    if (!template) return;
    $("name").value = template.name || "";
    const keepCurrent = Boolean(options.keepCurrentCategory);
    const categoryField = $("taskCategory");
    const currentCategory = categoryField ? (categoryField.value || "General") : "General";
    const category = keepCurrent ? currentCategory : (template.category || currentCategory);
    if (categoryField) {
      categoryField.value = category;
    }
    handleCategoryChange(category);
    $("importance").value = String(template.importance || 1);
    $("novelty").value = String(template.novelty || 1);
    $("interest").value = String(template.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = template.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(template.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(template.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(template.clinicSite);
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = String(template.urgency || 3);
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = String(template.externalPressure || 1);
    $("timeToStart").value = String(template.timeToStart || 1);
    $("difficulty").value = String(template.difficulty || 1);
    const dateField = $("dateOfService");
    if (dateField) dateField.value = formatDateForInput(new Date());
    urgencyAuto = false;
    updateDerivedFields();
  }

  function applyTemplate(template) {
    fillTaskFormFromTemplate(template, { keepCurrentCategory: true });
    setTaskDetailsCollapsed(false);
    setAddTaskCardCollapsed(false, { focusTarget: "dueDate" });
    closeTemplateModal();
  }

  function updateTemplateModalForCategory(category) {
    const modal = $("template-modal");
    if (!modal || modal.classList.contains("hidden")) return;
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
  }

  function setTaskDetailsCollapsed(collapsed) {
    const panel = $("taskDetails");
    const button = $("expandTaskDetailsButton");
    if (!panel || !button) return;
    panel.dataset.collapsed = collapsed ? "true" : "false";
    button.textContent = collapsed ? "Show details" : "Hide details";
    button.setAttribute("aria-expanded", collapsed ? "false" : "true");
    panel.setAttribute("aria-hidden", collapsed ? "true" : "false");
  }

  function toggleTaskDetails() {
    const panel = $("taskDetails");
    if (!panel) return;
    const collapsed = panel.dataset.collapsed !== "false";
    setTaskDetailsCollapsed(!collapsed);
  }

  function syncAddTaskActions() {
    const nameField = $("name");
    const addBtn = $("addTaskBtn");
    const startBtn = $("startBtn");
    if (!nameField || !addBtn || !startBtn) return;
    const hasName = Boolean(nameField.value.trim());
    const hasTasks = startBtn.dataset.hasTasks === "true";
    addBtn.classList.toggle("btn-primary", !hasName);
    addBtn.classList.toggle("btn-quiet", hasName);
    startBtn.classList.toggle("hero-cta", hasName);
    startBtn.classList.toggle("btn-secondary", !hasName);
    startBtn.disabled = !hasName && !hasTasks;
  }


  function setAllTasksAccordionOpen(open, options = {}) {
    const { skipPersist = false, highlight = false, skipSync = false, source = null } = options;
    const cards = getAllTasksCards();
    if (!cards.length) return;
    cards.forEach(({ accordion, summaryBtn, panel, card }) => {
      accordion.dataset.open = open ? "true" : "false";
      summaryBtn.setAttribute("aria-expanded", open ? "true" : "false");
      panel.hidden = !open;
      panel.setAttribute("aria-hidden", open ? "false" : "true");
      if (open && highlight && (!source || source === card || source === accordion || source === panel)) {
        panel.classList.add("is-highlighted");
        window.setTimeout(() => panel.classList.remove("is-highlighted"), 600);
      }
    });
    if (open && !skipSync) {
      setDueTodayAccordionOpen(false, { skipSync: true });
    }
    if (!skipPersist) {
      localStorage.setItem(ALL_TASKS_CARD_STATE_KEY, open ? "expanded" : "collapsed");
    }
  }

  function setModuleOpenState(module, body, open, header = null) {
    if (!module || !body) return;
    module.classList.toggle("is-open", open);
    body.hidden = !open;
    if (header) {
      header.setAttribute("aria-expanded", open ? "true" : "false");
    }
    body.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function openModuleById(id) {
    const routineDef = getRoutineDefinition(id) || ROUTINE_DEFINITIONS.find(def => def.moduleId === id);
    if (routineDef) {
      openRoutineTile(routineDef.id, { scrollIntoView: true });
      return;
    }
    const module = $(id);
    if (!module) return;
    const body = module.querySelector(".module-body");
    const header = module.querySelector(".module-header");
    if (!body) return;
    setModuleOpenState(module, body, true, header);
    localStorage.setItem(`${MODULE_STATE_PREFIX}${id}`, "open");
  }

  function initializeCollapsibleModules() {
    initializeRoutineTiles();
  }

  function getMostMeaningfulTask() {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const scored = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({ task, score: computeFocusScore(task, energyLevel, timeBudget) }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    return scored.length ? scored[0].task : null;
  }

  function updateWorstDayBanner() {
    const button = $("worstDayButton");
    const hint = $("worstDayHint");
    const focusTask = getMostMeaningfulTask();
    const hasTask = Boolean(focusTask);
    if (button) {
      button.disabled = !hasTask;
      button.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    const focusFab = $("startFocusFab");
    if (focusFab) {
      focusFab.disabled = !hasTask;
      focusFab.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    if (hint) {
      hint.textContent = hasTask ? `Most meaningful project: ${focusTask.name}` : "Add a task to unlock Worst-Day Mode.";
    }
  }

    function startWorstDayMode() {
    if (worstDayState.active) return;
    const overlay = $("worstDayOverlay");
    const focusLine = $("worstDayFocus");
    const prompt = $("worstDayPrompt");
    const timerEl = $("worstDayTimer");
    const actions = $("worstDayActions");
    const celebration = $("worstDayCelebration");
    const focusTask = getMostMeaningfulTask();
    if (!overlay || !focusTask) {
      showToast("Worst-Day Mode", "Add a task to give yourself something kind to focus on.");
      return;
    }
    const chunk = deriveMmpChunk(focusTask) || { label: focusTask.name, minutes: 5, subId: null };
    worstDayState = {
      active: true,
      countdownId: null,
      endTime: Date.now() + WORST_DAY_DURATION_MS,
      task: focusTask,
      chunk
    };
    if (focusLine) {
      focusLine.textContent = chunk.label || focusTask.name;
    }
    if (prompt) {
      prompt.textContent = "Move gently. Drift happens — we'll reset together.";
    }
    if (timerEl) {
      timerEl.textContent = "05:00";
    }
    if (actions) {
      actions.classList.add("hidden");
    }
    if (celebration) {
      celebration.textContent = "";
    }
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = setInterval(updateWorstDayTimer, 250);
    updateWorstDayTimer();
  }

    function updateWorstDayTimer() {
    if (!worstDayState.active) return;
    const timerEl = $("worstDayTimer");
    const prompt = $("worstDayPrompt");
    if (!timerEl) return;
    const remaining = Math.max(0, worstDayState.endTime - Date.now());
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    if (remaining <= 0) {
      completeWorstDaySprint();
      if (prompt) {
        prompt.textContent = "You stayed. Pick a gentle reward.";
      }
    }
  }

    function completeWorstDaySprint() {
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = null;
    worstDayState.active = false;
    worstDayState.endTime = null;
    const actions = $("worstDayActions");
    if (actions) {
      actions.classList.remove("hidden");
    }
    const celebration = $("worstDayCelebration");
    if (celebration) {
      celebration.textContent = "";
    }
  }

    function handleWorstDayChoice(choice) {
    const celebration = $("worstDayCelebration");
    if (choice === "laugh") {
      const line = WORST_DAY_LAUGHS[Math.floor(Math.random() * WORST_DAY_LAUGHS.length)] || "You showed up.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stretch") {
      const line = WORST_DAY_STRETCHES[Math.floor(Math.random() * WORST_DAY_STRETCHES.length)] || "Shoulder rolls, deep breath.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stop") {
      stopWorstDayMode({ celebrate: true });
    }
  }

    function stopWorstDayMode(options = {}) {
    const overlay = $("worstDayOverlay");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
    if (overlay) {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
    if (options.celebrate) {
      showToast("Worst-Day Mode", "Five minutes banked. That counts.");
    }
    updateWorstDayBanner();
  }

    function initializeWorstDayMode() {
    const button = $("worstDayButton");
    if (button) {
      button.addEventListener("click", startWorstDayMode);
    }
    const overlay = $("worstDayOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          stopWorstDayMode();
        }
      });
    }
    const closeBtn = $("worstDayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const exitBtn = $("worstDayExit");
    if (exitBtn) {
      exitBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const actions = $("worstDayActions");
    if (actions) {
      actions.addEventListener("click", event => {
        const buttonEl = event.target.closest('[data-worst-day-choice]');
        if (!buttonEl) return;
        handleWorstDayChoice(buttonEl.getAttribute('data-worst-day-choice'));
      });
    }
    updateWorstDayBanner();
  }

  function startFiveMinuteSprint(taskId = null) {
    setTaskDetailsCollapsed(false);
    const targetId = taskId || nextTaskId || null;
    startFocus(targetId, { sprintMinutes: 5 });
  }

  function extendSprintBy(minutes) {
    const extraMinutes = Number(minutes);
    if (!Number.isFinite(extraMinutes) || extraMinutes <= 0) return;
    const extraMs = extraMinutes * 60000;
    const now = Date.now();
    if (focusTimerStart === null) {
      startFocus(nextTaskId, { sprintMinutes: extraMinutes });
      return;
    }
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0 || !sprintEndTime) {
      const elapsed = Math.max(0, now - focusTimerStart);
      sprintDurationMinutes = Math.max(extraMinutes, (elapsed + extraMs) / 60000);
      sprintEndTime = now + extraMs;
      setSprintVisualState(true);
    } else {
      sprintEndTime += extraMs;
      const total = Math.max(sprintEndTime - focusTimerStart, extraMs);
      sprintDurationMinutes = Math.max(sprintDurationMinutes, total / 60000);
    }
    const remaining = Math.max(0, sprintEndTime - now);
    const totalDuration = Math.max(remaining, sprintDurationMinutes * 60000);
    setFocusProgress(totalDuration > 0 ? ((totalDuration - remaining) / totalDuration) * 100 : 0);
    showToast("Focus cocoon", `Sprint extended by ${extraMinutes} minute${extraMinutes === 1 ? "" : "s"}.`);
  }

  function quickAddTask(nameOverride = null) {
    const provided = typeof nameOverride === "string" ? nameOverride : prompt("Quick add task");
    if (!provided) return;
    const name = provided.trim();
    if (!name) return;
    const nowIso = new Date().toISOString();
    const task = {
      id: Date.now().toString(),
      name,
      category: "General",
      authorType: "attending",
      patientType: "Non-Complex",
      visitType: "Follow-Up",
      clinicSite: "General Clinic",
      dateOfService: null,
      daysSinceVisit: null,
      importance: 3,
      urgency: 3,
      novelty: 3,
      interest: 3,
      externalPressure: 2,
      timeToStart: 3,
      difficulty: 3,
      dueDate: null,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: false
    };
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    persist();
    setTaskDetailsCollapsed(true);
    updateUI();
  }

  let quickCaptureKeydownHandler = null;

  function openQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const input = $("quickCaptureInput");
    if (input) {
      input.value = "";
      window.requestAnimationFrame(() => input.focus());
    }
    quickCaptureKeydownHandler = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeQuickCaptureModal();
      }
      if (event.key === "Enter" && event.target === input) {
        event.preventDefault();
        handleQuickCaptureSubmit();
      }
    };
    document.addEventListener("keydown", quickCaptureKeydownHandler);
  }

  function closeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (quickCaptureKeydownHandler) {
      document.removeEventListener("keydown", quickCaptureKeydownHandler);
      quickCaptureKeydownHandler = null;
    }
    const trigger = $("nextTaskActionButton");
    if (trigger) {
      window.requestAnimationFrame(() => trigger.focus());
    }
  }

  function handleQuickCaptureSubmit() {
    const input = $("quickCaptureInput");
    if (!input) return;
    const value = input.value.trim();
    if (!value) {
      input.focus();
      return;
    }
    quickAddTask(value);
    closeQuickCaptureModal();
  }

  function initializeFocusLaunchSheet() {
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    const handle = $("focusLaunchHandle");
    const suggestionBtn = $("focusSuggestionButton");
    const options = sheet ? sheet.querySelector(".focus-sheet__options") : null;
    const labelMap = { now: "Do now", easy: "Do if easy", buddy: "Do with buddy" };
    const nextTaskAction = $("nextTaskActionButton");

    const activatePick = pickKey => {
      if (!pickKey) return false;
      const evaluation = latestNextBestPicks[pickKey];
      if (!evaluation) return false;
      launchNextBestOption(labelMap[pickKey] || "Start", evaluation);
      return true;
    };

    if (nextTaskAction) {
      const LONG_PRESS_MS = 650;
      let longPressTriggered = false;
      let pressTimer = null;

      const clearPressTimer = () => {
        if (pressTimer) {
          window.clearTimeout(pressTimer);
          pressTimer = null;
        }
      };

      const handlePointerEnd = () => {
        if (longPressTriggered) {
          window.setTimeout(() => nextTaskAction.classList.remove("is-long-press"), 220);
        }
        clearPressTimer();
      };

      nextTaskAction.addEventListener("pointerdown", event => {
        if (event.button !== 0) return;
        clearPressTimer();
        longPressTriggered = false;
        pressTimer = window.setTimeout(() => {
          longPressTriggered = true;
          nextTaskAction.classList.add("is-long-press");
          openQuickCaptureModal();
        }, LONG_PRESS_MS);
      });

      nextTaskAction.addEventListener("pointerup", handlePointerEnd);
      nextTaskAction.addEventListener("pointerleave", handlePointerEnd);
      nextTaskAction.addEventListener("pointercancel", handlePointerEnd);

      nextTaskAction.addEventListener("click", event => {
        if (longPressTriggered) {
          event.preventDefault();
          longPressTriggered = false;
          return;
        }
        startFiveMinuteSprint(nextTaskId);
      });
    }

    if (fab) {
      fab.addEventListener("click", event => {
        event.preventDefault();
        if (fab.disabled) return;
        setFocusLaunchOpen(!focusLaunchOpen);
      });
    }

    if (handle) {
      handle.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (backdrop) {
      backdrop.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (options) {
      options.addEventListener("click", event => {
        const button = event.target.closest(".focus-sheet__option");
        if (!button || button.disabled || button.getAttribute("aria-disabled") === "true") return;
        const mode = button.getAttribute("data-focus-mode");
        setFocusLaunchOpen(false);
        if (mode === "sprint") {
          if (!activatePick("now")) {
            startFiveMinuteSprint(nextTaskId);
          }
          return;
        }
        if (mode === "session") {
          if (!activatePick("easy")) {
            const fallbackId = latestNextBestPicks.now?.task?.id || nextTaskId;
            if (fallbackId) {
              startFocus(fallbackId);
            } else {
              startFocus();
            }
          }
          return;
        }
        if (mode === "suggestion") {
          const pickKey = button.dataset.pickKey || "now";
          if (!activatePick(pickKey)) {
            startFiveMinuteSprint(nextTaskId);
          }
        }
      });
    }

    if (suggestionBtn) {
      suggestionBtn.addEventListener("click", () => {
        const pickKey = suggestionBtn.dataset.pickKey;
        setFocusLaunchOpen(false);
        if (!activatePick(pickKey)) {
          startFiveMinuteSprint(nextTaskId);
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && focusLaunchOpen) {
        setFocusLaunchOpen(false);
      }
    });
  }

  function openDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function initializeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    const cancelBtn = $("quickCaptureCancel");
    const saveBtn = $("quickCaptureSave");
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeQuickCaptureModal();
      }
    });
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => closeQuickCaptureModal());
    }
    if (saveBtn) {
      saveBtn.addEventListener("click", () => handleQuickCaptureSubmit());
    }
  }

  function closeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (lastDefuseOpener) {
      lastDefuseOpener.focus();
      lastDefuseOpener = null;
    }
  }

  function initializeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeDefuseOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeDefuseOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeDefuseOverlay();
      }
    });
  }

  function initializeResourcesDrawer() {
    const toggle = $("resourcesToggle");
    const drawer = $("resourcesDrawer");
    const closeBtn = $("resourcesClose");
    const backdrop = $("resourcesBackdrop");
    if (!toggle || !drawer || !backdrop) return;

    let drawerOpen = false;
    const setDrawerOpen = open => {
      drawerOpen = Boolean(open);
      drawer.classList.toggle("is-open", drawerOpen);
      drawer.setAttribute("aria-hidden", drawerOpen ? "false" : "true");
      if (drawerOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
        drawer.focus();
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!drawerOpen) {
            backdrop.hidden = true;
          }
        }, 200);
        toggle.focus();
      }
    };

    toggle.addEventListener("click", () => setDrawerOpen(true));
    if (closeBtn) {
      closeBtn.addEventListener("click", () => setDrawerOpen(false));
    }
    backdrop.addEventListener("click", () => setDrawerOpen(false));
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && drawerOpen) {
        setDrawerOpen(false);
      }
    });
  }

  function initializeSosPanel() {
    const overlay = $("sosOverlay");
    const closeBtn = $("sosOverlayClose");
    const shieldBtn = $("sosShield");
    const defuseBtn = $("sosDefuse");
    const worstDayBtn = $("worstDayButton");
    const triggers = ["rescueLaunchButton", "meltdownSosButton"].map(id => $(id)).filter(Boolean);
    if (!triggers.length || !overlay) return;

    let sosOpen = false;
    let activeTrigger = null;

    const updateTriggerExpanded = () => {
      triggers.forEach(trigger => {
        trigger.setAttribute("aria-expanded", sosOpen && trigger === activeTrigger ? "true" : "false");
      });
    };

    updateTriggerExpanded();

    const setSosOpen = (open, { restoreFocus = true, focusTarget = null } = {}) => {
      sosOpen = Boolean(open);
      updateTriggerExpanded();
      if (sosOpen) {
        overlay.classList.remove("hidden");
        overlay.setAttribute("aria-hidden", "false");
        if (closeBtn) {
          closeBtn.focus();
        }
        lastSosTrigger = activeTrigger || triggers[0] || null;
      } else {
        overlay.classList.add("hidden");
        overlay.setAttribute("aria-hidden", "true");
        if (restoreFocus) {
          const target = focusTarget || activeTrigger || lastSosTrigger || triggers[0] || null;
          if (target) {
            window.requestAnimationFrame(() => target.focus());
          }
        }
      }
    };

    triggers.forEach(trigger => {
      trigger.addEventListener("click", () => {
        activeTrigger = trigger;
        lastSosTrigger = trigger;
        setSosOpen(true);
      });
    });

    if (closeBtn) {
      closeBtn.addEventListener("click", () => setSosOpen(false));
    }

    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        setSosOpen(false);
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && sosOpen) {
        setSosOpen(false);
      }
    });

    if (shieldBtn) {
      shieldBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        activateShield();
      });
    }

    if (defuseBtn) {
      defuseBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        lastDefuseOpener = activeTrigger || lastSosTrigger || triggers[0] || null;
        openDefuseOverlay();
      });
    }

    if (worstDayBtn) {
      worstDayBtn.addEventListener("click", () => setSosOpen(false, { restoreFocus: false }));
    }
  }

  function initializeCommandBarAutohide() {
    const bar = document.querySelector(".command-bar");
    if (!bar) return;
    let lastScrollY = window.scrollY || 0;
    let rafId = null;
    let hidden = false;

    const evaluate = () => {
      rafId = null;
      const currentY = window.scrollY || 0;
      const delta = currentY - lastScrollY;
      const hide = currentY > 96 && delta > 6;
      const reveal = delta < -6 || currentY <= 96;
      if (hide && !hidden) {
        bar.classList.add("is-hidden");
        hidden = true;
      } else if (reveal && hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = currentY;
    };

    window.addEventListener(
      "scroll",
      () => {
        if (rafId !== null) return;
        rafId = window.requestAnimationFrame(evaluate);
      },
      { passive: true }
    );

    window.addEventListener("focusin", () => {
      if (hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = window.scrollY || 0;
    });
  }

  function initializeTaskForm() {
    setTaskDetailsCollapsed(true);
    const expandBtn = $("expandTaskDetailsButton");
    if (expandBtn) {
      expandBtn.addEventListener("click", toggleTaskDetails);
    }
    const templateBtn = $("btn-use-template");
    if (templateBtn) {
      templateBtn.addEventListener("click", () => {
        setAddTaskCardCollapsed(false, { skipFocus: true });
        openTemplateModal();
      });
    }
    const saveTemplateBtn = $("btn-save-template");
    if (saveTemplateBtn) {
      saveTemplateBtn.addEventListener("click", () => saveAsTemplate());
    }
    const openCardBtn = $("openAddTaskPanel");
    if (openCardBtn) {
      openCardBtn.addEventListener("click", () => setAddTaskCardCollapsed(false));
    }
    const closeBtn = $("addTaskClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => setAddTaskCardCollapsed(true));
    }
    const overlay = $("addTaskOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
      document.addEventListener("keydown", event => {
        if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
    }
    const modal = $("template-modal");
    if (modal) {
      modal.addEventListener("click", event => {
        if (event.target === modal) {
          closeTemplateModal();
        }
      });
      const closeBtn = modal.querySelector(".modal__close");
      if (closeBtn) {
        closeBtn.addEventListener("click", closeTemplateModal);
      }
    }
    syncAddTaskActions();
    const nameInput = $("name");
    if (nameInput) {
      nameInput.addEventListener("input", syncAddTaskActions);
    }
  }
// === START: Long-press Quick Capture from Focus button ===
function initializeFocusFabLongPress() {
  const fab = document.getElementById("nextTaskActionButton");
  if (!fab) return;

  const LONG_PRESS_MS = 600;
  let timer = null;

  fab.addEventListener("pointerdown", () => {
    timer = setTimeout(() => {
      // open your Quick Capture modal
      openModal();
    }, LONG_PRESS_MS);
  });

  ["pointerup", "pointerleave", "pointercancel"].forEach(type =>
    fab.addEventListener(type, () => clearTimeout(timer))
  );
}

// Call this once at startup
initializeFocusFabLongPress();
// === END: Long-press Quick Capture from Focus button ===
    
  // main UI update
  function updateUI() {
    tasks = tasks.map(recalcTaskPriority);
    persist();
    renderCategoryFilter();
    renderCategoryProgress();

    const totalTasks = tasks.length;
    const activeTasksCount = tasks.filter(t => !isTaskCompleted(t)).length;
    getAllTasksCards().forEach(({ title, summaryText, summaryChip }) => {
      if (title) {
        title.textContent = `All Tasks (${totalTasks})`;
      }
      if (summaryText) {
        summaryText.textContent = totalTasks
          ? `${activeTasksCount} active • ${totalTasks} total`
          : "No tasks yet";
      }
      if (summaryChip) {
        if (totalTasks) {
          summaryChip.textContent = activeCategory === "All" ? "All categories" : activeCategory;
          summaryChip.classList.remove("hidden");
        } else {
          summaryChip.classList.add("hidden");
        }
      }
    });

    const taskList = $("taskList");
    taskList.innerHTML = "";

    const taskViewSelect = $("taskViewMode");
    if (taskViewSelect) {
      taskViewSelect.value = taskListMode;
    }

    if (taskListMode !== TASK_LIST_MODES.ACTIVE) {
      showAllActiveTasks = false;
    }

    const eligibleTasks = tasks.filter(t => activeCategory === "All" || t.category === activeCategory);
    const remaining = eligibleTasks.filter(t => !isTaskCompleted(t));
    const startBtn = $("startBtn");
    if (startBtn) {
      startBtn.dataset.hasTasks = remaining.length > 0 ? "true" : "false";
    }
    syncAddTaskActions();
    const timeBudget = getTimeBudgetMinutes();
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const hasTimeBudget = Number.isFinite(timeBudget);
    const sortedRemaining = [...remaining].sort((a, b) => b.priority - a.priority);
    const budgetFilteredRemaining = hasTimeBudget
      ? sortedRemaining.filter(task => estimateTaskMinutes(task) <= timeBudget)
      : sortedRemaining;

    const toggleBtn = $("showAllToggle");
    if (toggleBtn) {
      if (taskListMode !== TASK_LIST_MODES.ACTIVE || budgetFilteredRemaining.length <= 3) {
        toggleBtn.classList.add("hidden");
        toggleBtn.textContent = "Show All";
      } else {
        toggleBtn.classList.remove("hidden");
        toggleBtn.textContent = showAllActiveTasks ? "Show Top 3" : "Show All";
      }
    }

    let displayTasks = [];
    if (taskListMode === TASK_LIST_MODES.COMPLETED) {
      displayTasks = eligibleTasks
        .filter(t => isTaskCompleted(t))
        .sort((a, b) => {
          const aDate = getCompletionTimestamp(a) ? new Date(getCompletionTimestamp(a)).getTime() : 0;
          const bDate = getCompletionTimestamp(b) ? new Date(getCompletionTimestamp(b)).getTime() : 0;
          return bDate - aDate;
        });
    } else {
      const pool = budgetFilteredRemaining;
      if (pool.length <= 3 || showAllActiveTasks) {
        displayTasks = pool;
      } else {
        displayTasks = pool.slice(0, 3);
      }
    }

    if (!displayTasks.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      if (taskListMode === TASK_LIST_MODES.ACTIVE && hasTimeBudget && remaining.length > 0 && budgetFilteredRemaining.length === 0) {
        empty.textContent = "No tasks fit the selected time budget.";
      } else {
        empty.textContent = taskListMode === TASK_LIST_MODES.COMPLETED
          ? "No completed tasks yet."
          : "No active tasks to show.";
      }
      taskList.appendChild(empty);
    } else {
      displayTasks.forEach(task => {
        const card = renderTaskListCard(task, taskListMode, hasTimeBudget ? timeBudget : null);
        taskList.appendChild(card);
      });
    }

    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const today = now.toISOString().split("T")[0];
    const dueTodayEntries = [];

    tasks.forEach(task => {
      if (isTaskCompleted(task)) return;
      if (activeCategory !== "All" && task.category !== activeCategory) return;

      const fallbackDueDate = (!task.dueDate && task.dateOfService)
        ? (() => {
            const dt = new Date(`${task.dateOfService}T00:00:00`);
            if (!Number.isNaN(dt.getTime())) {
              dt.setDate(dt.getDate() + 3);
              return dt.toISOString().split("T")[0];
            }
            return null;
          })()
        : null;

      if (task.dueDate === today || (fallbackDueDate && fallbackDueDate === today)) {
        dueTodayEntries.push({
          task,
          fallback: Boolean(fallbackDueDate && !task.dueDate)
        });
      }
    });

    dueTodayEntries.sort((a, b) => computeFocusScore(b.task, energyLevel, timeBudget) - computeFocusScore(a.task, energyLevel, timeBudget));
    renderDueTodayList(dueTodayEntries);
    updateNextTaskCard();
    updateNextBestOptions();
    updateConflictResolver();
    refreshGanttSnapshotIfOpen();
    updateWorstDayBanner();
    updateSleepToolkitUI();
    refreshTaskGestureTargets();
  }

  function toggleShowAllActive() {
    if (taskListMode !== TASK_LIST_MODES.ACTIVE) return;
    showAllActiveTasks = !showAllActiveTasks;
    updateUI();
  }

  function startFocus(initialTaskId = null, options = {}) {
    if (editingTaskId) cancelEdit();
    if (options && options.expandDetails) {
      setTaskDetailsCollapsed(false);
    }
    const sprintMinutes = Number(options?.sprintMinutes);
    stopFocusTimer();
    if (Number.isFinite(sprintMinutes) && sprintMinutes > 0) {
      sprintDurationMinutes = sprintMinutes;
    } else {
      sprintDurationMinutes = null;
    }
    setSprintVisualState(Boolean(sprintDurationMinutes));
    setFocusLaunchOpen(false);
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.setAttribute("aria-hidden", "true");
    }
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.remove("hidden");
      focusSection.setAttribute("aria-hidden", "false");
      const focusSheet = focusSection.querySelector(".focus-overlay__sheet");
      if (focusSheet) {
        window.requestAnimationFrame(() => focusSheet.focus());
      }
    }
    document.body.classList.add("focus-overlay-active");
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    lastFocusEnergyLevel = energyLevel;
    lastFocusTimeBudget = timeBudget;
    const score = task => Number(task?.priority || 0) * energyFit(task, energyLevel) * timeFit(task, timeBudget);
    focusQueue = tasks
      .filter(t => !isTaskCompleted(t) && (activeCategory === "All" || t.category === activeCategory))
      .sort((a, b) => score(b) - score(a));
    if (initialTaskId) {
      const targetIndex = focusQueue.findIndex(task => task.id === initialTaskId);
      if (targetIndex > 0) {
        const [selected] = focusQueue.splice(targetIndex, 1);
        focusQueue.unshift(selected);
      } else if (targetIndex === -1) {
        const directTask = tasks.find(t => t.id === initialTaskId && !isTaskCompleted(t));
        if (directTask) {
          focusQueue.unshift(directTask);
        }
      }
    }
    showNextTask();
  }

  function showNextTask() {
    const display = document.querySelector(".focus");
    const scoreView = $("scoreView");
    if (focusQueue.length === 0) {
      display.textContent = "✅ All tasks complete!";
      scoreView.textContent = "";
      updateFocusFitHint(null, lastFocusEnergyLevel, lastFocusTimeBudget);
      const subTaskView = $("subTaskView");
      if (subTaskView) subTaskView.innerHTML = "";
      clearRunningTimers();
      stopFocusTimer();
      currentFocusTaskIndex = null;
      setSprintVisualState(false);
      return;
    }
    const current = focusQueue[0];
    display.textContent = current.name;
    startFocusTimer();
    const idx = tasks.findIndex(t => t.id === current.id);
    const task = idx !== -1 ? tasks[idx] : current;
    scoreView.textContent = `Score: ${task.priority.toFixed(1)}`;
    updateFocusFitHint(task, lastFocusEnergyLevel, lastFocusTimeBudget);
    renderFocusTask(task, idx);
  }

  function updateFocusFitHint(task, energyLevel, timeBudget) {
    const hintEl = $("focusFitHint");
    if (!hintEl) return;
    if (!task) {
      hintEl.textContent = "";
      return;
    }
    const pieces = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(timeBudget)) {
      if (Number.isFinite(estimated) && estimated > 0) {
        const rounded = Math.max(1, Math.round(estimated));
        if (rounded <= timeBudget) {
          pieces.push(`Fits your ${timeBudget}-minute block (est. ${rounded} min)`);
        } else {
          pieces.push(`Stretch past ${timeBudget}-minute block (est. ${rounded} min)`);
        }
      } else {
        pieces.push(`Focus window: ${timeBudget} min`);
      }
    }
    if (Number.isFinite(energyLevel)) {
      const difficulty = clampScale(task?.difficulty, 3);
      if (energyLevel <= 2) {
        if (estimated <= 20) {
          pieces.push("Easiest win for low energy");
        } else {
          pieces.push("Try a 5-min pass—energy is low");
        }
      } else if (energyLevel >= 4) {
        if (difficulty >= 4) {
          pieces.push("Perfect for your high energy window");
        } else {
          pieces.push("Use the high energy to bank progress");
        }
      } else if (ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
        pieces.push(`Energy check: ${ENERGY_LABELS[energyLevel]}`);
      }
    }
    hintEl.textContent = pieces.length ? pieces.join(" • ") : "Working the highest-impact task next.";
  }

  function completeTaskById(taskId, options = {}) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (task.completed) return false;
    const nowIso = new Date().toISOString();
    task.completed = true;
    task.completedAt = nowIso;
    updateChartDurationForTask(task);
    if (Array.isArray(task.subTasks)) {
      task.subTasks.forEach(sub => stopTimerForSubTask(sub.id));
    }
    persist();
    recordTaskCompletion(task);
    maybeShowEndOfDayAudit();
    if (!options.skipUI) {
      updateUI();
    }
    return true;
  }

  function markTaskDoneFromPeek(taskId) {
    const completed = completeTaskById(taskId);
    if (!completed) return;
    const wasCurrentFocus = focusQueue.length && focusQueue[0].id === taskId;
    focusQueue = focusQueue.filter(t => t.id !== taskId);
    if (wasCurrentFocus) {
      clearRunningTimers();
      stopFocusTimer();
    }
    const focusSection = $("focus");
    if (focusSection && !focusSection.classList.contains("hidden")) {
      showNextTask();
    }
  }

  function completeTask() {
    if (!focusQueue.length) return;
    const current = focusQueue[0];
    const completed = completeTaskById(current.id, { skipUI: true });
    clearRunningTimers();
    if (completed) {
      updateUI();
    }
    focusQueue.shift();
    showNextTask();
  }

  function backToCapture() {
    clearRunningTimers();
    stopFocusTimer();
    currentFocusTaskIndex = null;
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.add("hidden");
      focusSection.setAttribute("aria-hidden", "true");
    }
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.classList.remove("hidden");
      captureSection.removeAttribute("aria-hidden");
    }
    document.body.classList.remove("focus-overlay-active");
    setSprintVisualState(false);
    setFocusLaunchOpen(false);
    updateUI();
  }

  function reset() {
    if (!confirm("Clear all tasks?")) return;
    cancelEdit();
    tasks = [];
    localStorage.removeItem("tasks");
    updateUI();
  }

  function saveAsTemplate() {
    const name = $("name").value.trim();
    if (!name) return alert("Task name is required");
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const template = {
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1)
    };
    templates.push(template);
    localStorage.setItem("templates", JSON.stringify(templates));
    renderTemplates();
  }

  function renderTemplates() {
    const container = $("templateButtons");
    const selectedCategory = $("taskCategory")?.value || "General";
    const matchingTemplates = templates
      .map((template, index) => ({ template, index }))
      .filter(({ template }) => (template.category || "General") === selectedCategory);

    const useTemplateBtn = $("btn-use-template");
    if (useTemplateBtn) {
      const hasTemplates = matchingTemplates.length > 0;
      useTemplateBtn.disabled = !hasTemplates;
      useTemplateBtn.setAttribute("aria-disabled", hasTemplates ? "false" : "true");
      useTemplateBtn.title = hasTemplates ? "" : "No templates for this category yet";
    }

    updateTemplateModalForCategory(selectedCategory);

    if (!container) return;

    container.innerHTML = "";

    if (!matchingTemplates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      container.appendChild(empty);
      return;
    }

    matchingTemplates.forEach(({ template: t, index: templateIndex }) => {
      const wrapper = document.createElement("div");
      const useBtn = document.createElement("button");
      useBtn.textContent = `📋 ${t.name}`;
      useBtn.onclick = () => {
        applyTemplate(t);
      };
      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Edit template";
      editBtn.setAttribute("aria-label", "Edit template");
      editBtn.onclick = () => {
        const newName = prompt("Edit template name:", t.name);
        if (!newName) return;
        t.name = newName;
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Delete template";
      deleteBtn.setAttribute("aria-label", "Delete template");
      deleteBtn.onclick = () => {
        if (!confirm("Delete this template?")) return;
        templates.splice(templateIndex, 1);
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      [useBtn, editBtn, deleteBtn].forEach(b => {
        b.style.marginRight = "0.3rem";
        b.style.fontSize = "0.9rem";
      });
      wrapper.appendChild(useBtn);
      wrapper.appendChild(editBtn);
      wrapper.appendChild(deleteBtn);
      container.appendChild(wrapper);
    });
  }

  function normalizeBlockBatchProfile(profile = {}) {
    const normalized = {
      category: profile.category || "General",
      authorType: profile.authorType || "attending",
      patientType: normalizePatientType(profile.patientType || "Non-Complex"),
      visitType: normalizeVisitType(profile.visitType || "Follow-Up"),
      clinicSite: normalizeClinicSite(profile.clinicSite || "General Clinic"),
      importance: clampScale(profile.importance, 1),
      urgency: clampScale(profile.urgency, 3),
      novelty: clampScale(profile.novelty, 1),
      interest: clampScale(profile.interest, 1),
      externalPressure: clampScale(profile.externalPressure, 1),
      timeToStart: clampScale(profile.timeToStart, 1),
      difficulty: clampScale(profile.difficulty, 1),
      useChartTemplate: Boolean(profile.useChartTemplate)
    };
    if (Array.isArray(profile.subTasks)) {
      normalized.subTasks = profile.subTasks.map(line => line.trim()).filter(Boolean);
    } else if (typeof profile.subTasks === "string") {
      normalized.subTasks = profile.subTasks
        .split("\n")
        .map(line => line.trim())
        .filter(Boolean);
    } else {
      normalized.subTasks = [];
    }
    return normalized;
  }

  function getBlockBatchDefinition(batchId) {
    return DEFAULT_BLOCK_BATCHES.find(batch => batch.id === batchId) || null;
  }

  function getBlockBatchProfile(batchId) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return null;
    const base = normalizeBlockBatchProfile(definition.defaultProfile);
    const stored = blockBatchProfiles[batchId];
    if (!stored) {
      return { ...base };
    }
    const overrides = normalizeBlockBatchProfile(stored);
    const merged = { ...base, ...overrides };
    merged.subTasks = overrides.subTasks.slice();
    merged.useChartTemplate = overrides.useChartTemplate;
    return merged;
  }

  function loadBlockBatchProfiles() {
    const saved = localStorage.getItem(BLOCK_BATCH_STORAGE_KEY);
    blockBatchProfiles = {};
    if (!saved) return;
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") {
        Object.entries(parsed).forEach(([batchId, profile]) => {
          if (!getBlockBatchDefinition(batchId)) return;
          blockBatchProfiles[batchId] = normalizeBlockBatchProfile(profile);
        });
      }
    } catch (error) {
      console.warn("Block batch profiles could not be parsed", error);
      blockBatchProfiles = {};
    }
  }

  function saveBlockBatchProfiles() {
    localStorage.setItem(BLOCK_BATCH_STORAGE_KEY, JSON.stringify(blockBatchProfiles));
  }

  function renderBlockBatchList() {
    const list = $("blockBatchList");
    if (!list) return;
    list.innerHTML = "";
    const activeId = blockBatchState.activeId || (DEFAULT_BLOCK_BATCHES[0]?.id || null);
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const item = document.createElement("div");
      item.className = "block-batch-item";
      item.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        item.classList.add("is-active");
      }
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "block-batch-item__edit";
      editBtn.setAttribute("aria-label", `Edit ${definition.label} default profile`);
      editBtn.textContent = "✏️";
      editBtn.addEventListener("click", event => {
        event.preventDefault();
        event.stopPropagation();
        showBlockBatchEditor(definition.id);
      });
      const selectBtn = document.createElement("button");
      selectBtn.type = "button";
      selectBtn.className = "block-batch-item__select";
      selectBtn.textContent = definition.label;
      selectBtn.setAttribute("role", "option");
      selectBtn.setAttribute("aria-selected", definition.id === activeId ? "true" : "false");
      selectBtn.addEventListener("click", () => setActiveBlockBatch(definition.id, { focusInput: true }));
      item.appendChild(editBtn);
      item.appendChild(selectBtn);
      list.appendChild(item);
    });
  }

  function renderBlockBatchCounts() {
    const container = $("blockBatchCounts");
    if (!container) return;
    container.innerHTML = "";
    const activeId = blockBatchState.activeId;
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const label = document.createElement("label");
      label.className = "block-batch-count";
      label.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        label.classList.add("is-active");
      }
      const title = document.createElement("span");
      title.textContent = definition.label;
      const input = document.createElement("input");
      input.type = "number";
      input.id = `blockBatchCount-${definition.id}`;
      input.name = `blockBatchCount-${definition.id}`;
      input.min = "0";
      input.step = "1";
      const current = Number(blockBatchState.counts?.[definition.id] || 0);
      input.value = String(current);
      input.addEventListener("input", () => {
        const parsed = Math.max(0, Math.floor(Number(input.value) || 0));
        input.value = String(parsed);
        blockBatchState.counts[definition.id] = parsed;
      });
      input.addEventListener("focus", () => {
        if (blockBatchState.activeId !== definition.id) {
          setActiveBlockBatch(definition.id);
        } else {
          updateBlockBatchHighlights();
        }
      });
      label.appendChild(title);
      label.appendChild(input);
      container.appendChild(label);
    });
  }

  function updateBlockBatchHighlights({ focusInput = false } = {}) {
    const activeId = blockBatchState.activeId;
    const list = $("blockBatchList");
    if (list) {
      list.querySelectorAll(".block-batch-item").forEach(item => {
        const isActive = item.dataset.batchId === activeId;
        item.classList.toggle("is-active", isActive);
        const optionBtn = item.querySelector(".block-batch-item__select");
        if (optionBtn) {
          optionBtn.setAttribute("aria-selected", isActive ? "true" : "false");
        }
      });
    }
    const countsContainer = $("blockBatchCounts");
    if (countsContainer) {
      countsContainer.querySelectorAll(".block-batch-count").forEach(wrapper => {
        wrapper.classList.toggle("is-active", wrapper.dataset.batchId === activeId);
      });
    }
    if (focusInput) {
      const targetInput = document.getElementById(`blockBatchCount-${activeId}`);
      if (targetInput) {
        window.setTimeout(() => {
          targetInput.focus();
          targetInput.select();
        }, 0);
      }
    }
  }

  function setActiveBlockBatch(batchId, options = {}) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return;
    blockBatchState.activeId = definition.id;
    updateBlockBatchHighlights(options);
  }

  function populateBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    const profile = getBlockBatchProfile(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (!profile || !definition) return;
    editor.dataset.batchId = batchId;
    const title = $("blockBatchEditorTitle");
    if (title) {
      title.textContent = `Edit default profile · ${definition.label}`;
    }
    const setValue = (id, value) => {
      const field = $(id);
      if (!field) return;
      field.value = value;
    };
    setValue("blockBatchCategory", profile.category || "General");
    setValue("blockBatchAuthor", profile.authorType || "attending");
    setValue("blockBatchPatient", profile.patientType || "Non-Complex");
    setValue("blockBatchVisit", profile.visitType || "Follow-Up");
    setValue("blockBatchClinic", profile.clinicSite || "General Clinic");
    setValue("blockBatchImportance", String(profile.importance || 1));
    setValue("blockBatchUrgency", String(profile.urgency || 3));
    setValue("blockBatchNovelty", String(profile.novelty || 1));
    setValue("blockBatchInterest", String(profile.interest || 1));
    setValue("blockBatchExternalPressure", String(profile.externalPressure || 1));
    setValue("blockBatchTimeToStart", String(profile.timeToStart || 1));
    setValue("blockBatchDifficulty", String(profile.difficulty || 1));
    const subtasksField = $("blockBatchSubtasks");
    if (subtasksField) {
      subtasksField.value = (profile.subTasks || []).join("\n");
    }
    const templateToggle = $("blockBatchUseChartTemplate");
    if (templateToggle) {
      templateToggle.checked = Boolean(profile.useChartTemplate);
    }
  }

  function showBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    setActiveBlockBatch(batchId);
    populateBlockBatchEditor(batchId);
    editor.classList.remove("hidden");
    const firstField = editor.querySelector("select, textarea, input");
    if (firstField) {
      window.setTimeout(() => firstField.focus(), 0);
    }
  }

  function hideBlockBatchEditor() {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    editor.classList.add("hidden");
    delete editor.dataset.batchId;
  }

  function handleBlockBatchSaveProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    const profile = normalizeBlockBatchProfile({
      category: $("blockBatchCategory")?.value || "General",
      authorType: $("blockBatchAuthor")?.value || "attending",
      patientType: $("blockBatchPatient")?.value || "Non-Complex",
      visitType: $("blockBatchVisit")?.value || "Follow-Up",
      clinicSite: $("blockBatchClinic")?.value || "General Clinic",
      importance: $("blockBatchImportance")?.value || 1,
      urgency: $("blockBatchUrgency")?.value || 3,
      novelty: $("blockBatchNovelty")?.value || 1,
      interest: $("blockBatchInterest")?.value || 1,
      externalPressure: $("blockBatchExternalPressure")?.value || 1,
      timeToStart: $("blockBatchTimeToStart")?.value || 1,
      difficulty: $("blockBatchDifficulty")?.value || 1,
      subTasks: $("blockBatchSubtasks")?.value || "",
      useChartTemplate: $("blockBatchUseChartTemplate")?.checked || false
    });
    blockBatchProfiles[batchId] = profile;
    saveBlockBatchProfiles();
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile saved.`);
    }
    hideBlockBatchEditor();
  }

  function handleBlockBatchResetProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    delete blockBatchProfiles[batchId];
    saveBlockBatchProfiles();
    populateBlockBatchEditor(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile reset to default.`);
    }
  }

  function buildBlockBatchTaskName(prefix, serviceDate, index) {
    const date = serviceDate instanceof Date && !Number.isNaN(serviceDate.getTime()) ? serviceDate : new Date();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${prefix}_${month}_${day}_pt${index + 1}`;
  }

  function buildTaskFromBatchProfile(profile, overrides = {}) {
    if (!profile) return null;
    const normalized = normalizeBlockBatchProfile(profile);
    const nowIso = new Date().toISOString();
    const dateOfService = overrides.dateOfService || null;
    const dueDate = overrides.dueDate || null;
    const task = {
      id: `${Date.now()}-${blockBatchIdCounter++}`,
      name: overrides.name || "Block Batch Task",
      category: normalized.category,
      authorType: normalized.authorType,
      patientType: normalized.patientType,
      visitType: normalized.visitType,
      clinicSite: normalized.clinicSite,
      dateOfService,
      daysSinceVisit: calculateDaysSince(dateOfService),
      importance: normalized.importance,
      urgency: normalized.urgency,
      novelty: normalized.novelty,
      interest: normalized.interest,
      externalPressure: normalized.externalPressure,
      timeToStart: normalized.timeToStart,
      difficulty: normalized.difficulty,
      dueDate,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: Boolean(normalized.useChartTemplate)
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = Array.isArray(normalized.subTasks) ? normalized.subTasks : [];
    task.subTasks = subLines.map(line => createSubTask(line, basePriority));
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    return task;
  }

  function resetBlockBatchCounts() {
    blockBatchState.counts = {};
    const container = $("blockBatchCounts");
    if (container) {
      container.querySelectorAll('input[type="number"]').forEach(input => {
        input.value = "0";
      });
    }
  }

  function handleBlockBatchAdd() {
    const dateField = $("blockBatchDate");
    const rawDate = dateField && dateField.value ? dateField.value : null;
    let serviceDateObj = rawDate ? new Date(rawDate) : new Date();
    if (Number.isNaN(serviceDateObj.getTime())) {
      serviceDateObj = new Date();
    }
    const serviceDate = formatDateForInput(serviceDateObj);
    const dueDate = formatDateForInput(addDays(serviceDateObj, 3));
    const additions = [];
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const count = Math.max(0, Number(blockBatchState.counts?.[definition.id] || 0));
      if (!count) return;
      const profile = getBlockBatchProfile(definition.id);
      for (let index = 0; index < count; index += 1) {
        const name = buildBlockBatchTaskName(definition.prefix, serviceDateObj, index);
        const task = buildTaskFromBatchProfile(profile, {
          name,
          dateOfService: serviceDate,
          dueDate
        });
        if (task) {
          additions.push(task);
        }
      }
    });
    if (!additions.length) {
      showToast("Block Batch", "Set at least one batch count to add tasks.");
      return;
    }
    additions.forEach(task => tasks.push(task));
    persist();
    updateUI();
    showToast("Block Batch", `Added ${additions.length} tasks.`);
    resetBlockBatchCounts();
    closeBlockBatchModal();
  }

  function updateBlockBatchModal({ focusActive = false } = {}) {
    renderBlockBatchList();
    renderBlockBatchCounts();
    updateBlockBatchHighlights({ focusInput: focusActive });
  }

  function openBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    loadBlockBatchProfiles();
    if (!blockBatchState.activeId && DEFAULT_BLOCK_BATCHES.length) {
      blockBatchState.activeId = DEFAULT_BLOCK_BATCHES[0].id;
    }
    updateBlockBatchModal({ focusActive: true });
    hideBlockBatchEditor();
    const dateField = $("blockBatchDate");
    if (dateField) {
      const today = formatDateForInput(new Date());
      dateField.value = dateField.value || today;
    }
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    const firstOption = modal.querySelector(".block-batch-item__select");
    if (firstOption) {
      window.setTimeout(() => firstOption.focus(), 0);
    }
  }

  function closeBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    hideBlockBatchEditor();
    resetBlockBatchCounts();
  }

  function initializeBlockBatchModule() {
    const openBtn = $("blockBatchOpen");
    const modal = $("block-batch-modal");
    if (!openBtn || !modal) return;
    openBtn.addEventListener("click", () => openBlockBatchModal());
    const closeBtn = modal.querySelector(".modal__close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeBlockBatchModal());
    }
    modal.addEventListener("click", event => {
      if (event.target === modal) {
        closeBlockBatchModal();
      }
    });
    modal.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        event.stopPropagation();
        closeBlockBatchModal();
      }
    });
    const saveBtn = $("blockBatchSaveProfile");
    if (saveBtn) {
      saveBtn.addEventListener("click", handleBlockBatchSaveProfile);
    }
    const resetBtn = $("blockBatchResetProfile");
    if (resetBtn) {
      resetBtn.addEventListener("click", handleBlockBatchResetProfile);
    }
    const closeEditorBtn = $("blockBatchEditorClose");
    if (closeEditorBtn) {
      closeEditorBtn.addEventListener("click", hideBlockBatchEditor);
    }
    const addBtn = $("blockBatchAdd");
    if (addBtn) {
      addBtn.addEventListener("click", handleBlockBatchAdd);
    }
    loadBlockBatchProfiles();
  }

  function updateHeaderSubtitle() {
    const subtitle = $("headerSubtitle");
    if (!subtitle) return;
    try {
      const formatted = new Date().toLocaleDateString(undefined, {
        weekday: "long",
        month: "short",
        day: "numeric"
      });
      subtitle.textContent = formatted;
    } catch (error) {
      subtitle.textContent = "";
    }
  }

  function updateBillingReminder() {
    const reminder = $("billingReminder");
    if (!reminder) return;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 95);
    const formatted = cutoff.toLocaleDateString(undefined, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
    reminder.innerHTML = `<span class="header-chip"><span class="header-chip__label">Eligibility cutoff</span><span class="header-chip__value">${formatted}</span></span>`;
  }

  function registerFieldListeners() {
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.addEventListener("change", () => {
        updateDerivedFields();
      });
    }
    const categoryField = $("taskCategory");
    if (categoryField) {
      categoryField.addEventListener("change", event => {
        handleCategoryChange(event.target.value);
      });
    }
    const urgencyField = $("urgency");
    if (urgencyField) {
      urgencyField.addEventListener("change", () => {
        urgencyAuto = false;
        updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
      });
    }
  }

  function registerTaskListModeControl() {
    const modeSelect = $("taskViewMode");
    if (!modeSelect) return;
    modeSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_LIST_MODES.ACTIVE).toLowerCase();
      taskListMode = value === TASK_LIST_MODES.COMPLETED ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      showAllActiveTasks = false;
      updateUI();
    });
  }

  function registerTimeBudgetControl() {
    const budgetSelect = $("timeBudget");
    if (!budgetSelect) return;
    budgetSelect.addEventListener("change", () => {
      updateUI();
    });
  }

  function registerCategoryFilterControl() {
    const categorySelect = $("taskCategoryFilter");
    if (!categorySelect) return;
    categorySelect.addEventListener("change", event => {
      const value = (event.target.value || "All").toString();
      activeCategory = categories.includes(value) || value === "All" ? value : "All";
      updateUI();
    });
  }

  function triggerStartReward(button) {
    if (!button) return;
    button.classList.add("start-action");
    button.classList.remove("cta-reward-active");
    void button.offsetWidth;
    button.classList.add("cta-reward-active");
    if (navigator?.vibrate) {
      navigator.vibrate(12);
    }
    window.setTimeout(() => {
      button.classList.remove("cta-reward-active");
    }, 240);
  }

  function markStartRewardButtons() {
    const buttons = document.querySelectorAll("button");
    buttons.forEach(button => {
      if (button.dataset.startReward === "ready") return;
      const label = (button.textContent || button.getAttribute("aria-label") || "")
        .trim()
        .toLowerCase();
      if (!label.startsWith("start")) return;
      button.dataset.startReward = "ready";
      button.classList.add("start-action");
      button.addEventListener("click", () => triggerStartReward(button));
    });
  }

  function setupStartRewardObserver() {
    markStartRewardButtons();
    const observer = new MutationObserver(() => {
      markStartRewardButtons();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }

  window.addEventListener('DOMContentLoaded', () => {
    const nextStepBtn = $("meltdownShieldNext");
    if (nextStepBtn) {
      nextStepBtn.addEventListener("click", completeCurrentMeltdownStep);
    }
    prepareAccordionContainers();
    function showToast(message, duration = 2000) {
  const toast = document.createElement("div");
  toast.textContent = message;
  Object.assign(toast.style, {
    position: "fixed",
    bottom: "90px",
    left: "50%",
    transform: "translateX(-50%)",
    background: "#00bfa5", // teal
    color: "#fff",
    padding: "10px 18px",
    borderRadius: "20px",
    fontSize: "14px",
    boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
    opacity: "0",
    transition: "opacity 0.3s ease",
    zIndex: "9999",
  });
  document.body.appendChild(toast);
  requestAnimationFrame(() => (toast.style.opacity = "1"));
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 300);
  }, duration);
    }
    restoreBriefModePreference();
    setupMomentumZones();
    setupNextBestObserver();
    setupSmartCollapse();
    setupTaskGestures();
    setupFocusOverlay();
    setupLazyMedia();
    initializeChartFields();
    registerFieldListeners();
    registerTaskListModeControl();
    registerTimeBudgetControl();
    setDefaultFieldValues();
    updateHeaderSubtitle();
    updateBillingReminder();
    initializeSoundPreference();
    initializeFirstThreeWizard();
    initializeTaskForm();
    initializeBlockBatchModule();
    initializeAddTaskCardState();
    initializePreflightToggles();
    initializeDueTodayAccordionState();
    initializeAllTasksCardState();
    initializeFocusLaunchSheet();
    initializeQuickCaptureModal();

// === START: Accordions ===
// Existing accordion wiring lives in renderDueTodayList and initializeAllTasksCardState.
// Keep the two sections mutually exclusive by collapsing the other when one opens.
// === END: Accordions ===
    
    initializeResourcesDrawer();
    initializeSosPanel();
    initializeCommandBarAutohide();
    initializeDefuseOverlay();
    initializeCollapsibleModules();
    initializeMorningLaunchModule();
    initializeLaunchPadModule();
    initializeSleepToolkitModule();
    initializeNextBestEngine();
    initializeConflictResolverModule();
    initializeDefuseMode();
    initializeDopamineModule();
    initializeDistractionTools();
    initializeGanttSnapshot();
    initializeWorstDayMode();
    const saved = localStorage.getItem("tasks");
    if (saved) {
      tasks = JSON.parse(saved).map(task => {
        const normalizedTask = {
          ...task,
          authorType: task.authorType || "attending",
          patientType: normalizePatientType(task.patientType),
          visitType: normalizeVisitType(task.visitType),
          clinicSite: normalizeClinicSite(task.clinicSite),
          dateOfService: task.dateOfService || null,
          createdAt: task.createdAt || task.addedAt || new Date().toISOString()
        };
        if (normalizedTask.dateOfService) {
          normalizedTask.daysSinceVisit = calculateDaysSince(normalizedTask.dateOfService);
        }
        return recalcTaskPriority(normalizedTask);
      });
    }
    const savedTemplates = localStorage.getItem("templates");
    if (savedTemplates) {
      templates = JSON.parse(savedTemplates).map(template => ({
        ...template,
        authorType: template.authorType || "attending",
        patientType: normalizePatientType(template.patientType),
        visitType: normalizeVisitType(template.visitType),
        clinicSite: normalizeClinicSite(template.clinicSite)
      }));
    }
    registerCategoryFilterControl();
    setupStartRewardObserver();
    startReminderLoop();
    renderTemplates();
    updateUI();
    updateSleepToolkitUI();
    updateDerivedFields();
  });
  </script>
    <script>
  (function () {
    const root = document.querySelector('.focus-command-deck');
    if (!root) return;

    const fill = root.querySelector('.cm-fill');
    const doneEl = root.querySelector('.cm-done');
    const totalEl = root.querySelector('.cm-total');
    const floatEl = root.querySelector('.cm-float');

    function zone(pct) {
      if (pct >= 1) return 'high';
      if (pct >= 0.3) return 'mid';
      return 'low';
    }

    function setFill(pct) {
      const z = zone(pct);
      fill.dataset.zone = z;
      fill.style.width = (pct * 100).toFixed(0) + '%';
    }

    window.updateChartProgress = function (completed, total) {
      const prev = parseFloat((fill.style.width || '0').replace('%', '')) / 100 || 0;
      const pct = total > 0 ? completed / total : 0;

      doneEl.textContent = completed;
      totalEl.textContent = total;
      setFill(pct);

      floatEl.textContent = Math.round(pct * 100) + '% complete';
      floatEl.style.opacity = '1';
      floatEl.style.transform = 'translateY(-4px)';

      setTimeout(() => {
        floatEl.style.opacity = '0';
        floatEl.style.transform = 'translateY(-10px)';
      }, 700);

      if (pct > prev || pct >= 1) {
        fill.classList.remove('pulse');
        void fill.offsetWidth; // force reflow
        fill.classList.add('pulse');
      }
    };

    // Optional: initialize from any existing DOM values
    const initDone = parseInt(doneEl.textContent, 10) || 0;
    const initTotal = parseInt(totalEl.textContent, 10) || 0;
    setFill(initTotal ? initDone / initTotal : 0);
  })();
    </script>
</body>
</html>

