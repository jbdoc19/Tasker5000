<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Task Focus</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1, h3 { color: #fff; }
    .billing-reminder {
      color: #ff6b6b;
      font-weight: 600;
      margin: 0.25rem 0 1rem;
      text-align: center;
    }
    .hidden { display: none !important; }
    label { display: block; margin-top: 0.5rem; }
    input[type="text"], select, input[type="date"], textarea {
      background: #222; color: #eee; border: 1px solid #555;
      padding: 0.5rem; width: 100%;
    }
    textarea { resize: vertical; }
    button {
      background: #333; color: #fff; border: none; padding: 0.6rem 1rem;
      margin: 0.5rem 0.25rem; cursor: pointer; border-radius: 4px;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    .peek { background: #222; margin-top: 1rem; padding: 1rem; border-radius: 6px; max-width: 600px; }
    .peek summary { cursor: pointer; }
    .task-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }
    .time-budget-control {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: #a0a0a0;
    }
    .time-budget-control select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .show-all-toggle {
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      padding: 0.35rem 0.6rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .task-view-label {
      color: #a0a0a0;
      font-size: 0.85rem;
    }
    .task-view-select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .task-card {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 0.85rem;
      margin-bottom: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .task-card.is-completed {
      background: #161616;
      border: 1px solid #2a2a2a;
    }
    .task-card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: flex-start;
    }
    .task-card-title-group {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1;
      min-width: 0;
    }
    .task-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0;
      line-height: 1.4;
      color: #fff;
      word-break: break-word;
    }
    .task-complete-indicator {
      color: #8fc97a;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .task-card-actions {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
    }
    .task-card-actions button {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
    }
    .task-descriptors {
      font-size: 0.8rem;
      color: #b0b0b0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .task-descriptors span::before {
      content: "•";
      margin-right: 0.25rem;
      color: #555;
    }
    .task-descriptors span:first-child::before {
      content: "";
      margin: 0;
    }
    .task-progress {
      font-size: 0.82rem;
      color: #d0dcff;
      font-weight: 500;
    }
    .task-progress-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .task-progress-meter {
      background: #111922;
      border-radius: 999px;
      overflow: hidden;
      height: 6px;
      width: 100%;
    }
    .task-progress-meter .fill {
      display: block;
      height: 100%;
      background: #0a84ff;
      width: 0%;
      transition: width 150ms ease-out;
    }
    .task-meta {
      font-size: 0.75rem;
      color: #8f9aa8;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .task-detail-toggle {
      align-self: flex-start;
      background: #2a2a2a;
      font-size: 0.8rem;
      padding: 0.35rem 0.6rem;
    }
    .task-details {
      font-size: 0.8rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.6rem;
      width: 100%;
      box-sizing: border-box;
    }
    .task-details h5 {
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
      color: #eee;
    }
    .task-details ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .task-details li {
      margin: 0.25rem 0;
    }
    .score { font-size: 0.8rem; color: #ccc; }
    #focusFitHint {
      color: #8f9aa8;
      font-size: 0.85rem;
      margin-top: 0.35rem;
      max-width: 600px;
      text-align: center;
    }
    .chart-age, .urgency-hint {
      display: block;
      margin-top: 0.25rem;
      color: #aaa;
      font-size: 0.85rem;
      max-width: 600px;
    }
    .focus { font-size: 1.5rem; margin: 1rem 0; }
    .category-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .category-filter button {
      background: #444;
      color: #fff;
      border: none;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .category-filter button.active {
      background: #666;
    }
    .category-progress {
      margin-top: 0.5rem;
      width: 100%;
      max-width: 600px;
    }
    .category-progress .line {
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
    .category-progress .bar {
      background: #333;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      overflow: hidden;
    }
    .category-progress .bar .fill {
      background: #0a84ff;
      height: 100%;
      display: block;
      width: 0%;
    }
    .subtask-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.4rem 0;
      padding: 0.5rem;
      background: #1a1a1a;
      border-radius: 6px;
    }
    .subtask-row.completed {
      opacity: 0.7;
    }
    .subtask-name {
      flex: 1;
      margin-left: 0.35rem;
    }
    .subtask-actions {
      display: flex;
      gap: 0.25rem;
    }
    .subtask-actions button {
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
    }
    .timer-label {
      font-size: 0.75rem;
      color: #9aa0a6;
      min-width: 110px;
      text-align: right;
      margin-left: auto;
    }
    .chart-summary {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #181818;
      border-radius: 6px;
      width: 100%;
      max-width: 600px;
    }
    .chart-summary h4 {
      margin: 0 0 0.5rem;
    }
    .chart-summary ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .chart-summary li {
      margin: 0.25rem 0;
      padding: 0.35rem;
      background: #202020;
      border-radius: 4px;
    }
    .chart-summary li.longest-step {
      border: 1px solid #0a84ff;
      background: #0a1a33;
    }
    .chart-fields {
      width: 100%;
      overflow: hidden;
      max-height: 1000px;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 250ms ease, max-height 250ms ease;
    }
    .chart-fields.is-hidden {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .chart-total {
      margin-top: 0.5rem;
      font-weight: 600;
    }
    .chart-step-controls {
      margin-top: 0.75rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chart-step-controls button {
      font-size: 0.85rem;
    }
    #focusTimer {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #d0dcff;
    }
    #focusTimer.pulse {
      animation: focus-pulse 1s ease-out;
    }
    @keyframes focus-pulse {
      0% { color: #d0dcff; }
      50% { color: #0a84ff; }
      100% { color: #d0dcff; }
    }
    .sound-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
    }
    .sound-toggle input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #0a84ff;
    }
    .audit-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 999;
    }
    .audit-modal {
      background: #151515;
      border-radius: 10px;
      max-width: 520px;
      width: 100%;
      padding: 1.25rem;
      color: #f5f5f5;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }
    .audit-modal h3 {
      margin: 0 0 0.75rem;
    }
    .audit-summary {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #d0dcff;
    }
    .audit-task-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }
    .audit-task-list li {
      background: #1f1f1f;
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 0.85rem;
      color: #e0e0e0;
    }
    .audit-task-list li strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .audit-task-subtasks {
      margin: 0.35rem 0 0;
      padding-left: 1rem;
      color: #b0b0b0;
    }
    .audit-modal button {
      margin-top: 1rem;
    }
    [aria-live] { outline: none; }
    .meltdown-sos-button {
      position: fixed;
      bottom: 1.5rem;
      left: 1.5rem;
      background: #ff4d4f;
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.75rem 1.25rem;
      box-shadow: 0 8px 20px rgba(255, 77, 79, 0.35);
      z-index: 1200;
      margin: 0;
    }
    .meltdown-sos-button:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }
    .meltdown-shield {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      width: min(340px, 90vw);
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1rem;
      color: #f5f5f5;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      z-index: 1300;
    }
    .meltdown-shield-header {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 0.75rem;
    }
    .meltdown-shield-prompt {
      font-size: 0.95rem;
      background: rgba(32, 32, 32, 0.85);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      line-height: 1.45;
    }
    .meltdown-shield-prompt strong {
      display: block;
      margin-bottom: 0.35rem;
    }
    .meltdown-shield ul {
      margin: 0 0 0.75rem;
      padding-left: 1.1rem;
      font-size: 0.9rem;
      max-height: 160px;
      overflow-y: auto;
    }
    .meltdown-shield li {
      margin: 0.4rem 0;
      line-height: 1.4;
    }
    .meltdown-shield-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .meltdown-shield button {
      font-size: 0.85rem;
    }
    .meltdown-top-task {
      color: #7bd88f;
      font-weight: 600;
    }
    .module-card {
      width: 100%;
      max-width: 720px;
      background: #181818;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin: 1rem 0;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
    }
    .module-card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.35rem;
    }
    .module-card p {
      margin: 0.25rem 0 0.75rem;
      color: #c9d1d9;
      line-height: 1.45;
    }
    .module-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .module-toggle label {
      margin: 0;
      font-weight: 600;
    }
    .module-toggle input[type="checkbox"],
    .module-toggle input[type="time"] {
      accent-color: #0a84ff;
      background: #111;
      color: #fff;
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      border-radius: 6px;
    }
    .morning-blocks {
      display: grid;
      gap: 0.75rem;
      margin: 0.75rem 0;
    }
    .routine-block {
      background: rgba(12, 12, 12, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.85rem;
      display: grid;
      gap: 0.5rem;
    }
    .routine-block.completed {
      border-color: rgba(123, 216, 143, 0.6);
      background: rgba(18, 40, 20, 0.85);
    }
    .routine-block h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .routine-block small {
      color: #a0aec0;
      display: block;
    }
    .countdown-display {
      font-size: 1.25rem;
      font-weight: 600;
      color: #7bd88f;
    }
    .intention-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .intention-buttons button {
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(34, 34, 34, 0.85);
    }
    .progress-strip {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      position: relative;
      margin: 0.5rem 0;
    }
    .progress-strip span {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #0a84ff, #7bd88f);
      transition: width 200ms ease-out;
    }
    .module-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .history-list {
      margin: 0.5rem 0 0;
      padding: 0;
      list-style: none;
      font-size: 0.85rem;
      color: #aab8c8;
    }
    .history-list li {
      padding: 0.3rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    .history-list li:last-child {
      border-bottom: none;
    }
    .toast-container {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      display: grid;
      gap: 0.75rem;
      z-index: 1500;
    }
    .toast {
      background: rgba(30, 30, 30, 0.95);
      border-left: 4px solid #0a84ff;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      color: #f5f5f5;
      min-width: 220px;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    }
    .toast strong {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.95rem;
    }
    .wizard-overlay,
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1400;
    }
    .wizard-content,
    .modal-card {
      background: #121212;
      border-radius: 12px;
      padding: 1.25rem;
      max-width: 520px;
      width: 100%;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      color: #f1f5f9;
    }
    .wizard-content h3,
    .modal-card h3 {
      margin: 0 0 0.75rem;
    }
    .wizard-steps {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .wizard-steps label {
      font-size: 0.85rem;
    }
    .wizard-actions,
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    .launch-pad-settings {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-settings select,
    .launch-pad-settings input[type="text"] {
      background: #222;
      color: #eee;
      border: 1px solid #444;
      padding: 0.45rem;
      border-radius: 6px;
    }
    .launch-pad-list {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-item {
      display: grid;
      grid-template-columns: 1fr minmax(110px, 150px) auto;
      align-items: center;
      gap: 0.5rem;
      background: rgba(20, 20, 20, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    .launch-pad-item small {
      color: #9aa0a6;
      font-size: 0.75rem;
    }
    .sleep-checklist {
      display: grid;
      gap: 0.5rem;
      margin: 0.75rem 0;
    }
    .sleep-checklist label {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      background: rgba(15, 15, 15, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .sleep-checklist input[type="checkbox"] {
      margin-top: 0.1rem;
      accent-color: #7bd88f;
    }
    .sleep-tips {
      display: grid;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: #9aa0a6;
    }
    .sleep-summary {
      font-size: 0.9rem;
      background: rgba(18, 26, 36, 0.85);
      border-radius: 8px;
      padding: 0.6rem;
      margin-top: 0.75rem;
    }
    .sunlight-alert {
      margin-top: 0.75rem;
      padding: 0.65rem;
      border-radius: 8px;
      background: rgba(40, 36, 16, 0.85);
      color: #f8e3a1;
      font-size: 0.85rem;
    }
    .energy-rating {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .energy-rating input[type="range"] {
      flex: 1;
    }
    .celebration {
      background: rgba(14, 48, 22, 0.85);
      border-left: 3px solid #7bd88f;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #d2ffde;
      margin-top: 0.5rem;
    }
    .launch-pad-summary {
      background: rgba(22, 24, 30, 0.9);
      border-radius: 10px;
      padding: 0.75rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .launch-pad-summary strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .routine-affirmation {
      font-size: 0.85rem;
      color: #f0ead6;
      background: rgba(50, 42, 24, 0.6);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      margin-top: 0.5rem;
    }
    .morning-chart-wrapper {
      margin-top: 0.75rem;
      background: #191919;
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 0.75rem;
      border-radius: 10px;
    }
    .chart-canvas {
      width: 100%;
      max-width: 360px;
      height: 160px;
      display: block;
      margin: 0 auto;
    }
    .chart-legend {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: #a5adba;
      margin-top: 0.5rem;
      justify-content: center;
    }
    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 0.35rem;
    }
    .legend-swatch.completion {
      background: #0a84ff;
    }
    .legend-swatch.energy {
      background: #f97316;
    }
    .module-note {
      font-size: 0.78rem;
      color: #9ba6b9;
      margin-top: 0.5rem;
      text-align: center;
    }

    :root {
      --accent: #2dd4bf;
      --background: #05090f;
      --surface: rgba(18, 22, 28, 0.9);
      --surface-muted: rgba(24, 28, 36, 0.9);
      --border: rgba(255, 255, 255, 0.06);
      --text-primary: #f4f7fb;
      --text-secondary: #aeb8c9;
      --text-muted: #6b7280;
      --radius-lg: 14px;
      --radius-md: 10px;
      --shadow-soft: 0 18px 36px rgba(0, 0, 0, 0.35);
      --space-1: 8px;
      --space-2: 12px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;
      --transition: 160ms ease;
    }

    body {
      background: var(--background);
      color: var(--text-primary);
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      min-height: 100vh;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: clamp(1.5rem, 4vw, 2.5rem) clamp(1rem, 4vw, 2.25rem) 120px;
      line-height: 1.6;
    }

    .app-shell {
      width: min(100%, 1100px);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    @media (max-width: 1024px) {
      .app-shell {
        width: min(100%, 960px);
      }
    }

    @media (max-width: 768px) {
      .app-shell {
        width: min(100%, 720px);
      }

      body {
        padding: clamp(1.25rem, 5vw, 2rem) clamp(0.85rem, 4vw, 1.75rem) 100px;
      }
    }

    @media (max-width: 600px) {
      body {
        padding: clamp(1rem, 6vw, 1.5rem) clamp(0.75rem, 5vw, 1.25rem) 90px;
      }

      .action-bar {
        flex-direction: column;
        align-items: stretch;
        gap: var(--space-2);
      }

      .action-bar-primary,
      .action-bar-secondary {
        width: 100%;
        margin-left: 0;
      }

      .action-bar-primary {
        flex-direction: column;
      }

      .action-bar .btn {
        width: 100%;
        justify-content: center;
      }

      .action-bar-secondary {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: var(--space-1);
      }

      .action-bar-secondary .icon-button {
        width: 100%;
        height: 44px;
      }

      .card {
        padding: var(--space-3);
        gap: var(--space-2);
      }

      .card-sticky-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .card-sticky-actions__primary,
      .card-sticky-actions__secondary {
        justify-content: stretch;
      }

      .card-sticky-actions__primary > *,
      .card-sticky-actions__secondary > * {
        width: 100%;
      }

      .toast-container {
        left: var(--space-2);
        right: var(--space-2);
      }
    }

    .page-header {
      text-align: center;
      margin: 8px 0 12px;
    }

    .page-header .title {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
    }

    .page-header .subtitle {
      margin-top: 6px;
      opacity: 0.8;
      font-size: 0.9rem;
    }

    .action-bar {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      align-items: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-3);
      box-shadow: var(--shadow-soft);
    }

    .action-bar-primary {
      display: flex;
      gap: var(--space-2);
      flex: 1 1 auto;
    }

    .action-bar-secondary {
      display: flex;
      gap: var(--space-1);
      margin-left: auto;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition), color var(--transition), border-color var(--transition);
    }

    a.btn {
      text-decoration: none;
    }

    .btn:focus-visible,
    .icon-button:focus-visible,
    .link-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn-primary {
      background: var(--accent);
      color: #041013;
      font-weight: 600;
    }

    .btn-secondary {
      background: rgba(45, 212, 191, 0.12);
      color: var(--accent);
      border: 1px solid rgba(45, 212, 191, 0.25);
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .icon-button {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      width: 38px;
      height: 38px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition);
    }

    .icon-button:hover,
    .btn:hover {
      transform: translateY(-1px);
    }

    .resource-card .card-body {
      gap: var(--space-2);
    }

    .resource-intro {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .resource-links {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-2);
    }

    .resource-button {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      padding: var(--space-2);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      text-decoration: none;
      color: var(--text-primary);
      background: linear-gradient(135deg, rgba(45, 212, 191, 0.16), rgba(45, 212, 191, 0));
      transition: transform var(--transition), border-color var(--transition), box-shadow var(--transition);
    }

    .resource-button:hover,
    .resource-button:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(45, 212, 191, 0.35);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
    }

    .resource-button strong {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .resource-button span {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .resource-button--deep {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.18), rgba(59, 130, 246, 0));
      border-color: rgba(59, 130, 246, 0.18);
    }

    .resource-button--sunrise {
      background: linear-gradient(135deg, rgba(250, 204, 21, 0.18), rgba(250, 204, 21, 0));
      border-color: rgba(250, 204, 21, 0.18);
    }

    .resource-button--orchid {
      background: linear-gradient(135deg, rgba(192, 132, 252, 0.18), rgba(192, 132, 252, 0));
      border-color: rgba(192, 132, 252, 0.18);
    }

    .resource-button--emerald {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0));
      border-color: rgba(16, 185, 129, 0.22);
    }

    .resource-button small {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .card {
      background: rgba(18, 22, 28, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .card-head h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .card-body {
      display: grid;
      gap: var(--space-2);
    }

    .card--collapsed .card-body {
      display: none;
    }

    .card--collapsed .card-sticky-actions {
      display: none;
    }

    .status-card {
      background: rgba(18, 22, 28, 0.85);
    }

    .status-card .category-progress {
      margin-top: 0;
    }

    .task-form-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-1);
      align-items: center;
      justify-content: flex-start;
    }

    .card-sticky-actions {
      position: sticky;
      bottom: -12px;
      margin: 0 -12px -12px;
      padding: var(--space-3);
      background: linear-gradient(180deg, rgba(18, 22, 28, 0) 0%, rgba(18, 22, 28, 0.92) 45%, rgba(18, 22, 28, 0.98) 100%);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      justify-content: space-between;
      align-items: center;
      z-index: 2;
      border-bottom-left-radius: 14px;
      border-bottom-right-radius: 14px;
    }

    .card-sticky-actions__primary,
    .card-sticky-actions__secondary {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-1);
      align-items: center;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1400;
    }

    .modal.hidden {
      display: none;
    }

    .modal__content {
      width: min(560px, 92vw);
      max-height: 80vh;
      overflow: auto;
      background: #0f141a;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: var(--space-2);
    }

    .modal__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-1);
    }

    .modal__close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.1rem;
      cursor: pointer;
    }

    .template-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 8px;
    }

    .template-card {
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      background: rgba(16, 20, 28, 0.9);
      display: grid;
      gap: 6px;
    }

    .template-card strong {
      font-size: 0.95rem;
    }

    .template-card button {
      justify-self: flex-start;
    }


    .section-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .section-heading h2,
    .next-task-card h2 {
      font-size: clamp(16px, 2.3vw, 18px);
      font-weight: 600;
      margin: 0;
    }

    .link-button {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .next-task-card {
      gap: var(--space-2);
    }

    .next-task-name {
      font-size: 1.05rem;
      font-weight: 600;
      margin: 0;
    }

    .next-task-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-1);
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .chip {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      padding: 0.25rem 0.6rem;
      font-size: 0.75rem;
    }

    .next-task-actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .due-today-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .due-today-item {
      display: grid;
      gap: var(--space-1);
      background: var(--surface-muted);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-md);
      padding: var(--space-2);
    }

    .due-today-title {
      font-size: 0.95rem;
      font-weight: 500;
      margin: 0;
      color: var(--text-primary);
    }

    .due-today-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-1);
    }

    .due-today-pills {
      display: inline-flex;
      gap: var(--space-1);
      flex-wrap: wrap;
    }

    .pill {
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 0.25rem 0.65rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .pill-primary {
      background: rgba(45, 212, 191, 0.18);
      color: var(--accent);
      border-color: rgba(45, 212, 191, 0.35);
    }

    .module-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 0;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .module-header {
      width: 100%;
      background: transparent;
      color: var(--text-primary);
      border: none;
      padding: var(--space-3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .module-heading {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .module-caret {
      display: inline-block;
      transition: transform var(--transition);
      color: var(--text-secondary);
    }

    .module-card.is-open .module-caret {
      transform: rotate(90deg);
    }

    .module-body {
      padding: 0 var(--space-4) var(--space-4);
      display: grid;
      gap: var(--space-3);
    }

    .module-body[hidden] {
      display: none;
    }

    .module-footnote {
      font-size: 0.78rem;
      color: var(--text-secondary);
    }

    .task-form-card {
      gap: var(--space-3);
    }

    .task-form-actions--inline {
      align-items: center;
    }

    .task-form-actions--inline .btn {
      padding: 0.35rem 0.75rem;
      font-size: 0.85rem;
    }

    .task-form-minimal {
      display: grid;
      gap: var(--space-2);
    }

    .task-form-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .task-form-actions {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .task-details-panel {
      display: grid;
      gap: var(--space-2);
    }

    .task-details-panel[data-collapsed="true"] {
      display: none;
    }

    label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    input[type="text"],
    select,
    input[type="date"],
    textarea {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      width: 100%;
      box-sizing: border-box;
    }

    textarea {
      resize: vertical;
      min-height: 96px;
    }

    .category-filter,
    .category-progress,
    .peek {
      margin-top: var(--space-3);
    }

    .peek {
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
    }

    .hidden {
      display: none !important;
    }

    .toast-container {
      position: fixed;
      top: var(--space-4);
      right: var(--space-4);
      z-index: 1500;
    }

    .meltdown-sos-button {
      display: none;
    }

    .module-stack {
      display: grid;
      gap: var(--space-3);
    }

    .due-today-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .next-task-empty {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .quick-pill {
      border: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .quick-pill:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .info-dot {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
    }

    .info-dot[title] {
      cursor: help;
    }

    button:not(.btn):not(.icon-button):not(.pill):not(.link-button):not(.module-header) {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.5rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="toastContainer" class="toast-container" aria-live="polite"></div>

  <section
    id="meltdownShield"
    class="meltdown-shield hidden"
    aria-live="polite"
    aria-label="Meltdown Shield Panel"
    aria-hidden="true"
  >
    <h4 class="meltdown-shield-header">🛡️ Meltdown Shield Activated</h4>
    <div id="meltdownShieldPrompt" class="meltdown-shield-prompt" aria-live="assertive"></div>
    <ul id="meltdownShieldSteps"></ul>
    <div class="meltdown-shield-actions">
      <button id="meltdownShieldNext" type="button">▶️ Next</button>
      <button type="button" onclick="deactivateShield()">❌ Close</button>
    </div>
  </section>

  <section id="capture">
    <div class="app-shell">
      <div class="page-header">
        <div class="title">🎯 Task Focus</div>
        <div class="subtitle" id="billingReminder"></div>
      </div>

      <section id="supportLinks" class="card resource-card" aria-labelledby="supportLinksTitle">
        <div class="card-head">
          <h2 id="supportLinksTitle">Quick access partners</h2>
        </div>
        <div class="card-body">
          <p class="resource-intro">
            Launch the assistants and knowledge bases you rely on for planning, EPIC efficiency, and assessment templates.
          </p>
          <div class="resource-links">
            <a
              class="resource-button"
              href="https://chatgpt.com/g/g-p-68feee841e7081919a28fe9b3083e9f0-karl/project"
              target="_blank"
              rel="noopener noreferrer"
            >
              <small>Planning ally</small>
              <strong>Chat with Karl</strong>
              <span>ADHD-tailored task partner ready to map out your day.</span>
            </a>
            <a
              class="resource-button resource-button--deep"
              href="https://chatgpt.com/g/g-p-6836a5682d0481918484506cbc1f3082-epic-companion/project"
              target="_blank"
              rel="noopener noreferrer"
            >
              <small>EPIC strategies</small>
              <strong>EPIC Companion</strong>
              <span>Brainstorm workflows to move faster inside the EHR.</span>
            </a>
            <a
              class="resource-button resource-button--sunrise"
              href="https://notebooklm.google.com/"
              target="_blank"
              rel="noopener noreferrer"
            >
              <small>Article digest</small>
              <strong>NotebookLM</strong>
              <span>Summarize research and notes in a focused workspace.</span>
            </a>
            <a
              class="resource-button resource-button--orchid"
              href="https://www.notion.so/Assessments-and-Plans-28131b26f81f803088bad074ee0e00fb?source=copy_link"
              target="_blank"
              rel="noopener noreferrer"
            >
              <small>Reference vault</small>
              <strong>Assessments &amp; Plans</strong>
              <span>Review ready-made assessment and plan examples.</span>
            </a>
            <a
              class="resource-button resource-button--emerald"
              href="https://chatgpt.com/g/g-p-68feff1f73ac819189dcf556e573c912-assessments-plans/project"
              target="_blank"
              rel="noopener noreferrer"
            >
              <small>Document builder</small>
              <strong>Create Assessments &amp; Plans</strong>
              <span>Draft new assessments from your history and physical notes.</span>
            </a>
          </div>
        </div>
      </section>

      <section id="statusCard" class="card card--collapsed status-card" data-collapsed="true" aria-live="polite">
        <div class="card-head">
          <h2>Status</h2>
          <button
            id="toggleStatusCard"
            class="link-button"
            type="button"
            aria-expanded="false"
            aria-controls="statusCardBody"
          >
            Expand
          </button>
        </div>
        <div class="card-body" id="statusCardBody" aria-hidden="true">
          <div id="categoryProgress" class="category-progress"></div>
        </div>
      </section>

      <div class="action-bar">
        <div class="action-bar-primary">
          <button id="startNextAction" class="btn btn-primary" type="button">Start next task</button>
          <button id="startSprintAction" class="btn btn-secondary" type="button">Start 5-min</button>
        </div>
        <div class="action-bar-secondary">
          <button id="quickAddAction" class="icon-button" type="button" aria-label="Quick add task">＋</button>
          <button id="dueTodayAction" class="icon-button" type="button" aria-label="Open due-today list">📋</button>
          <button id="shieldAction" class="icon-button" type="button" aria-label="Overwhelmed shield">🛡️</button>
        </div>
      </div>

      <section id="nextTaskCard" class="card next-task-card hidden" aria-live="polite">
        <div class="card-head">
          <h2>Next focus</h2>
          <span id="nextTaskScore" class="chip hidden"></span>
        </div>
        <p id="nextTaskName" class="next-task-name"></p>
        <p id="nextTaskSubstep" class="next-task-meta"></p>
        <div id="nextTaskChips" class="next-task-meta"></div>
        <div class="next-task-actions">
          <button id="nextTaskStartFull" class="btn btn-primary" type="button">Start full</button>
          <button id="nextTaskStartSprint" class="btn btn-secondary" type="button">Start 5-min</button>
        </div>
        <p id="nextTaskEmpty" class="next-task-empty hidden">You're clear for now. Add what matters next.</p>
      </section>

      <section id="dueTodaySection" class="card due-today-card hidden" aria-live="polite">
        <div class="section-heading">
          <h2>Due today</h2>
          <button id="toggleDueToday" class="link-button hidden" type="button"></button>
        </div>
        <div id="dueTodayList" class="due-today-list"></div>
        <p id="dueTodayEmpty" class="due-today-empty hidden">Nothing due today. You're caught up.</p>
      </section>

      <section id="addTaskCard" class="card card--collapsed" aria-live="polite" data-collapsed="true">
        <div class="card-head">
          <h2>Add task</h2>
          <button id="toggleAddTaskCard" class="link-button" type="button" aria-expanded="false" aria-controls="addTaskCardBody">
            Expand
          </button>
        </div>
        <div class="card-body" id="addTaskCardBody" aria-hidden="true">
          <label for="name">Task name
            <input id="name" type="text" placeholder="3/14 – J.M. – Complex Care Follow-Up (Resident)" autofocus />
          </label>
          <label for="taskCategory">Category
            <select id="taskCategory">
              <option value="General" selected>General</option>
              <option value="Admin">Admin</option>
              <option value="Chart">Chart</option>
              <option value="Inbox">Inbox</option>
              <option value="Calls">Calls</option>
              <option value="Teaching">Teaching</option>
              <option value="Personal">Personal</option>
            </select>
          </label>
          <div class="task-form-toolbar">
            <button type="button" class="btn btn-ghost" id="btn-use-template">Use template</button>
            <button type="button" class="btn btn-ghost" onclick="saveAsTemplate()">Add as Template</button>
            <button
              type="button"
              class="btn btn-ghost"
              id="expandTaskDetailsButton"
              aria-controls="taskDetails"
              aria-expanded="false"
            >
              Show details
            </button>
          </div>
          <div id="taskDetails" class="task-details-panel" data-collapsed="true">
            <div id="chartFields" class="chart-fields is-hidden" aria-hidden="true">
              <label for="authorType">Chart Author
                <select id="authorType">
                  <option value="attending" selected>Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="patientType" title="Complex = medically fragile, multi-specialty, or DME-dependent.">Patient Type
                <select id="patientType">
                  <option value="Non-Complex" selected>Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="visitType" title="Determines estimated chart complexity and time to complete.">Visit Type
                <select id="visitType">
                  <option value="Follow-Up" selected>Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="clinicSite" title="Same-day notes from St PJ’s or Craniofacial automatically rise to the top.">Clinic Site
                <select id="clinicSite">
                  <option value="General Clinic" selected>General Clinic</option>
                  <option value="St PJ’s Shelter">St PJ’s Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="dateOfService" title="Select the date of the encounter; defaults to today.">Date of Service
                <input type="date" id="dateOfService" />
              </label>
              <small id="chartAgeDisplay" class="chart-age"></small>
            </div>
            <label for="importance">Importance (1–5) <select id="importance"></select></label>
            <label for="urgency">Urgency (1–5)
              <select id="urgency"></select>
            </label>
            <small id="urgencyHint" class="urgency-hint"></small>
            <label for="novelty">Novelty (1–5) <select id="novelty"></select></label>
            <label for="interest">Interest (1–5) <select id="interest"></select></label>
            <label for="externalPressure">External Pressure (1–5)
              <select id="externalPressure"></select>
            </label>
            <label for="timeToStart">Time to Start (1–5) <select id="timeToStart"></select></label>
            <label for="difficulty">Difficulty (1–5) <select id="difficulty"></select></label>
            <label for="dueDate" title="Optional specific target date; used for personal scheduling.">Due Date (Optional)
              <input type="date" id="dueDate" />
            </label>
            <label for="initialSubTasks">Subtasks
              <textarea id="initialSubTasks" rows="3" placeholder="One subtask per line."></textarea>
            </label>
            <label class="sound-toggle" for="focusSoundToggle">
              <input type="checkbox" id="focusSoundToggle" checked />
              Enable focus mode ping
            </label>
          </div>
        </div>
        <div class="card-sticky-actions" aria-hidden="true">
          <div class="card-sticky-actions__primary">
            <button id="addTaskBtn" class="btn btn-primary" type="button" onclick="addTask()">Add Task</button>
            <button id="saveUpdateBtn" class="btn btn-primary hidden" type="button" onclick="saveTaskUpdate()">Save Update</button>
            <button id="cancelEditBtn" class="btn btn-ghost hidden" type="button" onclick="cancelEdit()">Cancel</button>
          </div>
          <div class="card-sticky-actions__secondary">
            <button type="button" class="btn btn-secondary" onclick="startFiveMinuteSprint()" id="startBtn" disabled>Start 5-min</button>
            <button type="button" class="btn btn-ghost" onclick="reset()">Reset</button>
          </div>
        </div>
      </section>

      <section id="allTasksCard" class="card card--collapsed" data-collapsed="true" aria-live="polite">
        <div class="card-head">
          <h2 id="allTasksTitle">All Tasks</h2>
          <button
            id="toggleAllTasksCard"
            class="link-button"
            type="button"
            aria-expanded="false"
            aria-controls="allTasksCardBody"
          >
            Expand
          </button>
        </div>
        <div class="card-body" id="allTasksCardBody" aria-hidden="true">
          <div class="task-list-header" id="taskListHeader">
            <label class="task-view-label" for="taskViewMode">View</label>
            <select id="taskViewMode" class="task-view-select">
              <option value="active" selected>Active Tasks</option>
              <option value="completed">Completed Tasks</option>
            </select>
            <label class="task-view-label" for="taskCategoryFilter">Category</label>
            <select id="taskCategoryFilter" class="task-view-select"></select>
            <label class="time-budget-control" for="timeBudget">
              I have
              <select id="timeBudget" data-field="time-budget">
                <option value="">--</option>
                <option value="15">15</option>
                <option value="30">30</option>
                <option value="60">60</option>
              </select>
              minutes
            </label>
            <button id="showAllToggle" class="show-all-toggle hidden" type="button" onclick="toggleShowAllActive()">Show All</button>
          </div>
          <div id="taskList"></div>
        </div>
      </section>

      <div class="module-stack">
        <div id="morningLaunchModule" class="module-card" data-module-id="morningLaunchModule">
          <button class="module-header" type="button" aria-expanded="false">
            <div class="module-heading">
              <span class="module-caret" aria-hidden="true">▸</span>
              <span>🌅 Morning Launch Sequence</span>
            </div>
            <span class="info-dot" title="Prime your brain for dopamine, cortisol, and clarity with a 60-minute guided ramp into the day.">i</span>
          </button>
          <div class="module-body" hidden>
            <div class="module-toggle">
              <label for="morningLaunchToggle">Enable Morning Launch</label>
              <input type="checkbox" id="morningLaunchToggle" />
            </div>
            <div class="routine-affirmation">No-phone pledge: leave your device in another room overnight and wake up with an analog alarm.</div>
            <div id="morningLaunchContent" class="hidden" aria-hidden="true">
              <div class="progress-strip" aria-hidden="true">
                <span id="morningLaunchProgress"></span>
              </div>
              <div id="morningLaunchStatus" class="score"></div>
              <div class="module-inline-actions">
                <button id="morningLaunchResetBtn" type="button">Reset morning blocks</button>
                <button id="morningLaunchSkipBtn" type="button">Skip today</button>
              </div>
              <div class="morning-blocks">
                <article class="routine-block" data-block="move">
                  <h3>MOVE — Light Aerobic + Sunlight</h3>
                  <small>Take a brisk walk, 50 jumping jacks, and soak in 5 minutes of direct sunlight.</small>
                  <div class="countdown-display" id="moveCountdown">20:00</div>
                  <div class="module-inline-actions">
                    <button id="moveStartBtn" type="button">Start 20-min timer</button>
                    <button id="moveCompleteBtn" type="button">Mark MOVE complete</button>
                  </div>
                </article>
                <article class="routine-block" data-block="reflect">
                  <h3>REFLECT — Cold Splash + Intention</h3>
                  <small>Reset with a cold rinse, then name the tone for your day.</small>
                  <div class="intention-buttons">
                    <button type="button" data-intention="Calm & steady">Calm & steady</button>
                    <button type="button" data-intention="Playful & connected">Playful & connected</button>
                    <button type="button" data-intention="Focused craftsmanship">Focused craftsmanship</button>
                  </div>
                  <label for="morningIntention" style="margin:0;">
                    <textarea id="morningIntention" rows="2" placeholder="How do I want today to feel? What would make it meaningful?" style="margin-top:0.35rem;"></textarea>
                  </label>
                  <div class="module-inline-actions">
                    <button id="reflectCompleteBtn" type="button">Save intention</button>
                  </div>
                </article>
                <article class="routine-block" data-block="plan">
                  <h3>PLAN — Process Anchors</h3>
                  <small>Lock in process-based actions and block time before the day takes over.</small>
                  <textarea id="morningPlanNotes" rows="2" placeholder="Ex: Draft progress notes for 2 patients before noon."></textarea>
                  <div class="module-inline-actions">
                    <button id="planCompleteBtn" type="button">Plan locked in</button>
                  </div>
                </article>
              </div>
              <div class="energy-rating">
                <label for="morningEnergy" style="margin:0;">Energy check-in</label>
                <input id="morningEnergy" data-field="energy-level" type="range" min="1" max="5" step="1" value="3" />
                <span id="morningEnergyLabel">--</span>
                <button id="morningEnergySave" type="button">Log energy</button>
              </div>
              <div class="morning-chart-wrapper">
                <canvas
                  id="morningLaunchChart"
                  class="chart-canvas"
                  width="360"
                  height="160"
                  role="img"
                  aria-label="Line chart of morning launch completion and energy trends"
                ></canvas>
                <div class="chart-legend" aria-hidden="true">
                  <span><span class="legend-swatch completion"></span>Completion %</span>
                  <span><span class="legend-swatch energy"></span>Energy (1–5 scaled)</span>
                </div>
                <div id="morningLaunchChartSummary" class="module-note"></div>
              </div>
              <ul id="morningLaunchHistory" class="history-list" aria-live="polite"></ul>
            </div>
          </div>
        </div>

        <div id="launchPadModule" class="module-card" data-module-id="launchPadModule">
          <button class="module-header" type="button" aria-expanded="false">
            <div class="module-heading">
              <span class="module-caret" aria-hidden="true">▸</span>
              <span>🚀 Environmental Reminders & Launch Pads</span>
            </div>
            <span class="info-dot" title="Curate a nightly launch pad so tomorrow starts calm, stocked, and on time.">i</span>
          </button>
          <div class="module-body" hidden>
            <div class="module-toggle">
              <label for="launchPadReminderTime">Reminder time</label>
              <input type="time" id="launchPadReminderTime" />
            </div>
            <div class="launch-pad-summary" id="launchPadSummary"></div>
            <div class="module-inline-actions">
              <button id="openLaunchPadModal" type="button">Evening checklist</button>
              <button id="launchPadMorningReview" type="button">Morning review</button>
            </div>
            <div class="launch-pad-settings">
              <label for="launchPadSiteSelect">Clinic / environment
                <select id="launchPadSiteSelect"></select>
              </label>
              <div class="module-inline-actions">
                <input type="text" id="launchPadNewItem" placeholder="Add launch pad item" />
                <button id="launchPadAddItem" type="button">Add Item</button>
                <button id="launchPadLoadPreset" type="button">Reset to preset</button>
              </div>
              <div id="launchPadItemList" class="launch-pad-list" aria-live="polite"></div>
            </div>
          </div>
        </div>

        <div id="sleepToolkitModule" class="module-card" data-module-id="sleepToolkitModule">
          <button class="module-header" type="button" aria-expanded="false">
            <div class="module-heading">
              <span class="module-caret" aria-hidden="true">▸</span>
              <span>😴 Sleep & Circadian Rhythm Toolkit</span>
            </div>
            <span class="info-dot" title="Stabilize melatonin and cortisol rhythms with gentle wind-down and light cues.">i</span>
          </button>
          <div class="module-body" hidden>
            <div class="module-toggle">
              <label for="sleepToolkitToggle">Enable toolkit</label>
              <input type="checkbox" id="sleepToolkitToggle" />
            </div>
            <div id="sleepToolkitContent" class="hidden" aria-hidden="true">
              <div class="sleep-checklist" id="sleepChecklist"></div>
              <div id="sleepCompletionSummary" class="sleep-summary"></div>
              <div class="module-inline-actions">
                <label for="melatoninReminderToggle" style="flex:1;">
                  <input type="checkbox" id="melatoninReminderToggle" /> Melatonin reminder
                </label>
                <label for="melatoninReminderTime" style="margin:0;">Time
                  <input type="time" id="melatoninReminderTime" />
                </label>
              </div>
              <div class="module-inline-actions">
                <label for="sunlightReminderToggle" style="flex:1;">
                  <input type="checkbox" id="sunlightReminderToggle" /> Morning sunlight alert
                </label>
                <label for="sunlightReminderTime" style="margin:0;">Time
                  <input type="time" id="sunlightReminderTime" />
                </label>
              </div>
              <div id="sunlightAlert" class="sunlight-alert hidden" aria-live="polite"></div>
              <div id="sleepMorningRating" class="energy-rating"></div>
              <div id="sleepCorrelationSummary" class="sleep-summary"></div>
              <div class="sleep-tips" id="sleepTips"></div>
            </div>
          </div>
        </div>

        <div id="templateModule" class="module-card" data-module-id="templateModule">
          <button class="module-header" type="button" aria-expanded="false">
            <div class="module-heading">
              <span class="module-caret" aria-hidden="true">▸</span>
              <span>🧩 Templates</span>
            </div>
            <span class="info-dot" title="Pull in proven task blueprints without rewriting every field.">i</span>
          </button>
          <div class="module-body" hidden>
            <div id="templateButtons"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <div id="template-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="templateModalTitle">
    <div class="modal__content">
      <div class="modal__head"><strong id="templateModalTitle">Choose a template</strong><button class="modal__close" type="button">✕</button></div>
      <div class="template-grid" id="template-grid"></div>
    </div>
  </div>

  <div id="firstThreeWizard" class="wizard-overlay hidden" aria-hidden="true">
    <div class="wizard-content" role="dialog" aria-modal="true" aria-labelledby="firstThreeTitle">
      <h3 id="firstThreeTitle">🪜 First-Three-Steps Wizard</h3>
      <p>Break the project into tiny, guaranteed-win actions to get moving.</p>
      <div class="wizard-steps">
        <label>Step 1
          <input type="text" id="firstThreeStep1" placeholder="Open patient chart" />
        </label>
        <label>Step 2
          <input type="text" id="firstThreeStep2" placeholder="Skim last visit notes" />
        </label>
        <label>Step 3
          <input type="text" id="firstThreeStep3" placeholder="Draft first paragraph" />
        </label>
      </div>
      <div class="wizard-actions">
        <button id="firstThreeSkip" type="button">Skip for this task</button>
        <button id="firstThreeCancel" type="button">Cancel</button>
        <button id="firstThreeSave" type="button">Save steps</button>
      </div>
    </div>
  </div>

  <div id="launchPadModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="launchPadModalTitle">
      <h3 id="launchPadModalTitle">🚀 Prep Tomorrow's Launch Pad</h3>
      <p>Gather items tonight so future-you can walk out the door calm.</p>
      <div id="launchPadModalList" class="sleep-checklist" aria-live="polite"></div>
      <div class="modal-actions">
        <button id="launchPadModalClose" type="button">Done</button>
      </div>
    </div>
  </div>

  <!-- Focus mode -->
  <section id="focus" class="hidden">
    <div id="focusTimer" aria-live="polite">🧭 Focus Time: 0:00</div>
    <div class="focus" tabindex="0" aria-live="polite"></div>
    <div class="score" id="scoreView"></div>
    <div id="focusFitHint" aria-live="polite"></div>
    <div id="subTaskView"></div>
    <div>
      <button onclick="completeTask()">Task complete</button>
      <button onclick="backToCapture()">Back to capture</button>
    </div>
  </section>

  <script>
  const $ = id => document.getElementById(id);

  const categories = ["General","Admin","Chart","Inbox","Calls","Teaching","Personal"];
  let activeCategory = "All";
  const TASK_LIST_MODES = { ACTIVE: "active", COMPLETED: "completed" };
  let taskListMode = TASK_LIST_MODES.ACTIVE;
  let showAllActiveTasks = false;
  let derivedDaysSinceVisit = null;
  let urgencyAuto = true;
  const runningTimers = new Map();
  let sprintDurationMinutes = null;
  let sprintEndTime = null;
  let nextTaskId = null;
  let showAllDueToday = false;
  let lastFocusedBeforeTemplateModal = null;
  const MODULE_STATE_PREFIX = "moduleState_";
  const ADD_TASK_CARD_STATE_KEY = "ui.addTask.collapsed";
  const LEGACY_ADD_TASK_CARD_STATE_KEY = "addTaskCardState";
  const STATUS_CARD_STATE_KEY = "ui.status.collapsed";
  const ALL_TASKS_CARD_STATE_KEY = "ui.allTasks.collapsed";
  const COLLAPSIBLE_MODULE_IDS = [
    "morningLaunchModule",
    "launchPadModule",
    "sleepToolkitModule",
    "templateModule"
  ];
  const chartFieldIds = ["authorType", "patientType", "visitType", "clinicSite", "dateOfService"];
  let storedChartFieldValues = null;
  let currentScaleDescriptorCategory = "general";
  const FOCUS_PING_INTERVAL_MS = 10 * 60 * 1000;
  const AUDIT_STORAGE_PREFIX = "audit_";
  const AUDIT_SHOWN_SUFFIX = "_shown";
  const MORNING_LAUNCH_KEY = "morningLaunchState";
  const LAUNCH_PAD_KEY = "launchPadState";
  const SLEEP_TOOLKIT_KEY = "sleepToolkitState";
  let lastFocusEnergyLevel = null;
  let lastFocusTimeBudget = null;
  const FIRST_THREE_KEYWORDS = [
    "report",
    "project",
    "backlog",
    "chart",
    "presentation",
    "summary",
    "documentation",
    "analysis",
    "panel",
    "prep"
  ];
  const FIRST_THREE_WORD_THRESHOLD = 5;
  const DEFAULT_MORNING_TIMER_MINUTES = 20;
  const MORNING_BLOCKS = ["move", "reflect", "plan"];
  const MORNING_CHART_LIMIT = 10;
  const MORNING_CHART_COLORS = {
    completion: "#0a84ff",
    energy: "#f97316",
    grid: "rgba(148, 163, 184, 0.25)",
    axis: "rgba(148, 163, 184, 0.4)"
  };
  const DEFAULT_LAUNCH_PAD_REMINDER = "20:00";
  const DEFAULT_MELATONIN_TIME = "21:30";
  const DEFAULT_SUNLIGHT_TIME = "08:00";
  const DEFAULT_LAUNCH_PAD_SITE = "General Clinic";
  const ENERGY_LABELS = {
    1: "Foggy",
    2: "Sleepy",
    3: "Steady",
    4: "Energized",
    5: "Lit up"
  };
  const SLEEP_RATING_LABELS = {
    1: "Exhausted",
    2: "Restless",
    3: "Adequate",
    4: "Rested",
    5: "Recharged"
  };
  const LAUNCH_PAD_PRESETS = {
    "General Clinic": [
      "Stethoscope",
      "Laptop + charger",
      "Clinic badge",
      "Progress note templates",
      "Snacks / water"
    ],
    "St PJ’s Shelter": [
      "ID badge",
      "Warm layers",
      "Resource handouts",
      "Portable charger",
      "Snacks"
    ],
    "Craniofacial Clinic": [
      "Care plan binders",
      "Growth charts",
      "Camera / tablet",
      "Consent forms",
      "Comfort items"
    ]
  };
  const SLEEP_CHECKLIST_ITEMS = [
    {
      id: "warmShower",
      label: "Warm shower or bath 1–2 hours before bed",
      tip: "Warm water triggers a cooling rebound that cues melatonin."
    },
    {
      id: "blueLight",
      label: "Blue-light blocker on screens",
      tip: "Filtering blue light reduces melatonin suppression from devices."
    },
    {
      id: "activity",
      label: "Light physical activity earlier today",
      tip: "Daytime movement builds sleep pressure for smoother nights."
    },
    {
      id: "caffeine",
      label: "Caffeine curfew observed (last sip by 2 PM)",
      tip: "Caffeine has a ~6 hour half-life—curbing it prevents bedtime jitters."
    },
    {
      id: "magnesium",
      label: "Optional magnesium or electrolytes",
      tip: "Magnesium calms the nervous system and supports muscle recovery."
    }
  ];
  const WEEKDAY_OPTIONS = [
    { label: "Any day", value: "any" },
    { label: "Weekdays", value: "weekdays" },
    { label: "Monday", value: "1" },
    { label: "Tuesday", value: "2" },
    { label: "Wednesday", value: "3" },
    { label: "Thursday", value: "4" },
    { label: "Friday", value: "5" },
    { label: "Saturday", value: "6" },
    { label: "Sunday", value: "0" }
  ];

  function getChartFields() {
    return chartFieldIds
      .map(id => $(id))
      .filter(Boolean);
  }

  function setChartFieldsDisabled(isDisabled) {
    getChartFields().forEach(field => {
      field.disabled = isDisabled;
    });
  }

  function storeChartFieldValues() {
    storedChartFieldValues = {};
    chartFieldIds.forEach(id => {
      const field = $(id);
      if (field) {
        storedChartFieldValues[id] = field.value;
      }
    });
  }

  function restoreChartFieldValues() {
    if (!storedChartFieldValues) return;
    chartFieldIds.forEach(id => {
      if (Object.prototype.hasOwnProperty.call(storedChartFieldValues, id)) {
        const field = $(id);
        if (field) {
          field.value = storedChartFieldValues[id];
        }
      }
    });
    storedChartFieldValues = null;
  }

  function showChartFields() {
    const container = $("chartFields");
    if (!container) return;
    container.classList.remove("is-hidden");
    container.setAttribute("aria-hidden", "false");
    setChartFieldsDisabled(false);
    restoreChartFieldValues();
    updateDerivedFields();
  }

  function hideChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storeChartFieldValues();
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  function getToastContainer() {
    return $("toastContainer");
  }

  function showToast(title, message, options = {}) {
    const container = getToastContainer();
    if (!container) return;
    const toast = document.createElement("div");
    toast.className = "toast";
    toast.setAttribute("role", "status");
    const heading = document.createElement("strong");
    heading.textContent = title;
    toast.appendChild(heading);
    const body = document.createElement("div");
    body.textContent = message;
    toast.appendChild(body);
    container.appendChild(toast);
    const timeout = Number.isFinite(options.timeout) ? options.timeout : 6000;
    setTimeout(() => {
      toast.classList.add("hidden");
      setTimeout(() => toast.remove(), 350);
    }, timeout);
  }

  function getDateKey(date = new Date()) {
    const dt = new Date(date);
    dt.setHours(0, 0, 0, 0);
    const year = dt.getFullYear();
    const month = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function getTodayKey() {
    return getDateKey(new Date());
  }

  function getTomorrowKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() + 1);
    return getDateKey(dt);
  }

  function getYesterdayKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() - 1);
    return getDateKey(dt);
  }

  function formatFriendlyDate(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function formatShortDateLabel(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  function getDateKeyFromIso(isoString) {
    if (!isoString) return null;
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) return null;
    return getDateKey(date);
  }

  function getDefaultMorningEntry() {
    return {
      completed: {
        move: false,
        reflect: false,
        plan: false
      },
      intention: "",
      planNotes: "",
      energy: null,
      skip: false,
      countdownBlock: null,
      countdownEnd: null,
      celebrated: false,
      lastUpdated: null
    };
  }

  function getDefaultMorningState() {
    return {
      enabled: false,
      entries: {}
    };
  }

  function loadMorningLaunchState() {
    if (morningLaunchState) return morningLaunchState;
    try {
      const raw = localStorage.getItem(MORNING_LAUNCH_KEY);
      if (!raw) {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const state = { ...getDefaultMorningState(), ...parsed };
      if (!state.entries || typeof state.entries !== "object") {
        state.entries = {};
      }
      Object.keys(state.entries).forEach(key => {
        state.entries[key] = { ...getDefaultMorningEntry(), ...state.entries[key] };
      });
      morningLaunchState = state;
    } catch (error) {
      console.error("Unable to load morning launch state", error);
      morningLaunchState = getDefaultMorningState();
    }
    return morningLaunchState;
  }

  function persistMorningLaunchState() {
    if (!morningLaunchState) return;
    try {
      if (morningLaunchState.entries) {
        const keys = Object.keys(morningLaunchState.entries).sort();
        if (keys.length > 60) {
          const toRemove = keys.slice(0, keys.length - 60);
          toRemove.forEach(key => delete morningLaunchState.entries[key]);
        }
      }
      const serialized = JSON.stringify(morningLaunchState);
      localStorage.setItem(MORNING_LAUNCH_KEY, serialized);
    } catch (error) {
      console.error("Unable to persist morning launch state", error);
    }
  }

  function getMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    if (!state.entries) state.entries = {};
    if (!state.entries[dateKey]) {
      state.entries[dateKey] = getDefaultMorningEntry();
    }
    return state.entries[dateKey];
  }

  function resetMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    state.entries[dateKey] = getDefaultMorningEntry();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function setMorningSkip(dateKey = getTodayKey(), skip = true) {
    const entry = getMorningEntry(dateKey);
    entry.skip = skip;
    if (skip) {
      MORNING_BLOCKS.forEach(block => {
        entry.completed[block] = false;
      });
      entry.celebrated = false;
    }
    clearMorningCountdown(entry);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function clearMorningCountdown(entry) {
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = null;
    if (entry) {
      entry.countdownBlock = null;
      entry.countdownEnd = null;
    }
  }

  function formatCountdown(msRemaining) {
    if (!Number.isFinite(msRemaining) || msRemaining <= 0) {
      return "00:00";
    }
    const totalSeconds = Math.ceil(msRemaining / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }

  function updateMoveCountdownDisplay(remainingMs) {
    const display = $("moveCountdown");
    if (!display) return;
    if (!Number.isFinite(remainingMs) || remainingMs <= 0) {
      display.textContent = "20:00";
      return;
    }
    display.textContent = formatCountdown(remainingMs);
  }

  function resumeMorningCountdown(entry) {
    if (!entry || !entry.countdownBlock || !entry.countdownEnd) {
      updateMoveCountdownDisplay(null);
      return;
    }
    const remaining = entry.countdownEnd - Date.now();
    if (remaining <= 0) {
      clearMorningCountdown(entry);
      updateMoveCountdownDisplay(null);
      showToast("MOVE timer", "20 minutes are up. Celebrate the endorphins!");
      return;
    }
    updateMoveCountdownDisplay(remaining);
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = {
      block: entry.countdownBlock,
      intervalId: setInterval(() => {
        const nowRemaining = entry.countdownEnd - Date.now();
        if (nowRemaining <= 0) {
          clearMorningCountdown(entry);
          updateMoveCountdownDisplay(null);
          showToast("MOVE timer", "20 minutes are up. Nice job getting sunlight and motion!");
        } else {
          updateMoveCountdownDisplay(nowRemaining);
        }
      }, 1000)
    };
  }

  function startMorningCountdown(block = "move") {
    const entry = getMorningEntry();
    entry.skip = false;
    entry.countdownBlock = block;
    entry.countdownEnd = Date.now() + DEFAULT_MORNING_TIMER_MINUTES * 60 * 1000;
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    resumeMorningCountdown(entry);
  }

  function setMorningBlockCompleted(block, data = {}) {
    const entry = getMorningEntry();
    entry.skip = false;
    if (!entry.completed) {
      entry.completed = { move: false, reflect: false, plan: false };
    }
    entry.completed[block] = true;
    if (block === "reflect" && data.intention !== undefined) {
      entry.intention = data.intention;
    }
    if (block === "plan" && data.planNotes !== undefined) {
      entry.planNotes = data.planNotes;
    }
    if (block === "move") {
      clearMorningCountdown(entry);
    }
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    showToast("Morning Launch", `Nice momentum! ${block.toUpperCase()} locked in.`);
  }

  function logMorningEnergy(value) {
    const entry = getMorningEntry();
    entry.energy = Number(value);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    if (Number.isFinite(entry.energy)) {
      const label = ENERGY_LABELS[entry.energy] || entry.energy;
      showToast("Energy logged", `Morning energy set to ${label}.`);
    }
  }

  function getMorningHistory(limit = 10) {
    const state = loadMorningLaunchState();
    const entries = Object.entries(state.entries || {});
    return entries
      .sort((a, b) => (a[0] > b[0] ? -1 : 1))
      .slice(0, limit)
      .map(([dateKey, entry]) => ({ dateKey, entry }));
  }

  function buildMorningStatus(entry) {
    if (entry.skip) {
      return "Launch skipped today. Reset whenever you’re ready.";
    }
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed[block]);
    if (!completedBlocks.length) {
      return "Start with MOVE to flood dopamine and sunlight cues.";
    }
    if (completedBlocks.length === MORNING_BLOCKS.length) {
      if (!entry.celebrated) {
        entry.celebrated = true;
        persistMorningLaunchState();
        showToast("Morning Launch", "All three blocks complete. Notice your focus surge later today.");
      }
      return "🌟 All three blocks complete. Anchor this momentum into your next action.";
    }
    if (completedBlocks.length === 1) {
      return `Great job completing ${completedBlocks[0].toUpperCase()}! Next up: ${completedBlocks[0] === "move" ? "REFLECT" : "PLAN"}.`;
    }
    return "Great job completing MOVE and REFLECT! Lock in a process-based PLAN next.";
  }

  function updateMorningHistoryList() {
    const list = $("morningLaunchHistory");
    if (!list) return;
    const history = getMorningHistory(7);
    list.innerHTML = "";
    if (!history.length) {
      const item = document.createElement("li");
      item.textContent = "No mornings logged yet.";
      list.appendChild(item);
      return;
    }
    history.forEach(({ dateKey, entry }) => {
      const item = document.createElement("li");
      const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
      const energyLabel = entry.energy ? ENERGY_LABELS[entry.energy] || entry.energy : "--";
      item.textContent = `${formatFriendlyDate(dateKey)} — ${completedCount}/${MORNING_BLOCKS.length} blocks • Energy: ${energyLabel}`;
      list.appendChild(item);
    });
  }

  function calculateMorningCompletionPercent(entry) {
    if (!entry || entry.skip) return 0;
    const totalBlocks = MORNING_BLOCKS.length || 1;
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    return Math.round((completedBlocks / totalBlocks) * 100);
  }

  function renderMorningLaunchChart(limit = MORNING_CHART_LIMIT) {
    const canvas = $("morningLaunchChart");
    const summaryEl = $("morningLaunchChartSummary");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const width = canvas.clientWidth || canvas.width || 360;
    const height = canvas.clientHeight || canvas.height || 160;
    canvas.width = width;
    canvas.height = height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const history = getMorningHistory(limit);
    if (!history.length) {
      ctx.fillStyle = "#6b7280";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Complete your morning launch to unlock insights.", canvas.width / 2, canvas.height / 2);
      if (summaryEl) {
        summaryEl.textContent = "Complete your morning launch to unlock momentum and energy trends.";
      }
      return;
    }
    const chronological = [...history].reverse();
    const padding = 28;
    const graphWidth = canvas.width - padding * 2;
    const graphHeight = canvas.height - padding * 2;
    const xStep = chronological.length > 1 ? graphWidth / (chronological.length - 1) : 0;
    const completionPoints = [];
    const energyPoints = [];
    chronological.forEach((item, index) => {
      const { entry, dateKey } = item;
      completionPoints.push({
        index,
        value: calculateMorningCompletionPercent(entry),
        dateKey
      });
      const energy = Number(entry.energy);
      energyPoints.push({
        index,
        value: Number.isFinite(energy) ? Math.round(Math.max(0, Math.min(100, ((energy - 1) / 4) * 100))) : null,
        energy: Number.isFinite(energy) ? energy : null,
        dateKey
      });
    });
    const project = value => {
      const safeValue = Math.max(0, Math.min(100, Number(value) || 0));
      return canvas.height - padding - (safeValue / 100) * graphHeight;
    };
    ctx.strokeStyle = MORNING_CHART_COLORS.axis;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    const gridValues = [25, 50, 75, 100];
    ctx.setLineDash([4, 4]);
    gridValues.forEach(value => {
      const y = project(value);
      ctx.strokeStyle = MORNING_CHART_COLORS.grid;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      ctx.fillStyle = "#7f8a9c";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      ctx.fillText(`${value}%`, padding - 6, y + 3);
    });
    ctx.setLineDash([]);
    ctx.fillStyle = "#9aa6b8";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    chronological.forEach((item, index) => {
      const x = padding + xStep * index;
      ctx.fillText(formatShortDateLabel(item.dateKey), x, canvas.height - padding + 14);
    });
    ctx.fillStyle = "#8893a5";
    ctx.textAlign = "left";
    ctx.fillText("Energy line scaled so top = level 5", padding, padding - 10);
    const drawLine = (points, color, dashed = false) => {
      const valid = points.filter(point => Number.isFinite(point.value));
      if (!valid.length) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dashed ? [6, 4] : []);
      ctx.beginPath();
      valid.forEach((point, idx) => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);
      valid.forEach(point => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });
      ctx.restore();
    };
    drawLine(completionPoints, MORNING_CHART_COLORS.completion, false);
    drawLine(energyPoints, MORNING_CHART_COLORS.energy, true);
    if (summaryEl) {
      const completionSum = completionPoints.reduce((sum, point) => sum + (Number.isFinite(point.value) ? point.value : 0), 0);
      const completionAvg = completionPoints.length
        ? Math.round(completionSum / completionPoints.length)
        : 0;
      const energyValid = energyPoints.filter(point => Number.isFinite(point.energy));
      let summary = `Last ${chronological.length}-day average completion: ${completionAvg}%`;
      if (energyValid.length) {
        const avgEnergy = energyValid.reduce((sum, point) => sum + point.energy, 0) / energyValid.length;
        const label = ENERGY_LABELS[Math.round(avgEnergy)] || "";
        summary += ` • Energy ≈ ${avgEnergy.toFixed(1)}${label ? ` (${label})` : ""}`;
      } else {
        summary += " • Log energy to compare how rested mornings drive completion";
      }
      summaryEl.textContent = `${summary}.`;
    }
  }

  function updateMorningLaunchUI() {
    const state = loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    const content = $("morningLaunchContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      clearMorningCountdown(getMorningEntry());
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const summary = $("morningLaunchChartSummary");
      if (summary) {
        summary.textContent = "Enable Morning Launch to start tracking your morning momentum.";
      }
      const chart = $("morningLaunchChart");
      if (chart) {
        const ctx = chart.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, chart.width, chart.height);
        }
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    const entry = getMorningEntry();
    const intentionField = $("morningIntention");
    const planField = $("morningPlanNotes");
    if (intentionField) {
      intentionField.value = entry.intention || "";
    }
    if (planField) {
      planField.value = entry.planNotes || "";
    }
    const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    const progress = $("morningLaunchProgress");
    if (progress) {
      const width = Math.round((completedCount / MORNING_BLOCKS.length) * 100);
      progress.style.width = `${width}%`;
    }
    const status = $("morningLaunchStatus");
    if (status) {
      status.textContent = buildMorningStatus(entry);
    }
    MORNING_BLOCKS.forEach(block => {
      const blockEl = document.querySelector(`.routine-block[data-block="${block}"]`);
      if (blockEl) {
        blockEl.classList.toggle("completed", Boolean(entry.completed?.[block]));
      }
    });
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      const value = Number.isFinite(entry.energy) ? entry.energy : 3;
      energySlider.value = String(value);
      if (energyLabel) {
        const label = ENERGY_LABELS[value] || value;
        energyLabel.textContent = `${label}`;
      }
    }
    resumeMorningCountdown(entry);
    updateMorningHistoryList();
    renderMorningLaunchChart();
  }

  function initializeMorningLaunchModule() {
    loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadMorningLaunchState();
        state.enabled = event.target.checked;
        persistMorningLaunchState();
        updateMorningLaunchUI();
      });
    }
    const resetBtn = $("morningLaunchResetBtn");
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        if (confirm("Reset today's launch blocks?")) {
          resetMorningEntry();
        }
      });
    }
    const skipBtn = $("morningLaunchSkipBtn");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => setMorningSkip(getTodayKey(), true));
    }
    const moveStart = $("moveStartBtn");
    if (moveStart) {
      moveStart.addEventListener("click", () => startMorningCountdown("move"));
    }
    const moveComplete = $("moveCompleteBtn");
    if (moveComplete) {
      moveComplete.addEventListener("click", () => setMorningBlockCompleted("move"));
    }
    const reflectSave = $("reflectCompleteBtn");
    if (reflectSave) {
      reflectSave.addEventListener("click", () => {
        const intention = $("morningIntention")?.value.trim() || "";
        setMorningBlockCompleted("reflect", { intention });
      });
    }
    const planSave = $("planCompleteBtn");
    if (planSave) {
      planSave.addEventListener("click", () => {
        const planNotes = $("morningPlanNotes")?.value.trim() || "";
        setMorningBlockCompleted("plan", { planNotes });
      });
    }
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || 3);
        if (energyLabel) {
          const label = ENERGY_LABELS[value] || value;
          energyLabel.textContent = label;
        }
      });
    }
    const energySave = $("morningEnergySave");
    if (energySave) {
      energySave.addEventListener("click", () => {
        const value = Number($("morningEnergy")?.value || 3);
        logMorningEnergy(value);
      });
    }
    const intentionButtons = document.querySelectorAll(".intention-buttons button[data-intention]");
    if (intentionButtons.length) {
      intentionButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const intention = btn.getAttribute("data-intention") || "";
          const field = $("morningIntention");
          if (field) {
            field.value = intention;
            field.focus();
          }
        });
      });
    }
    updateMorningLaunchUI();
  }

  function generateLaunchPadItemId() {
    return `lp_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`;
  }

  function getDefaultLaunchPadState() {
    return {
      reminderTime: DEFAULT_LAUNCH_PAD_REMINDER,
      activeSite: DEFAULT_LAUNCH_PAD_SITE,
      items: {},
      status: {},
      lastReminderDate: null,
      lastMorningNudge: null
    };
  }

  function normalizeLaunchPadState(state) {
    const base = { ...getDefaultLaunchPadState(), ...state };
    if (!base.items || typeof base.items !== "object") {
      base.items = {};
    }
    if (!base.status || typeof base.status !== "object") {
      base.status = {};
    }
    Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
      if (!Array.isArray(base.items[site]) || !base.items[site].length) {
        base.items[site] = LAUNCH_PAD_PRESETS[site].map(name => ({
          id: generateLaunchPadItemId(),
          name,
          dayRule: "any",
          isCustom: false
        }));
      } else {
        base.items[site] = base.items[site].map(item => ({
          id: item.id || generateLaunchPadItemId(),
          name: item.name || "Item",
          dayRule: item.dayRule || "any",
          isCustom: Boolean(item.isCustom)
        }));
      }
    });
    if (!base.items[base.activeSite]) {
      base.activeSite = DEFAULT_LAUNCH_PAD_SITE;
    }
    return base;
  }

  function loadLaunchPadState() {
    if (launchPadState) return launchPadState;
    try {
      const raw = localStorage.getItem(LAUNCH_PAD_KEY);
      if (!raw) {
        launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
        return launchPadState;
      }
      const parsed = JSON.parse(raw);
      launchPadState = normalizeLaunchPadState(parsed || {});
    } catch (error) {
      console.error("Unable to load launch pad state", error);
      launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
    }
    return launchPadState;
  }

  function persistLaunchPadState() {
    if (!launchPadState) return;
    try {
      if (launchPadState.status) {
        const keys = Object.keys(launchPadState.status).sort();
        if (keys.length > 90) {
          const toRemove = keys.slice(0, keys.length - 90);
          toRemove.forEach(key => delete launchPadState.status[key]);
        }
      }
      localStorage.setItem(LAUNCH_PAD_KEY, JSON.stringify(launchPadState));
    } catch (error) {
      console.error("Unable to persist launch pad state", error);
    }
    updateLaunchPadSummary();
  }

  function ensureLaunchPadSite(site) {
    const state = loadLaunchPadState();
    if (!state.items[site]) {
      const preset = LAUNCH_PAD_PRESETS[site] || [];
      state.items[site] = preset.map(name => ({
        id: generateLaunchPadItemId(),
        name,
        dayRule: "any",
        isCustom: false
      }));
    }
    return state.items[site];
  }

  function setLaunchPadActiveSite(site) {
    const state = loadLaunchPadState();
    state.activeSite = site;
    ensureLaunchPadSite(site);
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function loadPresetForActiveSite() {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const preset = LAUNCH_PAD_PRESETS[site] || [];
    state.items[site] = preset.map(name => ({
      id: generateLaunchPadItemId(),
      name,
      dayRule: "any",
      isCustom: false
    }));
    persistLaunchPadState();
    renderLaunchPadSettings();
    showToast("Launch pad reset", `${site} preset restored.`);
  }

  function addLaunchPadItem(name) {
    const trimmed = (name || "").trim();
    if (!trimmed) return;
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    ensureLaunchPadSite(site);
    state.items[site].push({
      id: generateLaunchPadItemId(),
      name: trimmed,
      dayRule: "any",
      isCustom: true
    });
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function removeLaunchPadItem(itemId) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const next = list.filter(item => item.id !== itemId);
    state.items[site] = next;
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function updateLaunchPadDayRule(itemId, dayRule) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const item = list.find(entry => entry.id === itemId);
    if (item) {
      item.dayRule = dayRule;
      persistLaunchPadState();
    }
  }

  function shouldIncludeLaunchPadItemOnDate(item, dateKey) {
    if (!item || !dateKey) return false;
    if (!item.dayRule || item.dayRule === "any") return true;
    const dt = new Date(`${dateKey}T00:00:00`);
    if (Number.isNaN(dt.getTime())) return true;
    const weekday = dt.getDay();
    if (item.dayRule === "weekdays") {
      return weekday >= 1 && weekday <= 5;
    }
    return String(weekday) === String(item.dayRule);
  }

  function getLaunchPadStatus(dateKey) {
    const state = loadLaunchPadState();
    if (!state.status[dateKey]) {
      state.status[dateKey] = {};
    }
    return state.status[dateKey];
  }

  function setLaunchPadItemReady(dateKey, itemId, ready) {
    const status = getLaunchPadStatus(dateKey);
    status[itemId] = Boolean(ready);
    persistLaunchPadState();
    updateLaunchPadSummary();
  }

  function computeLaunchPadReadiness(dateKey) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const relevant = list.filter(item => shouldIncludeLaunchPadItemOnDate(item, dateKey));
    const status = getLaunchPadStatus(dateKey);
    const readyCount = relevant.filter(item => status[item.id]).length;
    return {
      total: relevant.length,
      ready: readyCount,
      items: relevant,
      status
    };
  }

  function updateLaunchPadSummary() {
    const summary = $("launchPadSummary");
    if (!summary) return;
    const todayKey = getTodayKey();
    const readiness = computeLaunchPadReadiness(todayKey);
    if (readiness.total === 0) {
      summary.textContent = "No launch pad items scheduled for today.";
      return;
    }
    summary.innerHTML = "";
    const header = document.createElement("strong");
    header.textContent = `Launch Pad: ${readiness.ready}/${readiness.total} items ready`;
    summary.appendChild(header);
    const hint = document.createElement("div");
    if (readiness.ready === readiness.total) {
      hint.textContent = "Everything is staged — future you says thanks!";
    } else {
      const remaining = readiness.total - readiness.ready;
      hint.textContent = `${remaining} item(s) still need attention before heading out.`;
    }
    summary.appendChild(hint);
  }

  function renderLaunchPadSettings() {
    const state = loadLaunchPadState();
    const siteSelect = $("launchPadSiteSelect");
    if (siteSelect) {
      siteSelect.innerHTML = "";
      Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
        const option = document.createElement("option");
        option.value = site;
        option.textContent = site;
        if (site === state.activeSite) {
          option.selected = true;
        }
        siteSelect.appendChild(option);
      });
      siteSelect.onchange = event => {
        setLaunchPadActiveSite(event.target.value);
      };
    }
    const timeInput = $("launchPadReminderTime");
    if (timeInput) {
      timeInput.value = state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER;
      timeInput.onchange = event => {
        state.reminderTime = event.target.value || DEFAULT_LAUNCH_PAD_REMINDER;
        persistLaunchPadState();
      };
    }
    const listContainer = $("launchPadItemList");
    if (listContainer) {
      listContainer.innerHTML = "";
      const items = ensureLaunchPadSite(state.activeSite || DEFAULT_LAUNCH_PAD_SITE);
      if (!items.length) {
        const empty = document.createElement("p");
        empty.className = "score";
        empty.textContent = "No launch pad items yet.";
        listContainer.appendChild(empty);
      } else {
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "launch-pad-item";
          const name = document.createElement("div");
          name.textContent = item.name;
          if (item.isCustom) {
            const custom = document.createElement("small");
            custom.textContent = "custom";
            name.appendChild(document.createElement("br"));
            name.appendChild(custom);
          }
          const select = document.createElement("select");
          WEEKDAY_OPTIONS.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            if (option.value === item.dayRule) {
              opt.selected = true;
            }
            select.appendChild(opt);
          });
          select.addEventListener("change", event => {
            updateLaunchPadDayRule(item.id, event.target.value);
          });
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "🗑";
          removeBtn.title = "Remove item";
          removeBtn.addEventListener("click", () => {
            if (confirm(`Remove ${item.name}?`)) {
              removeLaunchPadItem(item.id);
            }
          });
          row.appendChild(name);
          row.appendChild(select);
          row.appendChild(removeBtn);
          listContainer.appendChild(row);
        });
      }
    }
    updateLaunchPadSummary();
  }

  function renderLaunchPadModalList(targetDateKey) {
    const container = $("launchPadModalList");
    if (!container) return;
    container.innerHTML = "";
    const readiness = computeLaunchPadReadiness(targetDateKey);
    if (!readiness.total) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No items needed for that day.";
      container.appendChild(empty);
      return;
    }
    readiness.items.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(readiness.status[item.id]);
      checkbox.addEventListener("change", event => {
        setLaunchPadItemReady(targetDateKey, item.id, event.target.checked);
      });
      const span = document.createElement("span");
      span.textContent = item.name;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function setModalVisibility(modalId, isVisible) {
    const overlay = $(modalId);
    if (!overlay) return;
    if (isVisible) {
      overlay.classList.remove("hidden");
      overlay.setAttribute("aria-hidden", "false");
    } else {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
  }

  function openLaunchPadModal(options = {}) {
    const { targetDateKey = getTomorrowKey() } = options;
    renderLaunchPadModalList(targetDateKey);
    const overlay = $("launchPadModal");
    if (!overlay) return;
    overlay.dataset.targetDate = targetDateKey;
    setModalVisibility("launchPadModal", true);
  }

  function closeLaunchPadModal() {
    setModalVisibility("launchPadModal", false);
  }

  function initializeLaunchPadModule() {
    loadLaunchPadState();
    renderLaunchPadSettings();
    const addBtn = $("launchPadAddItem");
    if (addBtn) {
      addBtn.addEventListener("click", () => {
        const field = $("launchPadNewItem");
        addLaunchPadItem(field?.value || "");
        if (field) field.value = "";
      });
    }
    const presetBtn = $("launchPadLoadPreset");
    if (presetBtn) {
      presetBtn.addEventListener("click", () => {
        if (confirm("Reset this site's launch pad to the curated preset?")) {
          loadPresetForActiveSite();
        }
      });
    }
    const openEvening = $("openLaunchPadModal");
    if (openEvening) {
      openEvening.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTomorrowKey() }));
    }
    const morningReview = $("launchPadMorningReview");
    if (morningReview) {
      morningReview.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTodayKey() }));
    }
    const modalClose = $("launchPadModalClose");
    if (modalClose) {
      modalClose.addEventListener("click", () => {
        closeLaunchPadModal();
      });
    }
    const overlay = $("launchPadModal");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeLaunchPadModal();
        }
      });
    }
    updateLaunchPadSummary();
  }

  function getDefaultSleepState() {
    return {
      enabled: false,
      checklist: {},
      melatonin: {
        enabled: false,
        time: DEFAULT_MELATONIN_TIME,
        lastPrompt: null
      },
      sunlight: {
        enabled: false,
        time: DEFAULT_SUNLIGHT_TIME,
        lastPrompt: null
      },
      restRatings: {}
    };
  }

  function loadSleepToolkitState() {
    if (sleepToolkitState) return sleepToolkitState;
    try {
      const raw = localStorage.getItem(SLEEP_TOOLKIT_KEY);
      if (!raw) {
        sleepToolkitState = getDefaultSleepState();
        return sleepToolkitState;
      }
      const parsed = JSON.parse(raw);
      sleepToolkitState = { ...getDefaultSleepState(), ...parsed };
      if (!sleepToolkitState.checklist || typeof sleepToolkitState.checklist !== "object") {
        sleepToolkitState.checklist = {};
      }
      if (!sleepToolkitState.restRatings || typeof sleepToolkitState.restRatings !== "object") {
        sleepToolkitState.restRatings = {};
      }
    } catch (error) {
      console.error("Unable to load sleep toolkit state", error);
      sleepToolkitState = getDefaultSleepState();
    }
    return sleepToolkitState;
  }

  function persistSleepToolkitState() {
    if (!sleepToolkitState) return;
    try {
      if (sleepToolkitState.checklist) {
        const keys = Object.keys(sleepToolkitState.checklist).sort();
        if (keys.length > 120) {
          const toRemove = keys.slice(0, keys.length - 120);
          toRemove.forEach(key => delete sleepToolkitState.checklist[key]);
        }
      }
      if (sleepToolkitState.restRatings) {
        const ratingKeys = Object.keys(sleepToolkitState.restRatings).sort();
        if (ratingKeys.length > 180) {
          const prune = ratingKeys.slice(0, ratingKeys.length - 180);
          prune.forEach(key => delete sleepToolkitState.restRatings[key]);
        }
      }
      localStorage.setItem(SLEEP_TOOLKIT_KEY, JSON.stringify(sleepToolkitState));
    } catch (error) {
      console.error("Unable to persist sleep toolkit state", error);
    }
  }

  function getSleepChecklistEntry(dateKey = getTodayKey()) {
    const state = loadSleepToolkitState();
    if (!state.checklist[dateKey]) {
      const entry = {};
      SLEEP_CHECKLIST_ITEMS.forEach(item => {
        entry[item.id] = false;
      });
      state.checklist[dateKey] = entry;
    }
    return state.checklist[dateKey];
  }

  function toggleSleepChecklistItem(itemId, value, dateKey = getTodayKey()) {
    const checklist = getSleepChecklistEntry(dateKey);
    if (!Object.prototype.hasOwnProperty.call(checklist, itemId)) return;
    checklist[itemId] = Boolean(value);
    persistSleepToolkitState();
    updateSleepToolkitUI();
  }

  function computeSleepCompletion(dateKey = getTodayKey()) {
    const checklist = getSleepChecklistEntry(dateKey);
    const total = SLEEP_CHECKLIST_ITEMS.length;
    const completed = SLEEP_CHECKLIST_ITEMS.filter(item => checklist[item.id]).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function renderSleepChecklist(dateKey = getTodayKey()) {
    const container = $("sleepChecklist");
    if (!container) return;
    const checklist = getSleepChecklistEntry(dateKey);
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(checklist[item.id]);
      checkbox.addEventListener("change", event => {
        toggleSleepChecklistItem(item.id, event.target.checked, dateKey);
      });
      const span = document.createElement("div");
      const title = document.createElement("strong");
      title.textContent = item.label;
      const tip = document.createElement("div");
      tip.textContent = item.tip;
      tip.style.fontSize = "0.78rem";
      tip.style.color = "#9aa0a6";
      span.appendChild(title);
      span.appendChild(tip);
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function updateSleepCompletionSummary(dateKey = getTodayKey()) {
    const summary = $("sleepCompletionSummary");
    if (!summary) return;
    const { total, completed, percent } = computeSleepCompletion(dateKey);
    summary.textContent = `You hit ${completed}/${total} sleep steps – ${percent}% consistency.`;
  }

  function renderSleepTips() {
    const container = $("sleepTips");
    if (!container) return;
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const tip = document.createElement("div");
      tip.textContent = `• ${item.tip}`;
      container.appendChild(tip);
    });
  }

  function recordSleepRating(dateKey, rating) {
    const state = loadSleepToolkitState();
    state.restRatings[dateKey] = Number(rating);
    persistSleepToolkitState();
    updateSleepToolkitUI();
    const label = SLEEP_RATING_LABELS[rating] || rating;
    showToast("Sleep logged", `Restfulness marked as ${label}.`);
  }

  function countChartTasksCompletedOn(dateKey) {
    if (!dateKey) return 0;
    return tasks.filter(task => {
      if (!isChartTask(task)) return false;
      const completionKey = getDateKeyFromIso(task.completedAt);
      return completionKey === dateKey;
    }).length;
  }

  function updateSleepCorrelationSummary() {
    const summary = $("sleepCorrelationSummary");
    if (!summary) return;
    const state = loadSleepToolkitState();
    const entries = Object.entries(state.restRatings || {});
    if (!entries.length) {
      summary.textContent = "Log rest ratings to see how sleep fuels charting momentum.";
      return;
    }
    let highCount = 0;
    let highCharts = 0;
    let lowCount = 0;
    let lowCharts = 0;
    entries.forEach(([dateKey, rating]) => {
      const charts = countChartTasksCompletedOn(dateKey);
      if (Number(rating) >= 4) {
        highCount += 1;
        highCharts += charts;
      } else {
        lowCount += 1;
        lowCharts += charts;
      }
    });
    const avgHigh = highCount ? (highCharts / highCount).toFixed(1) : "0.0";
    const avgLow = lowCount ? (lowCharts / lowCount).toFixed(1) : "0.0";
    summary.innerHTML = `Rested (≥4): ${avgHigh} chart(s) completed next day.<br/>Draggy (≤3): ${avgLow} chart(s).`;
  }

  function renderSleepMorningRating() {
    const container = $("sleepMorningRating");
    if (!container) return;
    container.innerHTML = "";
    const state = loadSleepToolkitState();
    const targetKey = getYesterdayKey();
    if (!targetKey) return;
    const existing = state.restRatings[targetKey];
    const label = document.createElement("label");
    label.style.margin = "0";
    label.textContent = `How rested do you feel this morning (${formatFriendlyDate(targetKey)})?`;
    container.appendChild(label);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "1";
    slider.max = "5";
    slider.step = "1";
    slider.value = String(existing || 3);
    slider.style.flex = "1";
    const valueLabel = document.createElement("span");
    valueLabel.textContent = SLEEP_RATING_LABELS[slider.value] || slider.value;
    slider.addEventListener("input", event => {
      const val = Number(event.target.value);
      valueLabel.textContent = SLEEP_RATING_LABELS[val] || val;
    });
    const save = document.createElement("button");
    save.textContent = existing ? "Update rating" : "Log rating";
    save.addEventListener("click", () => {
      recordSleepRating(targetKey, Number(slider.value));
    });
    container.appendChild(slider);
    container.appendChild(valueLabel);
    container.appendChild(save);
  }

  function updateSleepToolkitUI() {
    const state = loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    const content = $("sleepToolkitContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const alert = $("sunlightAlert");
      if (alert) {
        alert.classList.add("hidden");
        alert.setAttribute("aria-hidden", "true");
      }
      if (sunlightAlertTimeoutId) {
        clearTimeout(sunlightAlertTimeoutId);
        sunlightAlertTimeoutId = null;
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    renderSleepChecklist();
    updateSleepCompletionSummary();
    renderSleepTips();
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.checked = Boolean(state.melatonin?.enabled);
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.value = state.melatonin?.time || DEFAULT_MELATONIN_TIME;
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.checked = Boolean(state.sunlight?.enabled);
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.value = state.sunlight?.time || DEFAULT_SUNLIGHT_TIME;
    }
    renderSleepMorningRating();
    updateSleepCorrelationSummary();
  }

  function initializeSleepToolkitModule() {
    loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.enabled = event.target.checked;
        persistSleepToolkitState();
        updateSleepToolkitUI();
      });
    }
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.time = event.target.value || DEFAULT_MELATONIN_TIME;
        persistSleepToolkitState();
      });
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.time = event.target.value || DEFAULT_SUNLIGHT_TIME;
        persistSleepToolkitState();
      });
    }
    updateSleepToolkitUI();
  }

  function getMinutesFromTimeString(timeString) {
    if (!timeString || typeof timeString !== "string") return null;
    const [hours, minutes] = timeString.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    return hours * 60 + minutes;
  }

  function showSunlightBanner(message) {
    const alert = $("sunlightAlert");
    if (!alert) return;
    alert.textContent = message;
    alert.classList.remove("hidden");
    alert.setAttribute("aria-hidden", "false");
    if (sunlightAlertTimeoutId) {
      clearTimeout(sunlightAlertTimeoutId);
    }
    sunlightAlertTimeoutId = setTimeout(() => {
      alert.classList.add("hidden");
      alert.setAttribute("aria-hidden", "true");
    }, 5 * 60 * 1000);
  }

  function checkLaunchPadReminder() {
    const state = loadLaunchPadState();
    const timeMinutes = getMinutesFromTimeString(state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.lastReminderDate !== todayKey) {
      state.lastReminderDate = todayKey;
      persistLaunchPadState();
      showToast("Launch pad", "Prepare tomorrow's kit? Check your evening checklist.");
    }
  }

  function checkMelatoninReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.melatonin?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.melatonin.time || DEFAULT_MELATONIN_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.melatonin.lastPrompt !== todayKey) {
      state.melatonin.lastPrompt = todayKey;
      persistSleepToolkitState();
      showToast("Melatonin reminder", "Dim the lights and consider your melatonin routine.");
    }
  }

  function checkSunlightReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.sunlight?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.sunlight.time || DEFAULT_SUNLIGHT_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.sunlight.lastPrompt !== todayKey) {
      state.sunlight.lastPrompt = todayKey;
      persistSleepToolkitState();
      showSunlightBanner("Sunlight exposure due — step outside for 10 minutes to halt melatonin.");
      showToast("Sunlight cue", "Morning light = cortisol boost + melatonin shutoff.");
    }
  }

  function checkAllReminders() {
    checkLaunchPadReminder();
    checkMelatoninReminder();
    checkSunlightReminder();
  }

  function startReminderLoop() {
    if (reminderIntervalId) {
      clearInterval(reminderIntervalId);
    }
    checkAllReminders();
    reminderIntervalId = setInterval(checkAllReminders, 60 * 1000);
  }

  function handleCategoryChange(value) {
    const resolvedCategory = (value ?? $("taskCategory")?.value ?? "").toString();
    populateScalesForCategory(resolvedCategory);
    if (resolvedCategory.toLowerCase() === "chart") {
      showChartFields();
    } else {
      hideChartFields();
    }
    renderTemplates();
  }

  function initializeChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storedChartFieldValues = null;
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  const NUMERIC_SCALE_FIELDS = ["importance","novelty","interest","timeToStart","difficulty"];
  const SCALE_FIELDS = [...NUMERIC_SCALE_FIELDS, "urgency", "externalPressure"];
  const BASIC_NUMERIC_DESCRIPTORS = [1, 2, 3, 4, 5].map(value => ({
    value,
    text: String(value)
  }));

  const DEFAULT_DESCRIPTOR_SET = {
    importance: BASIC_NUMERIC_DESCRIPTORS,
    urgency: [
      { value: 5, text: "5 – Critical Billing Window or Immediate Patient Need" },
      { value: 4, text: "4 – High Priority – Near-Term Deadline" },
      { value: 3, text: "3 – Moderate Priority – Monthly Closure" },
      { value: 2, text: "2 – Low Billing Value – Already Overdue" },
      { value: 1, text: "1 – Routine Follow-Up Work" }
    ],
    novelty: BASIC_NUMERIC_DESCRIPTORS,
    interest: BASIC_NUMERIC_DESCRIPTORS,
    externalPressure: [
      { value: 1, text: "1 – Solo responsibility" },
      { value: 2, text: "2 – Soft deadline / courtesy check" },
      { value: 3, text: "3 – Peer or team waiting" },
      { value: 4, text: "4 – Leadership expectation" },
      { value: 5, text: "5 – Patient or compliance critical" }
    ],
    timeToStart: BASIC_NUMERIC_DESCRIPTORS,
    difficulty: BASIC_NUMERIC_DESCRIPTORS
  };

  const CATEGORY_DESCRIPTOR_SETS = {
    chart: {
      importance: [
        { value: 1, text: "1 – Chart adds minimal new information or duplicates an existing note." },
        { value: 2, text: "2 – Routine follow-up with limited clinical or legal relevance." },
        { value: 3, text: "3 – Contains moderate clinical content or affects internal workflow (e.g., continuity documentation)." },
        { value: 4, text: "4 – Impacts care coordination, billing, or orders being released." },
        { value: 5, text: "5 – Critical legal or clinical documentation—such as a new complex care note, DME letter, or therapy order summary." }
      ],
      urgency: [
        { value: 1, text: "1 – No immediate consequence if delayed more than a week." },
        { value: 2, text: "2 – Should be completed within five to seven days to keep the workflow moving." },
        { value: 3, text: "3 – Approaching the expected three-day chart completion window." },
        { value: 4, text: "4 – Actively holding up orders, referrals, or communication with other providers." },
        { value: 5, text: "5 – Must be completed within 24 hours—blocking patient care, billing, or compliance." }
      ],
      novelty: [
        { value: 1, text: "1 – Repetitive, nearly identical to prior encounters—mental autopilot work." },
        { value: 2, text: "2 – Familiar patient with predictable updates." },
        { value: 3, text: "3 – Some variation or new findings but overall routine." },
        { value: 4, text: "4 – Clearly different or updated scenario (new comorbidity, new specialist input)." },
        { value: 5, text: "5 – Entirely new case or patient; requires full synthesis and high cognitive effort." }
      ],
      interest: [
        { value: 1, text: "1 – Emotionally draining, tedious, or disengaging." },
        { value: 2, text: "2 – Slightly more tolerable but still repetitive." },
        { value: 3, text: "3 – Neutral—acceptable task without resistance or enthusiasm." },
        { value: 4, text: "4 – Personally engaging or meaningful (e.g., rewarding outcome, interesting complexity)." },
        { value: 5, text: "5 – Highly interesting or affirming—feels worth your energy investment." }
      ],
      externalPressure: [
        { value: 1, text: "1 – No one waiting on this; purely internal backlog." },
        { value: 2, text: "2 – Minimal outside awareness—perhaps a resident awaiting co-signature." },
        { value: 3, text: "3 – Family or administrative team may soon follow up." },
        { value: 4, text: "4 – Directly affects nursing, therapy, or resident progress if left undone." },
        { value: 5, text: "5 – Leadership, family, or compliance risk if not completed immediately." }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major prep—multiple subspecialty notes or context review needed." },
        { value: 2, text: "2 – Some setup required; moderate amount of data gathering first." },
        { value: 3, text: "3 – Ready to begin with basic template or SmartPhrase already open." },
        { value: 4, text: "4 – Mostly drafted or pre-filled by a resident." },
        { value: 5, text: "5 – One click from completion—review and sign only." }
      ],
      difficulty: [
        { value: 1, text: "1 – Very complex visit—multiple specialists, high stakes." },
        { value: 2, text: "2 – High cognitive load—multiple notes or CareEverywhere data to merge." },
        { value: 3, text: "3 – Moderate effort—some review of orders, results, or medication changes." },
        { value: 4, text: "4 – Small amount of synthesis or clean-up work." },
        { value: 5, text: "5 – Straightforward chart; minimal thought required." }
      ]
    },
    admin: {
      importance: [
        { value: 1, text: "1: Low-value clerical item — informational only, not linked to care or billing (e.g., generic record release)." },
        { value: 2, text: "2: Routine paperwork (e.g., school letter, general clearance) with limited medical impact." },
        { value: 3, text: "3: Moderately important — ensures continuity of services or avoids family confusion." },
        { value: 4, text: "4: Affects patient function, equipment use, or continuity of home health/therapy services." },
        { value: 5, text: "5: Legally, financially, or clinically critical (e.g., DME or home nursing orders, time-sensitive medical necessity forms)." }
      ],
      urgency: [
        { value: 1, text: "1: No time constraint; backlog cleanup or batch task." },
        { value: 2, text: "2: Preferred within a week to prevent workflow pileup." },
        { value: 3, text: "3: Due soon — flagged or requested multiple times (within 72 hours)." },
        { value: 4, text: "4: Time-sensitive — blocking care, equipment renewal, or external agency action." },
        { value: 5, text: "5: Immediate deadline — service interruption or patient safety risk if not completed today." }
      ],
      novelty: [
        { value: 1, text: "1: Routine, repetitive — identical to previous letters or forms." },
        { value: 2, text: "2: Minor variation (same patient, slightly different form)." },
        { value: 3, text: "3: Moderate variation — new formatting or service type but same structure." },
        { value: 4, text: "4: Requires rethinking or rewriting — new medical justification or appeal." },
        { value: 5, text: "5: Entirely new or unusual form requiring research, collaboration, or creative framing." }
      ],
      interest: [
        { value: 1, text: "1: Utterly draining paperwork with no personal reward." },
        { value: 2, text: "2: Mildly tolerable — repetitive but manageable." },
        { value: 3, text: "3: Neutral task; emotionally flat but not difficult." },
        { value: 4, text: "4: Slightly satisfying — clear, finite, ‘box checked’ gratification." },
        { value: 5, text: "5: Emotionally rewarding — high-impact document that feels meaningful or helps a deserving family." }
      ],
      externalPressure: [
        { value: 1, text: "1: No one waiting; background task only." },
        { value: 2, text: "2: Requested once, no follow-up." },
        { value: 3, text: "3: Family, therapist, or vendor has followed up once or twice." },
        { value: 4, text: "4: Repeated requests or escalating frustration from external partner." },
        { value: 5, text: "5: Time-sensitive escalation — multiple stakeholders involved, risk of complaint or service disruption." }
      ],
      timeToStart: [
        { value: 1, text: "1: Fully prepped or pre-filled — literally one click to sign, fax, or send." },
        { value: 2, text: "2: Nearly complete — requires signatures or minor edits." },
        { value: 3, text: "3: Ready to draft — information accessible, no major digging needed." },
        { value: 4, text: "4: Some setup required — gathering diagnostic codes, reviewing notes." },
        { value: 5, text: "5: Requires locating old versions or supporting documents (e.g., past forms, letters)." }
      ],
      difficulty: [
        { value: 1, text: "1: Straightforward — fill in basic info, minimal judgment." },
        { value: 2, text: "2: Simple but tedious — multiple checkboxes or sign-offs." },
        { value: 3, text: "3: Moderate — requires referencing recent visits or clinical notes." },
        { value: 4, text: "4: High cognitive effort — must summarize complex clinical picture concisely." },
        { value: 5, text: "5: Very complex — appeals, multidisciplinary coordination, or justification requiring clinical precision." }
      ]
    },
    personal: {
      importance: [
        { value: 1, text: "1 – Trivial — doesn’t really matter if done" },
        { value: 2, text: "2 – Mildly useful — minor quality-of-life improvement" },
        { value: 3, text: "3 – Helpful — meaningful progress toward a goal" },
        { value: 4, text: "4 – Significant — affects well-being or relationships" },
        { value: 5, text: "5 – Critical — has serious emotional, financial, or health consequences" }
      ],
      urgency: [
        { value: 1, text: "1 – No time pressure — can wait indefinitely" },
        { value: 2, text: "2 – Slight — would be good to do soon" },
        { value: 3, text: "3 – Moderate — needs attention within a few days" },
        { value: 4, text: "4 – High — needs to be done today" },
        { value: 5, text: "5 – Immediate — must be addressed now" }
      ],
      interest: [
        { value: 1, text: "1 – Dreaded — pure avoidance energy" },
        { value: 2, text: "2 – Unpleasant but tolerable" },
        { value: 3, text: "3 – Neutral — neither appealing nor aversive" },
        { value: 4, text: "4 – Mildly engaging" },
        { value: 5, text: "5 – Genuinely energizing or rewarding" }
      ],
      difficulty: [
        { value: 1, text: "1 – Very hard — high resistance, many steps, or emotionally draining" },
        { value: 2, text: "2 – Challenging — mentally or logistically demanding" },
        { value: 3, text: "3 – Moderate — manageable with steady focus" },
        { value: 4, text: "4 – Mild effort — easy, straightforward, minimal resistance" },
        { value: 5, text: "5 – Simple — effortless, can be done on autopilot" }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major setup or emotional readiness" },
        { value: 2, text: "2 – Some prep work before starting" },
        { value: 3, text: "3 – Can start with minimal prep" },
        { value: 4, text: "4 – Ready to begin immediately" },
        { value: 5, text: "5 – Already in motion / one click from done" }
      ]
    }
  };

  function getCategoryDescriptorKey(category) {
    const normalized = (category || "").toString().trim().toLowerCase();
    return normalized || "general";
  }

  function getScaleOptions(fieldId, categoryKey) {
    const key = categoryKey || "general";
    const descriptorSet = CATEGORY_DESCRIPTOR_SETS[key];
    if (descriptorSet && Array.isArray(descriptorSet[fieldId])) {
      return descriptorSet[fieldId];
    }
    const defaults = DEFAULT_DESCRIPTOR_SET[fieldId];
    if (defaults) {
      return defaults;
    }
    return BASIC_NUMERIC_DESCRIPTORS;
  }

  function populateScaleSelect(fieldId, categoryKey) {
    const select = $(fieldId);
    if (!select) return;
    const previousValue = select.value;
    const options = getScaleOptions(fieldId, categoryKey);
    select.innerHTML = "";
    options.forEach(option => {
      const opt = document.createElement("option");
      opt.value = String(option.value);
      opt.textContent = option.text || String(option.value);
      select.appendChild(opt);
    });
    const previous = previousValue !== undefined && previousValue !== null
      ? String(previousValue)
      : "";
    const hasPrevious = options.some(option => String(option.value) === previous);
    if (hasPrevious) {
      select.value = previous;
    } else if (options.length > 0) {
      select.value = String(options[0].value);
    }
  }

  function populateScalesForCategory(category) {
    const key = getCategoryDescriptorKey(category);
    currentScaleDescriptorCategory = key;
    SCALE_FIELDS.forEach(fieldId => populateScaleSelect(fieldId, key));
    updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
  }

  const BASE_CHART_STEPS = [
    "Load Abridge (dictation)",
    "Review/modify HPI",
    "Review/modify PE",
    "Review/modify A/P",
    "Review/submit orders",
    "Enter billing code",
    "Sign off"
  ];
  const RESIDENT_ATTESTATION_STEP = "Add Attestation";
  let currentFocusTaskIndex = null;

  function generateSubTaskId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  }

  function isChartTask(task) {
    return task && String(task.category).toLowerCase() === "chart";
  }

  function buildChartSteps(authorType) {
    const steps = [...BASE_CHART_STEPS];
    if (String(authorType).toLowerCase() === "resident") {
      const billingIndex = steps.indexOf("Enter billing code");
      const insertIndex = billingIndex === -1 ? steps.length - 1 : billingIndex;
      steps.splice(insertIndex, 0, RESIDENT_ATTESTATION_STEP);
    }
    return steps;
  }

  function calculateDurationMinutes(start, end) {
    if (!start || !end) return null;
    const startDate = new Date(start);
    const endDate = new Date(end);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Number((diff / (1000 * 60)).toFixed(2));
  }

  function isTaskCompleted(task) {
    if (!task) return false;
    return Boolean(task.completed || task.completedAt);
  }

  function getCompletionTimestamp(task) {
    if (!task) return null;
    return task.completedAt || task.completionTime || null;
  }

  function formatDateTime(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  }

  function formatDuration(minutes) {
    if (minutes === null || minutes === undefined) return "--";
    const num = Number(minutes);
    if (!Number.isFinite(num)) return "--";
    return `${num.toFixed(2)} min`;
  }

  function formatElapsedMs(ms) {
    if (!Number.isFinite(ms) || ms < 0) return "--";
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
  }

  function estimateTaskMinutes(task) {
    if (!task) return 0;
    const subTasks = Array.isArray(task.subTasks) ? task.subTasks : [];
    const remaining = subTasks.filter(sub => !sub.completed);
    const remainingCount = remaining.length > 0 ? remaining.length : 1;
    const recordedDurations = subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value) && value > 0);
    if (recordedDurations.length) {
      const avg = recordedDurations.reduce((sum, value) => sum + value, 0) / recordedDurations.length;
      return Math.max(1, Math.ceil(avg * remainingCount));
    }
    const n = subTasks.length;
    const difficulty = Number(task.difficulty || 3);
    const startFriction = Number(task.timeToStart || 3);
    const estimate = Math.round((10 + 2 * n) * (0.7 + 0.15 * difficulty) + (startFriction - 3) * 2);
    return Math.max(5, estimate);
  }

  function getEnergyLevel() {
    const el = document.querySelector('[data-field="energy-level"]');
    if (el) {
      const value = Number(el.value || el.getAttribute('data-value'));
      if (Number.isFinite(value)) return value;
    }
    return 3;
  }

  function getTimeBudgetMinutes() {
    const el = document.querySelector('[data-field="time-budget"]');
    if (!el) return Infinity;
    const value = Number(el.value);
    return Number.isFinite(value) && value > 0 ? value : Infinity;
  }

  function energyFit(task, energyLevel) {
    if (!Number.isFinite(energyLevel)) return 1;
    const est = estimateTaskMinutes(task);
    const difficulty = Number(task?.difficulty || 3);
    const lowEnergyWeight = energyLevel <= 2 ? (est > 20 ? 0.85 : 1) * (difficulty >= 4 ? 0.85 : 1) : 1;
    const highEnergyWeight = energyLevel >= 4 ? 1.05 : 1;
    return lowEnergyWeight * highEnergyWeight;
  }

  function timeFit(task, budgetMinutes) {
    if (!Number.isFinite(budgetMinutes)) return 1;
    const est = estimateTaskMinutes(task);
    if (!Number.isFinite(est) || est <= 0) return 1;
    if (est <= budgetMinutes) {
      const ratio = est / (budgetMinutes * 0.85);
      return Math.max(0.85, Math.min(1.05, 1.05 - Math.abs(1 - ratio) * 0.3));
    }
    const overRatio = est / budgetMinutes;
    return Math.max(0.55, 1 - (overRatio - 1) * 0.6);
  }


  function getEffectiveEnergyLevel() {
    let level = null;
    try {
      if (typeof getMorningEntry === "function") {
        const entry = getMorningEntry();
        if (entry && Number.isFinite(Number(entry.energy))) {
          level = clampScale(entry.energy, 3);
        }
      }
    } catch (error) {
      console.warn("Unable to read morning energy entry", error);
    }
    if (!Number.isFinite(level)) {
      const slider = $("morningEnergy");
      if (slider) {
        const sliderValue = Number(slider.value);
        if (Number.isFinite(sliderValue)) {
          level = clampScale(sliderValue, 3);
        }
      }
    }
    if (!Number.isFinite(level)) {
      level = 3;
    }
    return level;
  }

  function computeEnergyFit(task, energyLevel) {
    return energyFit(task, energyLevel);
  }

  function computeTimeFit(task, budgetMinutes) {
    return timeFit(task, budgetMinutes);
  }

  function createSubTask(name, priority, options = {}) {
    return {
      id: generateSubTaskId(),
      name,
      completed: false,
      priority,
      startTime: null,
      completionTime: null,
      durationMinutes: null,
      isFirstThree: Boolean(options.isFirstThree),
      deferredUntilUnlock: Boolean(options.deferredUntilUnlock)
    };
  }

  function normalizeSubTask(sub, basePriority) {
    if (!sub) {
      return createSubTask("Step", basePriority);
    }
    const normalized = {
      id: sub.id || generateSubTaskId(),
      name: sub.name || "Step",
      completed: Boolean(sub.completed),
      priority: toNumber(sub.priority, basePriority),
      startTime: sub.startTime || null,
      completionTime: sub.completionTime || null,
      durationMinutes: sub.durationMinutes !== undefined && sub.durationMinutes !== null && Number.isFinite(Number(sub.durationMinutes))
        ? Number(sub.durationMinutes)
        : null,
      isFirstThree: Boolean(sub.isFirstThree),
      deferredUntilUnlock: Boolean(sub.deferredUntilUnlock)
    };
    if (normalized.durationMinutes === null && normalized.startTime && normalized.completionTime) {
      normalized.durationMinutes = calculateDurationMinutes(normalized.startTime, normalized.completionTime);
    }
    return normalized;
  }

  function shouldTriggerFirstThreeWizard(taskName, subLines, category) {
    const normalizedName = (taskName || "").toLowerCase();
    const wordCount = normalizedName.split(/\s+/).filter(Boolean).length;
    const hasKeyword = FIRST_THREE_KEYWORDS.some(keyword => normalizedName.includes(keyword));
    const isChart = (category || "").toLowerCase() === "chart";
    if (Array.isArray(subLines) && subLines.length > 0) {
      return false;
    }
    return wordCount >= FIRST_THREE_WORD_THRESHOLD || hasKeyword || isChart;
  }

  function applyFirstThreeSteps(task, steps, basePriority) {
    if (!task) return;
    const trimmed = Array.isArray(steps)
      ? steps.map(step => step.trim()).filter(Boolean)
      : [];
    while (trimmed.length < 3) {
      const defaults = ["Open workspace", "Outline first move", "Start five-minute draft"];
      trimmed.push(defaults[trimmed.length] || `Micro step ${trimmed.length + 1}`);
    }
    task.firstThreeMode = true;
    task.firstThreeUnlocked = Boolean(task.firstThreeUnlocked);
    task.firstThreeSteps = trimmed.slice(0, 3);
    const firstThreeSubs = trimmed.slice(0, 3).map(step => createSubTask(step, basePriority, { isFirstThree: true }));
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const deferred = !task.firstThreeUnlocked;
    const remainder = existingSubs.map(sub => ({
      ...sub,
      deferredUntilUnlock: deferred && !sub.isFirstThree
    }));
    task.subTasks = [...firstThreeSubs, ...remainder];
  }

  function getVisibleSubTasks(task) {
    if (!task || !Array.isArray(task.subTasks)) return [];
    if (!task.firstThreeMode || task.firstThreeUnlocked) {
      return task.subTasks;
    }
    return task.subTasks.filter(sub => sub.isFirstThree || !sub.deferredUntilUnlock);
  }

  function maybeUnlockFirstThree(task, { silent = false } = {}) {
    if (!task || !task.firstThreeMode) return;
    const subs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const firstThreeSubs = subs.filter(sub => sub.isFirstThree);
    if (firstThreeSubs.length === 0) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      return;
    }
    const allComplete = firstThreeSubs.every(sub => sub.completed);
    if (allComplete && !task.firstThreeUnlocked) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      if (!silent) {
        showToast("Momentum!", "Nice momentum! Here's what's next.");
      }
    }
  }

  function computeTotalChartDuration(subTasks) {
    if (!Array.isArray(subTasks) || subTasks.length === 0) return 0;
    return Number(subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0).toFixed(2));
  }

  function getTaskTotalDuration(task) {
    if (!task) return null;
    if (isChartTask(task)) {
      const value = Number(task.chartDurationMinutes);
      return Number.isFinite(value) && value > 0 ? value : null;
    }
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);
    if (total <= 0) return null;
    return Number(total.toFixed(2));
  }

  function updateChartDurationForTask(task) {
    if (!isChartTask(task)) {
      delete task.chartDurationMinutes;
      return;
    }
    task.chartDurationMinutes = computeTotalChartDuration(task.subTasks);
  }

  function clearRunningTimers() {
    runningTimers.forEach(intervalId => clearInterval(intervalId));
    runningTimers.clear();
  }

  function stopTimerForSubTask(subId) {
    const intervalId = runningTimers.get(subId);
    if (intervalId) {
      clearInterval(intervalId);
      runningTimers.delete(subId);
    }
  }

  function trackTimer(sub, timerEl) {
    if (!timerEl) return;
    stopTimerForSubTask(sub.id);
    if (sub.completed) {
      timerEl.textContent = `Completed – ${formatDuration(sub.durationMinutes)}`;
      return;
    }
    if (!sub.startTime) {
      timerEl.textContent = "Timer: --";
      return;
    }
    const update = () => {
      const startDate = new Date(sub.startTime);
      if (Number.isNaN(startDate.getTime())) {
        timerEl.textContent = "Timer: --";
        return;
      }
      const now = new Date();
      timerEl.textContent = `Timer: ${formatElapsedMs(now.getTime() - startDate.getTime())}`;
    };
    update();
    const intervalId = setInterval(update, 1000);
    runningTimers.set(sub.id, intervalId);
  }

  function stopFocusTimer(resetDisplay = true) {
    if (focusTimerId) {
      clearInterval(focusTimerId);
      focusTimerId = null;
    }
    focusTimerStart = null;
    focusTimerLastPing = null;
    sprintEndTime = null;
    if (resetDisplay) {
      sprintDurationMinutes = null;
    }
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    timerEl.classList.remove("pulse");
    if (resetDisplay) {
      timerEl.textContent = "🧭 Focus Time: 0:00";
    }
  }

  function updateFocusTimerDisplay(elapsedMs) {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0 && sprintEndTime) {
      const remaining = Math.max(0, sprintEndTime - Date.now());
      if (remaining > 0) {
        const minutesLeft = Math.floor(remaining / 60000);
        const secondsLeft = Math.floor((remaining % 60000) / 1000);
        timerEl.textContent = `⏱️ Sprint: ${minutesLeft}:${String(secondsLeft).padStart(2, "0")}`;
        return;
      }
      sprintDurationMinutes = null;
      sprintEndTime = null;
      timerEl.textContent = "✅ Sprint complete";
      triggerFocusPing();
      return;
    }
    const minutes = Math.floor(elapsedMs / 60000);
    const seconds = Math.floor((elapsedMs % 60000) / 1000);
    timerEl.textContent = `🧭 Focus Time: ${minutes}:${String(seconds).padStart(2, "0")}`;
  }

  function playFocusPing() {
    if (!focusSoundEnabled) return;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor) return;
    if (!focusAudioContext) {
      try {
        focusAudioContext = new AudioContextCtor();
      } catch (error) {
        focusAudioContext = null;
        return;
      }
    }
    if (focusAudioContext.state === "suspended") {
      focusAudioContext.resume().catch(() => {});
    }
    const duration = 0.4;
    const oscillator = focusAudioContext.createOscillator();
    const gain = focusAudioContext.createGain();
    oscillator.type = "sine";
    oscillator.frequency.setValueAtTime(880, focusAudioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, focusAudioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, focusAudioContext.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, focusAudioContext.currentTime + duration);
    oscillator.connect(gain);
    gain.connect(focusAudioContext.destination);
    oscillator.start();
    oscillator.stop(focusAudioContext.currentTime + duration);
  }

  function triggerFocusPing() {
    const timerEl = $("focusTimer");
    if (timerEl) {
      timerEl.classList.add("pulse");
      setTimeout(() => timerEl.classList.remove("pulse"), 1000);
    }
    playFocusPing();
  }

  function startFocusTimer() {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    stopFocusTimer(false);
    focusTimerStart = Date.now();
    focusTimerLastPing = focusTimerStart;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0) {
      sprintEndTime = focusTimerStart + sprintDurationMinutes * 60000;
    } else {
      sprintEndTime = null;
    }
    updateFocusTimerDisplay(0);
    focusTimerId = setInterval(() => {
      if (focusTimerStart === null) return;
      const now = Date.now();
      const elapsed = now - focusTimerStart;
      updateFocusTimerDisplay(elapsed);
      if (!focusTimerLastPing || now - focusTimerLastPing >= FOCUS_PING_INTERVAL_MS) {
        triggerFocusPing();
        focusTimerLastPing = now;
      }
    }, 1000);
  }

  function setFocusSoundPreference(enabled) {
    focusSoundEnabled = Boolean(enabled);
    localStorage.setItem("focusSoundEnabled", focusSoundEnabled ? "true" : "false");
  }

  function getAuditStorageKey(date = new Date()) {
    return `${AUDIT_STORAGE_PREFIX}${date.toISOString().split("T")[0]}`;
  }

  function getAuditShownKey(storageKey) {
    return `${storageKey}${AUDIT_SHOWN_SUFFIX}`;
  }

  function loadAuditEntries(storageKey) {
    if (!storageKey) return [];
    const raw = localStorage.getItem(storageKey);
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  }

  function recordTaskCompletion(task) {
    if (!task) return;
    const storageKey = getAuditStorageKey();
    const entries = loadAuditEntries(storageKey);
    const subDetails = Array.isArray(task.subTasks)
      ? task.subTasks.map(sub => {
          const rawDuration = Number(sub?.durationMinutes);
          const normalizedDuration = Number.isFinite(rawDuration) && rawDuration > 0
            ? Number(rawDuration.toFixed(2))
            : null;
          return {
            name: sub?.name || "Step",
            duration: normalizedDuration
          };
        })
      : [];
    let totalDuration = getTaskTotalDuration(task);
    if (Number.isFinite(totalDuration) && totalDuration > 0) {
      totalDuration = Number(totalDuration.toFixed(2));
    } else {
      const fallbackTotal = subDetails.reduce((sum, sub) => {
        return Number.isFinite(sub.duration) ? sum + sub.duration : sum;
      }, 0);
      totalDuration = fallbackTotal > 0 ? Number(fallbackTotal.toFixed(2)) : null;
    }
    entries.push({
      name: task.name || "Task",
      subDetails,
      totalDuration,
      completedAt: getCompletionTimestamp(task) || new Date().toISOString()
    });
    localStorage.setItem(storageKey, JSON.stringify(entries));
  }

  function showEndOfDayAudit(entries = null, shownKeyOverride = null) {
    const storageKey = getAuditStorageKey();
    const auditEntries = entries || loadAuditEntries(storageKey);
    if (!auditEntries.length) return;
    const shownKey = shownKeyOverride || getAuditShownKey(storageKey);

    const overlay = document.createElement("div");
    overlay.className = "audit-backdrop";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.setAttribute("aria-labelledby", "auditModalTitle");

    const modal = document.createElement("div");
    modal.className = "audit-modal";

    const title = document.createElement("h3");
    title.id = "auditModalTitle";
    title.textContent = "End of Day Audit";
    modal.appendChild(title);

    const totalMinutes = auditEntries.reduce((sum, entry) => {
      const value = Number(entry?.totalDuration);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);

    let longestSubtask = null;
    auditEntries.forEach(entry => {
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      details.forEach(sub => {
        const duration = Number(sub?.duration);
        if (!Number.isFinite(duration)) return;
        if (!longestSubtask || duration > longestSubtask.duration) {
          longestSubtask = {
            taskName: entry?.name || "Task",
            name: sub?.name || "Step",
            duration
          };
        }
      });
    });

    const summary = document.createElement("div");
    summary.className = "audit-summary";
    const summaryLines = [
      `Tasks completed: ${auditEntries.length}`,
      `Productive minutes: ${formatDuration(totalMinutes)}`,
      longestSubtask
        ? `Longest subtask: ${longestSubtask.name} (${formatDuration(longestSubtask.duration)}) — ${longestSubtask.taskName}`
        : "Longest subtask: --"
    ];
    summaryLines.forEach(text => {
      const line = document.createElement("div");
      line.textContent = text;
      summary.appendChild(line);
    });
    modal.appendChild(summary);

    const list = document.createElement("ul");
    list.className = "audit-task-list";
    auditEntries.forEach(entry => {
      const item = document.createElement("li");
      const header = document.createElement("strong");
      header.textContent = `${entry?.name || "Task"} — ${formatDuration(entry?.totalDuration)}`;
      item.appendChild(header);
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      if (details.length) {
        const subList = document.createElement("ul");
        subList.className = "audit-task-subtasks";
        details.forEach(sub => {
          const subItem = document.createElement("li");
          subItem.textContent = `${sub?.name || "Step"}: ${formatDuration(sub?.duration)}`;
          subList.appendChild(subItem);
        });
        item.appendChild(subList);
      }
      list.appendChild(item);
    });
    modal.appendChild(list);

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "Close";

    const closeModal = () => {
      overlay.remove();
      document.removeEventListener("keydown", onKeyDown);
    };

    const onKeyDown = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeModal();
      }
    };

    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeModal();
      }
    });
    document.addEventListener("keydown", onKeyDown);

    modal.appendChild(closeBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    requestAnimationFrame(() => closeBtn.focus());
    if (shownKey) {
      localStorage.setItem(shownKey, "true");
    }
  }

  function maybeShowEndOfDayAudit() {
    const remainingActive = tasks.filter(task => !isTaskCompleted(task)).length;
    if (remainingActive > 0) return;
    const storageKey = getAuditStorageKey();
    const shownKey = getAuditShownKey(storageKey);
    if (localStorage.getItem(shownKey) === "true") return;
    const entries = loadAuditEntries(storageKey);
    if (!entries.length) return;
    showEndOfDayAudit(entries, shownKey);
  }

  function initializeSoundPreference() {
    const saved = localStorage.getItem("focusSoundEnabled");
    if (saved !== null) {
      focusSoundEnabled = saved === "true";
    }
    const toggle = $("focusSoundToggle");
    if (!toggle) return;
    toggle.checked = focusSoundEnabled;
    toggle.addEventListener("change", event => {
      setFocusSoundPreference(event.target.checked);
      if (focusSoundEnabled && focusAudioContext && focusAudioContext.state === "suspended") {
        focusAudioContext.resume().catch(() => {});
      }
    });
  }

  function ensureChartSubTasks(task, options = {}) {
    if (!isChartTask(task)) return false;
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    const basePriority = options.basePriority !== undefined
      ? options.basePriority
      : computePriority({ ...task, subTasks: [] });
    if (task.useChartTemplate === false) {
      task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      return false;
    }
    const defaults = buildChartSteps(task.authorType);
    const lowerDefaults = defaults.map(step => step.toLowerCase());
    const requiredSet = new Set(lowerDefaults);
    const attestationKey = RESIDENT_ATTESTATION_STEP.toLowerCase();
    let changed = false;

    if (!requiredSet.has(attestationKey)) {
      const filtered = task.subTasks.filter(sub => String(sub?.name || "").toLowerCase() !== attestationKey);
      if (filtered.length !== task.subTasks.length) {
        task.subTasks = filtered;
        changed = true;
      }
    }

    const existingByName = new Map();
    task.subTasks.forEach((sub, index) => {
      const key = String(sub?.name || "").toLowerCase();
      if (!existingByName.has(key)) {
        existingByName.set(key, { sub, index });
      }
    });

    const orderedDefaults = defaults.map(step => {
      const key = step.toLowerCase();
      const existing = existingByName.get(key);
      if (existing) {
        existingByName.delete(key);
        return existing.sub;
      }
      changed = true;
      return createSubTask(step, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    const extras = task.subTasks.filter(sub => {
      const key = String(sub?.name || "").toLowerCase();
      return !requiredSet.has(key);
    });

    const nextSubTasks = [...orderedDefaults, ...extras];
    const sameOrder = nextSubTasks.length === task.subTasks.length
      && nextSubTasks.every((sub, idx) => sub === task.subTasks[idx]);
    if (!sameOrder) {
      task.subTasks = nextSubTasks;
      if (!changed) changed = true;
    }

    task.subTasks.forEach(sub => {
      if (sub.priority !== basePriority) {
        sub.priority = basePriority;
        changed = true;
      }
      if (task.firstThreeMode) {
        sub.deferredUntilUnlock = !task.firstThreeUnlocked && !sub.isFirstThree;
      } else if (sub.deferredUntilUnlock) {
        sub.deferredUntilUnlock = false;
      }
    });

    return changed;
  }

  function resolveTaskAndSub(taskIndex, subIndex, options = {}) {
    let resolvedIndex = taskIndex;
    let task = tasks[resolvedIndex];
    if ((!task || resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && options.taskId) {
      resolvedIndex = tasks.findIndex(t => t.id === options.taskId);
      task = tasks[resolvedIndex];
    }
    if (!task) {
      return { task: null, taskIndex: -1, sub: null, subIndex: -1 };
    }
    let resolvedSubIndex = subIndex;
    let sub = Array.isArray(task.subTasks) ? task.subTasks[resolvedSubIndex] : undefined;
    if ((!sub || resolvedSubIndex === undefined || resolvedSubIndex === null || resolvedSubIndex < 0) && options.subId && Array.isArray(task.subTasks)) {
      resolvedSubIndex = task.subTasks.findIndex(s => s.id === options.subId);
      sub = task.subTasks[resolvedSubIndex];
    }
    return { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex };
  }

  function renderChartSummary(task) {
    const container = document.createElement("div");
    container.className = "chart-summary";
    const heading = document.createElement("h4");
    heading.textContent = "Chart Summary";
    container.appendChild(heading);
    const list = document.createElement("ul");
    const durations = task.subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value));
    const longest = durations.length ? Math.max(...durations) : null;
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      item.textContent = `${sub.name}: ${formatDuration(sub.durationMinutes)}`;
      if (longest !== null && Number(sub.durationMinutes) === longest) {
        item.classList.add("longest-step");
      }
      list.appendChild(item);
    });
    container.appendChild(list);
    const total = Number.isFinite(Number(task.chartDurationMinutes))
      ? Number(task.chartDurationMinutes)
      : computeTotalChartDuration(task.subTasks);
    const totalLabel = document.createElement("div");
    totalLabel.className = "chart-total";
    totalLabel.textContent = `Total duration: ${formatDuration(total)}`;
    container.appendChild(totalLabel);
    return container;
  }

  function refreshAfterSubTaskChange(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    persist();
    const focusActive = !$("focus").classList.contains("hidden");
    if (focusActive) {
      const currentFocusTask = focusQueue[0];
      if ((resolvedIndex !== -1 && currentFocusTaskIndex === resolvedIndex)
        || (options.taskId && currentFocusTask && currentFocusTask.id === options.taskId)) {
        renderFocusTask(task, resolvedIndex);
      }
    }
    if (!focusActive && !options.focusOnly) {
      updateUI();
    }
  }

  function startSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    sub.startTime = new Date().toISOString();
    sub.completed = false;
    sub.completionTime = null;
    sub.durationMinutes = null;
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function toggleSubTaskCompletion(taskIndex, subIndex, isCompleted, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    if (isCompleted) {
      if (!sub.startTime) {
        sub.startTime = new Date().toISOString();
      }
      sub.completed = true;
      sub.completionTime = new Date().toISOString();
      sub.durationMinutes = calculateDurationMinutes(sub.startTime, sub.completionTime) ?? 0;
      stopTimerForSubTask(sub.id);
      if (task.firstThreeMode) {
        maybeUnlockFirstThree(task);
      }
    } else {
      sub.completed = false;
      sub.completionTime = null;
      sub.durationMinutes = null;
      if (task.firstThreeMode && sub.isFirstThree) {
        task.firstThreeUnlocked = false;
        task.subTasks.forEach(step => {
          if (!step.isFirstThree) {
            step.deferredUntilUnlock = true;
          }
        });
      }
    }
    const nextOptions = { ...options, taskId: task.id, subId: sub.id };
    refreshAfterSubTaskChange(resolvedIndex, nextOptions);
  }

  function editSubTaskName(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const newName = prompt("Rename step", sub.name);
    if (!newName) return;
    sub.name = newName.trim();
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function removeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !Array.isArray(task.subTasks)) return;
    if (!confirm("Remove this step?")) return;
    const removed = task.subTasks.splice(resolvedSubIndex, 1);
    if (removed.length) {
      stopTimerForSubTask(removed[0].id);
    }
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function addSubTaskToTask(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    const name = prompt("New step name");
    if (!name) return;
    const base = computePriority({ ...task, subTasks: [] });
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.subTasks.push(createSubTask(name.trim(), base, {
      deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
    }));
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function renderChartTask(task, taskIndex) {
    const container = document.createElement("div");
    container.style.width = "100%";
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No steps configured.";
      container.appendChild(empty);
      return container;
    }
    const progressElement = createProgressElement(task);
    if (progressElement) {
      container.appendChild(progressElement);
    }
    const visibleSubs = getVisibleSubTasks(task);
    const hiddenCount = task.firstThreeMode && !task.firstThreeUnlocked
      ? task.subTasks.length - visibleSubs.length
      : 0;
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { focusOnly: true, taskId: task.id, subId: sub.id });

      const nameSpan = document.createElement("span");
      nameSpan.className = "subtask-name";
      nameSpan.textContent = sub.name;

      const actions = document.createElement("div");
      actions.className = "subtask-actions";

      const startBtn = document.createElement("button");
      startBtn.textContent = sub.startTime ? "Restart" : "Start";
      startBtn.title = "Start or restart timer";
      startBtn.onclick = () => startSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(startBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Rename step";
      editBtn.onclick = () => editSubTaskName(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Remove step";
      deleteBtn.onclick = () => removeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(deleteBtn);

      const timer = document.createElement("span");
      timer.className = "timer-label";
      trackTimer(sub, timer);

      row.appendChild(chk);
      row.appendChild(nameSpan);
      row.appendChild(actions);
      row.appendChild(timer);
      container.appendChild(row);
    });

    if (hiddenCount > 0) {
      const gate = document.createElement("div");
      gate.className = "celebration";
      gate.textContent = "Complete the first three micro-steps to reveal the rest of the chart flow.";
      container.appendChild(gate);
    }

    const controls = document.createElement("div");
    controls.className = "chart-step-controls";

    const addBtn = document.createElement("button");
    addBtn.textContent = "➕ Add Step";
    addBtn.onclick = () => addSubTaskToTask(taskIndex, { taskId: task.id });
    controls.appendChild(addBtn);

    const resetTimersBtn = document.createElement("button");
    resetTimersBtn.textContent = "⏱️ Reset Timers";
    resetTimersBtn.onclick = () => {
      task.subTasks.forEach(sub => {
        stopTimerForSubTask(sub.id);
        sub.startTime = null;
        sub.completionTime = null;
        sub.durationMinutes = null;
        sub.completed = false;
      });
      refreshAfterSubTaskChange(taskIndex, { focusOnly: true, taskId: task.id });
    };
    controls.appendChild(resetTimersBtn);

    container.appendChild(controls);

    if (task.subTasks.every(sub => sub.completed)) {
      container.appendChild(renderChartSummary(task));
    }

    return container;
  }

  function renderSimpleSubTasks(task, taskIndex) {
    const container = document.createElement("div");
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      container.textContent = "No sub-tasks for this task.";
      return container;
    }
    const completedCount = task.subTasks.filter(sub => sub.completed).length;
    const progressSummary = document.createElement("div");
    progressSummary.className = "task-progress";
    progressSummary.textContent = `${completedCount}/${task.subTasks.length} steps done`;
    container.appendChild(progressSummary);
    const visibleSubs = getVisibleSubTasks(task);
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");
      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { taskId: task.id, subId: sub.id });
      const label = document.createElement("span");
      label.className = "subtask-name";
      label.textContent = sub.name;
      row.appendChild(chk);
      row.appendChild(label);
      container.appendChild(row);
    });
    if (task.firstThreeMode && !task.firstThreeUnlocked) {
      const hint = document.createElement("div");
      hint.className = "celebration";
      hint.textContent = "Unlock the remaining steps by completing your first three micro-actions.";
      container.appendChild(hint);
    }
    return container;
  }

  function renderFocusTask(task, taskIndex) {
    const subTaskView = $("subTaskView");
    if (!subTaskView) return;
    let resolvedIndex = taskIndex;
    if ((resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && task) {
      resolvedIndex = tasks.findIndex(t => t.id === task.id);
    }
    const referenceTask = (resolvedIndex !== undefined && resolvedIndex !== null && resolvedIndex >= 0)
      ? tasks[resolvedIndex]
      : task;
    currentFocusTaskIndex = resolvedIndex;
    subTaskView.innerHTML = "";
    clearRunningTimers();
    let createdDefaults = false;
    if (isChartTask(referenceTask)) {
      createdDefaults = ensureChartSubTasks(referenceTask);
    }
    if (createdDefaults) {
      updateChartDurationForTask(referenceTask);
      referenceTask.priority = computePriority(referenceTask);
      persist();
    }
    const content = isChartTask(referenceTask)
      ? renderChartTask(referenceTask, resolvedIndex)
      : renderSimpleSubTasks(referenceTask, resolvedIndex);
    subTaskView.appendChild(content);
  }

  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function calculateDaysSince(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = today.getTime() - parsed.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  }

  function calculateDaysUntil(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = parsed.getTime() - today.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  }

  function isDateInCurrentMonth(dateString) {
    if (!dateString) return false;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return false;
    const today = new Date();
    return parsed.getFullYear() === today.getFullYear()
      && parsed.getMonth() === today.getMonth();
  }

  function getUrgencyDescriptor(value) {
    const options = getScaleOptions("urgency", currentScaleDescriptorCategory);
    const option = options.find(opt => Number(opt.value) === Number(value));
    return option ? option.text : null;
  }

  function getSuggestedUrgency(days) {
    if (days === null || days === undefined || Number.isNaN(days)) return 3;
    if (days < 0) return 3;
    if (days >= 90 && days <= 95) return 5;
    if (days > 95) return 2;
    if (days >= 30 && days < 90) return 1;
    if (days >= 2 && days <= 4) return 4;
    if (days < 30) return 3;
    return 3;
  }

  function updateChartAgeDisplay(days) {
    const display = $("chartAgeDisplay");
    if (!display) return;
    if (days === null || days === undefined) {
      display.textContent = "";
      return;
    }
    if (days < 0) {
      display.textContent = `Service date is ${Math.abs(days)} day(s) in the future.`;
      return;
    }
    display.textContent = `Chart age: ${days} day(s) since visit.`;
  }

  function updateUrgencyHint(suggested) {
    const hint = $("urgencyHint");
    const urgencyField = $("urgency");
    if (!hint || !urgencyField) return;
    const current = Number(urgencyField.value || 3);
    const suggestedDescriptor = getUrgencyDescriptor(suggested);
    const currentDescriptor = getUrgencyDescriptor(current);
    if (!suggestedDescriptor) {
      hint.textContent = currentDescriptor ? `Urgency set to ${currentDescriptor}.` : "";
      return;
    }
    if (current !== suggested) {
      hint.textContent = `Suggested: ${suggestedDescriptor}. (Current: ${currentDescriptor || current})`;
    } else {
      hint.textContent = `Suggested: ${suggestedDescriptor}.`;
    }
  }

  function updateDerivedFields() {
    const dateField = $("dateOfService");
    if (!dateField) return;
    const value = dateField.value;
    const days = calculateDaysSince(value);
    derivedDaysSinceVisit = days;
    updateChartAgeDisplay(days);
    const suggested = getSuggestedUrgency(days);
    const urgencyField = $("urgency");
    if (urgencyField && (urgencyAuto || !urgencyField.value)) {
      urgencyField.value = String(suggested);
    }
    updateUrgencyHint(suggested);
  }

  function setDefaultFieldValues() {
    const nameField = $("name");
    if (nameField) nameField.value = "";
    const categoryField = $("taskCategory");
    if (categoryField) categoryField.value = "General";
    const authorField = $("authorType");
    if (authorField) authorField.value = "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = "Non-Complex";
    const visitField = $("visitType");
    if (visitField) visitField.value = "Follow-Up";
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = "General Clinic";
    NUMERIC_SCALE_FIELDS.forEach(id => {
      const field = $(id);
      if (field) field.value = "1";
    });
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = "3";
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = "1";
    const dueDateField = $("dueDate");
    if (dueDateField) dueDateField.value = "";
    const subField = $("initialSubTasks");
    if (subField) subField.value = "";
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.value = formatDateForInput(new Date());
    }
    derivedDaysSinceVisit = calculateDaysSince($("dateOfService")?.value || null);
    urgencyAuto = true;
    updateDerivedFields();
    handleCategoryChange($("taskCategory")?.value);
  }

  let tasks = [];
  let templates = [];
  let focusQueue = [];
  let editingTaskId = null;
  let focusTimerId = null;
  let focusTimerStart = null;
  let focusTimerLastPing = null;
  let focusSoundEnabled = true;
  let focusAudioContext = null;
  let morningLaunchState = null;
  let launchPadState = null;
  let sleepToolkitState = null;
  let morningCountdown = null;
  let reminderIntervalId = null;
  let pendingTaskDraft = null;
  let sunlightAlertTimeoutId = null;

  const meltdownShieldState = {
    stepIndex: 0
  };

  const MELTDOWN_STEPS = [
    {
      title: "Noise Reduction",
      description: "Close all other browser tabs to eliminate competing stimuli."
    },
    {
      title: "4–4–4 Breathing",
      description: "Take three cycles: inhale for four seconds, hold for four, exhale for four."
    },
    {
      title: "Verbal Grounding",
      description: "Say aloud: ‘I am safe. I can pick one thing.’"
    },
    {
      title: "Task Narrowing",
      descriptionBuilder: () => {
        const topTaskName = getTopTaskName();
        const fragment = document.createDocumentFragment();
        const intro = document.createElement("span");
        intro.textContent = "Remember there is just one next step. Top priority task:";
        const nameEl = document.createElement("span");
        nameEl.className = "meltdown-top-task";
        nameEl.textContent = topTaskName || "No active tasks available.";
        fragment.appendChild(intro);
        fragment.appendChild(document.createElement("br"));
        fragment.appendChild(nameEl);
        return fragment;
      }
    },
    {
      title: "5-Minute Action Timer",
      description: "Set a five-minute timer and commit to only the first subtask for this session."
    },
    {
      title: "Body Movement",
      description: "Stand up, shake out your arms, and loosen your shoulders."
    },
    {
      title: "Music Cue",
      description: "Play a favorite upbeat song to pair with your movement."
    },
    {
      title: "Re-entry",
      description: "Slide back into Focus Mode ready to attack the task with reduced anxiety."
    }
  ];

  function resolvePriorityValue(value) {
    const num = Number(value);
    return Number.isFinite(num) ? num : 0;
  }

  function getTopTaskName() {
    const sourceTasks = Array.isArray(tasks) ? tasks : [];
    const activeTasks = sourceTasks
      .filter(task => !isTaskCompleted(task))
      .sort((a, b) => resolvePriorityValue(b.priority) - resolvePriorityValue(a.priority));

    if (activeTasks.length > 0) {
      return activeTasks[0]?.name || null;
    }

    try {
      const saved = localStorage.getItem("tasks");
      if (!saved) return null;
      const parsed = JSON.parse(saved);
      if (!Array.isArray(parsed)) return null;
      const fallbackActive = parsed
        .filter(task => task && !isTaskCompleted(task))
        .map(task => ({
          ...task,
          priority: resolvePriorityValue(task?.priority)
        }))
        .sort((a, b) => b.priority - a.priority);
      return fallbackActive.length > 0 ? (fallbackActive[0].name || null) : null;
    } catch (error) {
      console.error("Unable to parse saved tasks for Meltdown Shield.", error);
      return null;
    }
  }

  function buildMeltdownDescription(step) {
    if (typeof step.descriptionBuilder === "function") {
      return step.descriptionBuilder();
    }
    const span = document.createElement("span");
    span.textContent = step.description;
    return span;
  }

  function resetMeltdownShieldProgress() {
    meltdownShieldState.stepIndex = 0;
    const list = $("meltdownShieldSteps");
    if (list) {
      list.innerHTML = "";
    }
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.textContent = "▶️ Next";
    }
    updateMeltdownPrompt();
  }

  function updateMeltdownPrompt() {
    const prompt = $("meltdownShieldPrompt");
    const nextBtn = $("meltdownShieldNext");
    if (!prompt || !nextBtn) return;

    prompt.innerHTML = "";

    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      const finalMessage = document.createElement("strong");
      finalMessage.textContent = "System stabilized. Ready for Focus Mode.";
      prompt.appendChild(finalMessage);
      nextBtn.disabled = true;
      nextBtn.textContent = "Complete";
      return;
    }

    const currentStep = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const heading = document.createElement("strong");
    heading.textContent = `Step ${meltdownShieldState.stepIndex + 1}: ${currentStep.title}`;
    const description = buildMeltdownDescription(currentStep);
    prompt.appendChild(heading);
    prompt.appendChild(description);
    nextBtn.disabled = false;
    nextBtn.textContent = "▶️ Next";
  }

  function activateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.remove("hidden");
    panel.setAttribute("aria-hidden", "false");
    resetMeltdownShieldProgress();
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.focus();
    }
  }

  function deactivateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.add("hidden");
    panel.setAttribute("aria-hidden", "true");
    resetMeltdownShieldProgress();
    const sosButton = $("meltdownSosButton");
    if (sosButton) {
      sosButton.focus();
    }
  }

  function completeCurrentMeltdownStep() {
    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      updateMeltdownPrompt();
      return;
    }

    const list = $("meltdownShieldSteps");
    if (!list) return;

    const step = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const listItem = document.createElement("li");
    const stepLabel = document.createElement("strong");
    stepLabel.textContent = `${step.title}`;
    listItem.appendChild(stepLabel);
    listItem.appendChild(document.createElement("br"));
    listItem.appendChild(buildMeltdownDescription(step));
    list.appendChild(listItem);

    meltdownShieldState.stepIndex += 1;
    updateMeltdownPrompt();
  }

  function clearFormFields() {
    setDefaultFieldValues();
  }

  function toggleEditMode(isEditing) {
    const addBtn = $("addTaskBtn");
    const saveBtn = $("saveUpdateBtn");
    const cancelBtn = $("cancelEditBtn");
    if (!addBtn || !saveBtn || !cancelBtn) return;
    addBtn.classList.toggle("hidden", isEditing);
    saveBtn.classList.toggle("hidden", !isEditing);
    cancelBtn.classList.toggle("hidden", !isEditing);
  }

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function clampScale(value, fallback = 1) {
    const base = toNumber(value, fallback);
    return Math.min(5, Math.max(1, base));
  }

  function normalizePatientType(value) {
    const normalized = (value || "").toString().toLowerCase();
    return normalized === "complex" ? "Complex" : "Non-Complex";
  }

  function getPatientTypeWeight(patientType) {
    return normalizePatientType(patientType) === "Complex" ? 1.2 : 1;
  }

  function normalizeVisitType(value) {
    const normalized = (value || "").toString().toLowerCase();
    if (normalized === "establish" || normalized === "establish care") return "Establish Care";
    if (normalized === "well-child" || normalized === "well child visit") return "Well Child Visit";
    if (normalized === "acute" || normalized === "acute visit") return "Acute Visit";
    return "Follow-Up";
  }

  function getVisitTypeWeight(visitType) {
    const normalized = normalizeVisitType(visitType);
    if (normalized === "Establish Care") return 1.3;
    if (normalized === "Well Child Visit") return 1.1;
    if (normalized === "Acute Visit") return 0.9;
    return 1;
  }

  function normalizeClinicSite(value) {
    const normalized = (value || "").toString().toLowerCase().replace(/[’]/g, "'").trim();
    if (normalized.includes("cranio")) return "Craniofacial Clinic";
    if (normalized.includes("pj")) return "St PJ’s Shelter";
    if (normalized.includes("general")) return "General Clinic";
    return "General Clinic";
  }

  function isSameLocalDay(dateA, dateB) {
    if (!(dateA instanceof Date) || !(dateB instanceof Date)) return false;
    if (Number.isNaN(dateA.getTime()) || Number.isNaN(dateB.getTime())) return false;
    return dateA.getFullYear() === dateB.getFullYear()
      && dateA.getMonth() === dateB.getMonth()
      && dateA.getDate() === dateB.getDate();
  }

  function getSameDayBonus(clinicSite, createdAt) {
    const normalizedClinic = normalizeClinicSite(clinicSite);
    if (normalizedClinic !== "St PJ’s Shelter" && normalizedClinic !== "Craniofacial Clinic") {
      return 1;
    }
    if (!createdAt) return 1;
    const createdDate = new Date(createdAt);
    if (Number.isNaN(createdDate.getTime())) return 1;
    const now = new Date();
    return isSameLocalDay(createdDate, now) ? 2 : 1;
  }

  function computeRawPriorityScore(t) {
    const importance = clampScale(t.importance, 1);
    const urgency = clampScale(t.urgency, 3);
    const novelty = clampScale(t.novelty, 1);
    const interest = clampScale(t.interest, 1);
    const pressure = clampScale(t.externalPressure, 1);
    const timeToStart = clampScale(t.timeToStart, 1);
    const difficulty = clampScale(t.difficulty, 1);
    const dopamine = novelty + interest;
    const friction = (6 - timeToStart) + (6 - difficulty);
    const baseScore = (importance * 2)
         + (urgency * 2)
         + (dopamine * 2)
         + (pressure * 5)
         + (friction * 1.5);
    const patientWeight = getPatientTypeWeight(t.patientType);
    const visitWeight = getVisitTypeWeight(t.visitType);
    const sameDayBonus = getSameDayBonus(t.clinicSite, t.createdAt);
    return baseScore * patientWeight * visitWeight * sameDayBonus;
  }

  function computeTimeWeight(task) {
    if (!task) return 1;
    const isChart = isChartTask(task);
    const parsedDays = Number(task.daysSinceVisit);
    const daysSince = Number.isFinite(parsedDays)
      ? parsedDays
      : (task.dateOfService ? calculateDaysSince(task.dateOfService) : null);
    const daysUntilDue = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
    const currentMonth = isDateInCurrentMonth(task.dateOfService)
      || isDateInCurrentMonth(task.dueDate);

    if (!isChart) {
      if (daysUntilDue !== null && Number.isFinite(daysUntilDue) && daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.2;
      }
      return 1.0;
    }

    if (daysSince !== null && Number.isFinite(daysSince)) {
      if (daysSince > 95) return 0.5;
      if (daysSince >= 90 && daysSince <= 95) return 2.0;
      if (daysSince >= 0 && daysSince < 3) return 1.8;
      if (daysSince >= 3 && currentMonth) return 1.3;
    }

    if (daysUntilDue !== null && Number.isFinite(daysUntilDue)) {
      if (daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.8;
      }
      if (daysUntilDue < 0 && daysSince === null) {
        return currentMonth ? 1.3 : 1.0;
      }
      if (currentMonth) {
        return 1.3;
      }
    }

    return 1.0;
  }

  function computePriority(t) {
    const weightedBase = computeRawPriorityScore(t) * computeTimeWeight(t);
    if (Array.isArray(t.subTasks) && t.subTasks.length) {
      const remaining = t.subTasks.filter(s => !s.completed);
      if (remaining.length === 0) return 0;
      const total = remaining.reduce((sum, s) => {
        const value = Number(s.priority);
        return Number.isFinite(value) ? sum + value : sum + weightedBase;
      }, 0);
      return total / remaining.length;
    }
    return weightedBase;
  }

  function recalcTaskPriority(task) {
    if (!task) return task;
    task.authorType = task.authorType || "attending";
    task.patientType = normalizePatientType(task.patientType);
    task.visitType = normalizeVisitType(task.visitType);
    task.clinicSite = normalizeClinicSite(task.clinicSite);
    task.dateOfService = task.dateOfService || null;
    task.createdAt = task.createdAt || task.addedAt || new Date().toISOString();
    if (task.category === "Charts") task.category = "Chart";
    task.firstThreeMode = Boolean(task.firstThreeMode);
    if (!Array.isArray(task.firstThreeSteps)) {
      task.firstThreeSteps = [];
    }
    if (!task.firstThreeMode) {
      task.firstThreeUnlocked = true;
      task.firstThreeSteps = [];
    } else if (task.firstThreeUnlocked === undefined) {
      task.firstThreeUnlocked = false;
    }
    if (task.dateOfService) {
      task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    } else {
      const parsedDays = Number(task.daysSinceVisit);
      task.daysSinceVisit = (task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === "" || !Number.isFinite(parsedDays))
        ? null
        : parsedDays;
    }
    task.urgency = clampScale(task.urgency, 3);
    task.importance = clampScale(task.importance, 1);
    task.novelty = clampScale(task.novelty, 1);
    task.interest = clampScale(task.interest, 1);
    task.externalPressure = clampScale(task.externalPressure, 1);
    task.timeToStart = clampScale(task.timeToStart, 1);
    task.difficulty = clampScale(task.difficulty, 1);
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.completedAt = task.completedAt || null;
    if (task.completed && !task.completedAt) {
      task.completedAt = null;
    }
    if (task.completedAt && !task.completed) {
      task.completed = true;
    } else {
      task.completed = Boolean(task.completed);
    }
    if (isChartTask(task) && task.useChartTemplate === undefined) {
      const defaults = new Set(buildChartSteps(task.authorType).map(step => step.toLowerCase()));
      const hasCustomSteps = Array.isArray(task.subTasks)
        ? task.subTasks.some(sub => !defaults.has(String(sub?.name || "").toLowerCase()))
        : false;
      task.useChartTemplate = !hasCustomSteps;
    }
    const baseRaw = computeRawPriorityScore({ ...task, subTasks: [] });
    const timeWeight = computeTimeWeight(task);
    task.timeWeight = timeWeight;
    const base = baseRaw * timeWeight;
    if (isChartTask(task)) {
      ensureChartSubTasks(task, { basePriority: base });
    }
    if (task.subTasks.length) {
      task.subTasks = task.subTasks.map(sub => {
        const normalizedSub = normalizeSubTask(sub, base);
        normalizedSub.priority = base;
        return normalizedSub;
      });
      if (task.firstThreeMode) {
        if (!task.firstThreeSteps.length) {
          task.firstThreeSteps = task.subTasks.slice(0, 3).map(sub => sub.name);
        } else {
          task.firstThreeSteps = task.firstThreeSteps.slice(0, 3);
        }
        task.subTasks.forEach((sub, index) => {
          const isFirst = index < 3;
          sub.isFirstThree = isFirst;
          sub.deferredUntilUnlock = !task.firstThreeUnlocked && !isFirst;
        });
        maybeUnlockFirstThree(task, { silent: true });
      } else {
        task.subTasks.forEach(sub => {
          sub.isFirstThree = false;
          sub.deferredUntilUnlock = false;
        });
      }
    }
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    return task;
  }

  function persist() {
    localStorage.setItem("tasks", JSON.stringify(tasks));
  }

  function buildTaskDraftFromForm() {
    const nameField = $("name");
    if (!nameField) return null;
    const name = nameField.value.trim();
    if (!name) return null;
    const category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const dateField = $("dateOfService");
    const dateOfService = dateField && dateField.value ? dateField.value : null;
    const daysSinceVisit = calculateDaysSince(dateOfService);
    const task = {
      id: Date.now().toString(),
      name,
      category,
      authorType,
      patientType,
      visitType,
      clinicSite,
      dateOfService,
      daysSinceVisit,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1),
      dueDate: $("dueDate").value || null,
      completed: false,
      completedAt: null,
      createdAt: new Date().toISOString(),
      addedAt: new Date().toISOString(),
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: []
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);
    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    }
    return { task, basePriority, subLines };
  }

  function finalizeNewTask(draft, options = {}) {
    if (!draft) return;
    const { task, basePriority, subLines } = draft;
    const firstThreeSteps = Array.isArray(options.firstThreeSteps) ? options.firstThreeSteps : null;
    const deferred = task.firstThreeMode && !task.firstThreeUnlocked;
    task.subTasks = Array.isArray(subLines)
      ? subLines.map(line => createSubTask(line, basePriority, {
          deferredUntilUnlock: deferred
        }))
      : [];
    if (firstThreeSteps && firstThreeSteps.length) {
      task.firstThreeMode = true;
      task.firstThreeUnlocked = false;
      applyFirstThreeSteps(task, firstThreeSteps, basePriority);
    } else {
      if (!task.firstThreeMode) {
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
      }
    }
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    persist();
    clearFormFields();
    toggleEditMode(false);
    editingTaskId = null;
    updateUI();
  }

  // create a new task with optional sub‑tasks from textarea
  function addTask() {
    const draft = buildTaskDraftFromForm();
    if (!draft) return;
    const triggerWizard = shouldTriggerFirstThreeWizard(
      draft.task.name,
      draft.subLines,
      draft.task.category
    );
    if (triggerWizard) {
      pendingTaskDraft = draft;
      openFirstThreeWizard();
      return;
    }
    finalizeNewTask(draft);
  }

  function generateFirstThreeSuggestions(taskName) {
    const anchor = (taskName || "").split(/[–—:-]/)[0].trim() || "this work";
    return [
      `Open materials for ${anchor}`,
      "List three micro-actions in your notebook",
      "Start a 5-minute draft or outline"
    ];
  }

  function setFirstThreeInputs(values) {
    const ids = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"];
    ids.forEach((id, index) => {
      const field = $(id);
      if (field) {
        field.value = values[index] || "";
      }
    });
  }

  function openFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    const suggestions = generateFirstThreeSuggestions(pendingTaskDraft?.task?.name);
    setFirstThreeInputs(suggestions);
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const firstInput = $("firstThreeStep1");
    if (firstInput) {
      firstInput.focus();
      firstInput.select();
    }
  }

  function closeFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }

  function submitFirstThreeWizard() {
    if (!pendingTaskDraft) {
      closeFirstThreeWizard();
      return;
    }
    const steps = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"]
      .map(id => $(id)?.value || "")
      .map(value => value.trim())
      .filter(Boolean);
    finalizeNewTask(pendingTaskDraft, { firstThreeSteps: steps });
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function skipFirstThreeWizard() {
    if (pendingTaskDraft) {
      pendingTaskDraft.task.firstThreeMode = false;
      pendingTaskDraft.task.firstThreeUnlocked = true;
      pendingTaskDraft.task.firstThreeSteps = [];
      finalizeNewTask(pendingTaskDraft);
      pendingTaskDraft = null;
    }
    closeFirstThreeWizard();
  }

  function cancelFirstThreeWizard() {
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function initializeFirstThreeWizard() {
    const saveBtn = $("firstThreeSave");
    if (saveBtn) {
      saveBtn.addEventListener("click", submitFirstThreeWizard);
    }
    const skipBtn = $("firstThreeSkip");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipFirstThreeWizard);
    }
    const cancelBtn = $("firstThreeCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelFirstThreeWizard);
    }
    const overlay = $("firstThreeWizard");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          cancelFirstThreeWizard();
        }
      });
    }
  }

  function startEditTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    editingTaskId = taskId;
    $("name").value = task.name;
    $("taskCategory").value = task.category || "General";
    handleCategoryChange(task.category || "General");
    $("importance").value = String(task.importance || 1);
    $("urgency").value = String(task.urgency || 3);
    $("novelty").value = String(task.novelty || 1);
    $("interest").value = String(task.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = task.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(task.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(task.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(task.clinicSite);
    const dateField = $("dateOfService");
    if (dateField) {
      if (task.dateOfService) {
        dateField.value = task.dateOfService;
      } else {
        dateField.value = formatDateForInput(new Date());
      }
    }
    urgencyAuto = false;
    derivedDaysSinceVisit = task.daysSinceVisit ?? calculateDaysSince($("dateOfService")?.value || null);
    updateDerivedFields();
    const pressureField = $("externalPressure");
    if (pressureField) {
      const pressureValue = task.externalPressure;
      pressureField.value = String(pressureValue || 1);
    }
    $("timeToStart").value = String(task.timeToStart || 1);
    $("difficulty").value = String(task.difficulty || 1);
    $("dueDate").value = task.dueDate || "";
    const subs = Array.isArray(task.subTasks) ? task.subTasks.map(sub => sub.name).join("\n") : "";
    $("initialSubTasks").value = subs;
    toggleEditMode(true);
    $("name").focus();
  }

  function saveTaskUpdate() {
    if (!editingTaskId) return;
    const idx = tasks.findIndex(t => t.id === editingTaskId);
    if (idx === -1) return;
    const name = $("name").value.trim();
    if (!name) return;

    const task = tasks[idx];
    task.name = name;
    task.category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    task.authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    task.patientType = normalizePatientType(patientField ? patientField.value : task.patientType);
    const visitField = $("visitType");
    task.visitType = normalizeVisitType(visitField ? visitField.value : task.visitType);
    const clinicField = $("clinicSite");
    task.clinicSite = normalizeClinicSite(clinicField ? clinicField.value : task.clinicSite);
    const dateField = $("dateOfService");
    task.dateOfService = dateField && dateField.value ? dateField.value : null;
    task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    task.importance = clampScale($("importance").value, 1);
    task.urgency = clampScale($("urgency").value, 3);
    task.novelty = clampScale($("novelty").value, 1);
    task.interest = clampScale($("interest").value, 1);
    task.externalPressure = clampScale($("externalPressure").value, 1);
    task.timeToStart = clampScale($("timeToStart").value, 1);
    task.difficulty = clampScale($("difficulty").value, 1);
    task.dueDate = $("dueDate").value || null;
    task.updatedAt = new Date().toISOString();

    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);

    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    } else if (task.useChartTemplate !== undefined) {
      delete task.useChartTemplate;
    }

    const basePriority = computePriority({ ...task, subTasks: [] });
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks.slice() : [];
    const newSubTasks = subLines.map(line => {
      const matchIndex = existingSubs.findIndex(sub => sub.name === line);
      if (matchIndex !== -1) {
        const existing = existingSubs.splice(matchIndex, 1)[0];
        const normalizedExisting = normalizeSubTask(existing, basePriority);
        normalizedExisting.name = line;
        normalizedExisting.priority = basePriority;
        return normalizedExisting;
      }
      return createSubTask(line, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    task.subTasks = newSubTasks;
    if (task.firstThreeMode) {
      const firstThreeSubset = task.subTasks.slice(0, 3);
      if (firstThreeSubset.length < 3) {
        task.firstThreeMode = false;
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
        task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
      } else {
        task.firstThreeSteps = firstThreeSubset.map(sub => sub.name);
        task.subTasks = task.subTasks.map((sub, index) => {
          const isFirst = index < 3;
          return {
            ...sub,
            isFirstThree: isFirst,
            deferredUntilUnlock: !task.firstThreeUnlocked && !isFirst
          };
        });
        maybeUnlockFirstThree(task, { silent: true });
      }
    } else {
      task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
    }
    if (isChartTask(task)) {
      const defaultsChanged = ensureChartSubTasks(task, { basePriority });
      if (defaultsChanged) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    if (task.firstThreeMode) {
      maybeUnlockFirstThree(task, { silent: true });
    }
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    persist();

    toggleEditMode(false);
    clearFormFields();
    editingTaskId = null;
    updateUI();
  }

  function cancelEdit() {
    editingTaskId = null;
    toggleEditMode(false);
    clearFormFields();
  }

  // render filter bar
  function renderCategoryFilter() {
    const select = $("taskCategoryFilter");
    if (!select) return;
    const options = ["All", ...categories];
    if (!options.includes(activeCategory)) {
      activeCategory = "All";
    }
    const previous = select.value;
    select.innerHTML = "";
    options.forEach(cat => {
      const option = document.createElement("option");
      option.value = cat;
      option.textContent = cat;
      select.appendChild(option);
    });
    const targetValue = options.includes(activeCategory) ? activeCategory : "All";
    select.value = options.includes(previous) ? previous : targetValue;
    if (select.value !== targetValue) {
      select.value = targetValue;
    }
  }

  // render progress per category
  function renderCategoryProgress() {
    const cont = $("categoryProgress");
    cont.innerHTML = "";
    categories.forEach(cat => {
      const total = tasks.filter(t => t.category === cat).length;
      if (total === 0) return;
      const done = tasks.filter(t => t.category === cat && isTaskCompleted(t)).length;
      const percent = (done / total) * 100;

      const line = document.createElement("div");
      line.className = "line";
      const title = document.createElement("span");
      title.textContent = `${cat}: ${done}/${total} complete`;
      line.appendChild(title);

      const bar = document.createElement("div");
      bar.className = "bar";
      const fill = document.createElement("span");
      fill.className = "fill";
      fill.style.width = percent + "%";
      bar.appendChild(fill);

      line.appendChild(bar);
      cont.appendChild(line);
    });
  }

  function buildTaskDescriptors(task) {
    const descriptors = [];
    if (task.patientType) descriptors.push(`Patient: ${task.patientType}`);
    if (task.visitType) descriptors.push(`Visit: ${task.visitType}`);
    if (task.clinicSite) descriptors.push(task.clinicSite);
    if (task.urgency) descriptors.push(`Urgency ${task.urgency}`);
    return descriptors;
  }

  function getSubTaskProgress(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.length;
    const completed = task.subTasks.filter(sub => sub.completed).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    const label = `${completed} of ${total} steps done`;
    return { total, completed, percent, label };
  }

  function createProgressElement(task) {
    const progressData = getSubTaskProgress(task);
    if (!progressData) return null;
    const container = document.createElement("div");
    container.className = "task-progress-group";

    const label = document.createElement("div");
    label.className = "task-progress";
    label.textContent = `${progressData.label} (${progressData.percent} %)`;
    container.appendChild(label);

    const meter = document.createElement("div");
    meter.className = "task-progress-meter";
    const fill = document.createElement("span");
    fill.className = "fill";
    fill.style.width = `${progressData.percent}%`;
    meter.appendChild(fill);
    container.appendChild(meter);

    return container;
  }

  function createMetaItem(text) {
    const span = document.createElement("span");
    span.textContent = text;
    return span;
  }

  function createTaskDetails(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const details = document.createElement("div");
    details.className = "task-details hidden";
    const heading = document.createElement("h5");
    heading.textContent = "Subtasks";
    details.appendChild(heading);
    const list = document.createElement("ul");
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      const marker = sub.completed ? "✓" : "•";
      item.textContent = `${marker} ${sub.name}`;
      list.appendChild(item);
    });
    details.appendChild(list);
    return details;
  }

  function renderTaskListCard(task, mode, timeBudgetMinutes = null) {
    const card = document.createElement("article");
    card.className = "task-card";
    if (mode === TASK_LIST_MODES.COMPLETED) {
      card.classList.add("is-completed");
    }

    const header = document.createElement("div");
    header.className = "task-card-header";

    const titleGroup = document.createElement("div");
    titleGroup.className = "task-card-title-group";

    const title = document.createElement("h4");
    title.className = "task-title";
    title.textContent = task.name;
    titleGroup.appendChild(title);

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const indicator = document.createElement("span");
      indicator.className = "task-complete-indicator";
      indicator.textContent = "✓ Completed";
      titleGroup.appendChild(indicator);
    }

    header.appendChild(titleGroup);

    const actions = document.createElement("div");
    actions.className = "task-card-actions";

    if (mode === TASK_LIST_MODES.ACTIVE) {
      const startNowBtn = document.createElement("button");
      startNowBtn.textContent = "Start Now";
      startNowBtn.title = "Focus on this task";
      startNowBtn.onclick = () => startFocus(task.id);
      actions.appendChild(startNowBtn);

      const completeBtn = document.createElement("button");
      completeBtn.textContent = "Mark Done";
      completeBtn.title = "Complete task";
      completeBtn.onclick = () => markTaskDoneFromPeek(task.id);
      actions.appendChild(completeBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Edit task";
      editBtn.onclick = () => startEditTask(task.id);
      actions.appendChild(editBtn);
    }

    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "🗑️";
    deleteBtn.title = "Delete task";
    deleteBtn.onclick = () => {
      if (!confirm("Delete this task?")) return;
      const idx = tasks.findIndex(t => t.id === task.id);
      if (idx !== -1) {
        if (editingTaskId === task.id) {
          cancelEdit();
        }
        tasks.splice(idx, 1);
        persist();
        updateUI();
      }
    };
    actions.appendChild(deleteBtn);

    header.appendChild(actions);
    card.appendChild(header);

    const descriptors = buildTaskDescriptors(task);
    if (descriptors.length) {
      const descriptorContainer = document.createElement("div");
      descriptorContainer.className = "task-descriptors";
      descriptors.forEach(text => {
        const span = document.createElement("span");
        span.textContent = text;
        descriptorContainer.appendChild(span);
      });
      card.appendChild(descriptorContainer);
    }

    if (task.firstThreeMode && !task.firstThreeUnlocked && mode === TASK_LIST_MODES.ACTIVE) {
      const nudge = document.createElement("div");
      nudge.className = "score";
      nudge.textContent = "Start with the first three micro-steps to unlock the rest.";
      card.appendChild(nudge);
    }

    const progress = createProgressElement(task);
    if (progress) {
      card.appendChild(progress);
    }

    const meta = document.createElement("div");
    meta.className = "task-meta";
    const metaItems = [];

    if (mode === TASK_LIST_MODES.ACTIVE) {
      metaItems.push(`Score ${task.priority.toFixed(1)}`);
      if (Number.isFinite(timeBudgetMinutes) && timeBudgetMinutes > 0) {
        const estimatedMinutes = estimateTaskMinutes(task);
        metaItems.push(`Est ${estimatedMinutes} min`);
      }
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
      if (task.addedAt) {
        const formatted = formatDateTime(task.addedAt);
        if (formatted) metaItems.push(`Added ${formatted}`);
      }
      const age = task.dateOfService ? calculateDaysSince(task.dateOfService) : (
        task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === ""
          ? null
          : Number(task.daysSinceVisit)
      );
      if (age !== null && Number.isFinite(age)) {
        const ageLabel = age < 0 ? `${Math.abs(age)} day(s) until visit` : `${age} day(s) since visit`;
        metaItems.push(ageLabel);
      }
      if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
        metaItems.push(`Chart time ${formatDuration(Number(task.chartDurationMinutes))}`);
      }
    } else {
      const completedAt = formatDateTime(getCompletionTimestamp(task));
      metaItems.push(`Completed ${completedAt || "--"}`);
      const totalDuration = getTaskTotalDuration(task);
      metaItems.push(`Duration ${formatDuration(totalDuration)}`);
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
    }

    metaItems.forEach(text => meta.appendChild(createMetaItem(text)));
    if (metaItems.length) {
      card.appendChild(meta);
    }

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const details = createTaskDetails(task);
      if (details) {
        const toggle = document.createElement("button");
        toggle.className = "task-detail-toggle";
        toggle.textContent = "View details";
        toggle.onclick = () => {
          const isHidden = details.classList.contains("hidden");
          if (isHidden) {
            details.classList.remove("hidden");
            toggle.textContent = "Hide details";
          } else {
            details.classList.add("hidden");
            toggle.textContent = "View details";
          }
        };
        card.appendChild(toggle);
        card.appendChild(details);
      }
    }

    return card;
  }

  function computeFocusScore(task, energyLevel, timeBudget) {
    if (!task) return 0;
    const base = Number(task?.priority || 0);
    if (!Number.isFinite(base) || base <= 0) {
      return base || 0;
    }
    const energyWeight = computeEnergyFit(task, energyLevel);
    const timeWeight = computeTimeFit(task, timeBudget);
    return base * energyWeight * timeWeight;
  }

  function buildNextTaskInsights(task, energyLevel, timeBudget) {
    const insights = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(estimated) && estimated > 0) {
      insights.push(`Est. ${Math.max(1, Math.round(estimated))} min`);
    }
    if (Number.isFinite(timeBudget)) {
      const timeScore = timeFit(task, timeBudget);
      if (!Number.isFinite(estimated) || estimated <= 0) {
        insights.push(`${timeBudget}-min window`);
      } else if (timeScore > 1) {
        insights.push(`Fits ${timeBudget}-min`);
      } else if (estimated > timeBudget) {
        insights.push(`Stretch past ${timeBudget} min`);
      }
    }
    const energyScore = energyFit(task, energyLevel);
    if (energyScore < 1) {
      insights.push('Easy win');
    } else if (Number.isFinite(energyLevel) && ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
      insights.push(`Energy: ${ENERGY_LABELS[energyLevel]}`);
    }
    if (isChartTask(task) && Number.isFinite(Number(task.daysSinceVisit)) && Number(task.daysSinceVisit) > 0) {
      insights.push(`${task.daysSinceVisit}d since visit`);
    }
    if (task.category) {
      insights.push(task.category);
    }
    return insights.filter(Boolean).slice(0, 3);
  }

  function updateNextTaskCard() {
    const card = $("nextTaskCard");
    if (!card) return;
    const nameEl = $("nextTaskName");
    const substepEl = $("nextTaskSubstep");
    const chipsEl = $("nextTaskChips");
    const scoreEl = $("nextTaskScore");
    const emptyEl = $("nextTaskEmpty");
    const startFullBtn = $("nextTaskStartFull");
    const startSprintBtn = $("nextTaskStartSprint");

    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();

    const candidates = tasks
      .filter(task => !isTaskCompleted(task) && (activeCategory === "All" || task.category === activeCategory))
      .sort((a, b) => computeFocusScore(b, energyLevel, timeBudget) - computeFocusScore(a, energyLevel, timeBudget));

    const topTask = candidates[0] || null;
    nextTaskId = topTask ? topTask.id : null;

    card.classList.remove("hidden");
    if (!topTask) {
      if (nameEl) nameEl.textContent = "";
      if (substepEl) substepEl.textContent = "";
      if (chipsEl) chipsEl.innerHTML = "";
      if (scoreEl) {
        scoreEl.textContent = "";
        scoreEl.classList.add("hidden");
      }
      if (emptyEl) emptyEl.classList.remove("hidden");
      if (startFullBtn) startFullBtn.disabled = true;
      if (startSprintBtn) startSprintBtn.disabled = true;
      return;
    }

    if (emptyEl) emptyEl.classList.add("hidden");
    if (nameEl) nameEl.textContent = topTask.name;
    const firstSub = Array.isArray(topTask.subTasks)
      ? topTask.subTasks.find(sub => !sub.completed)
      : null;
    if (substepEl) {
      substepEl.textContent = firstSub
        ? `Next substep: ${firstSub.name}`
        : "Set your first micro-step.";
    }
    if (chipsEl) {
      chipsEl.innerHTML = "";
      buildNextTaskInsights(topTask, energyLevel, timeBudget).forEach(text => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = text;
        chipsEl.appendChild(chip);
      });
    }
    if (scoreEl) {
      scoreEl.textContent = `Score ${topTask.priority.toFixed(1)}`;
      scoreEl.classList.remove("hidden");
    }
    if (startFullBtn) startFullBtn.disabled = false;
    if (startSprintBtn) startSprintBtn.disabled = false;
  }

  function renderDueTodayList(entries) {
    const section = $("dueTodaySection");
    const listEl = $("dueTodayList");
    const toggleBtn = $("toggleDueToday");
    const emptyEl = $("dueTodayEmpty");
    if (!section || !listEl || !toggleBtn || !emptyEl) return;

    listEl.innerHTML = "";

    if (!entries.length) {
      section.classList.add("hidden");
      emptyEl.classList.remove("hidden");
      toggleBtn.classList.add("hidden");
      toggleBtn.textContent = "";
      return;
    }

    section.classList.remove("hidden");
    emptyEl.classList.add("hidden");

    const total = entries.length;
    const visibleCount = showAllDueToday ? total : Math.min(3, total);
    entries.slice(0, visibleCount).forEach(entry => {
      const item = document.createElement("div");
      item.className = "due-today-item";

      const title = document.createElement("p");
      title.className = "due-today-title";
      title.textContent = entry.task.name;
      item.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "due-today-meta";
      const metaBits = ["Due today"];
      if (entry.fallback && entry.task.dateOfService) {
        metaBits.push(`Visit ${entry.task.dateOfService}`);
      }
      if (isChartTask(entry.task) && Number.isFinite(Number(entry.task.chartDurationMinutes)) && Number(entry.task.chartDurationMinutes) > 0) {
        metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
      }
      meta.textContent = metaBits.join(" • ");
      item.appendChild(meta);

      if (entry.task.subTasks && entry.task.subTasks.length) {
        const progressElement = createProgressElement(entry.task);
        if (progressElement) {
          item.appendChild(progressElement);
        }
      }

      const pillRow = document.createElement("div");
      pillRow.className = "due-today-pills";
      const sprintBtn = document.createElement("button");
      sprintBtn.className = "pill pill-primary";
      sprintBtn.type = "button";
      sprintBtn.textContent = "Start 5m";
      sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
      pillRow.appendChild(sprintBtn);

      const fullBtn = document.createElement("button");
      fullBtn.className = "pill";
      fullBtn.type = "button";
      fullBtn.textContent = "Start full";
      fullBtn.addEventListener("click", () => startFocus(entry.task.id));
      pillRow.appendChild(fullBtn);

      item.appendChild(pillRow);
      listEl.appendChild(item);
    });

    if (total > 3) {
      toggleBtn.classList.remove("hidden");
      toggleBtn.textContent = showAllDueToday ? "Show top 3" : `Show all (${total})`;
    } else {
      toggleBtn.classList.add("hidden");
      toggleBtn.textContent = "";
    }
  }

  function setAddTaskCardCollapsed(collapsed, options = {}) {
    const card = $("addTaskCard");
    const toggle = $("toggleAddTaskCard");
    if (!card || !toggle) return;
    const {
      skipFocus = false,
      skipPersist = false,
      scroll = true,
      focusTarget = null
    } = options;
    const wasCollapsed = card.dataset.collapsed !== "false";
    card.classList.toggle("card--collapsed", collapsed);
    card.dataset.collapsed = collapsed ? "true" : "false";
    const body = card.querySelector(".card-body");
    if (body) {
      body.setAttribute("aria-hidden", collapsed ? "true" : "false");
    }
    const sticky = card.querySelector(".card-sticky-actions");
    if (sticky) {
      sticky.setAttribute("aria-hidden", collapsed ? "true" : "false");
    }
    toggle.textContent = collapsed ? "Expand" : "Collapse";
    toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
    if (!skipPersist) {
      localStorage.setItem(ADD_TASK_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
    const expandedNow = !collapsed && wasCollapsed;
    const handleDueDate = focusTarget === "dueDate";
    const shouldScroll = !collapsed && scroll && (expandedNow || handleDueDate);
    const shouldFocus = !collapsed && (!skipFocus || handleDueDate) && (expandedNow || handleDueDate);

    if (shouldScroll) {
      scrollCardHeaderIntoView(card);
    }

    if (!shouldFocus) {
      return;
    }

    window.setTimeout(() => {
      if (handleDueDate) {
        if (!focusDueDateField()) {
          focusFirstEditableField();
        }
        return;
      }
      focusFirstEditableField();
    }, 120);
  }

  function toggleAddTaskCard() {
    const card = $("addTaskCard");
    if (!card) return;
    const collapsed = card.dataset.collapsed !== "false";
    setAddTaskCardCollapsed(!collapsed);
  }

  function initializeAddTaskCardState() {
    const card = $("addTaskCard");
    if (!card) return;
    let stored = localStorage.getItem(ADD_TASK_CARD_STATE_KEY);
    if (!stored) {
      const legacy = localStorage.getItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      if (legacy) {
        stored = legacy;
        localStorage.setItem(ADD_TASK_CARD_STATE_KEY, legacy);
        localStorage.removeItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      }
    }
    const collapsed = stored ? stored !== "expanded" : true;
    setAddTaskCardCollapsed(collapsed, { skipFocus: true, skipPersist: true, scroll: false });
  }

  function initializeStatusCardState() {
    const toggle = $("toggleStatusCard");
    if (toggle) {
      toggle.addEventListener("click", () => {
        const card = $("statusCard");
        const collapsed = card?.dataset.collapsed !== "false";
        setStatusCardCollapsed(!collapsed);
      });
    }
    const stored = localStorage.getItem(STATUS_CARD_STATE_KEY);
    const collapsed = stored ? stored !== "expanded" : true;
    setStatusCardCollapsed(collapsed, { skipPersist: true });
  }

  function initializeAllTasksCardState() {
    const toggle = $("toggleAllTasksCard");
    if (toggle) {
      toggle.addEventListener("click", () => {
        const card = $("allTasksCard");
        const collapsed = card?.dataset.collapsed !== "false";
        setAllTasksCardCollapsed(!collapsed);
      });
    }
    const stored = localStorage.getItem(ALL_TASKS_CARD_STATE_KEY);
    const collapsed = stored ? stored !== "expanded" : true;
    setAllTasksCardCollapsed(collapsed, { skipPersist: true });
  }

  function focusFirstEditableField() {
    const nameField = $("name");
    if (nameField) {
      window.requestAnimationFrame(() => {
        nameField.focus();
        if (typeof nameField.select === "function") {
          nameField.select();
        }
      });
    }
  }

  function focusDueDateField() {
    const dueField = $("dueDate");
    if (dueField) {
      window.requestAnimationFrame(() => dueField.focus());
      return true;
    }
    const serviceField = $("dateOfService");
    if (serviceField) {
      window.requestAnimationFrame(() => serviceField.focus());
      return true;
    }
    return false;
  }

  function scrollCardHeaderIntoView(card) {
    if (!card) return;
    const target = card.querySelector(".card-head") || card;
    window.requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const offset = Math.max(0, window.scrollY + rect.top - 24);
      window.scrollTo({ top: offset, behavior: "smooth" });
    });
  }

  function handleTemplateModalKeydown(event) {
    if (event.key === "Escape") {
      closeTemplateModal();
    }
  }

  function closeTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    document.removeEventListener("keydown", handleTemplateModalKeydown);
    if (lastFocusedBeforeTemplateModal && typeof lastFocusedBeforeTemplateModal.focus === "function") {
      lastFocusedBeforeTemplateModal.focus();
    }
    lastFocusedBeforeTemplateModal = null;
  }

  function renderTemplateCards(list) {
    const grid = $("template-grid");
    if (!grid) return;
    grid.innerHTML = "";
    if (!list || !list.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      grid.appendChild(empty);
      return;
    }
    list.forEach(template => {
      const card = document.createElement("div");
      card.className = "template-card";
      const title = document.createElement("strong");
      title.textContent = template.name;
      card.appendChild(title);
      const meta = document.createElement("p");
      meta.className = "score";
      const categoryLabel = template.category || "General";
      meta.textContent = `Category: ${categoryLabel}`;
      card.appendChild(meta);
      const stats = document.createElement("p");
      stats.className = "score";
      stats.textContent = `Imp ${template.importance || 1} • Urg ${template.urgency || 3} • Diff ${template.difficulty || 3}`;
      card.appendChild(stats);
      const applyBtn = document.createElement("button");
      applyBtn.type = "button";
      applyBtn.className = "btn btn-primary";
      applyBtn.textContent = "Apply";
      applyBtn.addEventListener("click", () => applyTemplate(template));
      card.appendChild(applyBtn);
      grid.appendChild(card);
    });
  }

  function openTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    lastFocusedBeforeTemplateModal = document.activeElement;
    const category = $("taskCategory")?.value || "General";
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    document.addEventListener("keydown", handleTemplateModalKeydown);
    const firstButton = modal.querySelector(".template-card button") || modal.querySelector(".modal__close");
    if (firstButton) {
      firstButton.focus();
    }
  }

  function fillTaskFormFromTemplate(template, options = {}) {
    if (!template) return;
    $("name").value = template.name || "";
    const keepCurrent = Boolean(options.keepCurrentCategory);
    const categoryField = $("taskCategory");
    const currentCategory = categoryField ? (categoryField.value || "General") : "General";
    const category = keepCurrent ? currentCategory : (template.category || currentCategory);
    if (categoryField) {
      categoryField.value = category;
    }
    handleCategoryChange(category);
    $("importance").value = String(template.importance || 1);
    $("novelty").value = String(template.novelty || 1);
    $("interest").value = String(template.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = template.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(template.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(template.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(template.clinicSite);
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = String(template.urgency || 3);
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = String(template.externalPressure || 1);
    $("timeToStart").value = String(template.timeToStart || 1);
    $("difficulty").value = String(template.difficulty || 1);
    const dateField = $("dateOfService");
    if (dateField) dateField.value = formatDateForInput(new Date());
    urgencyAuto = false;
    updateDerivedFields();
  }

  function applyTemplate(template) {
    fillTaskFormFromTemplate(template, { keepCurrentCategory: true });
    setTaskDetailsCollapsed(false);
    setAddTaskCardCollapsed(false, { focusTarget: "dueDate" });
    closeTemplateModal();
  }

  function updateTemplateModalForCategory(category) {
    const modal = $("template-modal");
    if (!modal || modal.classList.contains("hidden")) return;
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
  }

  function setTaskDetailsCollapsed(collapsed) {
    const panel = $("taskDetails");
    const button = $("expandTaskDetailsButton");
    if (!panel || !button) return;
    panel.dataset.collapsed = collapsed ? "true" : "false";
    button.textContent = collapsed ? "Show details" : "Hide details";
    button.setAttribute("aria-expanded", collapsed ? "false" : "true");
    panel.setAttribute("aria-hidden", collapsed ? "true" : "false");
  }

  function toggleTaskDetails() {
    const panel = $("taskDetails");
    if (!panel) return;
    const collapsed = panel.dataset.collapsed !== "false";
    setTaskDetailsCollapsed(!collapsed);
  }

  function setStatusCardCollapsed(collapsed, options = {}) {
    const card = $("statusCard");
    const toggle = $("toggleStatusCard");
    const body = $("statusCardBody");
    if (!card || !toggle || !body) return;
    const { skipPersist = false } = options;
    card.classList.toggle("card--collapsed", collapsed);
    card.dataset.collapsed = collapsed ? "true" : "false";
    body.setAttribute("aria-hidden", collapsed ? "true" : "false");
    toggle.textContent = collapsed ? "Expand" : "Collapse";
    toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
    if (!skipPersist) {
      localStorage.setItem(STATUS_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
  }

  function setAllTasksCardCollapsed(collapsed, options = {}) {
    const card = $("allTasksCard");
    const toggle = $("toggleAllTasksCard");
    const body = $("allTasksCardBody");
    if (!card || !toggle || !body) return;
    const { skipPersist = false } = options;
    card.classList.toggle("card--collapsed", collapsed);
    card.dataset.collapsed = collapsed ? "true" : "false";
    body.setAttribute("aria-hidden", collapsed ? "true" : "false");
    toggle.textContent = collapsed ? "Expand" : "Collapse";
    toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
    if (!skipPersist) {
      localStorage.setItem(ALL_TASKS_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
  }

  function setModuleOpenState(module, body, open, header = null) {
    if (!module || !body) return;
    module.classList.toggle("is-open", open);
    body.hidden = !open;
    if (header) {
      header.setAttribute("aria-expanded", open ? "true" : "false");
    }
    body.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function openModuleById(id) {
    const module = $(id);
    if (!module) return;
    const body = module.querySelector(".module-body");
    const header = module.querySelector(".module-header");
    if (!body) return;
    setModuleOpenState(module, body, true, header);
    localStorage.setItem(`${MODULE_STATE_PREFIX}${id}`, "open");
  }

  function initializeCollapsibleModules() {
    COLLAPSIBLE_MODULE_IDS.forEach(id => {
      const module = $(id);
      if (!module) return;
      const header = module.querySelector(".module-header");
      const body = module.querySelector(".module-body");
      if (!header || !body) return;
      const stored = localStorage.getItem(`${MODULE_STATE_PREFIX}${id}`);
      const isOpen = stored === "open";
      setModuleOpenState(module, body, isOpen, header);
      header.addEventListener("click", () => {
        const nextState = !module.classList.contains("is-open");
        setModuleOpenState(module, body, nextState, header);
        localStorage.setItem(`${MODULE_STATE_PREFIX}${id}`, nextState ? "open" : "closed");
      });
    });
  }

  function startFiveMinuteSprint(taskId = null) {
    setTaskDetailsCollapsed(false);
    const targetId = taskId || nextTaskId || null;
    startFocus(targetId, { sprintMinutes: 5 });
  }

  function quickAddTask() {
    const input = prompt("Quick add task");
    if (!input) return;
    const name = input.trim();
    if (!name) return;
    const nowIso = new Date().toISOString();
    const task = {
      id: Date.now().toString(),
      name,
      category: "General",
      authorType: "attending",
      patientType: "Non-Complex",
      visitType: "Follow-Up",
      clinicSite: "General Clinic",
      dateOfService: null,
      daysSinceVisit: null,
      importance: 3,
      urgency: 3,
      novelty: 3,
      interest: 3,
      externalPressure: 2,
      timeToStart: 3,
      difficulty: 3,
      dueDate: null,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: false
    };
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    persist();
    setTaskDetailsCollapsed(true);
    updateUI();
  }

  function initializeActionBar() {
    const startNext = $("startNextAction");
    if (startNext) {
      startNext.addEventListener("click", () => {
        if (nextTaskId) {
          startFocus(nextTaskId);
        } else {
          startFocus();
        }
      });
    }
    const sprintAction = $("startSprintAction");
    if (sprintAction) {
      sprintAction.addEventListener("click", () => startFiveMinuteSprint(nextTaskId));
    }
    const quickAddBtn = $("quickAddAction");
    if (quickAddBtn) {
      quickAddBtn.addEventListener("click", quickAddTask);
    }
    const dueTodayBtn = $("dueTodayAction");
    if (dueTodayBtn) {
      dueTodayBtn.addEventListener("click", () => {
        showAllDueToday = true;
        updateUI();
        const section = $("dueTodaySection");
        if (section && !section.classList.contains("hidden")) {
          section.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      });
    }
    const shieldBtn = $("shieldAction");
    if (shieldBtn) {
      shieldBtn.addEventListener("click", activateShield);
    }
    const startFull = $("nextTaskStartFull");
    if (startFull) {
      startFull.addEventListener("click", () => {
        if (nextTaskId) {
          startFocus(nextTaskId);
        } else {
          startFocus();
        }
      });
    }
    const startSprint = $("nextTaskStartSprint");
    if (startSprint) {
      startSprint.addEventListener("click", () => startFiveMinuteSprint(nextTaskId));
    }
    const toggleDue = $("toggleDueToday");
    if (toggleDue) {
      toggleDue.addEventListener("click", () => {
        showAllDueToday = !showAllDueToday;
        updateUI();
        const section = $("dueTodaySection");
        if (section && !section.classList.contains("hidden")) {
          section.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      });
    }
  }

  function initializeTaskForm() {
    setTaskDetailsCollapsed(true);
    const expandBtn = $("expandTaskDetailsButton");
    if (expandBtn) {
      expandBtn.addEventListener("click", toggleTaskDetails);
    }
    const templateBtn = $("btn-use-template");
    if (templateBtn) {
      templateBtn.addEventListener("click", () => {
        setAddTaskCardCollapsed(false, { skipFocus: true });
        openTemplateModal();
      });
    }
    const toggleCardBtn = $("toggleAddTaskCard");
    if (toggleCardBtn) {
      toggleCardBtn.addEventListener("click", toggleAddTaskCard);
    }
    const modal = $("template-modal");
    if (modal) {
      modal.addEventListener("click", event => {
        if (event.target === modal) {
          closeTemplateModal();
        }
      });
      const closeBtn = modal.querySelector(".modal__close");
      if (closeBtn) {
        closeBtn.addEventListener("click", closeTemplateModal);
      }
    }
  }

  // main UI update
  function updateUI() {
    tasks = tasks.map(recalcTaskPriority);
    persist();
    renderCategoryFilter();
    renderCategoryProgress();

    const allTasksTitle = $("allTasksTitle");
    if (allTasksTitle) {
      const total = tasks.length;
      allTasksTitle.textContent = `All Tasks (${total})`;
    }

    const taskList = $("taskList");
    taskList.innerHTML = "";

    const taskViewSelect = $("taskViewMode");
    if (taskViewSelect) {
      taskViewSelect.value = taskListMode;
    }

    if (taskListMode !== TASK_LIST_MODES.ACTIVE) {
      showAllActiveTasks = false;
    }

    const eligibleTasks = tasks.filter(t => activeCategory === "All" || t.category === activeCategory);
    const remaining = eligibleTasks.filter(t => !isTaskCompleted(t));
    $("startBtn").disabled = remaining.length === 0;
    const timeBudget = getTimeBudgetMinutes();
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const hasTimeBudget = Number.isFinite(timeBudget);
    const sortedRemaining = [...remaining].sort((a, b) => b.priority - a.priority);
    const budgetFilteredRemaining = hasTimeBudget
      ? sortedRemaining.filter(task => estimateTaskMinutes(task) <= timeBudget)
      : sortedRemaining;

    const toggleBtn = $("showAllToggle");
    if (toggleBtn) {
      if (taskListMode !== TASK_LIST_MODES.ACTIVE || budgetFilteredRemaining.length <= 3) {
        toggleBtn.classList.add("hidden");
        toggleBtn.textContent = "Show All";
      } else {
        toggleBtn.classList.remove("hidden");
        toggleBtn.textContent = showAllActiveTasks ? "Show Top 3" : "Show All";
      }
    }

    let displayTasks = [];
    if (taskListMode === TASK_LIST_MODES.COMPLETED) {
      displayTasks = eligibleTasks
        .filter(t => isTaskCompleted(t))
        .sort((a, b) => {
          const aDate = getCompletionTimestamp(a) ? new Date(getCompletionTimestamp(a)).getTime() : 0;
          const bDate = getCompletionTimestamp(b) ? new Date(getCompletionTimestamp(b)).getTime() : 0;
          return bDate - aDate;
        });
    } else {
      const pool = budgetFilteredRemaining;
      if (pool.length <= 3 || showAllActiveTasks) {
        displayTasks = pool;
      } else {
        displayTasks = pool.slice(0, 3);
      }
    }

    if (!displayTasks.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      if (taskListMode === TASK_LIST_MODES.ACTIVE && hasTimeBudget && remaining.length > 0 && budgetFilteredRemaining.length === 0) {
        empty.textContent = "No tasks fit the selected time budget.";
      } else {
        empty.textContent = taskListMode === TASK_LIST_MODES.COMPLETED
          ? "No completed tasks yet."
          : "No active tasks to show.";
      }
      taskList.appendChild(empty);
    } else {
      displayTasks.forEach(task => {
        const card = renderTaskListCard(task, taskListMode, hasTimeBudget ? timeBudget : null);
        taskList.appendChild(card);
      });
    }

    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const today = now.toISOString().split("T")[0];
    const dueTodayEntries = [];

    tasks.forEach(task => {
      if (isTaskCompleted(task)) return;
      if (activeCategory !== "All" && task.category !== activeCategory) return;

      const fallbackDueDate = (!task.dueDate && task.dateOfService)
        ? (() => {
            const dt = new Date(`${task.dateOfService}T00:00:00`);
            if (!Number.isNaN(dt.getTime())) {
              dt.setDate(dt.getDate() + 3);
              return dt.toISOString().split("T")[0];
            }
            return null;
          })()
        : null;

      if (task.dueDate === today || (fallbackDueDate && fallbackDueDate === today)) {
        dueTodayEntries.push({
          task,
          fallback: Boolean(fallbackDueDate && !task.dueDate)
        });
      }
    });

    dueTodayEntries.sort((a, b) => computeFocusScore(b.task, energyLevel, timeBudget) - computeFocusScore(a.task, energyLevel, timeBudget));
    if (!dueTodayEntries.length) {
      showAllDueToday = false;
    }
    renderDueTodayList(dueTodayEntries);
    updateNextTaskCard();
    updateSleepToolkitUI();
  }

  function toggleShowAllActive() {
    if (taskListMode !== TASK_LIST_MODES.ACTIVE) return;
    showAllActiveTasks = !showAllActiveTasks;
    updateUI();
  }

  function startFocus(initialTaskId = null, options = {}) {
    if (editingTaskId) cancelEdit();
    if (options && options.expandDetails) {
      setTaskDetailsCollapsed(false);
    }
    const sprintMinutes = Number(options?.sprintMinutes);
    if (Number.isFinite(sprintMinutes) && sprintMinutes > 0) {
      sprintDurationMinutes = sprintMinutes;
    } else {
      sprintDurationMinutes = null;
    }
    stopFocusTimer();
    $("capture").classList.add("hidden");
    $("focus").classList.remove("hidden");
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    lastFocusEnergyLevel = energyLevel;
    lastFocusTimeBudget = timeBudget;
    const score = task => Number(task?.priority || 0) * energyFit(task, energyLevel) * timeFit(task, timeBudget);
    focusQueue = tasks
      .filter(t => !isTaskCompleted(t) && (activeCategory === "All" || t.category === activeCategory))
      .sort((a, b) => score(b) - score(a));
    if (initialTaskId) {
      const targetIndex = focusQueue.findIndex(task => task.id === initialTaskId);
      if (targetIndex > 0) {
        const [selected] = focusQueue.splice(targetIndex, 1);
        focusQueue.unshift(selected);
      } else if (targetIndex === -1) {
        const directTask = tasks.find(t => t.id === initialTaskId && !isTaskCompleted(t));
        if (directTask) {
          focusQueue.unshift(directTask);
        }
      }
    }
    showNextTask();
  }

  function showNextTask() {
    const display = document.querySelector(".focus");
    const scoreView = $("scoreView");
    if (focusQueue.length === 0) {
      display.textContent = "✅ All tasks complete!";
      scoreView.textContent = "";
      updateFocusFitHint(null, lastFocusEnergyLevel, lastFocusTimeBudget);
      const subTaskView = $("subTaskView");
      if (subTaskView) subTaskView.innerHTML = "";
      clearRunningTimers();
      stopFocusTimer();
      currentFocusTaskIndex = null;
      return;
    }
    const current = focusQueue[0];
    display.textContent = current.name;
    startFocusTimer();
    const idx = tasks.findIndex(t => t.id === current.id);
    const task = idx !== -1 ? tasks[idx] : current;
    scoreView.textContent = `Score: ${task.priority.toFixed(1)}`;
    updateFocusFitHint(task, lastFocusEnergyLevel, lastFocusTimeBudget);
    renderFocusTask(task, idx);
  }

  function updateFocusFitHint(task, energyLevel, timeBudget) {
    const hintEl = $("focusFitHint");
    if (!hintEl) return;
    if (!task) {
      hintEl.textContent = "";
      return;
    }
    const pieces = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(timeBudget)) {
      if (Number.isFinite(estimated) && estimated > 0) {
        const rounded = Math.max(1, Math.round(estimated));
        if (rounded <= timeBudget) {
          pieces.push(`Fits your ${timeBudget}-minute block (est. ${rounded} min)`);
        } else {
          pieces.push(`Stretch past ${timeBudget}-minute block (est. ${rounded} min)`);
        }
      } else {
        pieces.push(`Focus window: ${timeBudget} min`);
      }
    }
    if (Number.isFinite(energyLevel)) {
      const difficulty = clampScale(task?.difficulty, 3);
      if (energyLevel <= 2) {
        if (estimated <= 20) {
          pieces.push("Easiest win for low energy");
        } else {
          pieces.push("Try a 5-min pass—energy is low");
        }
      } else if (energyLevel >= 4) {
        if (difficulty >= 4) {
          pieces.push("Perfect for your high energy window");
        } else {
          pieces.push("Use the high energy to bank progress");
        }
      } else if (ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
        pieces.push(`Energy check: ${ENERGY_LABELS[energyLevel]}`);
      }
    }
    hintEl.textContent = pieces.length ? pieces.join(" • ") : "Working the highest-impact task next.";
  }

  function completeTaskById(taskId, options = {}) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (task.completed) return false;
    const nowIso = new Date().toISOString();
    task.completed = true;
    task.completedAt = nowIso;
    updateChartDurationForTask(task);
    if (Array.isArray(task.subTasks)) {
      task.subTasks.forEach(sub => stopTimerForSubTask(sub.id));
    }
    persist();
    recordTaskCompletion(task);
    maybeShowEndOfDayAudit();
    if (!options.skipUI) {
      updateUI();
    }
    return true;
  }

  function markTaskDoneFromPeek(taskId) {
    const completed = completeTaskById(taskId);
    if (!completed) return;
    const wasCurrentFocus = focusQueue.length && focusQueue[0].id === taskId;
    focusQueue = focusQueue.filter(t => t.id !== taskId);
    if (wasCurrentFocus) {
      clearRunningTimers();
      stopFocusTimer();
    }
    const focusSection = $("focus");
    if (focusSection && !focusSection.classList.contains("hidden")) {
      showNextTask();
    }
  }

  function completeTask() {
    if (!focusQueue.length) return;
    const current = focusQueue[0];
    const completed = completeTaskById(current.id, { skipUI: true });
    clearRunningTimers();
    if (completed) {
      updateUI();
    }
    focusQueue.shift();
    showNextTask();
  }

  function backToCapture() {
    clearRunningTimers();
    stopFocusTimer();
    currentFocusTaskIndex = null;
    $("focus").classList.add("hidden");
    $("capture").classList.remove("hidden");
    updateUI();
  }

  function reset() {
    if (!confirm("Clear all tasks?")) return;
    cancelEdit();
    tasks = [];
    localStorage.removeItem("tasks");
    updateUI();
  }

  function saveAsTemplate() {
    const name = $("name").value.trim();
    if (!name) return alert("Task name is required");
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const template = {
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1)
    };
    templates.push(template);
    localStorage.setItem("templates", JSON.stringify(templates));
    renderTemplates();
  }

  function renderTemplates() {
    const container = $("templateButtons");
    const selectedCategory = $("taskCategory")?.value || "General";
    const matchingTemplates = templates
      .map((template, index) => ({ template, index }))
      .filter(({ template }) => (template.category || "General") === selectedCategory);

    const useTemplateBtn = $("btn-use-template");
    if (useTemplateBtn) {
      const hasTemplates = matchingTemplates.length > 0;
      useTemplateBtn.disabled = !hasTemplates;
      useTemplateBtn.setAttribute("aria-disabled", hasTemplates ? "false" : "true");
      useTemplateBtn.title = hasTemplates ? "" : "No templates for this category yet";
    }

    updateTemplateModalForCategory(selectedCategory);

    if (!container) return;

    container.innerHTML = "";

    if (!matchingTemplates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      container.appendChild(empty);
      return;
    }

    matchingTemplates.forEach(({ template: t, index: templateIndex }) => {
      const wrapper = document.createElement("div");
      const useBtn = document.createElement("button");
      useBtn.textContent = `📋 ${t.name}`;
      useBtn.onclick = () => {
        applyTemplate(t);
      };
      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Edit template";
      editBtn.setAttribute("aria-label", "Edit template");
      editBtn.onclick = () => {
        const newName = prompt("Edit template name:", t.name);
        if (!newName) return;
        t.name = newName;
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Delete template";
      deleteBtn.setAttribute("aria-label", "Delete template");
      deleteBtn.onclick = () => {
        if (!confirm("Delete this template?")) return;
        templates.splice(templateIndex, 1);
        localStorage.setItem("templates", JSON.stringify(templates));
        renderTemplates();
      };
      [useBtn, editBtn, deleteBtn].forEach(b => {
        b.style.marginRight = "0.3rem";
        b.style.fontSize = "0.9rem";
      });
      wrapper.appendChild(useBtn);
      wrapper.appendChild(editBtn);
      wrapper.appendChild(deleteBtn);
      container.appendChild(wrapper);
    });
  }

  function updateBillingReminder() {
    const reminder = $("billingReminder");
    if (!reminder) return;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 95);
    const formatted = cutoff.toLocaleDateString(undefined, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
    reminder.innerHTML = `Make sure that all charts from <strong>${formatted}</strong> must be completed today to be eligible for billing.`;
  }

  function registerFieldListeners() {
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.addEventListener("change", () => {
        updateDerivedFields();
      });
    }
    const categoryField = $("taskCategory");
    if (categoryField) {
      categoryField.addEventListener("change", event => {
        handleCategoryChange(event.target.value);
      });
    }
    const urgencyField = $("urgency");
    if (urgencyField) {
      urgencyField.addEventListener("change", () => {
        urgencyAuto = false;
        updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
      });
    }
  }

  function registerTaskListModeControl() {
    const modeSelect = $("taskViewMode");
    if (!modeSelect) return;
    modeSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_LIST_MODES.ACTIVE).toLowerCase();
      taskListMode = value === TASK_LIST_MODES.COMPLETED ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      showAllActiveTasks = false;
      updateUI();
    });
  }

  function registerTimeBudgetControl() {
    const budgetSelect = $("timeBudget");
    if (!budgetSelect) return;
    budgetSelect.addEventListener("change", () => {
      updateUI();
    });
  }

  function registerCategoryFilterControl() {
    const categorySelect = $("taskCategoryFilter");
    if (!categorySelect) return;
    categorySelect.addEventListener("change", event => {
      const value = (event.target.value || "All").toString();
      activeCategory = categories.includes(value) || value === "All" ? value : "All";
      updateUI();
    });
  }

  window.addEventListener('DOMContentLoaded', () => {
    const nextStepBtn = $("meltdownShieldNext");
    if (nextStepBtn) {
      nextStepBtn.addEventListener("click", completeCurrentMeltdownStep);
    }
    initializeChartFields();
    registerFieldListeners();
    registerTaskListModeControl();
    registerTimeBudgetControl();
    setDefaultFieldValues();
    updateBillingReminder();
    initializeSoundPreference();
    initializeFirstThreeWizard();
    initializeTaskForm();
    initializeAddTaskCardState();
    initializeStatusCardState();
    initializeAllTasksCardState();
    initializeActionBar();
    initializeCollapsibleModules();
    initializeMorningLaunchModule();
    initializeLaunchPadModule();
    initializeSleepToolkitModule();
    const saved = localStorage.getItem("tasks");
    if (saved) {
      tasks = JSON.parse(saved).map(task => {
        const normalizedTask = {
          ...task,
          authorType: task.authorType || "attending",
          patientType: normalizePatientType(task.patientType),
          visitType: normalizeVisitType(task.visitType),
          clinicSite: normalizeClinicSite(task.clinicSite),
          dateOfService: task.dateOfService || null,
          createdAt: task.createdAt || task.addedAt || new Date().toISOString()
        };
        if (normalizedTask.dateOfService) {
          normalizedTask.daysSinceVisit = calculateDaysSince(normalizedTask.dateOfService);
        }
        return recalcTaskPriority(normalizedTask);
      });
    }
    const savedTemplates = localStorage.getItem("templates");
    if (savedTemplates) {
      templates = JSON.parse(savedTemplates).map(template => ({
        ...template,
        authorType: template.authorType || "attending",
        patientType: normalizePatientType(template.patientType),
        visitType: normalizeVisitType(template.visitType),
        clinicSite: normalizeClinicSite(template.clinicSite)
      }));
    }
    registerCategoryFilterControl();
    startReminderLoop();
    renderTemplates();
    updateUI();
    updateSleepToolkitUI();
    updateDerivedFields();
  });
  </script>
</body>
</html>
