
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tasker 5000</title>
  <style>
    :root {
      --hero-teal: #2dd4c3;
      --surface: rgba(20, 26, 32, 0.88);
      --surface-elevated: rgba(18, 24, 30, 0.92);
      --text-primary: #e6eef7;
      --text-secondary: #93a0aa;
      --card-radius: 16px;
      --card-border-color: rgba(147, 160, 170, 0.18);
      --page-gutter: clamp(1rem, 4vw, 2.25rem);
      --page-padding-top: clamp(1.5rem, 4vw, 2.5rem);
      --page-padding-bottom: 120px;
      --command-bar-height: 96px;
      --command-bar-safe-offset: env(safe-area-inset-bottom, 0px);
      /* Full-screen overlay width with 8px safe margins on both sides */
      --focus-shell-width: calc(100vw - 16px);
      --tasker-brand-gradient: linear-gradient(90deg, #7bd88f, #2dd4c3);
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html {
      width: 100%;
      max-width: 100vw;
    }

    body {
      background: #0c1117;
      color: var(--text-primary);
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-weight: 400;
      line-height: 1.5;
      margin: 0;
      padding: var(--page-padding-top) 0
        calc(var(--page-padding-bottom) + var(--command-bar-height) + var(--command-bar-safe-offset));
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 100vw;
      min-width: 0;
      overflow-x: hidden;
    }

    body.modal-active {
      overflow: hidden;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: #fff;
      font-weight: 600;
      line-height: 1.3;
    }
    .billing-reminder {
      color: #ff6b6b;
      font-weight: 600;
      margin: 0;
      text-align: left;
      display: inline-flex;
      align-items: center;
    }
    .hidden { display: none !important; }
    label { display: block; margin-top: 0.5rem; }
    input[type="text"], select, input[type="date"], textarea {
      background: #222; color: #eee; border: 1px solid #555;
      padding: 0.5rem; width: 100%;
    }
    .task-recovery-panel {
      background: rgba(17, 24, 31, 0.92);
      border: 1px solid rgba(125, 138, 150, 0.35);
      border-radius: 18px;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.35);
      color: var(--text-primary);
      margin: 1.5rem auto;
      max-width: min(720px, 92vw);
      padding: 1.5rem;
    }
    .task-recovery-panel h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.25rem;
    }
    .task-recovery-panel p {
      margin: 0.5rem 0;
    }
    .task-recovery-panel__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1rem 0;
    }
    .task-recovery-panel button,
    .task-recovery-panel .btn,
    .task-recovery-panel .link-button {
      margin: 0;
    }
    .task-recovery-panel details {
      background: rgba(9, 13, 18, 0.88);
      border-radius: 12px;
      border: 1px solid rgba(125, 138, 150, 0.25);
      margin-top: 1rem;
      padding: 1rem;
    }
    .task-recovery-panel details[open] {
      border-color: rgba(45, 212, 195, 0.4);
    }
    .task-recovery-panel pre {
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 240px;
      overflow: auto;
      margin: 0.75rem 0 0;
      padding: 0.75rem;
      background: rgba(12, 18, 24, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(125, 138, 150, 0.2);
    }
    textarea { resize: vertical; }
    button,
    .btn,
    .icon-button,
    .link-button {
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      padding: 0.6rem 1rem;
      margin: 0.5rem 0.25rem;
      cursor: pointer;
      border-radius: 12px;
      transition: background 150ms ease, color 150ms ease, border-color 150ms ease;
    }

    button:hover,
    .btn:hover,
    .icon-button:hover,
    .link-button:hover {
      background: rgba(35, 46, 58, 0.85);
      color: #f5f9ff;
    }

    button:focus-visible,
    .btn:focus-visible,
    .icon-button:focus-visible,
    .link-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    button:disabled,
    .btn:disabled,
    .icon-button:disabled,
    .link-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }

    .hero-cta:hover {
      background: #27c2b0;
      color: #011c1a;
    }

    .hero-cta:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(45, 212, 195, 0.6);
    }

    button,
    .btn,
    .icon-button,
    .link-button,
    .hero-cta {
      transition: transform 120ms ease, background 150ms ease, color 150ms ease, border-color 150ms ease;
    }

    button:active,
    .btn:active,
    .icon-button:active,
    .link-button:active,
    .hero-cta:active {
      transform: scale(1.02);
    }

    .start-action {
      position: relative;
      overflow: hidden;
    }

    .start-action::after,
    .start-action::before {
      content: "";
      position: absolute;
      pointer-events: none;
      opacity: 0;
    }

    .start-action::after {
      inset: -6px;
      border: 2px solid var(--hero-teal);
      border-radius: inherit;
      transform: scale(0.75);
    }

    .start-action::before {
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      margin: -6px 0 0 -6px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0));
      border-radius: 50%;
      transform: scale(0.5);
    }

    .start-action.cta-reward-active::after {
      animation: cta-ring-fill 200ms ease-out forwards;
    }

    .start-action.cta-reward-active::before {
      animation: cta-sparkle 200ms ease-out forwards;
    }

    @keyframes cta-ring-fill {
      0% {
        opacity: 0.2;
        transform: scale(0.65);
      }
      60% {
        opacity: 0.6;
      }
      100% {
        opacity: 0;
        transform: scale(1.05);
      }
    }

    @keyframes cta-sparkle {
      0% {
        opacity: 0;
        transform: translate(-2px, -4px) scale(0.2);
      }
      50% {
        opacity: 1;
        transform: translate(0, -10px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(2px, -16px) scale(0.4);
      }
    }

    @keyframes button-spin {
      to {
        transform: rotate(360deg);
      }
    }

    .card,
    .peek,
    .task-card,
    .resource-button,
    .worst-day-banner,
    .worst-day-card,
    .distraction-tools,
    .distraction-log li,
    .doorway-reset,
    .gantt-card,
    .chart-summary,
    .subtask-row,
    .routine-block,
    .toast,
    .modal__content,
    .modal-card,
    .wizard-content,
    .audit-card,
    .category-progress .line,
    .category-progress .bar,
    .history-list li,
    .morning-blocks .routine-card,
    .progress-strip,
    .nbt-result-card,
    .task-details,
    .doorway-reset-actions button,
    .next-task-card,
    .due-today-card,
    .status-card,
    .next-best-card {
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      background: var(--surface-elevated);
      max-width: 100%;
      box-sizing: border-box;
    }

    .resource-button,
    .doorway-reset-actions button,
    .card .link-button,
    .next-task-actions button,
    .worst-day-celebrations button,
    .distraction-options button,
    .subtask-actions button,
    .module-inline-actions button,
    .intention-buttons button,
    .card-sticky-actions__primary > *,
    .card-sticky-actions__secondary > * {
      border-radius: 12px;
    }

    .card p,
    .card li,
    .task-card p,
    .task-card .task-descriptors,
    .worst-day-banner p,
    .gantt-card p,
    .doorway-reset p,
    .distraction-log__label,
    .chart-summary li,
    .routine-block p,
    .toast,
    .modal-card p,
    .wizard-content p,
    .next-task-name,
    .next-task-meta,
    .nbt-result-card p,
    .resource-button span,
    .card .score,
    .category-progress .line,
    .next-best-empty,
    .worst-day-hint {
      max-width: 48ch;
    }

    .distraction-tools__header strong,
    .distraction-log__time,
    .worst-day-label,
    .doorway-countdown,
    .card small,
    .chip,
    .score,
    label,
    button,
    input,
    select,
    textarea {
      text-transform: none !important;
      letter-spacing: normal !important;
    }

    .card.collapsed,
    .module-card.collapsed {
      opacity: 0.78;
      filter: saturate(0.85);
    }

    .neuro-checklist-card {
      position: relative;
      width: min(100%, var(--focus-shell-width));
      margin: clamp(0.75rem, 2vw, 1rem) auto 0;
      padding: clamp(1.1rem, 2.5vw, 1.65rem);
      display: flex;
      flex-direction: column;
      gap: clamp(0.85rem, 2.2vw, 1.4rem);
      background: #0b1120;
      border: 1px solid #1e293b;
      box-shadow: 0 20px 48px #000000;
      opacity: 1;
      isolation: isolate;
    }

    /* Availability calibration sheet */
    .checklist-capacity-sheet {
      position: absolute;
      top: calc(100% + 0.5rem);
      right: clamp(1rem, 4vw, 1.5rem);
      width: min(420px, 94vw);
      background: #0b172d;
      color: var(--text-primary);
      border-radius: 16px;
      border: 1px solid #1f2a3d;
      box-shadow: 0 32px 80px #000000;
      padding: 1.25rem 1.4rem 1.1rem;
      display: none;
      z-index: 1400;
      flex-direction: column;
      gap: 1.1rem;
      max-height: 80vh;
      overflow-y: auto;
      isolation: isolate;
    }

    .checklist-capacity-sheet,
    .checklist-capacity-sheet * {
      opacity: 1 !important;
    }

    .capacity-overlay-active .card.collapsed,
    .capacity-overlay-active .module-card.collapsed,
    .capacity-overlay-active .neuro-checklist-card {
      opacity: 1 !important;
      filter: none !important;
    }

    .checklist-capacity-sheet.is-open {
      display: flex;
    }

    .checklist-capacity-sheet__header {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .checklist-capacity-sheet__title {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 700;
    }

    .checklist-capacity-sheet__subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.88rem;
    }

    .checklist-capacity-sheet__summary {
      display: grid;
      gap: 0.45rem;
      background: #113437;
      border: 1px solid #2dd4bf;
      border-radius: 12px;
      padding: 0.85rem 1rem;
    }

    .checklist-capacity-sheet__summary strong {
      font-size: 0.95rem;
    }

    .checklist-capacity-sheet__stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.6rem 1rem;
      font-size: 0.82rem;
      color: var(--text-secondary);
    }

    .checklist-capacity-sheet__stat strong {
      display: block;
      color: var(--text-primary);
      font-size: 0.85rem;
      margin-bottom: 0.15rem;
    }

    .capacity-adjustments {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .capacity-adjustments__heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .capacity-adjustments__heading h5 {
      margin: 0;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      color: var(--text-secondary);
    }

    .capacity-adjustments__list {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    .capacity-adjustments__row {
      display: grid;
      grid-template-columns: auto auto auto auto 1fr auto;
      align-items: center;
      gap: 0.45rem;
      background: #1b2537;
      border: 1px solid #334155;
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
    }

    .capacity-adjustments__row[data-kind="gain"] {
      border-color: #4ade80;
      background: #1a3a2b;
    }

    .capacity-adjustments__row[data-kind="loss"] {
      border-color: #f87171;
      background: #3a1f1f;
    }

    .capacity-adjustments__row input[type="time"] {
      width: 5.2rem;
      background: #111d30;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 0.35rem 0.4rem;
      color: var(--text-primary);
      font-weight: 600;
    }

    .capacity-adjustments__row input[type="text"] {
      width: 100%;
      background: #111d30;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 0.35rem 0.55rem;
      color: var(--text-primary);
      font-size: 0.85rem;
    }

    .capacity-adjustments__icon {
      font-size: 1.1rem;
    }

    .capacity-adjustments__label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .capacity-adjustments__remove {
      border: none;
      background-color: #1b2537;
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1;
      padding: 0.2rem;
      cursor: pointer;
    }

    .capacity-adjustments__row[data-kind="gain"] .capacity-adjustments__remove {
      background-color: #1a3a2b;
    }

    .capacity-adjustments__row[data-kind="loss"] .capacity-adjustments__remove {
      background-color: #3a1f1f;
    }

    .capacity-adjustments__remove:hover,
    .capacity-adjustments__remove:focus-visible {
      color: var(--hero-teal);
    }

    .capacity-adjustments__add {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: #123d3a;
      border: 1px solid #2dd4bf;
      border-radius: 999px;
      color: var(--hero-teal);
      padding: 0.35rem 0.75rem;
      font-weight: 600;
      font-size: 0.82rem;
      cursor: pointer;
    }

    .capacity-adjustments__add[data-kind="loss"] {
      background: #3a1f1f;
      border-color: #f87171;
      color: #fca5a5;
    }

    .capacity-adjustments__add:hover,
    .capacity-adjustments__add:focus-visible {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.28);
      outline: none;
    }

    .capacity-adjustments__add[data-kind="loss"]:hover,
    .capacity-adjustments__add[data-kind="loss"]:focus-visible {
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.25);
    }

    .capacity-adjustments__empty {
      color: var(--text-secondary);
      font-size: 0.82rem;
      font-style: italic;
    }

    .checklist-capacity-sheet__footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    .checklist-capacity-sheet__footer button {
      font-weight: 600;
      color: var(--hero-teal);
    }

    .energy-sheet {
      position: fixed;
      top: var(--energy-sheet-top, 50%);
      left: var(--energy-sheet-left, 50%);
      transform: translate(-50%, calc(-50% + 24px));
      width: min(420px, 90vw);
      max-height: calc(100vh - 32px);
      overflow: auto;
      background: rgba(15, 22, 30, 0.96);
      border: 1px solid rgba(120, 164, 193, 0.35);
      border-radius: 18px;
      padding: 1.25rem;
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.45);
      z-index: 1500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease, transform 160ms ease;
    }

    .energy-sheet.is-open {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%);
    }

    .energy-sheet__header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      text-align: center;
      margin-bottom: 1rem;
    }

    .energy-sheet__title {
      margin: 0;
      font-size: 1.1rem;
      color: #fbbf24;
    }

    .energy-sheet__subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .energy-sheet__body {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .energy-sheet__body--dual {
      gap: 1rem;
    }

    .energy-sheet__slider {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .energy-sheet__labels {
      display: flex;
      justify-content: space-between;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .energy-sheet__value {
      font-weight: 600;
      color: var(--text-primary);
    }

    .energy-sheet__bucket {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(120, 164, 193, 0.25);
      border-radius: 12px;
      padding: 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .energy-sheet__bucket-heading {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .energy-sheet__bucket-title {
      font-weight: 700;
      color: #f8fafc;
      font-size: 0.95rem;
    }

    .energy-sheet__bucket-labels {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 0.35rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
      text-align: center;
    }

    .energy-sheet__bucket-labels span {
      padding: 0.35rem 0.25rem;
      border-radius: 10px;
      border: 1px solid transparent;
    }

    .energy-sheet__bucket-labels span.is-active {
      border-color: rgba(248, 180, 0, 0.6);
      color: #fbbf24;
      background: rgba(251, 191, 36, 0.08);
      font-weight: 600;
    }

    .energy-sheet__bucket-notes {
      margin: 0;
      padding-left: 1rem;
      color: var(--text-secondary);
      display: grid;
      gap: 0.35rem;
    }

    .energy-sheet__bucket-notes li {
      line-height: 1.4;
    }

    .energy-sheet__bucket-approx {
      color: #8ed1fc;
      font-weight: 600;
      list-style: none;
      margin-top: 0.25rem;
    }

    .energy-sheet__summary {
      background: linear-gradient(90deg, rgba(8, 47, 73, 0.8), rgba(14, 116, 144, 0.7));
      border: 1px solid rgba(56, 189, 248, 0.35);
      border-radius: 12px;
      padding: 0.85rem 1rem;
      display: grid;
      gap: 0.35rem;
    }

    .energy-sheet__summary-title {
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.75rem;
      color: #bae6fd;
      margin: 0;
    }

    .energy-sheet__summary-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #f8fafc;
      margin: 0;
    }

    .energy-sheet__summary-detail {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .energy-sheet__actions {
      display: flex;
      justify-content: center;
    }

    .energy-sheet__actions button {
      min-width: 120px;
    }

    /* Backdrop for sheet */
    .checklist-capacity-backdrop {
      position: fixed;
      inset: 0;
      background-color: #020617;
      display: none;
      z-index: 1390;
      opacity: 1 !important;
    }

    .checklist-capacity-backdrop.is-visible {
      display: block;
    }

    .neuro-checklist__header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      text-align: center;
    }

    .neuro-checklist__title {
      margin: 0;
      font-size: clamp(1.15rem, 3vw, 1.45rem);
      color: #7bd88f;
      letter-spacing: 0.01em;
    }

    .neuro-checklist__snapshot {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
      max-width: 100%;
      white-space: pre-line;
    }

    .neuro-checklist__control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: clamp(0.5rem, 2vw, 1rem);
      width: 100%;
      justify-items: center;
    }

    .neuro-checklist__control {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.35rem;
    }

    .neuro-checklist__control button {
      margin: 0;
      width: clamp(48px, 10vw, 56px);
      height: clamp(48px, 10vw, 56px);
      border-radius: 14px;
      font-size: clamp(1.25rem, 5vw, 1.6rem);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(13, 19, 25, 0.85);
      border: 1px solid rgba(124, 144, 160, 0.35);
      transition: transform 150ms ease, background 150ms ease, border-color 150ms ease;
    }

    .neuro-checklist__control button:hover,
    .neuro-checklist__control button:focus-visible {
      transform: translateY(-1px);
      background: rgba(31, 42, 54, 0.9);
      border-color: rgba(125, 196, 177, 0.55);
    }

    .neuro-checklist__control button.is-active {
      background: rgba(45, 212, 195, 0.18);
      border-color: rgba(45, 212, 195, 0.6);
    }

    .neuro-checklist__control span {
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .neuro-checklist__control select {
      width: 100%;
      min-width: 140px;
      padding: 0.6rem 0.75rem;
      background: rgba(13, 19, 25, 0.85);
      color: var(--text-primary);
      border: 1px solid rgba(124, 144, 160, 0.35);
      border-radius: 14px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      transition: transform 150ms ease, background 150ms ease, border-color 150ms ease;
    }

    .neuro-checklist__control select:focus-visible,
    .neuro-checklist__control select:hover {
      transform: translateY(-1px);
      background: rgba(31, 42, 54, 0.9);
      border-color: rgba(125, 196, 177, 0.55);
      outline: none;
    }

    .neuro-checklist__control--dropdown {
      align-items: stretch;
      position: relative;
      width: 100%;
    }

    .neuro-checklist__control--dropdown > button {
      width: 100%;
      background: rgba(13, 19, 25, 0.85);
      border: 1px solid rgba(124, 144, 160, 0.35);
      border-radius: 14px;
      padding: 0.65rem 0.75rem;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.01em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
      transition: transform 150ms ease, background 150ms ease, border-color 150ms ease;
    }

    .neuro-checklist__control--dropdown > button:hover,
    .neuro-checklist__control--dropdown > button:focus-visible {
      transform: translateY(-1px);
      background: rgba(31, 42, 54, 0.9);
      border-color: rgba(125, 196, 177, 0.55);
      outline: none;
    }

    .neuro-checklist__dropdown {
      position: absolute;
      inset: auto 0  auto;
      top: calc(100% + 0.35rem);
      background: rgba(10, 15, 21, 0.96);
      border: 1px solid rgba(124, 144, 160, 0.35);
      border-radius: 16px;
      padding: 0.4rem;
      display: none;
      flex-direction: column;
      gap: 0.3rem;
      z-index: 4;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
    }

    .neuro-checklist__dropdown.is-open {
      display: flex;
    }

    .neuro-checklist__dropdown-option {
      width: 100%;
      text-align: left;
      padding: 0.65rem 0.75rem;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
      font-weight: 600;
      letter-spacing: 0.01em;
      text-transform: uppercase;
      transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
    }

    .neuro-checklist__dropdown-option:hover,
    .neuro-checklist__dropdown-option:focus-visible {
      background: rgba(31, 42, 54, 0.9);
      border-color: rgba(125, 196, 177, 0.55);
      outline: none;
      transform: translateY(-1px);
    }

    .neuro-checklist__dropdown-option.is-active {
      background: rgba(45, 212, 195, 0.14);
      border-color: rgba(45, 212, 195, 0.45);
    }

    .neuro-checklist__body {
      display: grid;
      gap: clamp(1rem, 3vw, 1.5rem);
    }

    .neuro-checklist-card.neuro-checklist--collapsed .neuro-checklist__body {
      display: none;
    }

    @media (min-width: 900px) {
      .neuro-checklist__body {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .neuro-checklist__section:nth-child(1) {
        grid-column: span 2;
      }

      .neuro-checklist__section:nth-child(3) {
        grid-column: span 3;
      }
    }

    .neuro-checklist__section {
      background: rgba(11, 17, 23, 0.55);
      border: 1px solid rgba(147, 160, 170, 0.16);
      border-radius: 14px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .neuro-checklist__section-title {
      font-size: 1rem;
      margin: 0;
      color: #f5f9ff;
    }

    .neuro-checklist__list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .neuro-checklist__section--itinerary {
      grid-column: span 3;
    }

    @media (max-width: 899px) {
      .neuro-checklist__section--itinerary {
        grid-column: auto;
      }
    }

    .neuro-checklist__itinerary {
      display: grid;
      gap: 0.75rem;
    }

    .neuro-checklist__itinerary-list {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .neuro-checklist__itinerary-timeline {
      display: none;
    }

    .neuro-checklist-card.neuro-checklist--timeline .neuro-checklist__body {
      grid-template-columns: minmax(0, 1fr);
    }

    .neuro-checklist-card.neuro-checklist--timeline .neuro-checklist__section:not(.neuro-checklist__section--itinerary) {
      display: none;
    }

    .neuro-checklist-card.neuro-checklist--timeline .neuro-checklist__itinerary-list {
      display: none;
    }

    .neuro-checklist-card.neuro-checklist--timeline .neuro-checklist__itinerary-timeline {
      display: block;
    }

    .neuro-checklist__itinerary-empty {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .neuro-checklist-card.neuro-checklist--timeline .neuro-checklist__itinerary-empty {
      text-align: center;
    }

    .itinerary-timeline {
      display: grid;
      gap: 0.5rem;
    }

    .itinerary-row {
      display: grid;
      grid-template-columns: 80px 1fr 2fr;
      align-items: center;
      gap: 0.5rem;
    }

    .itinerary-row .t-time {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .t-bar {
      height: 8px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      overflow: hidden;
    }

    .t-fill {
      height: 100%;
      width: 100%;
      background: var(--hero-teal);
    }
/* === Phase 4 – Timeline cards + backdrop tones === */

.itinerary-card {

display:grid; grid-template-columns: 86px 1fr; gap:0.75rem;

background: rgba(15,23,42,0.5); border:1px solid rgba(148,163,184,0.22);

border-radius:12px; padding:0.75rem; align-items:flex-start;

}

.itinerary-card .t-time { font-weight:700; opacity:0.9; }

.itinerary-card .t-main { display:grid; gap:0.35rem; }

.itinerary-card .t-title { font-weight:700; }

.itinerary-card .t-meta { font-size:0.85rem; opacity:0.9; }

.itinerary-card .t-rationale { font-size:0.85rem; opacity:0.8; }

.itinerary-card .t-source { font-size:0.8rem; opacity:0.7; }



.itinerary-card .t-controls { display:flex; gap:0.35rem; align-items:center; }

.itinerary-card .t-controls button {

border:none; background:rgba(45,212,195,0.12); color:var(--hero-teal);

padding:0.25rem 0.5rem; border-radius:8px; cursor:pointer; font-weight:600;

}

.itinerary-card .t-progress { height:6px; background:rgba(148,163,184,0.25);

border-radius:999px; overflow:hidden; }

.itinerary-card .t-progress .fill { height:100%; width:0%; background:var(--hero-teal); transition:width 240ms ease; }



body.calm-backdrop { background-image: none; }

body.win-flash { animation: winFlash 800ms ease; }
    body.calm backdrop{background-image:none;}

@keyframes winFlash {

0%{box-shadow: inset 0 0 0 0 rgba(45,212,195,0)}

30%{box-shadow: inset 0 0 0 100vmax rgba(45,212,195,0.08)}

100%{box-shadow: inset 0 0 0 0 rgba(45,212,195,0)}

}
    /* HUD / Win Log */

.winlog-hud { position:fixed; inset:0; display:grid; place-items:center;

background: rgba(2,6,23,0.55); backdrop-filter: blur(2px); z-index:1300; }

.winlog-hud.hidden { display:none; }

.winlog-card { width:min(420px,92vw); background:#fff; color:#0f172a; border-radius:14px;

padding:1rem; box-shadow:0 18px 40px rgba(15,23,42,0.25); }

.winlog-card h3 { margin:0 0 0.35rem; }

.winlog-sub { margin:0 0 0.5rem; opacity:0.8; }

.winlog-actions { display:flex; flex-wrap:wrap; gap:0.35rem; margin-bottom:0.5rem; }

.winlog-actions button { border:none; background:#eef2ff; padding:0.35rem 0.6rem; border-radius:8px; cursor:pointer; }

.winlog-card input { width:100%; margin:0.25rem 0 0.5rem; padding:0.45rem 0.6rem; border-radius:8px; border:1px solid #cbd5e1; }

.winlog-footer { display:flex; gap:0.5rem; justify-content:flex-end; }

.winlog-footer .secondary {
  background:transparent; color:#0f172a;
    }

/* === Phase 5 – Insights Overlay === */
.insight-overlay {
  position: fixed; inset: 0; display: grid; place-items: center;
  background: rgba(2,6,23,0.55); backdrop-filter: blur(2px); z-index: 1350;
}
.insight-overlay.hidden { display: none; }
.insight-card {
  width: min(520px, 94vw);
  background: #fff; color: #0f172a;
  border-radius: 14px; padding: 1rem 1.25rem;
  box-shadow: 0 18px 40px rgba(15,23,42,0.25);
}
.insight-stats { margin-top: 0.5rem; font-size: 0.9rem; line-height: 1.3; }
.insight-footer { margin-top: 0.75rem; text-align: right; }
    
    .neuro-checklist__list--ordered {
      counter-reset: neuro-focus-counter;
    }

    .neuro-checklist__list--ordered li {
      counter-increment: neuro-focus-counter;
      padding-left: 2rem;
      position: relative;
    }

    .neuro-checklist__list--ordered li::before {
      content: counter(neuro-focus-counter) ".";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--hero-teal);
      font-weight: 700;
    }

    .neuro-checklist__item-label {
      display: block;
      font-weight: 600;
      color: #fff;
    }

    .neuro-checklist__item-meta {
      display: block;
      color: var(--text-secondary);
      font-size: 0.88rem;
    }

    .neuro-checklist__empty {
      color: var(--text-secondary);
      font-style: italic;
    }

    .neuro-checklist__list--ordered li.neuro-checklist__empty::before {
      display: none;
    }

    .schedule-card__header {
      padding-inline: 1rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.6rem;
    }

    .schedule-card__title-group {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      width: 100%;
    }

    .schedule-card__mode-buttons {
      display: inline-flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .schedule-card__mode-button {
      font-size: 0.85rem;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(23, 32, 44, 0.88);
      color: rgba(226, 232, 240, 0.92);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, color 160ms ease,
        box-shadow 160ms ease;
    }

    .schedule-card__mode-button:hover,
    .schedule-card__mode-button:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(31, 45, 62, 0.95);
      color: #f8fafc;
      outline: none;
    }

    .schedule-card__mode-button--active {
      background: rgba(20, 83, 78, 0.4);
      border-color: rgba(45, 212, 195, 0.6);
      color: rgba(45, 212, 195, 0.95);
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.38) inset;
    }

    @media (max-width: 560px) {
      .schedule-card__header {
        padding-inline: 0.75rem;
      }
    }

    .schedule-card__title {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: -0.01em;
      color: #7bd88f;
      text-align: left;
    }

    .schedule-card__grid-wrapper {
      width: 100%;
    }

    .schedule-card__content {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(260px, 320px);
      gap: 1.35rem;
      align-items: start;
      padding-inline: 1rem;
      box-sizing: border-box;
    }

    .schedule-card__column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .schedule-card__column-head {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 0.75rem;
      padding-inline: 0.25rem;
    }

    .schedule-card__column-title {
      margin: 0;
      font-size: 0.9rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(203, 213, 225, 0.86);
    }

    .schedule-card__column-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    [data-schedule-summary] {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: #e6eef7;
    }

    .schedule-summary__icon {
      font-size: 1.1rem;
      line-height: 1;
      color: #a8f5c0;
    }

    .schedule-summary--with-icon {
      flex-wrap: wrap;
      row-gap: 0.2rem;
    }

    .clinic-basket {
      background: linear-gradient(180deg, rgba(14, 20, 28, 0.94), rgba(11, 16, 23, 0.92));
      border: 1px solid rgba(148, 163, 184, 0.28);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.45);
      border-radius: 18px;
      padding: 1.1rem 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-height: 100%;
    }

    .clinic-basket__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }

    .clinic-basket__title {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: -0.01em;
      color: #f8fafc;
    }

    .clinic-basket__updated {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      margin: 0;
      padding: 0.15rem 0.65rem;
      border-radius: 999px;
      background: rgba(45, 212, 195, 0.12);
      color: rgba(224, 231, 255, 0.85);
      font-size: 0.7rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .clinic-basket__list {
      display: grid;
      gap: 0.6rem;
      margin: 0;
      padding: 0;
    }

    .clinic-basket__row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      font-size: 0.95rem;
      font-weight: 500;
      color: rgba(226, 232, 240, 0.95);
    }

    .clinic-basket__label {
      display: inline-flex;
      align-items: baseline;
      gap: 0.35rem;
      letter-spacing: 0.02em;
    }

    .clinic-basket__label::after {
      content: ":";
      color: rgba(148, 163, 184, 0.75);
    }

    .clinic-basket__value {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .clinic-basket__input {
      width: 72px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 10px;
      padding: 0.25rem 0.5rem;
      color: #f8fafc;
      font-size: 1.05rem;
      font-variant-numeric: tabular-nums;
      text-align: right;
      transition: border-color 120ms ease, background 120ms ease, box-shadow 120ms ease;
    }

    .clinic-basket__input:focus {
      outline: none;
      border-color: rgba(45, 212, 195, 0.45);
      background: rgba(15, 23, 42, 0.6);
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.16);
    }

    .clinic-basket__input::-webkit-outer-spin-button,
    .clinic-basket__input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .clinic-basket__input[type="number"] {
      -moz-appearance: textfield;
    }

    .clinic-basket__hint {
      margin: 0;
      font-size: 0.75rem;
      color: rgba(148, 163, 184, 0.75);
      letter-spacing: 0.03em;
    }

    .clinic-basket__updated-highlight {
      animation: clinic-basket-pulse 480ms ease-out;
    }

    @keyframes clinic-basket-pulse {
      0% {
        background: rgba(45, 212, 195, 0.35);
        color: #022624;
      }
      100% {
        background: rgba(45, 212, 195, 0.12);
        color: rgba(224, 231, 255, 0.85);
      }
    }

    @media (max-width: 1024px) {
      .schedule-card__content {
        grid-template-columns: 1fr;
      }

      .schedule-card__column-head {
        justify-content: flex-start;
      }

      .clinic-basket__header {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    .weekly-grid {
      display: grid;
      grid-template-columns: repeat(var(--weekly-grid-columns, 5), minmax(0, 1fr));
      grid-template-rows: repeat(var(--weekly-grid-rows, 2), minmax(96px, 1fr));
      width: 100%;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(12, 18, 27, 0.94), rgba(9, 13, 20, 0.92));
      border: 1px solid rgba(148, 163, 184, 0.28);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.45);
      overflow: hidden;
    }

    .weekly-grid:empty {
      display: none;
    }

    .weekly-grid__cell {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.55rem;
      padding: 0.8rem 0.65rem 1.9rem;
      background: rgba(15, 21, 30, 0.92);
      color: inherit;
      text-align: left;
      cursor: default;
      border-right: 1px solid rgba(148, 163, 184, 0.22);
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      transition: background 150ms ease, color 150ms ease;
      min-height: 96px;
    }

    .weekly-grid:not(.weekly-grid--with-weekend) .weekly-grid__cell:nth-child(5n) {
      border-right: none;
    }

    .weekly-grid:not(.weekly-grid--with-weekend) .weekly-grid__cell:nth-last-child(-n + 5) {
      border-bottom: none;
    }

    .weekly-grid--with-weekend {
      --weekly-grid-columns: 7;
    }

    .weekly-grid--with-weekend .weekly-grid__cell:nth-child(7n) {
      border-right: none;
    }

    .weekly-grid--with-weekend .weekly-grid__cell:nth-last-child(-n + 7) {
      border-bottom: none;
    }

    .weekly-grid__cell--weekend {
      padding: 0.95rem 0.85rem 1.2rem;
      border-right: none;
      border-bottom: none;
    }

    .weekly-grid__cell--pm {
      border-bottom: none;
    }

    .weekly-grid__day {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(203, 213, 225, 0.76);
    }

    .weekly-grid__cell:hover,
    .weekly-grid__cell:focus-visible {
      background: rgba(23, 33, 46, 0.95);
      color: #f8fafc;
    }

    .weekly-grid__cell:focus-visible {
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(45, 212, 195, 0.4);
    }

    .weekly-grid__header {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(203, 213, 225, 0.9);
      align-self: flex-start;
    }

    .weekly-grid__clinic-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      width: 100%;
    }

    .weekly-grid__clinic-select {
      appearance: none;
      background: rgba(23, 32, 44, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      color: rgba(226, 232, 240, 0.96);
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      padding: 0.6rem 2.25rem 0.6rem 0.9rem;
      text-align: center;
      text-transform: uppercase;
      min-width: 220px;
      max-width: 100%;
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, color 160ms ease;
    }

    .weekly-grid__resident-icon {
      font-size: 1.15rem;
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 160ms ease, transform 160ms ease;
    }

    .weekly-grid__resident-icon--visible {
      opacity: 1;
      transform: scale(1);
    }

    .weekly-grid__clinic-select:hover,
    .weekly-grid__clinic-select:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(31, 45, 62, 0.95);
      outline: none;
    }

    .weekly-grid__manage {
      position: absolute;
      right: 0.7rem;
      bottom: 0.75rem;
      width: 2.25rem;
      height: 2.25rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(23, 32, 44, 0.88);
      color: rgba(226, 232, 240, 0.96);
      font-size: 1.05rem;
      line-height: 1;
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, color 160ms ease,
        transform 120ms ease;
    }

    .weekly-grid__manage:hover,
    .weekly-grid__manage:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(31, 45, 62, 0.95);
      color: #e2e8f0;
      outline: none;
    }

    .weekly-grid__manage:active {
      transform: scale(0.96);
    }

    .weekend-card {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      background: linear-gradient(180deg, rgba(15, 23, 36, 0.9), rgba(11, 17, 26, 0.92));
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.35);
      padding: 0.85rem 0.9rem 0.85rem;
      min-height: 100%;
    }

    .weekend-card__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .weekend-card__title {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: rgba(226, 232, 240, 0.96);
    }

    .weekend-card__note {
      margin: 0;
      font-size: 0.85rem;
      line-height: 1.5;
      color: rgba(203, 213, 225, 0.78);
    }

    .weekend-card__badge {
      align-self: flex-start;
      padding: 0.28rem 0.65rem;
      border-radius: 999px;
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.32);
      background: rgba(148, 163, 184, 0.18);
      color: rgba(226, 232, 240, 0.9);
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
    }

    .weekend-card__badge--on {
      background: rgba(45, 212, 191, 0.18);
      border-color: rgba(45, 212, 191, 0.42);
      color: rgba(16, 185, 129, 0.9);
    }

    .weekend-card__badge--off {
      background: rgba(100, 116, 139, 0.16);
      border-color: rgba(100, 116, 139, 0.38);
      color: rgba(148, 163, 184, 0.82);
    }

    .weekend-card__toggle {
      align-self: flex-end;
      padding: 0.45rem 0.85rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(23, 32, 44, 0.88);
      color: rgba(226, 232, 240, 0.94);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, color 160ms ease,
        box-shadow 160ms ease;
    }

    .weekend-card__toggle:hover,
    .weekend-card__toggle:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(31, 45, 62, 0.95);
      color: #f8fafc;
      outline: none;
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.25);
    }

    .weekend-card__toggle--active {
      background: rgba(20, 83, 78, 0.4);
      border-color: rgba(45, 212, 195, 0.6);
      color: rgba(45, 212, 195, 0.95);
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.4) inset;
    }

    .weekly-grid__time {
      font-size: 0.75rem;
      color: rgba(148, 163, 184, 0.8);
      letter-spacing: 0.05em;
      text-align: center;
      margin-top: auto;
    }

    .weekly-grid__indicator {
      margin-top: auto;
      font-size: 1rem;
      opacity: 0;
      transition: opacity 160ms ease;
      align-self: center;
    }

    .weekly-grid__indicator--visible {
      opacity: 1;
    }

    .weekly-grid--single-day {
      --weekly-grid-columns: 2;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-rows: minmax(110px, 1fr);
    }

    .weekly-grid--single-day .weekly-grid__cell {
      border-right: none;
    }

    .weekly-grid--single-day .weekly-grid__cell:first-child {
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    }

    .weekly-grid.weekly-grid--single-day .weekly-grid__cell {
      min-height: 110px;
    }

    @media (max-width: 600px) {
      .weekly-grid__cell {
        min-height: 92px;
        padding: 0.75rem 0.6rem 1.95rem;
      }

      .weekly-grid__clinic-select {
        font-size: 0.85rem;
        min-width: 0;
      }

      .weekly-grid__time {
        font-size: 0.7rem;
      }

      .weekly-grid__manage {
        width: 2rem;
        height: 2rem;
        right: 0.55rem;
        bottom: 0.55rem;
        font-size: 1rem;
      }
    }

    .week-overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 1.5rem;
      background: rgba(4, 7, 12, 0.72);
      backdrop-filter: blur(18px);
      z-index: 2100;
    }

    .week-overlay[hidden] {
      display: none;
    }

    .week-overlay__dialog {
      position: relative;
      width: min(900px, 94vw);
      border-radius: 22px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(9, 14, 22, 0.94);
      box-shadow: 0 30px 70px rgba(2, 8, 23, 0.65);
      padding: 1.5rem;
      display: grid;
      gap: 1.2rem;
    }

    .week-overlay__close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.82);
      color: var(--text-secondary);
      border-radius: 999px;
      width: 2.2rem;
      height: 2.2rem;
      display: grid;
      place-items: center;
      font-size: 1.1rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .week-overlay__close:hover,
    .week-overlay__close:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(21, 32, 44, 0.92);
      outline: none;
    }

    .week-overlay__title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      color: #e2e8f0;
      text-align: center;
    }

    .week-overlay__grid-wrapper {
      width: 100%;
    }

    .week-overlay__grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      grid-auto-rows: minmax(120px, 1fr);
      gap: 0.75rem;
    }

    .week-overlay__cell {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 1rem;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(15, 21, 30, 0.92);
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, transform 160ms ease;
    }

    .week-overlay__cell:hover,
    .week-overlay__cell:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(23, 33, 46, 0.95);
      outline: none;
    }

    .week-overlay__day {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(203, 213, 225, 0.82);
    }

    .week-overlay__slot {
      font-size: 0.85rem;
      font-weight: 600;
      color: rgba(226, 232, 240, 0.96);
    }

    .week-overlay__time {
      font-size: 0.75rem;
      color: rgba(148, 163, 184, 0.8);
    }

    .week-overlay__cell[aria-current="true"] {
      border-color: rgba(45, 212, 195, 0.6);
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35);
    }

    .day-overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 1.5rem;
      background: rgba(4, 7, 12, 0.72);
      backdrop-filter: blur(18px);
      z-index: 2000;
    }

    .day-overlay[hidden] {
      display: none;
    }

    .day-overlay__dialog {
      position: relative;
      width: min(520px, 92vw);
      border-radius: 22px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(9, 14, 22, 0.94);
      box-shadow: 0 30px 70px rgba(2, 8, 23, 0.65);
      padding: 1.35rem 1.5rem 1.6rem;
      display: grid;
      gap: 1.1rem;
    }

    .day-overlay__close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.82);
      color: var(--text-secondary);
      border-radius: 999px;
      width: 2.2rem;
      height: 2.2rem;
      display: grid;
      place-items: center;
      font-size: 1.1rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .day-overlay__close:hover,
    .day-overlay__close:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(21, 32, 44, 0.92);
      outline: none;
    }

    .day-overlay__header {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      padding-right: 2.75rem;
    }

    .day-overlay__title {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: -0.01em;
    }

    .day-overlay__subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .day-overlay__slots {
      display: grid;
      gap: 0.65rem;
    }

    .day-overlay__slot {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.9rem;
      padding: 0.75rem 0.85rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(13, 20, 33, 0.82);
    }

    .day-overlay__slot-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      flex: 1;
    }

    .day-overlay__slot-time {
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .day-overlay__slot-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .day-overlay__slot-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .day-overlay__custom-time,
    .day-overlay__custom-label {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      border-radius: 10px;
      padding: 0.4rem 0.5rem;
      font-size: 0.85rem;
    }

    .day-overlay__custom-time {
      width: 5.25rem;
    }

    .day-overlay__custom-label {
      width: clamp(8rem, 20vw, 12rem);
    }

    .day-overlay__custom-label::placeholder {
      color: rgba(226, 232, 240, 0.55);
    }

    .day-overlay__remove-patient {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.75);
      color: rgba(226, 232, 240, 0.9);
      border-radius: 50%;
      width: 2rem;
      height: 2rem;
      display: grid;
      place-items: center;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 160ms ease, border-color 160ms ease, transform 120ms ease;
    }

    .day-overlay__remove-patient:hover,
    .day-overlay__remove-patient:focus-visible {
      border-color: rgba(248, 113, 113, 0.6);
      color: #fee2e2;
      background: rgba(127, 29, 29, 0.65);
    }

    .resident-toggle {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.85);
      color: rgba(226, 232, 240, 0.9);
      width: 2.35rem;
      height: 2.35rem;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-size: 1.1rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 120ms ease, color 160ms ease, opacity 120ms ease;
      opacity: 0.55;
    }

    .resident-toggle:hover {
      transform: translateY(-1px);
      border-color: rgba(45, 212, 195, 0.6);
    }

    .resident-toggle[aria-pressed="true"] {
      background: rgba(125, 216, 143, 0.35);
      border-color: rgba(125, 216, 143, 0.7);
      color: #052e16;
      opacity: 1;
    }

    .day-overlay__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .day-overlay__add-patient {
      padding: 0.65rem 1rem;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: rgba(226, 232, 240, 0.92);
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, transform 160ms ease;
    }

    .day-overlay__add-patient:hover,
    .day-overlay__add-patient:focus-visible {
      border-color: rgba(45, 212, 195, 0.6);
      background: rgba(23, 34, 48, 0.9);
      outline: none;
      transform: translateY(-1px);
    }

    .day-overlay__add-patient:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .day-overlay__confirm {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.95rem;
      background: var(--tasker-brand-gradient);
      border: none;
      color: #041b1b;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    .day-overlay__confirm:hover,
    .day-overlay__confirm:focus-visible {
      outline: none;
      transform: translateY(-1px);
      box-shadow: 0 16px 40px rgba(45, 212, 195, 0.35);
    }

    @media (max-width: 1200px) {
      .weekly-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 860px) {
      .weekly-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 560px) {
      .schedule-card {
        --schedule-card-inline: var(--page-gutter);
        padding: 1.15rem var(--schedule-card-inline);
        margin-inline: calc(-1 * var(--page-gutter));
        width: calc(100% + (var(--page-gutter) * 2));
        max-width: none;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
/* For desktop / default */
.schedule-card__grid-wrapper {
  width: 100%;
  box-sizing: border-box;
  padding-inline: 1rem;      /* adds side padding */
  max-width: 960px;          /* optional: limit on huge screens */
  margin: 0 auto;            /* center within section */
}

/* For mobile screens */
@media (max-width: 560px) {
  .schedule-card__grid-wrapper {
    padding-inline: 0.75rem; /* slightly narrower gutters */
  }
}
      }

      .weekly-grid {
        grid-template-columns: minmax(0, 1fr);
        border-radius: 0;
      }

      .weekly-grid__cell {
        min-height: 110px;
      }
    }

    .card.collapsed .card-body,
    .card.collapsed .card-sticky-actions,
    .card.collapsed .next-best-results,
    .card.collapsed .due-today-list,
    .module-card.collapsed .module-body {
      display: none !important;
    }

    .card.collapsed .card-head,
    .module-card.collapsed .module-header {
      border-bottom: none;
    }

    .starter-stack {
      display: grid;
      gap: 0.85rem;
      width: min(100%, 720px);
      position: relative;
      z-index: 10;
    }

    .routine-grid-shell {
      width: min(92vw, 720px);
      margin: 1.5rem auto 0;
      padding: clamp(0.9rem, 3vw, 1.4rem);
      border-radius: 26px;
      background: rgba(12, 20, 32, 0.45);
      border: 1px solid rgba(148, 163, 184, 0.14);
      box-shadow: 0 16px 40px rgba(2, 8, 18, 0.3);
    }

    .routine-stack {
      display: grid;
      gap: 1.1rem;
      width: 100%;
      margin: 0;
      position: relative;
      z-index: 12;
      grid-template-columns: 1fr;
    }

    .routine-feature-grid {
      display: grid;
      gap: 1.1rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .routine-feature-grid .routine-tile {
      height: 100%;
    }

    .routine-feature-grid .routine-tile__surface {
      height: 100%;
    }

    .routine-preferences {
      display: flex;
      justify-content: flex-end;
      padding: 0.25rem 0.5rem 0;
      grid-column: 1 / -1;
    }

    .routine-preferences__toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      background: rgba(12, 20, 30, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
    }

    .routine-preferences__toggle:hover {
      background: rgba(15, 24, 36, 0.75);
      color: var(--text-primary);
    }

    .routine-preferences__toggle input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #38bdf8;
    }

    .routine-preferences__label {
      font-weight: 500;
    }

    .routine-tile {
      position: relative;
      border-radius: 22px;
      overflow: visible;
      isolation: isolate;
    }

    .routine-tile__surface {
      position: relative;
      border-radius: inherit;
      padding: 1.1rem 1.2rem 1.1rem;
      color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 24px 36px rgba(5, 12, 21, 0.45);
      transition: transform 180ms ease, box-shadow 220ms ease;
      overflow: hidden;
      background: linear-gradient(135deg, #1f2937, #111827);
      --routine-context-glow-alpha: 0.18;
    }

    .routine-tile__surface::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: rgba(255, 255, 255, 0.05);
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
    }

    .routine-tile:hover .routine-tile__surface::before {
      opacity: 0.15;
    }

    .routine-tile__surface:focus-within {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.22), 0 26px 40px rgba(6, 10, 20, 0.6);
    }

    .routine-tile__trigger {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      padding: 0;
      text-align: left;
      cursor: pointer;
    }

    .routine-tile__info {
      display: grid;
      gap: 0.35rem;
      flex: 1;
    }

    .routine-tile__title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .routine-tile__prompt {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.85);
    }

    .routine-tile__meta {
      display: grid;
      gap: 0.35rem;
      align-items: center;
      justify-items: end;
      min-width: 2.5rem;
    }

    .routine-info-dot {
      width: 1.6rem;
      height: 1.6rem;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.22);
      color: rgba(255, 255, 255, 0.92);
      font-weight: 600;
      font-size: 0.8rem;
    }

    .routine-tile__chevron {
      display: inline-block;
      width: 0.85rem;
      height: 0.85rem;
      border-right: 2px solid rgba(255, 255, 255, 0.75);
      border-bottom: 2px solid rgba(255, 255, 255, 0.75);
      transform: rotate(-45deg);
      transition: transform 200ms ease;
    }

    .routine-tile--open .routine-tile__chevron {
      transform: rotate(45deg);
    }

    .routine-accent {
      flex-shrink: 0;
      display: grid;
      place-items: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
    }

    .routine-accent__icon {
      font-size: 1.35rem;
      animation: routine-accent-bounce 2.4s infinite ease-in-out;
    }

    @keyframes routine-accent-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .routine-tile__body {
      margin-top: 1rem;
      border-radius: 18px;
      background: rgba(10, 16, 24, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1rem;
      overflow: hidden;
      max-height: 0;
      transition: max-height 240ms ease, padding 240ms ease;
    }

    .routine-tile--open .routine-tile__body {
      padding: 1rem;
    }

    .routine-tile__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.85rem;
    }

    .routine-start-btn {
      background: rgba(255, 255, 255, 0.92);
      color: #0b1520;
      border: none;
      padding: 0.7rem 1.35rem;
      border-radius: 14px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 180ms ease;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
    }

    .routine-start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.4);
    }

    .routine-quick-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .routine-chip {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.15);
      color: rgba(226, 232, 240, 0.95);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .routine-chip:hover {
      background: rgba(148, 163, 184, 0.25);
      transform: translateY(-1px);
    }

    .routine-tile__content {
      display: grid;
      gap: 1rem;
    }

    .routine-tile__surface.routine-theme--morning {
      background: linear-gradient(135deg, #f97316, #facc15);
    }

    .routine-tile__surface.routine-theme--environment {
      background: linear-gradient(135deg, #4ade80, #14b8a6);
    }

    .routine-tile__surface.routine-theme--sleep {
      background: linear-gradient(135deg, #4338ca, #8b5cf6);
    }

    .routine-tile__surface.routine-theme--conflict {
      background: linear-gradient(135deg, #2563eb, #f87171);
    }

    .routine-tile__surface.routine-theme--dopamine {
      background: linear-gradient(135deg, #0ea5e9, #f43f5e);
    }

    .routine-tile__surface.routine-theme--utility {
      background: linear-gradient(135deg, #475569, #94a3b8);
    }

    .routine-tile--context .routine-tile__surface {
      animation: routine-context-glow 3.2s ease-in-out infinite;
    }

    @keyframes routine-context-glow {
      0%,
      100% {
        box-shadow:
          0 26px 36px rgba(7, 13, 24, 0.55),
          0 0 0 0 rgba(255, 255, 255, var(--routine-context-glow-alpha, 0.18));
      }
      50% {
        box-shadow:
          0 28px 40px rgba(7, 13, 24, 0.6),
          0 0 0 14px rgba(255, 255, 255, calc(var(--routine-context-glow-alpha, 0.18) * 0.6));
      }
    }
    .routine-tile__surface.is-pulsing {
      animation: routine-start-pulse 220ms ease;
    }
    @keyframes routine-start-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.01); }
      100% { transform: scale(1); }
    }

    .routine-reminder {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.82);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .routine-quick-overlay {
      position: absolute;
      inset: 0;
      background: rgba(9, 14, 22, 0.75);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: inherit;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    .routine-quick-overlay.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .routine-quick-overlay__content {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 1.1rem;
      width: min(100%, 320px);
      display: grid;
      gap: 0.75rem;
      text-align: left;
      color: #e2e8f0;
      box-shadow: 0 24px 36px rgba(2, 6, 14, 0.55);
    }

    .routine-quick-overlay__title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .routine-quick-overlay__list {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.35rem;
      font-size: 0.9rem;
    }

    .routine-quick-overlay__action {
      background: #38bdf8;
      border: none;
      border-radius: 12px;
      padding: 0.6rem 1rem;
      font-weight: 600;
      color: #03121f;
      cursor: pointer;
    }

    .routine-tile.is-running::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      border: 2px solid rgba(255, 255, 255, 0.65);
      opacity: 0.85;
      animation: routine-running-halo 1.6s linear infinite;
      pointer-events: none;
    }

    @keyframes routine-running-halo {
      0% { transform: scale(0.92); opacity: 0.9; }
      60% { opacity: 0.4; }
      100% { transform: scale(1.05); opacity: 0; }
    }

    .routine-tile--celebrate::after {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      background-image: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.45), transparent 60%), radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.35), transparent 55%), radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.4), transparent 65%);
      opacity: 0;
      animation: routine-celebrate 900ms ease-out forwards;
      pointer-events: none;
    }

    @keyframes routine-celebrate {
      0% { opacity: 0; transform: scale(0.9); }
      20% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.05); }
    }

    .routine-tile__surface.swiping {
      transition: none;
    }

    .routine-sheet {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
    }

    .routine-sheet.is-visible {
      display: grid;
    }

    .routine-sheet__scrim {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 20, 0.65);
      backdrop-filter: blur(4px);
    }

    .routine-sheet__panel {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 24px 24px 0 0;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 1.4rem 1.2rem 1.75rem;
      box-shadow: 0 -22px 45px rgba(2, 6, 14, 0.65);
      transform: translateY(100%);
      transition: transform 240ms ease;
      max-height: 88vh;
      overflow-y: auto;
      display: grid;
      gap: 1rem;
      color: #e2e8f0;
    }

    .routine-sheet.is-visible .routine-sheet__panel {
      transform: translateY(0);
    }

    .routine-sheet__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .routine-sheet__field {
      display: grid;
      gap: 0.35rem;
    }

    .routine-sheet__field input,
    .routine-sheet__field textarea,
    .routine-sheet__field select {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: #e2e8f0;
      padding: 0.55rem 0.65rem;
      font-family: inherit;
    }

    .routine-sheet__actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .routine-sheet__actions button {
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .routine-sheet__save {
      background: #38bdf8;
      border: none;
      color: #04111d;
    }

    .routine-sheet__cancel {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #cbd5f5;
    }

    @media (prefers-reduced-motion: reduce) {
      .routine-tile__surface,
      .routine-tile__body,
      .routine-tile__chevron,
      .routine-accent__icon,
      .routine-tile__surface::before,
      .routine-quick-overlay,
      .routine-sheet__panel {
        transition-duration: 0ms !important;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }
      .routine-tile--context .routine-tile__surface {
        animation: none;
      }
    }

    .routine-stack {
      display: grid;
      gap: 1.1rem;
      width: min(100%, 780px);
      margin-top: 1.25rem;
      position: relative;
      z-index: 12;
    }

    .routine-preferences {
      display: flex;
      justify-content: flex-end;
      padding: 0.25rem 0.5rem 0;
    }

    .routine-preferences__toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      background: rgba(12, 20, 30, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
    }

    .routine-preferences__toggle:hover {
      background: rgba(15, 24, 36, 0.75);
      color: var(--text-primary);
    }

    .routine-preferences__toggle input[type="checkbox"] {
      width: 1.1rem;
      height: 1.1rem;
      accent-color: #38bdf8;
    }

    .routine-preferences__label {
      font-weight: 500;
    }

    .routine-tile {
      position: relative;
      border-radius: 22px;
      overflow: visible;
      isolation: isolate;
    }

    .routine-tile__surface {
      position: relative;
      border-radius: inherit;
      padding: 1.1rem 1.2rem 1.1rem;
      color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 24px 36px rgba(5, 12, 21, 0.45);
      transition: transform 180ms ease, box-shadow 220ms ease;
      overflow: hidden;
      background: linear-gradient(135deg, #1f2937, #111827);
    }

    .routine-tile__surface::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: rgba(255, 255, 255, 0.05);
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
    }

    .routine-tile:hover .routine-tile__surface::before {
      opacity: 0.15;
    }

    .routine-tile__surface:focus-within {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.22), 0 26px 40px rgba(6, 10, 20, 0.6);
    }

    .routine-tile__trigger {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      padding: 0;
      text-align: left;
      cursor: pointer;
    }

    .routine-tile__info {
      display: grid;
      gap: 0.35rem;
      flex: 1;
    }

    .routine-tile__title {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .routine-tile__prompt {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.85);
    }

    .routine-tile__meta {
      display: grid;
      gap: 0.35rem;
      align-items: center;
      justify-items: end;
      min-width: 2.5rem;
    }

    .routine-info-dot {
      width: 1.6rem;
      height: 1.6rem;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.22);
      color: rgba(255, 255, 255, 0.92);
      font-weight: 600;
      font-size: 0.8rem;
    }

    .routine-tile__chevron {
      display: inline-block;
      width: 0.85rem;
      height: 0.85rem;
      border-right: 2px solid rgba(255, 255, 255, 0.75);
      border-bottom: 2px solid rgba(255, 255, 255, 0.75);
      transform: rotate(-45deg);
      transition: transform 200ms ease;
    }

    .routine-tile--open .routine-tile__chevron {
      transform: rotate(45deg);
    }

    .routine-accent {
      flex-shrink: 0;
      display: grid;
      place-items: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
    }

    .routine-accent__icon {
      font-size: 1.35rem;
      animation: routine-accent-bounce 2.4s infinite ease-in-out;
    }

    @keyframes routine-accent-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .routine-tile__body {
      margin-top: 1rem;
      border-radius: 18px;
      background: rgba(10, 16, 24, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1rem;
      overflow: hidden;
      max-height: 0;
      transition: max-height 240ms ease, padding 240ms ease;
    }

    .routine-tile--open .routine-tile__body {
      padding: 1rem;
    }

    .routine-tile__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.85rem;
    }

    .routine-start-btn {
      background: rgba(255, 255, 255, 0.92);
      color: #0b1520;
      border: none;
      padding: 0.7rem 1.35rem;
      border-radius: 14px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 180ms ease;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
    }

    .routine-start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.4);
    }

    .routine-quick-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .routine-chip {
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.15);
      color: rgba(226, 232, 240, 0.95);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .routine-chip:hover {
      background: rgba(148, 163, 184, 0.25);
      transform: translateY(-1px);
    }

    .routine-tile__content {
      display: grid;
      gap: 1rem;
    }

    .routine-tile__surface.routine-theme--morning {
      background: linear-gradient(135deg, #f97316, #facc15);
    }

    .routine-tile__surface.routine-theme--environment {
      background: linear-gradient(135deg, #4ade80, #14b8a6);
    }

    .routine-tile__surface.routine-theme--sleep {
      background: linear-gradient(135deg, #4338ca, #8b5cf6);
    }

    .routine-tile__surface.routine-theme--conflict {
      background: linear-gradient(135deg, #2563eb, #f87171);
    }

    .routine-tile__surface.routine-theme--dopamine {
      background: linear-gradient(135deg, #0ea5e9, #f43f5e);
    }

    .routine-tile__surface.routine-theme--utility {
      background: linear-gradient(135deg, #475569, #94a3b8);
    }

    .routine-tile--context .routine-tile__surface {
      animation: routine-context-glow 3.2s ease-in-out infinite;
    }

    @keyframes routine-context-glow {
      0%,
      100% {
        box-shadow:
          0 26px 36px rgba(7, 13, 24, 0.55),
          0 0 0 0 rgba(255, 255, 255, var(--routine-context-glow-alpha, 0.18));
      }
      50% {
        box-shadow:
          0 28px 40px rgba(7, 13, 24, 0.6),
          0 0 0 14px rgba(255, 255, 255, calc(var(--routine-context-glow-alpha, 0.18) * 0.6));
      }
    }
    .routine-tile__surface.is-pulsing {
      animation: routine-start-pulse 220ms ease;
    }
    @keyframes routine-start-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.01); }
      100% { transform: scale(1); }
    }

    .routine-reminder {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.82);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .routine-quick-overlay {
      position: absolute;
      inset: 0;
      background: rgba(9, 14, 22, 0.75);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: inherit;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    .routine-quick-overlay.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .routine-quick-overlay__content {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 1.1rem;
      width: min(100%, 320px);
      display: grid;
      gap: 0.75rem;
      text-align: left;
      color: #e2e8f0;
      box-shadow: 0 24px 36px rgba(2, 6, 14, 0.55);
    }

    .routine-quick-overlay__title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .routine-quick-overlay__list {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.35rem;
      font-size: 0.9rem;
    }

    .routine-quick-overlay__action {
      background: #38bdf8;
      border: none;
      border-radius: 12px;
      padding: 0.6rem 1rem;
      font-weight: 600;
      color: #03121f;
      cursor: pointer;
    }

    .routine-tile.is-running::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: inherit;
      border: 2px solid rgba(255, 255, 255, 0.65);
      opacity: 0.85;
      animation: routine-running-halo 1.6s linear infinite;
      pointer-events: none;
    }

    @keyframes routine-running-halo {
      0% { transform: scale(0.92); opacity: 0.9; }
      60% { opacity: 0.4; }
      100% { transform: scale(1.05); opacity: 0; }
    }

    .routine-tile--celebrate::after {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      background-image: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.45), transparent 60%),
        radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.35), transparent 55%),
        radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.4), transparent 65%);
      opacity: 0;
      animation: routine-celebrate 900ms ease-out forwards;
      pointer-events: none;
    }

    @keyframes routine-celebrate {
      0% { opacity: 0; transform: scale(0.9); }
      20% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.05); }
    }

    .routine-tile__surface.swiping {
      transition: none;
    }

    .routine-sheet {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
    }

    .routine-sheet.is-visible {
      display: grid;
    }

    .routine-sheet__scrim {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 20, 0.65);
      backdrop-filter: blur(4px);
    }

    .routine-sheet__panel {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 24px 24px 0 0;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 1.4rem 1.2rem 1.75rem;
      box-shadow: 0 -22px 45px rgba(2, 6, 14, 0.65);
      transform: translateY(100%);
      transition: transform 240ms ease;
      max-height: 88vh;
      overflow-y: auto;
      display: grid;
      gap: 1rem;
      color: #e2e8f0;
    }

    .routine-sheet.is-visible .routine-sheet__panel {
      transform: translateY(0);
    }

    .routine-sheet__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .routine-sheet__field {
      display: grid;
      gap: 0.35rem;
    }

    .routine-sheet__field input,
    .routine-sheet__field textarea,
    .routine-sheet__field select {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      color: #e2e8f0;
      padding: 0.55rem 0.65rem;
      font-family: inherit;
    }

    .routine-sheet__actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    .routine-sheet__actions button {
      border-radius: 12px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .routine-sheet__save {
      background: #38bdf8;
      border: none;
      color: #04111d;
    }

    .routine-sheet__cancel {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: #cbd5f5;
    }

    @media (prefers-reduced-motion: reduce) {
      .routine-tile__surface,
      .routine-tile__body,
      .routine-tile__chevron,
      .routine-accent__icon,
      .routine-tile__surface::before,
      .routine-quick-overlay,
      .routine-sheet__panel {
        transition-duration: 0ms !important;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }
      .routine-tile--context .routine-tile__surface {
        animation: none;
      }
    }

    .starter-micro-header {
      position: sticky;
      top: 0.75rem;
      z-index: 40;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
      padding: 0.4rem 0.6rem;
      border-radius: 999px;
      background: rgba(10, 16, 22, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 18px 34px rgba(2, 8, 18, 0.45);
      backdrop-filter: blur(12px);
    }

    .starter-micro-header .start-action {
      flex-shrink: 0;
    }

    .starter-fit-chips {
      display: flex;
      gap: 0.4rem;
      flex-wrap: nowrap;
      overflow: hidden;
      flex: 1;
      min-height: 1.65rem;
    }

    .starter-fit-chips .chip {
      font-size: 0.78rem;
      white-space: nowrap;
      background: rgba(148, 163, 184, 0.16);
      border: 1px solid rgba(148, 163, 184, 0.22);
    }

    .starter-rescue {
      flex-shrink: 0;
      font-size: 0.85rem;
      padding: 0.35rem 0.85rem;
      background: rgba(239, 68, 68, 0.18);
      border: 1px solid rgba(239, 68, 68, 0.35);
    }

    .stage-strip {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      background: rgba(13, 18, 26, 0.82);
    }

    .stage-strip .preflight-toggles {
      display: inline-flex;
      gap: 0.35rem;
    }

    .starter-micro-header #categoryProgress {
      margin-inline: 0.35rem;
    }

    .next-focus-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .next-focus-head__titles {
      display: grid;
      gap: 0.2rem;
      text-align: center;
      justify-items: center;
    }

    .next-focus-hint {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .next-best-inline {
      display: grid;
      gap: 0.75rem;
    }

    .next-best-toolbar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .peek { background: #222; margin-top: 1rem; padding: 1rem; border-radius: 6px; max-width: 600px; }
    .peek summary { cursor: pointer; }
    .task-list-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      width: 100%;
      min-width: 0;
    }
/* ------------------------------
 * Full-screen All Tasks overlay
 * ------------------------------ */
#focus.focus-overlay,
.focus-overlay {
  position: fixed;
  inset: 8px;                 /* 8px safe area on all sides */
  margin: 0;
  width: auto;
  height: auto;
  max-width: none;            /* remove global caps */
  max-height: none;
  display: flex;
  align-items: stretch;
  z-index: 1000;
  background: transparent;    /* sheet provides the surface */
}

/* Ensure the inner sheet actually fills the container */
.focus-overlay__sheet {
  width: auto
  height: auto
  max-width: none !important;
  max-height: none !important;
  border-radius: 8px;        /* keep rounded floating-sheet style */
  overflow: hidden;
  box-shadow: 0 0 24px rgba(0,0,0,0.5);
}
    .task-list-header > * {
      min-width: 0;
    }

    .task-filter-field {
      position: relative;
      display: block;
      flex: 1 1 clamp(160px, 30%, 220px);
      min-width: 140px;
    }

    .task-filter-field__title {
      position: absolute;
      inset-inline-start: 0.75rem;
      inset-block-start: 0.55rem;
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.02em;
      color: var(--text-secondary);
      pointer-events: none;
      line-height: 1.1;
    }
    .ready-to-launch {
      display: grid;
      gap: 0.75rem;
    }
    .task-section-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 0.5rem 0 0.25rem;
    }
    .task-section-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }
    .time-budget-control {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: #a0a0a0;
    }
    .time-budget-control select {
      background: #1a1a1a;
      color: #eee;
      border: 1px solid #444;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }
    .task-view-select {
      width: 100%;
      background: rgba(15, 21, 30, 0.92);
      color: var(--text-primary);
      border: 1px solid rgba(148, 163, 184, 0.28);
      padding: 1.25rem 0.75rem 0.6rem;
      border-radius: 12px;
      font-size: 0.95rem;
    }

    .task-view-select:focus-visible {
      outline: none;
      border-color: rgba(45, 212, 195, 0.55);
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.25);
    }
    .task-card {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 0.65rem 0.75rem;
      margin-bottom: 0.65rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      touch-action: pan-y;
    }
    .task-card--reveal {
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 220ms ease, transform 220ms ease;
    }
    .task-card--reveal.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .task-card.is-completed {
      background: #161616;
      border: 1px solid #2a2a2a;
    }
    .task-card.is-completed .task-card-actions {
      justify-content: flex-end;
    }
    .task-card.is-completed .task-card-actions button:first-child {
      order: 1;
      margin-left: 0;
    }
    .task-card.is-completed .task-card-actions button:nth-child(2) {
      order: 2;
    }
    .task-card-header {
      display: block;
      margin-bottom: 0.15rem;
    }
    .task-card-title-group {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      flex: 1;
      min-width: 0;
    }
    .task-title {
      font-size: clamp(1rem, 3.6vw, 1.1rem);
      font-weight: 600;
      margin: 0;
      line-height: 1.4;
      color: #fff;
      word-break: break-word;
    }
    .task-complete-indicator {
      color: #8fc97a;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .task-card-actions {
      display: flex;
      gap: 0.3rem;
      flex-wrap: nowrap;
      align-items: center;
    }
    .task-card-actions button {
      font-size: 0.9rem;
      padding: 0.2rem 0.4rem;
      line-height: 1;
      min-width: 0;
      margin: 0;
    }
    .task-card-actions button:first-child {
      order: 3;
    }
    .task-card-actions button:first-child:not(:last-child) {
      margin-left: auto;
    }
    .task-card-actions button:nth-child(2) {
      order: 4;
    }
    .task-card-actions button:nth-child(3) {
      order: 1;
    }
    .task-card-actions button:nth-child(4) {
      order: 2;
    }
    .task-descriptors {
      font-size: 0.8rem;
      color: #b0b0b0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .task-descriptors span::before {
      content: "•";
      margin-right: 0.25rem;
      color: #555;
    }
    .task-descriptors span:first-child::before {
      content: "";
      margin: 0;
    }
    .task-progress {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .task-progress-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .task-progress-meter {
      background: rgba(148, 163, 184, 0.22);
      border-radius: 999px;
      overflow: hidden;
      height: 3px;
      width: 100%;
    }
    .task-progress-meter .fill {
      display: block;
      height: 100%;
      background: rgba(45, 212, 195, 0.85);
      width: 0%;
      transition: width 150ms ease-out;
    }
    .task-meta {
      font-size: 0.75rem;
      color: #8f9aa8;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .task-detail-toggle {
      align-self: flex-start;
      background: #2a2a2a;
      font-size: 0.8rem;
      padding: 0.35rem 0.6rem;
    }
    .task-list-more-btn {
      align-self: flex-start;
      background: rgba(45, 212, 195, 0.12);
      border: 1px solid rgba(45, 212, 195, 0.35);
      color: var(--hero-teal);
      font-weight: 600;
      padding: 0.55rem 1.1rem;
      border-radius: 999px;
      cursor: pointer;
      transition: opacity 220ms ease, transform 220ms ease, background 150ms ease, color 150ms ease, border-color 150ms ease;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
    }
    .task-list-more-btn.is-visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .task-list-more-btn:hover {
      background: rgba(45, 212, 195, 0.2);
      color: #032422;
    }
    .task-list-more-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.45);
    }
    .task-details {
      font-size: 0.8rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.6rem;
      width: 100%;
      box-sizing: border-box;
    }
    .task-details h5 {
      margin: 0 0 0.4rem;
      font-size: 0.85rem;
      color: #eee;
    }
    .task-details ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .task-details li {
      margin: 0.25rem 0;
    }
    .score { font-size: 0.8rem; color: #ccc; }
    #focusFitHint {
      color: #8f9aa8;
      font-size: 0.85rem;
      margin-top: 0.35rem;
      max-width: 100%;
      text-align: left;
    }
    .chart-age, .urgency-hint {
      display: block;
      margin-top: 0.25rem;
      color: #aaa;
      font-size: 0.85rem;
      max-width: 600px;
    }
    .focus {
      font-size: 1.5rem;
      margin: 1rem 0;
      padding: 1.25rem;
      background: rgba(18, 24, 30, 0.88);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(147, 160, 170, 0.18);
    }
    .distraction-tools {
      margin-top: 1rem;
      background: rgba(18, 18, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 0.85rem;
      width: min(100%, 560px);
      display: grid;
      gap: 0.55rem;
    }
    .distraction-tools__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .distraction-tools__header strong {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9aa0a6;
    }
    .distraction-prompt {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.85rem;
      color: #cdd5e0;
    }
    .distraction-prompt span {
      opacity: 0.8;
    }
    .distraction-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .distraction-options button {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    .distraction-log {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.35rem;
      font-size: 0.82rem;
      color: #bfc7d3;
    }
    .distraction-log li {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      background: rgba(12, 18, 24, 0.85);
      border-radius: 8px;
      padding: 0.4rem 0.55rem;
    }
    .distraction-log__time {
      font-weight: 600;
      color: #8ab4ff;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .distraction-log__label {
      flex: 1;
      color: #e4e9f2;
    }
    .distraction-log li.distraction-empty {
      justify-content: center;
      background: rgba(32, 34, 36, 0.65);
      color: #7d8796;
      font-weight: 500;
    }
    .doorway-reset {
      background: rgba(26, 28, 38, 0.85);
      border-radius: 10px;
      border: 1px solid rgba(123, 216, 143, 0.25);
      padding: 0.6rem 0.75rem;
      display: grid;
      gap: 0.4rem;
    }
    .doorway-reset-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      align-items: center;
    }
    .doorway-countdown {
      font-size: 0.85rem;
      color: #7bd88f;
      font-weight: 600;
    }
    .gantt-card {
      background: rgba(15, 18, 26, 0.98);
      border-radius: 14px;
      padding: 1.1rem;
      width: min(92vw, 640px);
      box-shadow: 0 26px 48px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f5f7fb;
    }
    .gantt-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .gantt-intro {
      font-size: 0.85rem;
      color: #9aa0a6;
      margin: 0;
    }
    .gantt-blocks-wrapper {
      position: relative;
      background: rgba(11, 16, 24, 0.9);
      border-radius: 12px;
      padding: 0.85rem;
      overflow: hidden;
    }
    .gantt-blocks {
      display: flex;
      gap: 0.55rem;
      width: 100%;
      min-height: 110px;
      position: relative;
      z-index: 1;
    }
    .gantt-block {
      flex: 1;
      min-width: 100px;
      border-radius: 10px;
      background: linear-gradient(140deg, rgba(10, 132, 255, 0.65), rgba(123, 216, 143, 0.65));
      padding: 0.65rem;
      display: grid;
      gap: 0.35rem;
    }
    .gantt-block strong {
      font-size: 0.95rem;
    }
    .gantt-block small {
      color: rgba(245, 247, 251, 0.8);
      font-size: 0.75rem;
    }
    .gantt-progress {
      position: absolute;
      inset: 0;
      width: 0;
      background: rgba(123, 216, 143, 0.28);
      transition: width 320ms ease;
      z-index: 0;
    }
    .gantt-progress.is-paused {
      background: repeating-linear-gradient(135deg, rgba(123, 216, 143, 0.1), rgba(123, 216, 143, 0.1) 12px, rgba(10, 132, 255, 0.12) 12px, rgba(10, 132, 255, 0.12) 24px);
    }
    .gantt-status {
      font-size: 0.85rem;
      color: #a6b3c5;
      min-height: 1.2em;
    }
    .worst-day-banner {
      background: var(--surface-elevated);
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      padding: 1rem;
      display: grid;
      gap: 0.55rem;
      justify-items: center;
    }
    .worst-day-banner h2 {
      margin: 0;
      font-size: 1.05rem;
      color: #f8f9fb;
    }
    .worst-day-button {
      width: 100%;
      max-width: 520px;
      font-size: 1.05rem;
      font-weight: 600;
      padding: 0.85rem 1.1rem;
      border-radius: 12px;
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      box-shadow: none;
    }
    .worst-day-button.hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }
    .worst-day-button:disabled {
      box-shadow: none;
    }
    .worst-day-hint {
      margin: 0;
      font-size: 0.85rem;
      color: #c4c9d4;
      text-align: center;
    }
    .worst-day-card {
      background: var(--surface-elevated);
      border-radius: var(--card-radius);
      padding: 1.25rem;
      width: min(92vw, 520px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f8f9fb;
      position: relative;
    }
    .worst-day-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .worst-day-subheading {
      margin: 0;
      font-size: 0.9rem;
      color: #aeb7c8;
    }
    .worst-day-focus-line {
      display: flex;
      gap: 0.5rem;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .worst-day-label {
      font-size: 0.8rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #8fa5ff;
    }
    .worst-day-timer {
      font-size: 2.5rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-align: center;
      color: #7bd88f;
    }
    .worst-day-prompt {
      margin: 0;
      font-size: 0.9rem;
      color: #c4cad8;
      text-align: center;
    }
    .worst-day-actions {
      display: grid;
      gap: 0.65rem;
      text-align: center;
    }
    .worst-day-celebrations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      justify-content: center;
    }
    .worst-day-celebrations button {
      font-size: 0.9rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
    }
    .worst-day-celebration {
      min-height: 1.2rem;
      font-size: 0.9rem;
      color: #f4d47c;
    }
    @media (max-width: 600px) {
      .distraction-tools {
        padding: 0.75rem;
      }
      .gantt-block {
        min-width: 80px;
      }
      .worst-day-button {
        font-size: 1rem;
      }
    }

    @media (max-width: 520px) {
      .starter-micro-header {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      .starter-micro-header .start-action,
      .starter-micro-header .starter-rescue {
        width: 100%;
        margin: 0;
      }

      .starter-fit-chips {
        justify-content: center;
        flex-wrap: wrap;
        overflow: visible;
      }
    }

    @media (max-width: 540px) {
      #focus.focus-overlay {
        padding: clamp(0.6rem, 4vw, 1rem);
        align-items: stretch;
      }

      .focus-overlay__sheet {
        width: 100%;
        border-radius: 22px 22px 14px 14px;
        height: clamp(320px, calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - clamp(0.75rem, 5vw, 1.5rem)), 720px);
        max-height: clamp(320px, calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - clamp(0.75rem, 5vw, 1.5rem)), 720px);
      }

      .focus-overlay__body {
        padding-right: 0;
        gap: var(--space-2);
      }

      .focus {
        font-size: 1.35rem;
        padding: 1rem;
      }

      .focus-overlay__summary {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }

      .focus-overlay__summary .task-counter {
        text-align: left;
      }

      .subtask-row:not(.focus-overlay__task) {
        display: grid;
        grid-template-columns: auto 1fr;
        column-gap: 0.4rem;
        row-gap: 0.35rem;
        align-items: center;
      }

      .subtask-row:not(.focus-overlay__task) > input[type="checkbox"] {
        grid-column: 1;
        grid-row: 1;
      }

      .subtask-row:not(.focus-overlay__task) .subtask-name {
        grid-column: 2;
        grid-row: 1;
        margin-left: 0.15rem;
      }

      .subtask-row:not(.focus-overlay__task) .timer-label {
        grid-column: 2;
        grid-row: 2;
        margin-left: 0;
        justify-self: end;
        min-width: 0;
        font-size: 0.72rem;
      }

      .focus-overlay__task {
        gap: 0.35rem;
      }

      .focus-overlay__task .task-actions {
        gap: 0.35rem;
      }

      .distraction-tools {
        width: 100%;
      }
    }
    .distraction-tools {
      margin-top: 1rem;
      background: rgba(18, 18, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 0.85rem;
      width: min(100%, 560px);
      display: grid;
      gap: 0.55rem;
    }
    .distraction-tools__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .distraction-tools__header strong {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9aa0a6;
    }
    .distraction-prompt {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.85rem;
      color: #cdd5e0;
    }
    .distraction-prompt span {
      opacity: 0.8;
    }
    .distraction-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .distraction-options button {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    .distraction-log {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.35rem;
      font-size: 0.82rem;
      color: #bfc7d3;
    }
    .distraction-log li {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      background: rgba(12, 18, 24, 0.85);
      border-radius: 8px;
      padding: 0.4rem 0.55rem;
    }
    .distraction-log__time {
      font-weight: 600;
      color: #8ab4ff;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .distraction-log li.distraction-empty {
      justify-content: center;
      background: rgba(32, 34, 36, 0.65);
      color: #7d8796;
      font-weight: 500;
    }
    .doorway-reset {
      background: rgba(26, 28, 38, 0.85);
      border-radius: 10px;
      border: 1px solid rgba(123, 216, 143, 0.25);
      padding: 0.6rem 0.75rem;
      display: grid;
      gap: 0.4rem;
    }
    .doorway-reset-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      align-items: center;
    }
    .doorway-countdown {
      font-size: 0.85rem;
      color: #7bd88f;
      font-weight: 600;
    }
    .gantt-card {
      background: rgba(15, 18, 26, 0.98);
      border-radius: 14px;
      padding: 1.1rem;
      width: min(92vw, 640px);
      box-shadow: 0 26px 48px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f5f7fb;
    }
    .gantt-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .gantt-intro {
      font-size: 0.85rem;
      color: #9aa0a6;
      margin: 0;
    }
    .gantt-blocks-wrapper {
      position: relative;
      background: rgba(11, 16, 24, 0.9);
      border-radius: 12px;
      padding: 0.85rem;
      overflow: hidden;
    }
    .gantt-blocks {
      display: flex;
      gap: 0.55rem;
      width: 100%;
      min-height: 110px;
      position: relative;
      z-index: 1;
    }
    .gantt-block {
      flex: 1;
      min-width: 100px;
      border-radius: 10px;
      background: linear-gradient(140deg, rgba(10, 132, 255, 0.65), rgba(123, 216, 143, 0.65));
      padding: 0.65rem;
      display: grid;
      gap: 0.35rem;
    }
    .gantt-block strong {
      font-size: 0.95rem;
    }
    .gantt-block small {
      color: rgba(245, 247, 251, 0.8);
      font-size: 0.75rem;
    }
    .gantt-progress {
      position: absolute;
      inset: 0;
      width: 0;
      background: rgba(123, 216, 143, 0.28);
      transition: width 320ms ease;
      z-index: 0;
    }
    .gantt-progress.is-paused {
      background: repeating-linear-gradient(135deg, rgba(123, 216, 143, 0.1), rgba(123, 216, 143, 0.1) 12px, rgba(10, 132, 255, 0.12) 12px, rgba(10, 132, 255, 0.12) 24px);
    }
    .gantt-status {
      font-size: 0.85rem;
      color: #a6b3c5;
      min-height: 1.2em;
    }
    .worst-day-banner {
      background: linear-gradient(120deg, rgba(44, 44, 52, 0.85), rgba(26, 28, 38, 0.85));
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 1rem;
      display: grid;
      gap: 0.55rem;
      justify-items: center;
    }
    .worst-day-banner h2 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.02em;
      color: #f8f9fb;
    }
    .worst-day-button {
      width: 100%;
      max-width: 520px;
      font-size: 1.05rem;
      font-weight: 600;
      padding: 0.85rem 1.1rem;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255, 102, 126, 0.95), rgba(255, 159, 108, 0.9));
      color: #121212;
      border: none;
      cursor: pointer;
      box-shadow: 0 18px 32px rgba(255, 102, 126, 0.25);
    }
    .worst-day-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .worst-day-hint {
      margin: 0;
      font-size: 0.85rem;
      color: #c4c9d4;
      text-align: center;
    }
    .worst-day-card {
      background: rgba(18, 20, 28, 0.97);
      border-radius: 16px;
      padding: 1.25rem;
      width: min(92vw, 520px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.45);
      display: grid;
      gap: 0.75rem;
      color: #f8f9fb;
      position: relative;
    }
    .worst-day-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .worst-day-subheading {
      margin: 0;
      font-size: 0.9rem;
      color: #aeb7c8;
    }
    .worst-day-focus-line {
      display: flex;
      gap: 0.5rem;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .worst-day-label {
      font-size: 0.8rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #8fa5ff;
    }
    .worst-day-timer {
      font-size: 2.5rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-align: center;
      color: #7bd88f;
    }
    .worst-day-prompt {
      margin: 0;
      font-size: 0.9rem;
      color: #c4cad8;
      text-align: center;
    }
    .worst-day-actions {
      display: grid;
      gap: 0.65rem;
      text-align: center;
    }
    .worst-day-celebrations {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      justify-content: center;
    }
    .worst-day-celebrations button {
      font-size: 0.9rem;
      padding: 0.5rem 0.9rem;
      border-radius: 999px;
    }
    .worst-day-celebration {
      min-height: 1.2rem;
      font-size: 0.9rem;
      color: #f4d47c;
    }
    @media (max-width: 600px) {
      .distraction-tools {
        padding: 0.75rem;
      }
      .gantt-block {
        min-width: 80px;
      }
      .worst-day-button {
        font-size: 1rem;
      }
    }
    .category-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .category-filter button {
      background: #444;
      color: #fff;
      border: none;
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .category-filter button.active {
      background: #666;
    }
    .category-progress {
      position: relative;
      display: grid;
      gap: 0.45rem;
      padding: 0.5rem 0.7rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.22);
      background: rgba(8, 16, 24, 0.9);
      box-shadow: 0 14px 28px rgba(2, 8, 18, 0.32);
      flex: 1 0 100%;
      min-height: 48px;
    }
    .category-progress__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .category-progress__title {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(236, 254, 255, 0.92);
    }
    .category-progress__label {
      font-size: 0.82rem;
      color: var(--text-secondary);
      white-space: nowrap;
    }
    .category-progress__meter {
      position: relative;
      width: 100%;
      height: 16px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      overflow: hidden;
    }
    .category-progress__fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #0f766e, #14b8a6);
      box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      transition: width 150ms ease-out, background 220ms ease, box-shadow 220ms ease;
    }
    .category-progress__fill.is-warm {
      background: linear-gradient(90deg, #14b8a6, #5eead4);
    }
    .category-progress__fill.is-complete {
      background: linear-gradient(90deg, #22d3ee, #a7f3d0);
      box-shadow: 0 0 18px rgba(125, 231, 220, 0.55);
    }
    .category-progress__fill.progress-glow {
      animation: chartGlowPulse 620ms ease-out;
    }
    .category-progress__fill.complete-pulse {
      animation: chartCompletePulse 1.5s ease-out;
    }
    .category-progress__floating {
      position: absolute;
      top: -26px;
      right: 0.35rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      font-size: 0.72rem;
      background: rgba(34, 197, 187, 0.18);
      border: 1px solid rgba(125, 231, 220, 0.35);
      color: rgba(203, 255, 250, 0.95);
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 160ms ease, transform 160ms ease;
      pointer-events: none;
    }
    .category-progress__floating.is-visible {
      opacity: 1;
      transform: translateY(-12px);
    }
    @media (max-width: 400px) {
      .category-progress {
        min-height: 60px;
      }
      .category-progress__header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.4rem;
      }
      .category-progress__label {
        white-space: normal;
      }
    }
    @keyframes chartGlowPulse {
      0% {
        box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      }
      45% {
        box-shadow: 0 0 18px rgba(45, 212, 195, 0.48);
      }
      100% {
        box-shadow: 0 0 0 rgba(45, 212, 195, 0);
      }
    }
    @keyframes chartCompletePulse {
      0% {
        box-shadow: 0 0 0 rgba(125, 231, 220, 0.35);
      }
      40% {
        box-shadow: 0 0 22px rgba(125, 231, 220, 0.85);
      }
      100% {
        box-shadow: 0 0 18px rgba(125, 231, 220, 0.55);
      }
    }
    .subtask-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0.4rem 0;
      padding: 0.5rem;
      background: #1a1a1a;
      border-radius: 6px;
    }
    .subtask-row.completed {
      opacity: 0.7;
    }
    .subtask-name {
      flex: 1;
      margin-left: 0.35rem;
    }
    .subtask-actions {
      display: flex;
      gap: 0.25rem;
    }
    .subtask-actions button {
      font-size: 0.75rem;
      padding: 0.3rem 0.5rem;
    }
    .timer-label {
      font-size: 0.75rem;
      color: #9aa0a6;
      min-width: 96px;
      text-align: right;
      margin-left: auto;
    }
    .chart-summary {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #181818;
      border-radius: 6px;
      width: 100%;
      max-width: 600px;
    }
    .chart-summary h4 {
      margin: 0 0 0.5rem;
    }
    .chart-summary ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .chart-summary li {
      margin: 0.25rem 0;
      padding: 0.35rem;
      background: #202020;
      border-radius: 4px;
    }
    .chart-summary li.longest-step {
      border: 1px solid #0a84ff;
      background: #0a1a33;
    }
    .chart-fields {
      width: 100%;
      overflow: hidden;
      max-height: 1000px;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 250ms ease, max-height 250ms ease;
    }
    .chart-fields.is-hidden {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .chart-total {
      margin-top: 0.5rem;
      font-weight: 600;
    }
    .chart-step-controls {
      margin-top: 0.75rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chart-step-controls button {
      font-size: 0.85rem;
    }
    #focusTimer {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #d0dcff;
    }
    #focusTimer.pulse {
      animation: focus-pulse 1s ease-out;
    }
    @keyframes focus-pulse {
      0% { color: #d0dcff; }
      50% { color: #0a84ff; }
      100% { color: #d0dcff; }
    }
    .sound-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #ccc;
    }
    .sound-toggle input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: #0a84ff;
    }
    .audit-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 999;
    }
    .audit-modal {
      background: #151515;
      border-radius: 10px;
      max-width: 520px;
      width: 100%;
      padding: 1.25rem;
      color: #f5f5f5;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }
    .audit-modal h3 {
      margin: 0 0 0.75rem;
    }
    .audit-summary {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #d0dcff;
    }
    .audit-task-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }
    .audit-task-list li {
      background: #1f1f1f;
      border-radius: 6px;
      padding: 0.6rem;
      font-size: 0.85rem;
      color: #e0e0e0;
    }
    .audit-task-list li strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .audit-task-subtasks {
      margin: 0.35rem 0 0;
      padding-left: 1rem;
      color: #b0b0b0;
    }
    .audit-modal button {
      margin-top: 1rem;
    }
    [aria-live] { outline: none; }
    .meltdown-shield {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      width: min(340px, 90vw);
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1rem;
      color: #f5f5f5;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      z-index: 1300;
    }
    .meltdown-shield-header {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 0.75rem;
    }
    .meltdown-shield-prompt {
      font-size: 0.95rem;
      background: rgba(32, 32, 32, 0.85);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      line-height: 1.45;
    }
    .meltdown-shield-prompt strong {
      display: block;
      margin-bottom: 0.35rem;
    }
    .meltdown-shield ul {
      margin: 0 0 0.75rem;
      padding-left: 1.1rem;
      font-size: 0.9rem;
      max-height: 160px;
      overflow-y: auto;
    }
    .meltdown-shield li {
      margin: 0.4rem 0;
      line-height: 1.4;
    }
    .meltdown-shield-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .meltdown-shield button {
      font-size: 0.85rem;
    }
  /* Edit: styles – calming overlay for #meltdownShield */
.meltdown-shield {
position: fixed; inset: 0;
background: rgba(2, 6, 23, 0.55); /* opaque enough to read */
backdrop-filter: blur(2px);
display: grid; place-items: center;
z-index: 1000;
}
.meltdown-shield.hidden { display: none; }
.meltdown-shield .meltdown-shield-prompt,
.meltdown-shield .meltdown-shield-header,
.meltdown-shield ul, .meltdown-shield .meltdown-shield-actions {
background: #fff; color: #0f172a;
border-radius: 14px; padding: 1rem; max-width: 560px;
box-shadow: 0 18px 40px rgb a(15,23,42,0.25);          
}

    .meltdown-top-task {
      color: #7bd88f;
      font-weight: 600;
    }
    .module-card {
      width: 100%;
      max-width: 720px;
      background: #181818;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin: 1rem 0;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
    }
    .module-card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.35rem;
    }
    .module-card p {
      margin: 0.25rem 0 0.75rem;
      color: #c9d1d9;
      line-height: 1.45;
    }
    .module-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .module-toggle label {
      margin: 0;
      font-weight: 600;
    }
    .module-toggle input[type="checkbox"],
    .module-toggle input[type="time"] {
      accent-color: #0a84ff;
      background: #111;
      color: #fff;
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      border-radius: 6px;
    }
    .morning-blocks {
      display: grid;
      gap: 0.75rem;
      margin: 0.75rem 0;
    }
    .routine-block {
      background: rgba(12, 12, 12, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.85rem;
      display: grid;
      gap: 0.5rem;
    }
    .routine-block.completed {
      border-color: rgba(123, 216, 143, 0.6);
      background: rgba(18, 40, 20, 0.85);
    }
    .routine-block h3 {
      margin: 0;
      font-size: 1.05rem;
    }
    .routine-block small {
      color: #a0aec0;
      display: block;
    }
    .countdown-display {
      font-size: 1.25rem;
      font-weight: 600;
      color: #7bd88f;
    }
    .intention-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }
    .intention-buttons button {
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(34, 34, 34, 0.85);
    }
    .progress-strip {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      position: relative;
      margin: 0.5rem 0;
    }
    .progress-strip span {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #0a84ff, #7bd88f);
      transition: width 200ms ease-out;
    }
    .module-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .history-list {
      margin: 0.5rem 0 0;
      padding: 0;
      list-style: none;
      font-size: 0.85rem;
      color: #aab8c8;
    }
    .history-list li {
      padding: 0.3rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    .history-list li:last-child {
      border-bottom: none;
    }
    .toast-container {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      display: grid;
      gap: 0.75rem;
      z-index: 1500;
    }
    .toast {
      background: rgba(30, 30, 30, 0.95);
      border-left: 4px solid #0a84ff;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      color: #f5f5f5;
      min-width: 220px;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.35);
    }

    .toast {
      border-radius: 10px;
      background: #2dd4c3;
      color: #022624;
    }
        .toast strong {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.95rem;
    }
    .toast__action {
      margin-top: 0.6rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.45);
      color: #f8fafc;
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      cursor: pointer;
    }
    .toast__action:hover {
      background: rgba(148, 163, 184, 0.2);
    }
    .toast--bottom {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1600;
    }
    .toast--inline {
      border-left-color: #38bdf8;
    }
    .wizard-overlay,
    .modal-overlay {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 1400;
    }
    .wizard-content,
    .modal-card {
      background: #121212;
      border-radius: 12px;
      padding: 1.25rem;
      max-width: 520px;
      width: 100%;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      color: #f1f5f9;
    }

    .modal-card {
      display: flex;
      flex-direction: column;
      max-height: 80vh;
      overflow: hidden;
    }

    .modal-card--wide {
      max-width: 720px;
      max-height: 90vh;
    }
    .wizard-content h3,
    .modal-card h3 {
      margin: 0 0 0.75rem;
    }

    .modal-scroll-content {
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      flex: 1 1 auto;
      min-height: 0;
    }

    .modal-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      margin-bottom: var(--space-1);
    }

    .modal-card__header h3 {
      margin: 0;
    }

    .modal-scroll-content--task-builder {
      gap: var(--space-2);
    }

    .modal-scroll-content > .modal__close {
      align-self: flex-end;
    }

    .modal-card .card-body {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      scroll-behavior: smooth;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .modal-card .card-body::-webkit-scrollbar {
      display: none;
    }

    .templates-card {
      max-width: min(520px, 92vw);
      background: rgba(14, 20, 28, 0.94);
      border: 1px solid rgba(147, 160, 170, 0.24);
      border-radius: 18px;
      display: grid;
      gap: 0.75rem;
    }

    .templates-overlay__body {
      display: grid;
      gap: 0.75rem;
    }

    .templates-overlay__body .template-module__actions {
      display: flex;
      justify-content: flex-end;
    }

    .templates-overlay__body #templateButtons {
      display: grid;
      gap: 0.5rem;
    }

    .template-entry {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 0.75rem;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .template-entry button:first-child {
      flex: 1;
      justify-content: flex-start;
    }

    .conflict-card {
      max-width: min(640px, 94vw);
      background: rgba(10, 16, 24, 0.96);
      border: 1px solid rgba(147, 160, 170, 0.26);
      border-radius: 20px;
      display: grid;
      gap: 1rem;
      padding: clamp(1rem, 3vw, 1.5rem);
    }

    .conflict-overlay__body {
      display: grid;
      gap: 1rem;
    }

    .conflict-overlay__body .conflict-actions {
      justify-content: flex-end;
    }
    .wizard-steps {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .wizard-steps label {
      font-size: 0.85rem;
    }
    .wizard-actions,
    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    .launch-pad-settings {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-settings select,
    .launch-pad-settings input[type="text"] {
      background: #222;
      color: #eee;
      border: 1px solid #444;
      padding: 0.45rem;
      border-radius: 6px;
    }
    .launch-pad-list {
      display: grid;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }
    .launch-pad-item {
      display: grid;
      grid-template-columns: 1fr minmax(110px, 150px) auto;
      align-items: center;
      gap: 0.5rem;
      background: rgba(20, 20, 20, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    .launch-pad-item small {
      color: #9aa0a6;
      font-size: 0.75rem;
    }
    .sleep-checklist {
      display: grid;
      gap: 0.5rem;
      margin: 0.75rem 0;
    }
    .sleep-checklist label {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      background: rgba(15, 15, 15, 0.85);
      padding: 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .sleep-checklist input[type="checkbox"] {
      margin-top: 0.1rem;
      accent-color: #7bd88f;
    }
    .sleep-tips {
      display: grid;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: #9aa0a6;
    }
    .sleep-summary {
      font-size: 0.9rem;
      background: rgba(18, 26, 36, 0.85);
      border-radius: 8px;
      padding: 0.6rem;
      margin-top: 0.75rem;
    }
    .sunlight-alert {
      margin-top: 0.75rem;
      padding: 0.65rem;
      border-radius: 8px;
      background: rgba(40, 36, 16, 0.85);
      color: #f8e3a1;
      font-size: 0.85rem;
    }
    .energy-rating {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .energy-rating input[type="range"] {
      flex: 1;
    }
    .celebration {
      background: rgba(14, 48, 22, 0.85);
      border-left: 3px solid #7bd88f;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #d2ffde;
      margin-top: 0.5rem;
    }
    .launch-pad-summary {
      background: rgba(22, 24, 30, 0.9);
      border-radius: 10px;
      padding: 0.75rem;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .launch-pad-summary strong {
      display: block;
      margin-bottom: 0.25rem;
    }
    .routine-affirmation {
      font-size: 0.85rem;
      color: #f0ead6;
      background: rgba(50, 42, 24, 0.6);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      margin-top: 0.5rem;
    }
    .morning-chart-wrapper {
      margin-top: 0.75rem;
      background: #191919;
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 0.75rem;
      border-radius: 10px;
    }
    .chart-canvas {
      width: 100%;
      max-width: 360px;
      height: 160px;
      display: block;
      margin: 0 auto;
    }
    .chart-legend {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: #a5adba;
      margin-top: 0.5rem;
      justify-content: center;
    }
    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 0.35rem;
    }
    .legend-swatch.completion {
      background: #0a84ff;
    }
    .legend-swatch.energy {
      background: #f97316;
    }
    .module-note {
      font-size: 0.78rem;
      color: #9ba6b9;
      margin-top: 0.5rem;
      text-align: center;
    }

    :root {
      --accent: var(--hero-teal);
      --background: #12161a;
      --surface: rgba(18, 24, 30, 0.92);
      --surface-muted: rgba(22, 28, 34, 0.9);
      --border: var(--card-border-color);
      --text-primary: #e6eef7;
      --text-secondary: #93a0aa;
      --text-muted: #6b7280;
      --radius-lg: var(--card-radius);
      --radius-md: 12px;
      --shadow-soft: 0 18px 36px rgba(0, 0, 0, 0.35);
      --space-1: 8px;
      --space-2: 12px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;
      --transition: 200ms ease-in-out;
    }

    body {
      background: var(--background);
      color: var(--text-primary);
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      min-height: 100vh;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: var(--page-padding-top) 0 var(--page-padding-bottom);
      line-height: 1.5;
      font-weight: 400;
      overflow-x: hidden;
    }

    .app-shell {
      width: min(100%, 1100px);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
      padding-inline: var(--page-gutter);
      box-sizing: border-box;
      min-width: 0;
    }

    @media (max-width: 1024px) {
      .app-shell {
        width: min(100%, 960px);
      }
    }

    @media (max-width: 768px) {
      :root {
        --page-gutter: clamp(0.85rem, 4vw, 1.75rem);
        --page-padding-top: clamp(1.25rem, 5vw, 2rem);
      }

      .app-shell {
        width: min(100%, 720px);
      }
    }

    @media (max-width: 600px) {
      :root {
        --page-gutter: clamp(0.75rem, 5vw, 1.25rem);
        --page-padding-top: clamp(1rem, 6vw, 1.5rem);
        --page-padding-bottom: 100px;
      }

      .card {
        padding: var(--space-3);
        gap: var(--space-2);
      }

      .card-sticky-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .card-sticky-actions__primary,
      .card-sticky-actions__secondary {
        justify-content: stretch;
      }

      .card-sticky-actions__primary > *,
      .card-sticky-actions__secondary > * {
        width: 100%;
      }

      .toast-container {
        left: var(--space-2);
        right: var(--space-2);
      }
    }

    @media (max-width: 480px) {
      .task-card-actions {
        width: 100%;
      }

      .task-card-actions button {
        flex: 0 0 auto;
        width: auto;
      }
    }

    .app-header {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: var(--space-2);
    }

    .app-header__title {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .app-header__title h1 {
      margin: 0;
      font-size: clamp(1.4rem, 3vw, 1.65rem);
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .app-header__subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .header-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.85rem;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(76, 0, 12, 0.85), rgba(184, 28, 28, 0.85));
      color: #fdeaea;
      font-size: 0.82rem;
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(255, 107, 107, 0.35);
    }

    .header-chip__label {
      opacity: 0.85;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.72rem;
    }

    .header-chip__value {
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .momentum-zones {
      display: flex;
      flex-direction: column;
      gap: clamp(1.5rem, 4vw, 2.4rem);
      position: relative;
      width: 100%;
      max-width: 100%;
      min-width: 0;
    }

    .momentum-zone {
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      position: relative;
      min-width: 0;
    }

    .momentum-zone[data-zone="action"] {
      order: 0;
    }

    .momentum-zone[data-zone="launch"] {
      order: 1;
    }

    .momentum-zone[data-zone="recovery"] {
      order: 2;
    }

    .zone-header {
      display: none !important;
    }

    .zone-body {
      display: flex;
      flex-direction: column;
      gap: clamp(1.4rem, 4vw, 2.1rem);
      position: relative;
      min-width: 0;
    }

    .zone-anchor {
      position: relative;
      display: block;
      height: 1px;
      width: 100%;
      pointer-events: none;
      scroll-margin-top: clamp(120px, 15vh, 180px);
    }

    .command-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      margin: 0;
      width: 100%;
      max-width: none;
      padding: 0.45rem clamp(0.85rem, 4vw, 1.5rem)
        calc(0.45rem + var(--command-bar-safe-offset));
      background: rgba(8, 12, 18, 0.94);
      border-top: 1px solid rgba(147, 160, 170, 0.2);
      border-radius: 0;
      box-shadow: 0 -10px 28px rgba(0, 0, 0, 0.45);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
      align-items: center;
      gap: 0.2rem;
      min-height: var(--command-bar-height);
      z-index: 90;
      transition: opacity 200ms ease, transform 220ms ease;
    }

    .command-bar.is-hidden {
      opacity: 0;
      transform: translate3d(0, 16px, 0);
      pointer-events: none;
    }

    .command-link {
      padding: 0.65rem 0.5rem 0.4rem;
      text-decoration: none;
      color: rgba(226, 232, 240, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      transition: background 160ms ease, color 160ms ease;
      border: none;
      background: transparent;
      font-family: inherit;
      cursor: pointer;
    }

    .command-link:hover,
    .command-link:focus-visible {
      background: rgba(32, 41, 55, 0.9);
      color: #fff;
    }

    .command-link.is-active {
      background: rgba(41, 51, 68, 0.95);
      color: #fff;
      font-weight: 600;
    }

    .command-link__icon {
      font-size: 1.1rem;
    }

    .primary-action {
      background: var(--surface-elevated);
      border: 1px solid var(--card-border-color);
      border-radius: var(--card-radius);
      width: min(100%, 720px);
      margin: 0 auto clamp(1.5rem, 4vw, 2.2rem);
      padding: clamp(1.25rem, 4vw, 1.7rem);
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      position: relative;
      overflow: hidden;
    }

    .primary-action::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(45, 212, 195, 0.12), rgba(45, 212, 195, 0));
      opacity: 0.6;
      pointer-events: none;
    }

    .primary-action__context h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .primary-action__hint {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
      max-width: 48ch;
    }
  
  .focus-buddy {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.65rem;
  margin-top: 0.5rem;
  color: var(--text-primary);
}
.focus-buddy__timer {
  font-size: 2.2rem;
  font-weight: 700;
  color: var(--hero-teal);
}
.focus-buddy__controls button {
  margin: 0 0.25rem;
  padding: 0.4rem 0.8rem;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  background: rgba(45,212,195,0.15);
  color: var(--text-primary);
}
.focus-buddy__controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
  /* === Phase 2 – Step 2 : Dopaminergic Feedback === */
.dopamine-check {
  animation: pop 400ms ease forwards;
}
@keyframes pop {
  0% { transform: scale(0.7); opacity: 0; }
  60% { transform: scale(1.15); opacity: 1; }
  100% { transform: scale(1); }
}
.progress-bar-fill {
  height: 6px;
  background: var(--hero-teal);
  width: 0%;
  transition: width 0.4s ease;
  border-radius: 4px;
  margin-top: 0.25rem;
}

#nextTaskCard,
.zone-body > .card {
  width: min(100%, 720px);
  margin: 0 auto;
}

.next-task-card,
.all-tasks-card {
  width: var(--focus-shell-width);
  margin: 1.25rem auto 0;
}

    .focus-fab {
      position: fixed;
      right: clamp(1.25rem, 5vw, 2.5rem);
      bottom: clamp(5.5rem, 16vh, 7.5rem);
      background: var(--hero-teal);
      color: #022624;
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.55rem;
      box-shadow: 0 18px 42px rgba(45, 212, 195, 0.32);
      z-index: 110;
      cursor: pointer;
      transition: transform 180ms ease, box-shadow 220ms ease, background 180ms ease;
    }

    .focus-fab:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 22px 48px rgba(45, 212, 195, 0.36);
      background: #27c2b0;
    }

    .focus-fab:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .focus-fab:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.55), 0 18px 42px rgba(45, 212, 195, 0.32);
    }

    .focus-sheet__backdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.6);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 104;
    }

    .focus-sheet__backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .focus-sheet {
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translate(-50%, 110%);
      width: min(100%, 560px);
      background: rgba(10, 14, 20, 0.96);
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      border: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: 0 -20px 48px rgba(0, 0, 0, 0.55);
      padding: 1.2rem clamp(1rem, 4vw, 1.6rem);
      z-index: 105;
      transition: transform 220ms ease;
    }

    .focus-sheet[aria-hidden="true"] {
      display: none;
    }

    .focus-sheet.is-open {
      transform: translate(-50%, 0);
    }

    .focus-sheet__handle {
      width: 64px;
      height: 6px;
      margin: 0 auto 1rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.35);
      border: none;
      cursor: pointer;
    }

    .focus-sheet__content {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
    }

    .focus-sheet__header h2 {
      margin: 0;
      font-size: 1.15rem;
    }

    .focus-sheet__preview {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .focus-sheet__options {
      display: grid;
      gap: 0.75rem;
    }

    .focus-sheet__option {
      border-radius: 16px;
      border: 1px solid rgba(147, 160, 170, 0.24);
      padding: 0.75rem 1rem;
      background: rgba(20, 26, 34, 0.9);
      color: var(--text-primary);
      font-weight: 500;
      display: grid;
      gap: 0.25rem;
      text-align: left;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
    }

    .focus-sheet__option:hover:not(:disabled),
    .focus-sheet__option:focus-visible {
      background: rgba(30, 38, 48, 0.95);
      border-color: rgba(45, 212, 195, 0.4);
      transform: translateY(-1px);
      outline: none;
    }

    .focus-sheet__option--primary {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 16px 40px rgba(45, 212, 195, 0.32);
    }

    .focus-sheet__option--primary:hover {
      background: #27c2b0;
    }

    .focus-sheet__option--suggestion {
      background: rgba(15, 22, 30, 0.92);
      border-style: dashed;
    }

    .focus-sheet__option:disabled,
    .focus-sheet__option[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    .focus-sheet__option-label {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .focus-sheet__option-detail {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.55);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
      z-index: 101;
    }

    .drawer-backdrop.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .resources-drawer {
      position: fixed;
      top: 0;
      bottom: 0;
      right: 0;
      --drawer-width: min(360px, 86vw);
      --drawer-padding: clamp(1.25rem, 4vw, 1.75rem);
      width: var(--drawer-width);
      padding: var(--drawer-padding);
      background: rgba(10, 14, 20, 0.97);
      border-left: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: -18px 0 42px rgba(0, 0, 0, 0.5);
      z-index: 102;
      display: none;
      flex-direction: column;
      gap: 1.25rem;
      pointer-events: none;
      transform: translateX(1rem);
      opacity: 0;
      transition: transform 220ms ease, opacity 220ms ease;
    }

    .resources-drawer.is-open {
      display: flex;
      pointer-events: auto;
      transform: translateX(0);
      opacity: 1;
    }

    .resources-drawer__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .resources-drawer__header h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .resources-drawer__actions {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .resources-drawer__close,
    .resources-drawer__toggle {
      border: none;
      background: rgba(148, 163, 184, 0.16);
      border-radius: 999px;
      color: var(--text-primary);
      width: 32px;
      height: 32px;
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: 1.1rem;
      transition: background 150ms ease, color 150ms ease;
    }

    .resources-drawer__toggle {
      font-size: 1.15rem;
    }

    .resources-drawer__toggle--form {
      background: rgba(248, 113, 113, 0.18);
      color: #fca5a5;
    }

    .resources-drawer__close:hover,
    .resources-drawer__close:focus-visible,
    .resources-drawer__toggle:hover,
    .resources-drawer__toggle:focus-visible {
      background: rgba(148, 163, 184, 0.28);
      outline: none;
    }

    .resources-drawer__body {
      display: grid;
      gap: 0.85rem;
      overflow-y: auto;
      padding-right: 0.35rem;
    }

    .resources-drawer__form {
      margin: 0 0.25rem 1.75rem;
      padding: 1rem 1.1rem 1.25rem;
      display: none;
      gap: 0.85rem;
      background: rgba(14, 21, 30, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 14px;
    }

    .resources-drawer[data-view="form"] .resources-drawer__body {
      display: none;
    }

    .resources-drawer[data-view="form"] .resources-drawer__form {
      display: grid;
    }

    .resources-drawer[data-view="form"] .resources-drawer__toggle {
      font-size: 1.25rem;
    }

    .resources-drawer[data-view="list"] .resources-drawer__toggle {
      background: rgba(45, 212, 195, 0.18);
    }

    .resources-drawer__form legend {
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.78);
      padding: 0;
      margin: 0 0 0.25rem;
    }

    .resources-drawer__form fieldset {
      border: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.75rem;
    }

    .resources-drawer__form label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: rgba(203, 213, 225, 0.82);
    }

    .resources-drawer__form input,
    .resources-drawer__form textarea,
    .resources-drawer__form select {
      background: rgba(17, 25, 36, 0.88);
      border: 1px solid rgba(100, 116, 139, 0.35);
      border-radius: 10px;
      padding: 0.5rem 0.75rem;
      color: rgba(226, 232, 240, 0.96);
      font-size: 0.85rem;
      width: 100%;
    }

    .resources-drawer__form textarea {
      resize: vertical;
      min-height: 64px;
    }

    .resources-drawer__form select {
      text-transform: capitalize;
    }

    .resources-drawer__form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }

    .resources-drawer__form button[type="submit"] {
      background: var(--hero-teal);
      border: none;
      color: #022624;
      font-weight: 600;
      padding: 0.55rem 1.2rem;
      border-radius: 12px;
      cursor: pointer;
      transition: background 150ms ease, color 150ms ease, transform 120ms ease;
    }

    .resources-drawer__form button[type="submit"]:hover,
    .resources-drawer__form button[type="submit"]:focus-visible {
      background: #27c2b0;
      color: #011c1a;
      outline: none;
    }

    .resources-drawer__form button[type="submit"]:active {
      transform: translateY(1px);
    }

    .resources-drawer__form-message {
      font-size: 0.78rem;
      color: rgba(148, 163, 184, 0.9);
      min-height: 1.1rem;
    }

    .resources-drawer__form-message[data-status="error"] {
      color: #fca5a5;
    }

    .resources-drawer__form-message[data-status="success"] {
      color: #4ade80;
    }

    .command-link--drawer {
      letter-spacing: 0.05em;
    }

    .meltdown-sos-button {
      position: fixed;
      right: clamp(1.25rem, 5vw, 2.5rem);
      bottom: clamp(8.5rem, 22vh, 11rem);
      background: #ff4d4f;
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.75rem 1.3rem;
      box-shadow: 0 16px 36px rgba(255, 77, 79, 0.4);
      z-index: 120;
      border: none;
      cursor: pointer;
      transition: transform 180ms ease, box-shadow 220ms ease;
    }

    .meltdown-sos-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 42px rgba(255, 77, 79, 0.45);
    }

    .meltdown-sos-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6), 0 18px 42px rgba(255, 77, 79, 0.45);
    }

    .sos-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      padding: clamp(1rem, 5vw, 1.75rem);
      background: rgba(6, 10, 16, 0.7);
      backdrop-filter: blur(10px);
      z-index: 130;
    }

    .sos-card {
      width: min(320px, 92vw);
      background: rgba(10, 14, 20, 0.95);
      border: 1px solid rgba(147, 160, 170, 0.28);
      border-radius: 20px;
      padding: clamp(1rem, 4vw, 1.5rem);
      display: grid;
      gap: 1rem;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
    }

    .sos-card__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .sos-card__header h2 {
      margin: 0;
      font-size: 1.05rem;
    }

    .sos-card__close {
      border: none;
      background: rgba(148, 163, 184, 0.14);
      color: var(--text-primary);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
    }

    .sos-card__actions {
      display: grid;
      gap: 0.75rem;
    }

    .sos-card__action-group {
      display: grid;
      gap: 0.35rem;
    }

    .sos-card__action {
      border: 1px solid rgba(147, 160, 170, 0.28);
      border-radius: 14px;
      background: rgba(18, 24, 32, 0.92);
      color: var(--text-primary);
      padding: 0.65rem 1rem;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      transition: background 160ms ease, border-color 160ms ease;
    }

    .sos-card__action:hover,
    .sos-card__action:focus-visible {
      background: rgba(28, 38, 48, 0.95);
      border-color: rgba(45, 212, 195, 0.35);
      outline: none;
    }

    .sos-card__detail {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .sos-card__hint {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .defuse-modal {
      width: min(520px, 94vw);
      margin: auto;
      background: rgba(12, 17, 24, 0.96);
      border-radius: 20px;
      border: 1px solid rgba(147, 160, 170, 0.28);
      box-shadow: 0 24px 52px rgba(0, 0, 0, 0.6);
      display: grid;
      gap: 1rem;
      padding: clamp(1.25rem, 4vw, 1.75rem);
    }

    .defuse-modal__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .defuse-modal__header h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .defuse-modal__close {
      border: none;
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-primary);
      border-radius: 999px;
      width: 32px;
      height: 32px;
      cursor: pointer;
    }

    .defuse-modal__body {
      display: grid;
      gap: 1rem;
    }

    .sos-overlay.hidden,
    .defuse-overlay.hidden {
      display: none;
    }

    body.is-scrolling .zone-header,
    body.is-scrolling .focus-fab,
    body.is-scrolling .command-link {
      transition-duration: 0s !important;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(12, 16, 21, 0.65);
      opacity: 0;
      transition: opacity 320ms ease-in-out;
      pointer-events: none;
      z-index: 0;
    }

    body.sprint-active::before {
      opacity: 1;
    }

    body.sprint-active .app-shell {
      position: relative;
      z-index: 1;
    }

    body.sprint-active #nextTaskCard:not(.hidden),
    body.sprint-active #focus:not(.hidden) {
      position: relative;
      z-index: 2;
    }

    body.sprint-active #nextTaskCard:not(.hidden),
    body.sprint-active #focus:not(.hidden) .focus {
      border-color: rgba(45, 212, 195, 0.38);
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.35), 0 0 40px rgba(45, 212, 195, 0.22);
      animation: sprint-glow 45s ease-in-out infinite;
    }

    @keyframes sprint-glow {
      0%,
      100% {
        box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.25), 0 0 26px rgba(45, 212, 195, 0.18);
      }
      50% {
        box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.45), 0 0 46px rgba(45, 212, 195, 0.32);
      }
    }

    #focus.focus-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(0.75rem, 4vw, 2rem);
      background: rgba(8, 12, 18, 0.7);
      backdrop-filter: blur(10px);
      z-index: 140;
      pointer-events: none;
      width: 100vw;
      max-width: 100vw;
      overflow-x: hidden;
      margin: 0 auto;
    }

    body.focus-overlay-active #focus.focus-overlay {
      pointer-events: auto;
    }

    .focus-overlay__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(8, 12, 18, 0.55);
    }

    .focus-overlay__sheet {
      position: relative;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      border-radius: 28px 28px 16px 16px;
      background: rgba(9, 16, 23, 0.98);
      border: 1px solid rgba(148, 163, 184, 0.22);
      box-shadow: 0 -28px 64px rgba(0, 0, 0, 0.45);
      padding: clamp(1.1rem, 4vw, 1.75rem);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      transform: translateY(0);
      animation: focus-sheet-enter 240ms ease;
      overflow: hidden;
      max-height: clamp(320px, calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - clamp(1rem, 5vw, 2.5rem)), 760px);
      height: clamp(320px, calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - clamp(1rem, 5vw, 2.5rem)), 760px);
    }

    @keyframes focus-sheet-enter {
      from {
        transform: translateY(18px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .focus-overlay__header {
      display: grid;
      gap: 0.5rem;
    }

    .focus-overlay__progress {
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      overflow: hidden;
    }

    .focus-overlay__progress-fill {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, rgba(45, 212, 195, 0.9), rgba(45, 212, 195, 0.2));
      transition: width 180ms ease;
    }

    .focus-overlay__body {
      display: flex;
      flex-direction: column;
      gap: clamp(0.65rem, 2vw, 1rem);
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 0.2rem;
      padding-bottom: calc(env(safe-area-inset-bottom) + 3.5rem);
      scroll-padding-bottom: calc(env(safe-area-inset-bottom) + 3.5rem);
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    .focus-overlay__task {
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-areas:
        "title timer"
        "actions actions";
      align-items: center;
      gap: 0.4rem 0.65rem;
      padding: 0.5rem 0.75rem;
      margin: 0.3rem 0;
      border-radius: 14px;
    }

    .focus-overlay__task .task-title {
      grid-area: title;
      display: inline-flex;
      align-items: flex-start;
      gap: 0.4rem;
      margin: 0;
    }

    .focus-overlay__task .task-title input[type="checkbox"] {
      margin-top: 0.2rem;
    }

    .focus-overlay__task .subtask-name {
      margin: 0;
      line-height: 1.35;
    }

    .focus-overlay__task .timer-label {
      grid-area: timer;
      justify-self: end;
      margin-left: 0;
      font-size: 0.78rem;
    }

    .focus-overlay__task .task-actions {
      grid-area: actions;
      display: flex;
      gap: 0.4rem;
      flex-wrap: nowrap;
      justify-content: flex-start;
      width: 100%;
    }

    .focus-overlay__task .task-actions button,
    .focus-overlay__task .task-actions .icon-button {
      flex: 1 1 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.5rem;
      border-radius: 10px;
      font-size: 1rem;
      min-height: 0;
      margin: 0;
    }

    .focus-overlay__actions {
      display: flex;
      gap: 0.65rem;
      flex-wrap: nowrap;
      margin-top: auto;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(9, 16, 23, 0.7) 0%, rgba(9, 16, 23, 0.98) 60%);
      padding-top: 0.75rem;
      padding-bottom: calc(env(safe-area-inset-bottom) + 0.75rem);
      z-index: 2;
    }

    .focus-overlay__actions button {
      flex: 1 1 0;
      min-width: 0;
      margin: 0;
      border-radius: 14px;
      padding: 0.6rem 0.9rem;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .all-tasks-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: stretch;
  justify-content: center;
  --overlay-gutter: clamp(0.5rem, 4vw, 2.25rem);
  padding: 0 !important;   /* no gap around viewport */
  z-index: 130;
    }

    .all-tasks-overlay__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(8, 12, 18, 0.72);
      backdrop-filter: blur(8px);
    }
/* ============================================================
   LEGACY: .all-tasks-overlay__sheet (DEPRECATED 2025-11-06)
   Purpose: Old modal sizing rules retained for reference.
   Wrapped in .retired so they no longer affect layout.
   ============================================================ */

.retired {

  /* --- Legacy Version A: lines 4139–4165---*/
    .all-tasks-overlay__sheet {
  /* keep existing position/background/border styles */
  margin: var(--overlay-gutter) auto;
  width: calc(100vw - 2 * var(--overlay-gutter) - env(safe-area-inset-left) - env(safe-area-inset-right));
  max-width: calc(100vw - 2 * var(--overlay-gutter) - env(safe-area-inset-left) - env(safe-area-inset-right));
  min-height: calc(100dvh - 2 * var(--overlay-gutter) - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  max-height: calc(100dvh - 2 * var(--overlay-gutter) - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  overflow: hidden;
    }

    @media (min-width: 900px) {
      .all-tasks-overlay__sheet {
        width: min(calc(100vw - 2 * var(--overlay-gutter) - env(safe-area-inset-left) - env(safe-area-inset-right)), 840px);
        max-width: min(calc(100vw - 2 * var(--overlay-gutter) - env(safe-area-inset-left) - env(safe-area-inset-right)), 840px);
        min-height: auto;
        max-height: clamp(420px, 96vh, 940px);
      }
    }

    .all-tasks-overlay__body {
      position: relative;
      flex: 1 1 auto;
      overflow-y: auto;
      margin: 0;
      padding-top: clamp(0.5rem, 2vw, 0.75rem);
      padding-bottom: clamp(1rem, 3vw, 1.5rem);
    }
}
/*============================================================ */
    .all-tasks-overlay__close {
      position: absolute;
      top: clamp(0.65rem, 3vw, 1rem);
      right: clamp(0.65rem, 3vw, 1rem);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(17, 24, 32, 0.85);
      color: rgba(226, 232, 240, 0.9);
      width: 2.25rem;
      height: 2.25rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
      z-index: 2;
    }

    .all-tasks-overlay__close:hover,
    .all-tasks-overlay__close:focus-visible {
      background: rgba(31, 41, 55, 0.95);
      color: #fff;
      border-color: rgba(148, 163, 184, 0.5);
    }

    .all-tasks-overlay .card {
      margin: 0;
    }

    .all-tasks-overlay .all-tasks-panel {
      max-height: none;
    }

    body.focus-overlay-active,
    body.all-tasks-overlay-active {
      overflow: hidden;
    }

    body.brief-mode .card .card-body,
    body.brief-mode .card .card-sticky-actions,
    body.brief-mode .module-card .module-body {
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      pointer-events: none;
      transition: max-height 200ms ease, opacity 160ms ease;
    }

    body.brief-mode .card:focus-within .card-body,
    body.brief-mode .card:hover .card-body,
    body.brief-mode .card:focus-within .card-sticky-actions,
    body.brief-mode .card:hover .card-sticky-actions,
    body.brief-mode .module-card:focus-within .module-body,
    body.brief-mode .module-card:hover .module-body {
      max-height: 1200px;
      opacity: 1;
      pointer-events: auto;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition), color var(--transition), border-color var(--transition);
      min-height: 44px;
    }

    a.btn {
      text-decoration: none;
    }

    .icon-button {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-secondary);
      width: 48px;
      height: 48px;
      min-height: 48px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: transform var(--transition), background var(--transition), color var(--transition), border-color var(--transition);
    }

    .icon-button:hover,
    .btn:hover {
      transform: translateY(-1px);
    }

    .resource-card .card-body {
      gap: var(--space-2);
    }

    .resource-intro {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .resource-links {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-2);
    }

    .resource-button {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      padding: calc(var(--space-2) + 2px) var(--space-2);
      padding-left: calc(var(--space-2) + 18px);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      text-decoration: none;
      color: var(--text-primary);
      background: linear-gradient(135deg, rgba(45, 212, 191, 0.12), rgba(45, 212, 191, 0));
      transition: transform var(--transition), border-color var(--transition), box-shadow var(--transition);
    }

    .resource-button:hover,
    .resource-button:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(45, 212, 191, 0.35);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .resource-button::before {
      content: "";
      position: absolute;
      inset: calc(var(--space-2) + 2px) auto calc(var(--space-2) + 2px) var(--space-2);
      width: 4px;
      border-radius: 999px;
      background: var(--resource-accent, rgba(45, 212, 191, 0.85));
      opacity: 0.9;
    }

    .resource-button strong {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .resource-button span {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .resource-button--planning {
      --resource-accent: rgba(45, 212, 191, 0.85);
      background: linear-gradient(135deg, rgba(45, 212, 191, 0.12), rgba(45, 212, 191, 0));
      border-color: rgba(45, 212, 191, 0.2);
    }

    .resource-button--strategies {
      --resource-accent: rgba(99, 102, 241, 0.9);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.14), rgba(99, 102, 241, 0));
      border-color: rgba(99, 102, 241, 0.22);
    }

    .resource-button--digest {
      --resource-accent: rgba(251, 191, 36, 0.9);
      background: linear-gradient(135deg, rgba(251, 191, 36, 0.14), rgba(251, 191, 36, 0));
      border-color: rgba(251, 191, 36, 0.24);
    }

    .resource-button--vault {
      --resource-accent: rgba(167, 139, 250, 0.92);
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.14), rgba(167, 139, 250, 0));
      border-color: rgba(167, 139, 250, 0.22);
    }

    .resource-button small {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.72);
      text-transform: none;
      letter-spacing: 0.01em;
    }

    .card {
      background: rgba(18, 22, 28, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }

    .card.schedule-card {
      --schedule-card-inline: 1.35rem;
      padding: 1.35rem var(--schedule-card-inline);
      gap: 1.5rem;
      margin-bottom: calc(var(--command-bar-height) + 2.75rem);
    }

    @media (max-width: 560px) {
      .card.schedule-card {
        --schedule-card-inline: var(--page-gutter);
        padding: 1.15rem var(--schedule-card-inline);
        margin-inline: calc(-1 * var(--page-gutter));
        width: calc(100% + (var(--page-gutter) * 2));
        max-width: none;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
    }

    .card-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .card-head h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .card-body {
      display: grid;
      gap: var(--space-2);
    }

    .card--collapsed .card-body {
      display: none;
    }

    .card:not(.card--collapsed) .card-body {
      animation: module-expand var(--transition);
    }

    .card--collapsed .card-sticky-actions {
      display: none;
    }

    .status-card {
      background: rgba(18, 22, 28, 0.85);
    }

    .status-card .category-progress {
      margin-top: 0;
    }

    .preflight-panel {
      display: grid;
      gap: var(--space-2);
    }

    .preflight-toggles {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
    }

    .preflight-toggle {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: transparent;
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: background var(--transition), color var(--transition), border-color var(--transition);
    }

    .preflight-toggle:hover,
    .preflight-toggle:focus-visible {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .preflight-toggle.is-active {
      border-color: rgba(45, 212, 191, 0.55);
      background: rgba(45, 212, 191, 0.12);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.18);
    }

    .task-form-group {
      position: relative;
      display: grid;
      gap: var(--space-2);
      padding-top: var(--space-3);
      border-top: 1px solid rgba(148, 163, 184, 0.16);
    }

    .task-form-group__label {
      position: absolute;
      top: -0.75rem;
      left: 0;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(148, 163, 184, 0.75);
      padding: 0 0.35rem;
      background: linear-gradient(180deg, rgba(15, 20, 26, 1) 40%, rgba(15, 20, 26, 0));
    }

    .task-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      padding: 0.25rem 0;
    }

    .task-inline-actions .link-button {
      margin: 0;
      font-size: 0.85rem;
      color: var(--accent);
    }

    .section-chip {
      font-size: 0.72rem;
      letter-spacing: 0.08em;
    }

    .card-sticky-actions {
      position: sticky;
      bottom: -12px;
      margin: 0 -12px -12px;
      padding: var(--space-3);
      background: linear-gradient(180deg, rgba(18, 22, 28, 0) 0%, rgba(18, 22, 28, 0.92) 45%, rgba(18, 22, 28, 0.98) 100%);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      justify-content: space-between;
      align-items: center;
      z-index: 2;
      border-bottom-left-radius: 14px;
      border-bottom-right-radius: 14px;
      flex-shrink: 0;
    }

    #addTaskOverlay .card-sticky-actions {
      justify-content: flex-end;
      gap: var(--space-2);
    }

    #addTaskOverlay .card-sticky-actions__primary {
      flex-wrap: nowrap;
      justify-content: flex-end;
    }

    #addTaskOverlay[data-quick-task-mode="true"] .task-form-group__label,
    #addTaskOverlay[data-quick-task-mode="true"] label[for="taskCategory"],
    #addTaskOverlay[data-quick-task-mode="true"] .task-inline-actions,
    #addTaskOverlay[data-quick-task-mode="true"] #taskDetails {
      display: none;
    }

    #addTaskOverlay[data-quick-task-mode="true"] .card-sticky-actions__primary {
      justify-content: center;
    }

    #addTaskOverlay[data-quick-task-mode="true"] .task-form-group {
      padding-top: var(--space-2);
    }

    .card-sticky-actions__primary,
    .card-sticky-actions__secondary {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      align-items: center;
    }

    .btn-quiet {
      background: rgba(20, 28, 36, 0.35);
      border-color: rgba(148, 163, 184, 0.18);
      color: var(--text-secondary);
    }

    .btn-quiet:hover,
    .btn-quiet:focus-visible {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-primary);
    }

    .btn-quiet:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1400;
    }

    .modal.hidden {
      display: none;
    }

    #template-modal {
      z-index: 1600;
    }

    .modal__content {
      width: min(560px, 92vw);
      max-height: 80vh;
      overflow: auto;
      background: #0f141a;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: var(--space-2);
    }

    .modal__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-1);
    }

    .modal__close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.1rem;
      cursor: pointer;
    }

    .template-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 8px;
    }

    .template-card {
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      background: rgba(16, 20, 28, 0.9);
      display: grid;
      gap: 6px;
    }

    .template-card strong {
      font-size: 0.95rem;
    }

    .template-card button {
      justify-self: flex-start;
    }

    .template-module__actions {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1rem;
    }

    .block-batch-layout {
      display: grid;
      grid-template-columns: minmax(180px, 220px) 1fr;
      gap: 1.25rem;
      align-items: start;
      margin-top: 1rem;
    }

    .block-batch-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .block-batch-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.4rem;
      align-items: center;
    }

    .block-batch-item__edit {
      background: rgba(18, 24, 30, 0.92);
      border: 1px solid rgba(147, 160, 170, 0.18);
      border-radius: 10px;
      padding: 0.35rem 0.55rem;
      cursor: pointer;
      color: var(--text-secondary);
    }

    .block-batch-item__edit:hover {
      color: var(--text-primary);
    }

    .block-batch-item__select {
      text-align: left;
      padding: 0.45rem 0.75rem;
      border-radius: 12px;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.02);
      color: var(--text-primary);
      font-weight: 500;
      cursor: pointer;
    }

    .block-batch-item.is-active .block-batch-item__select {
      border-color: rgba(45, 212, 195, 0.45);
      background: rgba(45, 212, 195, 0.12);
      color: var(--hero-teal);
    }

    .block-batch-item__select:focus-visible,
    .block-batch-item__edit:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.55);
    }

    .block-batch-counts {
      display: grid;
      gap: 0.75rem;
    }

    .block-batch-count {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 0.85rem;
      border-radius: 14px;
      border: 1px solid rgba(147, 160, 170, 0.2);
      background: rgba(17, 23, 30, 0.75);
      transition: border-color 120ms ease, background 120ms ease;
    }

    .block-batch-count.is-active {
      border-color: rgba(45, 212, 195, 0.4);
      background: rgba(45, 212, 195, 0.08);
    }

    .block-batch-count span {
      font-weight: 500;
    }

    .block-batch-count input[type="number"] {
      max-width: 80px;
      background: rgba(12, 18, 24, 0.95);
      border-radius: 10px;
      border: 1px solid rgba(147, 160, 170, 0.3);
      color: var(--text-primary);
      padding: 0.4rem 0.6rem;
      text-align: right;
      font-size: 0.95rem;
    }

    .block-batch-editor {
      margin-top: 1.5rem;
      padding: 1.1rem;
      border-radius: 16px;
      border: 1px solid rgba(147, 160, 170, 0.18);
      background: rgba(12, 18, 24, 0.85);
      display: grid;
      gap: 1rem;
    }

    .block-batch-editor.hidden {
      display: none;
    }

    .block-batch-editor__head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .block-batch-editor__grid {
      display: grid;
      gap: 0.85rem;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .block-batch-editor textarea {
      min-height: 90px;
    }

    .block-batch-editor__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .block-batch-footer {
      margin-top: 1.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
    }

    .block-batch-footer label {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      color: var(--text-secondary);
      gap: 0.35rem;
    }

    .block-batch-footer input[type="date"] {
      min-width: 160px;
    }

    @media (max-width: 768px) {
      .block-batch-layout {
        grid-template-columns: 1fr;
      }

      .block-batch-list {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .block-batch-item {
        grid-template-columns: auto;
        gap: 0.35rem;
      }

      .block-batch-item__edit {
        justify-self: flex-start;
      }

      .block-batch-item__select {
        width: auto;
      }
    }


    .section-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .all-tasks-header {
      gap: 0.65rem;
    }

    .all-tasks-header__meta {
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .all-tasks-header__divider.hidden,
    [data-all-tasks-category].hidden {
      display: none !important;
    }

    .section-heading__title {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      flex: 1 1 auto;
      min-width: 0;
    }

    .section-heading__title .section-chip {
      margin-left: 0;
    }

    .section-heading--centered {
      justify-content: center;
      flex-direction: column;
      text-align: center;
    }

    .section-heading--centered .section-chip {
      margin-left: 0;
    }

    .section-heading h2,
    .next-task-card h2 {
      font-size: clamp(16px, 2.3vw, 18px);
      font-weight: 600;
      margin: 0;
    }

    .link-button {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .next-task-card {
      gap: var(--space-2);
    }

    .next-task-name {
      font-size: 1.05rem;
      font-weight: 600;
      margin: 0;
    }

    .next-task-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .chip {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      padding: 0.35rem 1.1rem;
      font-size: 0.8rem;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
    }

    .chip-muted {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-secondary);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .next-task-fit {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .next-task-fit__info {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.25rem;
      height: 1.25rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      color: rgba(226, 232, 240, 0.9);
      font-size: 0.75rem;
      cursor: help;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .next-task-actions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      width: 100%;
    }

    .next-task-start {
      width: 100%;
      justify-content: center;
      font-weight: 600;
    }

    .next-task-start.is-long-press {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.45);
    }

    .due-today-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .due-today-accordion {
      display: grid;
      gap: var(--space-2);
    }

    .due-today-summary {
      background: rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: var(--radius-md);
      padding: 0.55rem 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: var(--space-1);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.82rem;
      transition: border-color var(--transition), color var(--transition), background var(--transition);
      flex-shrink: 1;
      width: auto;
      min-width: 0;
      margin-left: auto;
      max-width: 100%;
    }

    .due-today-summary span[data-due-today-summary-text],
    .due-today-summary span[data-all-tasks-summary-text] {
      white-space: nowrap;
      flex: 1 1 auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .due-today-summary:hover,
    .due-today-summary:focus-visible {
      border-color: rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      background: rgba(148, 163, 184, 0.14);
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .due-today-summary__icon {
      font-size: 0.75rem;
      transition: transform var(--transition);
      margin-left: var(--space-1);
      flex-shrink: 0;
    }

    .due-today-accordion[data-open="true"] .due-today-summary__icon {
      transform: rotate(90deg);
    }

    .due-today-item {
      display: grid;
      gap: var(--space-1);
      background: var(--surface-muted);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-md);
      padding: var(--space-2);
    }

    .due-today-item--spotlight {
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.25), 0 0 24px rgba(45, 212, 195, 0.18);
      transition: box-shadow 220ms ease-out;
    }

    .due-today-title {
      font-size: 0.95rem;
      font-weight: 500;
      margin: 0;
      color: var(--text-primary);
    }

    .due-today-meta {
      font-size: 0.8rem;
      color: var(--text-secondary);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .due-today-pills {
      display: inline-flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .pill {
      font-size: 0.8rem;
      border-radius: 999px;
      padding: 0.35rem 1.1rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .pill-primary {
      background: rgba(45, 212, 191, 0.18);
      color: var(--accent);
      border-color: rgba(45, 212, 191, 0.35);
    }

    .module-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 0;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .module-header {
      width: 100%;
      background: transparent;
      color: var(--text-primary);
      border: none;
      padding: var(--space-3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .module-heading {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .module-heading__text {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
    }

    .module-heading__title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .module-heading__tagline {
      font-size: 0.78rem;
      font-weight: 500;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
    }

    .module-caret {
      display: inline-block;
      transition: transform var(--transition);
      color: var(--text-secondary);
    }

    .module-card.is-open .module-caret {
      transform: rotate(90deg);
    }

    .module-body {
      padding: 0 var(--space-4) var(--space-4);
      display: grid;
      gap: var(--space-3);
      transition: opacity var(--transition), transform var(--transition);
    }

    .module-body[hidden] {
      display: none;
    }

    .module-card.is-open .module-body {
      animation: module-expand var(--transition);
    }

    @keyframes module-expand {
      from {
        opacity: 0;
        transform: translateY(-6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .module-footnote {
      font-size: 0.78rem;
      color: var(--text-secondary);
    }

    .task-form-card {
      gap: var(--space-3);
    }

    .task-form-actions--inline {
      align-items: center;
    }

    .task-form-actions--inline .btn {
      padding: 0.35rem 0.75rem;
      font-size: 0.85rem;
    }

    .task-form-minimal {
      display: grid;
      gap: var(--space-2);
    }

    .task-form-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-2);
    }

    .task-form-actions {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .task-details-panel {
      display: grid;
      gap: var(--space-2);
    }

    .task-details-panel[data-collapsed="true"] {
      display: none;
    }

    label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    input[type="text"],
    select,
    input[type="date"],
    textarea {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      width: 100%;
      box-sizing: border-box;
    }

    textarea {
      resize: vertical;
      min-height: 96px;
    }

    .category-filter,
    .category-progress,
    .peek {
      margin-top: var(--space-3);
    }

    .peek {
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
    }

    .hidden {
      display: none !important;
    }

    .toast-container {
      position: fixed;
      top: var(--space-4);
      right: var(--space-4);
      z-index: 1500;
    }

    .module-stack {
      display: grid;
      gap: var(--space-3);
    }

    .next-best-card .card-body {
      display: grid;
      gap: var(--space-3);
    }

    .next-best-card.is-highlighted {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.4), 0 0 32px rgba(45, 212, 195, 0.22);
      transition: box-shadow var(--transition), transform var(--transition);
    }

    .next-best-controls {
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: var(--radius-md);
      padding: var(--space-2);
      background: rgba(15, 20, 27, 0.65);
      transition: border-color var(--transition), background var(--transition);
    }

    .next-best-controls:not([hidden]) {
      border-color: rgba(148, 163, 184, 0.28);
      background: rgba(15, 20, 27, 0.8);
    }

    .next-best-controls__form {
      margin-top: var(--space-2);
      display: grid;
      gap: var(--space-2);
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: flex-start;
    }

    .next-best-energy {
      display: grid;
      gap: 0.25rem;
    }

    .nbt-frictions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .nbt-frictions label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.8rem;
      cursor: pointer;
    }

    .nbt-frictions input[type="checkbox"] {
      margin: 0;
    }

    .next-best-results {
      position: relative;
      display: flex;
      align-items: stretch;
      flex-wrap: nowrap;
      gap: var(--space-2);
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: x mandatory;
      padding-bottom: 0.35rem;
      margin: 0 -0.25rem;
      padding-left: 0.25rem;
      padding-right: clamp(1.25rem, 4vw, 2.5rem);
    }

    .next-best-results > * {
      flex: 0 0 auto;
    }

    .next-best-results::after {
      content: "";
      position: absolute;
      top: 0;
      right: 0;
      width: clamp(1.5rem, 6vw, 3rem);
      height: 100%;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(12, 17, 23, 0), rgba(12, 17, 23, 0.88));
    }

    .next-best-results::-webkit-scrollbar {
      height: 6px;
    }

    .next-best-results::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
    }

    @media (min-width: 960px) {
      .next-best-results {
        display: flex;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        gap: var(--space-3, 1.25rem);
        margin: 0;
        padding: 0 0 clamp(0.5rem, 2vw, 0.75rem);
      }

      .next-best-results::after {
        width: clamp(2rem, 6vw, 3.5rem);
        background: linear-gradient(90deg, rgba(12, 17, 23, 0), rgba(12, 17, 23, 0.92));
      }

      .next-best-option {
        min-width: clamp(240px, 32vw, 320px);
        scroll-snap-align: center;
      }
    }

    .next-best-refresh {
      position: relative;
      font-size: 0.85rem;
      padding: 0.4rem 1.9rem 0.4rem 0.9rem;
      min-width: 110px;
    }

    .next-best-refresh.is-loading {
      color: rgba(226, 232, 240, 0.55);
    }

    .next-best-refresh.is-loading::after {
      content: "";
      position: absolute;
      top: 50%;
      right: 0.75rem;
      width: 14px;
      height: 14px;
      margin-top: -7px;
      border-radius: 50%;
      border: 2px solid currentColor;
      border-right-color: transparent;
      animation: button-spin 0.8s linear infinite;
    }

    .next-best-option {
      position: relative;
      display: grid;
      gap: var(--space-2);
      padding: calc(var(--space-2) + 6px) var(--space-2) var(--space-2);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148, 163, 184, 0.16);
      background: rgba(15, 20, 27, 0.75);
      box-shadow: 0 12px 24px rgba(2, 6, 23, 0.35);
      min-width: clamp(240px, 78vw, 320px);
      scroll-snap-align: center;
    }

    .next-best-option__label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.6);
    }

    .next-best-option__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .next-best-option__payoff {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .next-best-option__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .spec-chip {
      background: rgba(148, 163, 184, 0.16);
      color: rgba(226, 232, 240, 0.78);
    }

    .next-best-meter {
      display: grid;
      gap: 0.4rem;
    }

    .next-best-meter__label {
      font-size: 0.8rem;
      color: rgba(226, 232, 240, 0.75);
      font-weight: 500;
    }

    .next-best-meter__track {
      position: relative;
      height: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      overflow: hidden;
    }

    .next-best-meter__bar {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(45, 212, 191, 0.9), rgba(45, 212, 191, 0.2));
      width: 12%;
      transition: width 220ms ease;
    }

    .next-best-meter__scale {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.6);
    }

    .next-best-ring {
      position: absolute;
      top: var(--space-2);
      right: var(--space-2);
      width: 38px;
      height: 38px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.65);
    }

    .next-best-ring::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: conic-gradient(var(--accent) 0deg, var(--accent) 3.6deg, transparent 3.6deg 360deg);
      opacity: 0.7;
    }

    .next-best-ring::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-radius: 50%;
      background: rgba(12, 17, 23, 0.95);
    }

    .next-best-ring span {
      position: relative;
      z-index: 1;
    }

    .next-best-cta {
      justify-self: flex-start;
      min-width: 150px;
    }

    .next-best-cta--steady {
      background: var(--accent);
      border-color: rgba(45, 212, 191, 0.55);
      color: #041013;
    }

    .next-best-cta--low {
      background: rgba(30, 64, 175, 0.85);
      border-color: rgba(30, 64, 175, 0.6);
      color: #e0e7ff;
      box-shadow: 0 16px 30px rgba(30, 64, 175, 0.35);
    }

    .next-best-cta--high {
      background: rgba(52, 211, 153, 0.95);
      border-color: rgba(52, 211, 153, 0.6);
      color: #022c22;
      box-shadow: 0 16px 30px rgba(52, 211, 153, 0.32);
    }

    .next-best-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .conflict-grid {
      display: grid;
      gap: var(--space-2);
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .conflict-column {
      display: grid;
      gap: var(--space-2);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: var(--radius-md);
      padding: var(--space-2);
    }

    .conflict-column h3 {
      margin: 0;
      font-size: 0.95rem;
    }

    .conflict-list {
      display: grid;
      gap: 0.6rem;
    }

    .conflict-item {
      display: grid;
      gap: 0.35rem;
      padding: 0.55rem 0.65rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.15);
      cursor: grab;
    }

    .conflict-item:active {
      cursor: grabbing;
    }

    .conflict-item strong {
      font-size: 0.9rem;
    }

    .conflict-item span {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .conflict-arena {
      border: 2px dashed rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      min-height: 140px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: var(--space-3);
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.03);
      transition: border-color var(--transition), background var(--transition);
    }

    .conflict-arena.is-ready {
      border-color: var(--accent);
      background: rgba(45, 212, 191, 0.12);
    }

    .conflict-arena .arena-slot {
      font-weight: 600;
      color: var(--text-primary);
    }

    .conflict-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .defuse-grid {
      display: grid;
      gap: var(--space-2);
    }

    .defuse-steps {
      display: grid;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .defuse-progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .defuse-progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #0a84ff, #7bd88f);
      transition: width 180ms ease-out;
    }

    .defuse-locks {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .defuse-locks label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.15);
      font-size: 0.8rem;
    }

    .dopamine-playlist {
      display: grid;
      gap: var(--space-2);
    }

    .dopamine-intervals {
      display: grid;
      gap: 0.5rem;
    }

    .dopamine-interval {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.65rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.85rem;
    }

    .dopamine-progress {
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .dopamine-progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #f97316, #7c3aed);
      transition: width 180ms ease-out;
    }

    .confetti-burst {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: center;
      animation: confetti-pop 900ms ease-out forwards;
      font-size: 2.5rem;
      z-index: 2000;
    }

    @keyframes confetti-pop {
      0% { opacity: 0; transform: scale(0.7); }
      50% { opacity: 1; transform: scale(1.05); }
      100% { opacity: 0; transform: scale(1.2); }
    }

    .due-today-empty {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .next-task-empty {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .quick-tasks-card {
      display: grid;
      gap: var(--space-2);
    }

    .quick-tasks-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .quick-task-list {
      display: grid;
      gap: 0.5rem;
    }

    .quick-task-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.6rem 0.85rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      transition: background 160ms ease, border-color 160ms ease;
    }

    .quick-task-item:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.16);
    }

    .quick-task-name {
      flex: 1;
      margin-right: 0.75rem;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .quick-task-checkbox {
      width: 1.1rem;
      height: 1.1rem;
      cursor: pointer;
    }

    .quick-task-empty {
      margin: 0;
      color: var(--text-secondary);
      text-align: center;
      font-size: 0.95rem;
    }

    .quick-task-shortcut {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      font-weight: 500;
    }

    .quick-task-hint {
      margin: 0 0 0.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .quick-tasks-card.is-highlighted {
      box-shadow: 0 0 0 2px rgba(45, 212, 195, 0.45);
      border-radius: var(--card-radius);
    }

    .task-added-toast {
      position: fixed;
      top: 1.5rem;
      left: 50%;
      transform: translate(-50%, -20px);
      background: rgba(45, 212, 195, 0.9);
      color: #022624;
      padding: 0.65rem 1.5rem;
      border-radius: 999px;
      font-weight: 600;
      letter-spacing: 0.02em;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease, transform 200ms ease;
      z-index: 2000;
      box-shadow: 0 10px 30px rgba(45, 212, 195, 0.35);
    }

    .task-added-toast--visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .quick-pill {
      border: none;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .quick-pill:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .info-dot {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
    }

    .all-tasks-toggle {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      justify-content: flex-start;
      background: rgba(10, 16, 24, 0.55);
      border: 1px solid rgba(147, 160, 170, 0.25);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      color: inherit;
      font-size: 1rem;
      font-weight: 600;
      margin: 0;
      cursor: pointer;
      transition: border-color 160ms ease, background 160ms ease, transform 160ms ease;
    }

    .all-tasks-toggle:hover,
    .all-tasks-toggle:focus-visible {
      background: rgba(16, 24, 32, 0.65);
      border-color: rgba(125, 216, 143, 0.45);
      transform: translateY(-1px);
    }

    .all-tasks-toggle.is-open {
      background: rgba(16, 24, 32, 0.72);
      border-color: rgba(125, 216, 143, 0.55);
    }

    .all-tasks-toggle:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(125, 216, 143, 0.35);
    }

    .all-tasks-toggle__title {
      font-size: 1rem;
      font-weight: 600;
    }

    .all-tasks-toggle__meta {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
      white-space: nowrap;
    }

    .all-tasks-toggle__chevron {
      font-size: 1rem;
      transition: transform 160ms ease;
    }

    .all-tasks-toggle[aria-expanded="true"] .all-tasks-toggle__chevron {
      transform: rotate(90deg);
    }

    .all-tasks-panel {
      padding: var(--space-3) var(--space-2);
      display: grid;
      gap: var(--space-3);
      margin-top: 1rem;
    }

    .all-tasks-panel.is-highlighted {
      box-shadow: 0 0 0 2px rgba(148, 163, 184, 0.35);
      border-radius: var(--card-radius);
    }

    .task-panel-actions {
      display: flex;
      justify-content: flex-end;
    }

    .info-dot[title] {
      cursor: help;
    }

    button:not(.btn):not(.icon-button):not(.pill):not(.link-button):not(.module-header) {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.5rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    /* --- Final global polish overrides --- */
    body {
      font-weight: 400;
      line-height: 1.5;
      overflow-x: hidden;
    }

    .card,
    .peek,
    .task-card,
    .resource-button,
    .worst-day-banner,
    .worst-day-card,
    .distraction-tools,
    .distraction-log li,
    .doorway-reset,
    .gantt-card,
    .chart-summary,
    .subtask-row,
    .routine-block,
    .toast,
    .modal__content,
    .modal-card,
    .wizard-content,
    .audit-card,
    .category-progress .line,
    .category-progress .bar,
    .history-list li,
    .progress-strip,
    .nbt-result-card,
    .task-details,
    .next-task-card,
    .due-today-card,
    .status-card,
    .next-best-card {
      border-radius: var(--card-radius);
      border: 1px solid var(--card-border-color);
      background: var(--surface-elevated);
    }

    .btn-primary {
      background: var(--accent);
      color: #041013;
      border: 1px solid rgba(45, 212, 191, 0.55);
      box-shadow: 0 16px 30px rgba(45, 212, 191, 0.28);
      font-weight: 600;
    }

    .btn-secondary {
      background: rgba(148, 163, 184, 0.14);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: var(--text-primary);
      box-shadow: none;
    }

    .btn-ghost,
    .btn-outline,
    .btn-tertiary {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-secondary);
      box-shadow: none;
    }

    .btn-outline {
      border-color: rgba(45, 212, 191, 0.45);
      color: var(--accent);
    }

    .btn-outline:hover,
    .btn-outline:focus-visible {
      background: rgba(45, 212, 191, 0.08);
      color: var(--accent);
    }

    .btn-ghost:hover,
    .btn-tertiary:hover,
    .btn-secondary:hover {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
    }

    .icon-button {
      border-radius: 12px;
      padding: 0.5rem;
    }

    .icon-button:hover,
    .icon-button:focus-visible {
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-primary);
    }

    .icon-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6);
    }

    .resource-button {
      text-decoration: none;
      display: grid;
      gap: 0.25rem;
      padding: 0.85rem 1rem;
      color: var(--text-primary);
      background: rgba(20, 28, 36, 0.82);
    }

    .resource-button strong {
      font-weight: 600;
    }

    .worst-day-button {
      background: rgba(20, 28, 36, 0.8);
      color: var(--text-primary);
      border: 1px solid var(--card-border-color);
      box-shadow: none;
    }

    .worst-day-button.hero-cta {
      background: var(--hero-teal);
      color: #022624;
      border-color: transparent;
      box-shadow: 0 0 0 1px rgba(45, 212, 195, 0.35), 0 16px 40px rgba(45, 212, 195, 0.35);
    }
    .focus-command-deck {
  background: linear-gradient(145deg, rgba(15,18,26,0.98), rgba(12,22,20,0.9));
  border: 1px solid rgba(147,160,170,0.22);
  border-radius: 20px;
  padding: 1.5rem;
  width: var(--focus-shell-width);
  margin: 1rem auto;
  box-shadow: 0 20px 50px rgba(0,0,0,0.45);
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
  color: #e6eef7;
  font-family: "Inter", system-ui, sans-serif;
}

.focus-title {
  font-size: clamp(1.4rem, 2.3vw, 1.6rem);
  margin: 0;
  color: #7bd88f;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.focus-title__link {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0.35rem;
  margin-left: 0;
  border-radius: 10px;
  border: 1px solid rgba(45, 212, 195, 0.4);
  background: rgba(45, 212, 195, 0.18);
  text-decoration: none;
  transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
}

.focus-title__link:hover,
.focus-title__link:focus-visible {
  transform: translateY(-1px);
  background: rgba(45, 212, 195, 0.28);
  box-shadow: 0 0 0 2px rgba(125, 216, 143, 0.35);
  outline: none;
}

.focus-title__icon {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.focus-top {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.75rem;
}

.focus-meter {
  width: 100%;
  display: grid;
  gap: 0.45rem;
}

.focus-meter__header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 0.5rem;
}

.meter-label {
  text-transform: uppercase;
  letter-spacing: 0.08em;
  font-size: 0.82rem;
  font-weight: 600;
  color: #cdd5e0;
}

.meter-note {
  margin: 0;
  font-size: 0.8rem;
  color: #8fa5ff;
}

.chip {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  background: rgba(255,255,255,0.06);
  border-radius: 999px;
  padding: 0.4rem 0.8rem;
  font-size: 0.85rem;
  color: #cdd5e0;
}

.progress-strip {
  position: relative;
  width: 100%;
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
}

.cm-fill {
  display: block;
  height: 100%;
  background: linear-gradient(90deg, #0a84ff, #7bd88f);
  transition: width 200ms ease-out;
}

.cm-float {
  position: absolute;
  right: 0;
  top: -1.35rem;
  font-size: 0.78rem;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: #7bd88f;
  opacity: 0;
  transition: opacity 180ms ease, transform 180ms ease;
}

.focus-views {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.focus-view-toggle {
  border: 1px solid rgba(125, 216, 143, 0.3);
  background: rgba(125, 216, 143, 0.1);
  color: #e6eef7;
  border-radius: 10px;
  padding: 0.45rem 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
}

.focus-view-toggle.is-active {
  background: rgba(125, 216, 143, 0.2);
  border-color: rgba(125, 216, 143, 0.6);
}

.focus-view-toggle:hover:not(:disabled) {
  transform: translateY(-1px);
  background: rgba(125, 216, 143, 0.2);
}

.focus-view-toggle:focus-visible {
  outline: 2px solid #7bd88f;
  outline-offset: 2px;
}

.focus-actions {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 0.75rem;
}

.focus-actions button,
.focus-actions .btn-quiet,
.focus-actions .hero-cta {
  margin: 0;
  width: 100%;
}

.focus-footer {
  text-align: left;
}

@media (min-width: 640px) {
  .focus-top {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }

  .focus-meter {
    max-width: 260px;
  }

  .cm-float {
    top: -1.5rem;
  }
}

.hero-cta {
  background: #2dd4c3;
  color: #021b19;
  font-weight: 600;
  padding: 0.75rem 1.25rem;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: 0 12px 28px rgba(45,212,195,0.3);
  transition: transform 120ms ease, box-shadow 200ms ease;
}

.hero-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 18px 36px rgba(45,212,195,0.35);
}

.btn-quiet {
  background: rgba(255,255,255,0.08);
  color: #c4cad8;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.1);
  padding: 0.6rem 1rem;
}

.focus-micro {
  font-size: 0.8rem;
  color: #8fa5ff;
  margin: 0.25rem 0 0;
}

    .quick-add-menu {
      width: var(--focus-shell-width);
      margin: 0.5rem auto 1.25rem;
      padding: 0.65rem 0.9rem 0.75rem;
      border-radius: 18px;
      background: rgba(17, 23, 30, 0.82);
      border: 1px solid rgba(147, 160, 170, 0.18);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .quick-add-menu__label {
  margin: 0;
  font-size: 1.4rem;
  font-weight: 700;
  letter-spacing: 0.02em;
  background: var(--tasker-brand-gradient);
  color: #7bd88f;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

    .quick-add-menu__buttons {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(0, 1fr);
      width: 100%;
      gap: clamp(0.4rem, 1vw, 0.75rem);
      align-items: center;
      justify-items: center;
    }

    .quick-add-button {
      width: clamp(44px, 8vw, 56px);
      height: clamp(44px, 8vw, 56px);
      border-radius: 50%;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.4rem, 4.8vw, 1.75rem);
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 200ms ease, filter 140ms ease;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.35);
      color: #0d1015;
      justify-self: center;
    }

.quick-add-button:hover {
  transform: translateY(-2px);
  filter: brightness(1.05);
}

.quick-add-button:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.45), 0 10px 20px rgba(0, 0, 0, 0.35);
}

.quick-add-button--cherry {
  background: linear-gradient(135deg, #ff6b8a, #ff2156);
}

.quick-add-button--muscle {
  background: linear-gradient(135deg, #ffd166, #ff8a00);
}

.quick-add-button--unicorn {
  background: linear-gradient(135deg, #a06bff, #ff9dff);
}

.quick-add-button--home {
  background: linear-gradient(135deg, #6bffb0, #1ad69b);
}

.quick-add-button--kiddo {
  background: linear-gradient(135deg, #6ecbff, #1c8cff);
}

.quick-add-button--plus {
  background: linear-gradient(135deg, #2dd4c3, #7bd88f);
  color: #022624;
}
    /* Tasker 5000 Title Block */
/* --- TASK FOCUS HEADER --- */
    .app-header {
      background: linear-gradient(120deg, rgba(20, 28, 36, 0.9), rgba(12, 16, 22, 0.85));
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      padding: clamp(1rem, 3vw, 1.2rem) clamp(1rem, 4vw, 1.4rem);
      margin: 0 auto 1rem;
      width: min(94vw, 480px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: clamp(0.65rem, 2vw, 0.85rem);
    }

    .app-header__top {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .app-header__date-block {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      min-width: 0;
      flex: 1 1 auto;
    }

    .app-header__meta-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(230, 238, 247, 0.7);
    }

    .app-header__date {
      font-size: 1.1rem;
      font-weight: 600;
      color: #e6eef7;
      margin: 0;
    }

    .app-header__actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: flex-end;
      gap: clamp(0.35rem, 1.5vw, 0.65rem);
      margin-left: auto;
    }

    .app-header__quick-add {
      width: clamp(40px, 7vw, 52px);
      height: clamp(40px, 7vw, 52px);
    }

    .app-header__main {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: clamp(0.55rem, 2vw, 0.75rem);
      text-align: left;
    }

    .app-header__title {
      font-size: clamp(2rem, 7vw, 2.8rem);
      font-weight: 700;
      letter-spacing: 0.01em;
      margin: 0;
      background: var(--tasker-brand-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      color: #7bd88f;
      text-align: left;
      line-height: 1.05;
    }

    .app-header__subtitle {
      margin: 0;
      font-size: 1rem;
      color: #aeb7c8;
      margin: 0;
      max-width: 48ch;
      line-height: 1.4;
    }

    .billing-reminder {
      margin: 0;
    }

    .billing-reminder {
      display: inline-flex;
      align-items: center;
      margin: 0;
      padding: 0;
      background: transparent;
      border: none;
      color: inherit;
      animation: none;
      white-space: normal;
    }

    .billing-reminder:empty {
      display: none;
    }

    .settings-trigger {
      border: none;
      background: rgba(148, 163, 184, 0.16);
      border-radius: 999px;
      width: 36px;
      height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease;
    }

    .settings-trigger:hover,
    .settings-trigger:focus-visible {
      background: rgba(148, 163, 184, 0.26);
      transform: translateY(-1px);
      outline: none;
    }

    .settings-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      right: 1.5rem;
      width: min(240px, 80vw);
      background: rgba(9, 14, 20, 0.96);
      border: 1px solid rgba(147, 160, 170, 0.22);
      border-radius: 16px;
      padding: 0.75rem;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      display: none;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 105;
    }

    .settings-menu.is-open {
      display: flex;
    }

    .settings-menu__section {
      display: grid;
      gap: 0.35rem;
      padding-bottom: 0.35rem;
      border-bottom: 1px solid rgba(147, 160, 170, 0.18);
    }

    .settings-menu__toggle {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.45rem 0.65rem;
      border-radius: 12px;
      background: rgba(12, 20, 30, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: var(--text-secondary);
      font-size: 0.85rem;
      cursor: pointer;
    }

    .settings-menu__toggle:hover,
    .settings-menu__toggle:focus-visible {
      background: rgba(18, 28, 40, 0.75);
      color: var(--text-primary);
      outline: none;
    }

    .settings-menu__toggle input[type="checkbox"] {
      width: 1.2rem;
      height: 1.2rem;
      accent-color: #38bdf8;
    }

    .settings-menu__item {
      border: none;
      background: rgba(15, 22, 30, 0.85);
      color: var(--text-primary);
      padding: 0.55rem 0.7rem;
      border-radius: 12px;
      text-align: left;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 160ms ease, transform 160ms ease, color 160ms ease;
    }

    .settings-menu__item:hover,
    .settings-menu__item:focus-visible {
      background: rgba(25, 34, 44, 0.95);
      color: #f5f9ff;
      transform: translateY(-1px);
      outline: none;
    }

    @media (max-width: 600px) {
      .app-header {
        width: min(var(--focus-shell-width), 440px);
        padding: clamp(0.95rem, 5vw, 1.15rem) clamp(0.85rem, 4vw, 1.1rem);
        gap: 0.75rem;
      }

      .app-header__top {
        align-items: center;
        gap: 0.45rem;
      }

      .app-header__date {
        font-size: 1.05rem;
      }

      .settings-trigger {
        align-self: flex-start;
      }

      .billing-reminder {
        width: 100%;
        justify-content: flex-start;
        line-height: 1.3;
      }

      .app-header__title {
        font-size: clamp(1.9rem, 9vw, 2.35rem);
      }

      .app-header__subtitle {
        max-width: 100%;
      }
    }

    @media (max-width: 420px) {
      .app-header {
        width: min(var(--focus-shell-width), 400px);
        padding: clamp(0.85rem, 7vw, 1rem);
      }

      .app-header__title {
        font-size: clamp(1.8rem, 10vw, 2.2rem);
      }

      .billing-reminder {
        font-size: 0.85rem;
      }
    }

/* Gentle pulse to give it life */
@keyframes pulse-red {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.3); }
  50% { box-shadow: 0 0 8px 2px rgba(255, 107, 107, 0.45); }
}

/* Gradient underline for “momentum” feel */
.app-header::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 0;
  height: 3px;
  width: 100%;
  background: linear-gradient(90deg, #2dd4c3, #7bd88f, #2dd4c3);
  opacity: 0.85;
  background-size: 200% auto;
  animation: slide-glow 6s linear infinite;
  border-radius: 3px;
}

@keyframes slide-glow {
  from { background-position: 0 0; }
  to { background-position: 200% 0; }
}
    /* === FULL-SCREEN ALL TASKS OVERLAY === */
#focus.focus-overlay,
.focus-overlay {
  position: fixed;              /* make it span the viewport */
  inset: 8px;                   /* 8px margin on all sides */
  margin: 0;                    /* remove extra centering margins */
  width: auto;
  height: auto;
  max-width: none;              /* remove width caps */
  max-height: none;             /* remove height caps */
  border-radius: 16px;          /* keep soft rounded corners */
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.5); /* preserve floating-sheet look */
  background-color: var(--surface, rgba(20, 24, 32, 0.96)); /* same dark base */
  overflow: auto;               /* scroll within overlay if needed */
  z-index: 1000;                /* stay above page content */
}

/* === HOME SCREEN CARD SPACING === */
.focus-command-deck,
.quick-add,
.quick-tasks,
.title-card {
  margin-inline: 8px;           /* left & right spacing */
  border-radius: 16px;          /* preserve rounded corners */
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); /* subtle depth */
}

/* (Optional) If your main container or grid cancels card margins: */
.main-content,
.home,
.page-content {
  padding-inline: 8px;
}
  /* === SAFE AREA FIX for viewport fit on mobile === */
.all-tasks-overlay {
  padding-bottom: env(safe-area-inset-bottom);
  padding-top: env(safe-area-inset-top);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}

/* 3. Show true viewport edge */
html::before {
  content: "";
  position: fixed;
  inset: 0;
  outline: 2px solid magenta;
  pointer-events: none;
  z-index: 2147483647;
}

/* 4. Keep your mobile padding rule separate */
@media (max-width: 540px) {
  .starter-stack,
  .routine-stack { padding-inline: 8px; }
  /* No sideways scroll anywhere */
html, body { overflow-x: hidden; }

/* Overlay must not allow x-scroll either */
.all-tasks-overlay { overflow-x: hidden; }
/* --- Legacy Version B: lines 6578–6600 --- */
  .retired{
.all-tasks-overlay__sheet {
  /* width from container (%), not 100vw */
  width: min(840px, calc(100% - 2 * var(--overlay-gutter)));
  max-width: min(840px, calc(100% - 2 * var(--overlay-gutter)));
}
  }
/* ============================================================ */

  /* Let the overlay scroll if the sheet is taller than the screen */
.all-tasks-overlay {
  align-items: start;        /* start at top so scroll feels natural */
  overflow-y: auto;          /* overlay becomes the scroll container */
}

/* Sheet should be height-auto with only a max-height cap */
.all-tasks-overlay__sheet {
  height: auto !important;   /* remove fixed height */
  max-height: calc(100dvh - 2 * var(--overlay-gutter)) !important;
  overflow: auto;            /* inner scroll when content exceeds cap */
  -webkit-overflow-scrolling: touch;
}
  .all-tasks-overlay__sheet {
  max-height: calc(
    100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom)
  ) !important;
  }
/* === fix "I have ___ minutes" layout === */
.all-tasks-overlay .all-tasks-filter-time {
  display: flex;
  flex-direction: column;
  align-items: center;     /* center horizontally */
  justify-content: center;
  margin-top: 1rem;
  gap: 0.25rem;            /* small space between label/select/span */
}

.all-tasks-overlay .all-tasks-filter-time select {
  width: 80px;             /* keep narrow so centered nicely */
  text-align: center;
}
  /* === ensure overlay container fills the viewport === */
.all-tasks-overlay {
  position: fixed;
  inset: 0;
  width: 100vw;
  min-height: 100dvh;   /* fills the viewport vertically */
  height: 100dvh;
  display: flex;
  flex-direction: column;
  justify-content: flex-start; /* content starts at top, container still full height */
  overflow-y: auto;
  background-color: rgba(0,0,0,0); /* transparent; keeps backdrop visible */
}
  html, body {
  height: 100%;
  margin: 0;
  overflow: auto; /* Default: page scrolls normally */
}

/* When overlay is open, lock scroll */
body.all-tasks-overlay-active {
  overflow: hidden;
}

/* Fullscreen overlay stays fixed above page */
.all-tasks-overlay {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100dvh;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  z-index: 130;
}
  /* === FINAL CANONICAL SHEET STYLE (ACTIVE) === */
.all-tasks-overlay__sheet {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100dvh;
  margin: 0;
  max-width: none;
  max-height: none;
  border-radius: 0;
  overflow: hidden; /* only body scrolls */
  background: #0e0f12;
}

.all-tasks-overlay__body {
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}
  .all-tasks-overlay__body {
  scrollbar-gutter: stable both-edges;
  }

    .routine-launch-card {
      display: flex;
      justify-content: center;
      width: 100%;
    }

    .routine-launch-button {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 0.85rem;
      width: min(100%, 320px);
      padding: clamp(1rem, 4vw, 1.6rem);
      border-radius: 26px;
      background: rgba(15, 23, 32, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 180ms ease, background 180ms ease;
    }

    .routine-launch-button:hover,
    .routine-launch-button:focus-visible {
      background: rgba(24, 36, 48, 0.78);
      box-shadow: 0 18px 44px rgba(5, 12, 21, 0.5);
      transform: translateY(-2px);
    }

    .routine-launch-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(45, 212, 195, 0.6), 0 22px 48px rgba(5, 12, 21, 0.55);
    }

    .routine-launch-button__icon {
      width: clamp(72px, 16vw, 112px);
      aspect-ratio: 1;
      object-fit: contain;
      filter: drop-shadow(0 14px 26px rgba(4, 12, 22, 0.6));
    }

    .routine-launch-button__label {
      font-size: 1.05rem;
      letter-spacing: 0.01em;
    }

    .routine-overlay {
      position: fixed;
      inset: 0;
      z-index: 160;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1rem, 4vw, 2.4rem);
    }

    .routine-overlay__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(5, 12, 18, 0.78);
      backdrop-filter: blur(12px);
    }

    .routine-overlay__sheet {
      position: relative;
      z-index: 1;
      width: min(100%, 960px);
      max-height: calc(100dvh - 2 * clamp(1rem, 4vw, 2.4rem));
      border-radius: 28px;
      background: rgba(12, 18, 26, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 28px 70px rgba(2, 8, 18, 0.55);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .routine-overlay__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: clamp(1rem, 3vw, 1.6rem) clamp(1.2rem, 4vw, 2rem);
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    }

    .routine-overlay__title {
      margin: 0;
      font-size: clamp(1.35rem, 4vw, 1.7rem);
    }

    .routine-overlay__close {
      background: rgba(20, 30, 42, 0.85);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.45rem 1.2rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease;
    }

    .routine-overlay__close:hover,
    .routine-overlay__close:focus-visible {
      background: rgba(34, 48, 62, 0.9);
      color: #fff;
      outline: none;
    }

    .routine-overlay__body {
      padding: clamp(1rem, 3vw, 1.8rem);
      overflow-y: auto;
      scrollbar-gutter: stable;
    }

    .routine-overlay__body .routine-grid-shell {
      margin: 0 auto;
      width: min(100%, 720px);
    }

    body.routine-overlay-active {
      overflow: hidden;
    }

    @media (max-width: 720px) {
      .routine-overlay__sheet {
        width: var(--focus-shell-width);
        max-height: 100dvh;
        border-radius: 24px;
      }

      .routine-overlay__body {
        padding: clamp(0.85rem, 4vw, 1.4rem);
      }
    }

  </style>
</head>
<body>
  <div id="toastContainer" class="toast-container" aria-live="polite"></div>

  <section
    id="meltdownShield"
    class="meltdown-shield hidden"
    aria-live="polite"
    aria-label="Meltdown Shield Panel"
    aria-hidden="true"
  >
    <h4 class="meltdown-shield-header">🛡️ Meltdown Shield Activated</h4>
    <div id="meltdownShieldPrompt" class="meltdown-shield-prompt" aria-live="assertive"></div>
    <ul id="meltdownShieldSteps"></ul>
    <div class="meltdown-shield-actions">
      <button id="meltdownShieldNext" type="button">▶️ Next</button>
      <button type="button" onclick="deactivateShield()">❌ Close</button>
    </div>
  </section>

  <section id="capture">
    <div class="app-shell">
      <header class="app-header">
        <div class="app-header__top">
          <div class="app-header__date-block">
            <span class="app-header__meta-label">Today</span>
            <p id="headerDate" class="app-header__date"></p>
          </div>
          <div class="app-header__actions">
            <button
              id="settingsToggle"
              class="settings-trigger"
              type="button"
              aria-haspopup="true"
              aria-expanded="false"
              aria-controls="settingsMenu"
              title="Open settings"
            >
              ⚙️
            </button>
            <button
              id="headerQuickAddButton"
              class="quick-add-button quick-add-button--plus app-header__quick-add"
              type="button"
              aria-label="Add a new task"
              title="Add a task"
            >
              ➕️
            </button>
          </div>
        </div>
        <div class="app-header__main">
          <h1 class="app-header__title">Tasker 5000</h1>
          <p class="billing-reminder" id="billingReminder"></p>
          <p id="headerSubtitle" class="app-header__subtitle"></p>
        </div>
        <div id="settingsMenu" class="settings-menu" aria-hidden="true">
          <div class="settings-menu__section">
            <label class="settings-menu__toggle" for="routineHapticsToggle">
              <span>Enable haptic nudges</span>
              <input type="checkbox" id="routineHapticsToggle" />
            </label>
          </div>
          <button type="button" class="settings-menu__item" id="settingsTemplates">
            <span aria-hidden="true">🧩</span>
            <span>Templates</span>
          </button>
        </div>
      </header>
      <section class="card neuro-checklist-card" id="neuroChecklist" aria-live="polite"></section>
    </div>
  </section>
<!-- Legacy header block replaced by .focus-command-deck -->
<!--
<div class="starter-stack" id="starterStack">
  <div class="starter-micro-header" role="banner">
    <button
      id="nextTaskActionButton"
      class="btn hero-cta start-action next-task-start"
      type="button"
      aria-describedby="nextTaskActionHint"
    >
      Start 5-min
      <span id="nextTaskActionHint" class="visually-hidden">Long-press for quick capture.</span>
    </button>
    <div id="nextTaskChips" class="starter-fit-chips" aria-live="polite"></div>
    <button
      id="rescueLaunchButton"
      class="btn starter-rescue"
      type="button"
      aria-haspopup="dialog"
      aria-controls="sosOverlay"
      aria-expanded="false"
    >
      🛟 Rescue
    </button>
  </div>
</div>
-->
<section class="focus-command-deck" id="focus-command-deck" aria-label="Focus Command Deck">
  <div class="focus-top">
    <h2 class="focus-title">
      ⚔️ Focus Command Deck
      <a
        class="focus-title__link"
        href="https://docs.google.com/spreadsheets/d/1-kG9S5w_DX5TUFU9_MquWThrCBs1DnE-DKCzL_7Bx3I/edit?usp=drivesdk"
        target="_blank"
        rel="noopener noreferrer"
        aria-label="Open the Focus Command Deck schedule"
      >
        <img src="./Icons/excel-icon.svg" alt="" class="focus-title__icon" />
      </a>
    </h2>
    <div class="focus-meter" aria-label="Momentum Meter">
      <div class="focus-meter__header">
        <span class="meter-label">Momentum</span>
        <small class="meter-note">
          <span class="cm-done">12</span> / <span class="cm-total">57</span> complete
        </small>
      </div>
      <div class="progress-strip">
        <span class="cm-fill" style="width:21%"></span>
        <span class="cm-float" aria-live="polite">21% complete</span>
      </div>
    </div>
    <div class="focus-views" role="group" aria-label="Focus views">
      <button id="focusViewButton" class="focus-view-toggle" type="button">🔎 Focus view</button>
      <button id="visualWorkflowButton" class="focus-view-toggle" type="button">🌐 Visual workflow</button>
    </div>
  </div>
  <div id="focusBuddy" class="focus-buddy">
    <div class="focus-buddy__mode">
      <select id="sprintModeSelect">
        <option value="25">Classic 25 min</option>
        <option value="50">Deep 50 min</option>
        <option value="15">Quick 15 min</option>
      </select>
    </div>
    <div class="focus-buddy__timer"><span id="focusTimerDisplay">25:00</span></div>
    <div class="focus-buddy__controls">
      <button id="focusStartBtn">▶ Start Sprint</button>
      <button id="focusPauseBtn" disabled>⏸ Pause</button>
      <button id="focusEndBtn" disabled>⏹ End</button>
    </div>
  </div>
  <div class="focus-actions">
    <button
      id="nextTaskActionButton"
      class="hero-cta start-btn start-action"
      type="button"
      data-action="start-5"
      aria-describedby="nextTaskActionHint"
    >
      ▶ Start 5-Min Sprint
      <span id="nextTaskActionHint" class="visually-hidden">Long-press for quick capture.</span>
    </button>
    <button
      id="rescueLaunchButton"
      class="btn-quiet rescue-btn"
      type="button"
      data-action="rescue"
      aria-haspopup="dialog"
      aria-controls="sosOverlay"
      aria-expanded="false"
    >
      🛟 Rescue Mode
    </button>
    <button
      id="quickTaskShortcut"
      class="btn-quiet quick-task-shortcut"
      type="button"
      aria-controls="quickTasksCard"
    >
      ⏩ Quick Tasks
    </button>
    <button
      id="exportTasksBackupButton"
      class="btn-quiet task-backup-action"
      type="button"
    >
      💾 Export Tasks Backup
    </button>
    <button
      id="importTasksBackupButton"
      class="btn-quiet task-backup-action"
      type="button"
    >
      📂 Import Tasks Backup
    </button>
    <input type="file" id="importTasksBackupInput" accept="application/json" class="visually-hidden" />
    <button
      id="shredTopTaskButton"
      class="btn-quiet shred-top-task"
      type="button"
      aria-disabled="true"
      disabled
    >
      🔰 shred Top Task
    </button>
  </div>

  <footer class="focus-footer">
    <p class="focus-micro">💡 Tip: Five minutes is all you need to start momentum.</p>
  </footer>
</section>

<nav class="quick-add-menu" aria-label="Quick add templates">
  <p class="quick-add-menu__label">Quick Add</p>
  <div class="quick-add-menu__buttons" role="group" aria-label="Quick add buttons">
    <button class="quick-add-button quick-add-button--plus" type="button" aria-label="Quick add new task">➕️</button>
    <button class="quick-add-button quick-add-button--cherry" type="button" aria-label="Quick add cherry template">🍒</button>
    <button class="quick-add-button quick-add-button--muscle" type="button" aria-label="Quick add muscle template">💪</button>
    <button class="quick-add-button quick-add-button--unicorn" type="button" aria-label="Quick add unicorn template">🦄</button>
    <button class="quick-add-button quick-add-button--home" type="button" aria-label="Quick add home template">🏡</button>
    <button class="quick-add-button quick-add-button--kiddo" type="button" aria-label="Quick add kiddo template">🧒</button>
  </div>
</nav>

        <section id="nextTaskCard" class="card next-task-card hidden" aria-live="polite">
          <header class="card-head next-focus-head">
            <div class="next-focus-head__titles">
              <h2 class="focus-title">Next focus</h2>
              <p class="next-focus-hint">
                Next best: <span id="focusLaunchHint">Add a task to unlock focus.</span>
              </p>
            </div>
            <span id="nextTaskScore" class="chip chip-muted next-task-fit hidden"></span>
          </header>
          <span id="focus-engine" class="zone-anchor" aria-hidden="true"></span>
          <p id="nextTaskName" class="next-task-name"></p>
          <p id="nextTaskSubstep" class="next-task-meta"></p>
          <p id="nextTaskEmpty" class="next-task-empty hidden">You're clear for now. Add what matters next.</p>
          <div class="next-best-inline">
            <div class="next-best-toolbar" role="toolbar" aria-label="Next best options">
              <button id="nextBestRefresh" class="btn btn-ghost next-best-refresh" type="button">Refresh</button>
              <button
                id="nextBestAdjustToggle"
                class="quick-pill"
                type="button"
                aria-expanded="false"
                aria-controls="nextBestControls"
              >
                Adjust
              </button>
              <button id="nextBestStuck" class="quick-pill" type="button">I'm stuck</button>
            </div>
            <div id="nextBestControls" class="next-best-controls" hidden aria-hidden="true">
              <div class="next-best-controls__form">
                <label for="nextBestTime">
                  Time available
                  <select id="nextBestTime">
                    <option value="10">10 minutes</option>
                    <option value="15" selected>15 minutes</option>
                    <option value="20">20 minutes</option>
                    <option value="30">30 minutes</option>
                  </select>
                </label>
                <div class="next-best-energy">
                  <label for="nextBestEnergy">Energy right now</label>
                  <input
                    id="nextBestEnergy"
                    data-field="energy-level"
                    type="range"
                    min="1"
                    max="5"
                    step="1"
                    value="3"
                    aria-label="Energy right now"
                  />
                  <div class="next-best-meter">
                    <div class="next-best-meter__fill" id="nextBestEnergyFill"></div>
                    <div class="next-best-meter__scale">
                      <span aria-hidden="true">low</span>
                      <span aria-hidden="true">max</span>
                    </div>
                  </div>
                </div>
                <label for="nextBestDeadline">
                  Deadline urgency
                  <select id="nextBestDeadline"></select>
                </label>
                <label for="nextBestSize">
                  Task size
                  <select id="nextBestSize">
                    <option value="any" selected>Any size</option>
                    <option value="small">Quick win (&lt; 15 min)</option>
                    <option value="medium">Medium (15–30 min)</option>
                    <option value="large">Deep work (&gt; 30 min)</option>
                  </select>
                </label>
                <fieldset class="nbt-frictions">
                  <legend class="visually-hidden">Friction filters</legend>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="context" />
                    Needs certain location
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="conversation" />
                    Needs another person
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="energy" />
                    Energy heavy
                  </label>
                  <label>
                    <input type="checkbox" name="nextBestFriction" value="startup" />
                    High startup cost
                  </label>
                </fieldset>
              </div>
            </div>
            <div id="nextBestResults" class="next-best-results"></div>
            <p id="nextBestEmpty" class="next-best-empty hidden">Add a task to see your next best options.</p>
          </div>
        </section>
      
      <div class="momentum-zones">
        <section id="actionZone" class="momentum-zone" data-zone="action">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">⚡</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Action Zone</h2>
              <p class="zone-header__subtitle">Next best focus, active tasks, and due-today radar</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="tasks-zone" class="zone-anchor" aria-hidden="true"></span>
      <section class="card due-today-card hidden" aria-live="polite" data-due-today-section>
        <div class="section-heading">
          <h2>Due today</h2>
          <span class="chip chip-muted section-chip">Ready today</span>
        </div>
        <div class="due-today-accordion" data-open="false" data-accordion="dueToday">
          <button class="due-today-summary" type="button" aria-expanded="false" data-accordion-summary>
            <span data-due-today-summary-text>0 ready • est —</span>
            <span class="due-today-summary__icon" aria-hidden="true">▸</span>
          </button>
          <div class="due-today-list" hidden data-accordion-panel data-due-today-list></div>
        </div>
        <p class="due-today-empty hidden" data-due-today-empty>Nothing due today. You're caught up.</p>
      </section>
<section id="winLogHUD" class="winlog-hud hidden" role="dialog" aria-modal="true" aria-labelledby="winLogTitle">

<div class="winlog-card">

<h3 id="winLogTitle">Quick reflection</h3>

<p class="winlog-sub">What helped you restart?</p>

<div class="winlog-actions">

<button data-log="timer">Timer</button>

<button data-log="buddy">Buddy</button>

<button data-log="ritual">Ritual</button>

<button data-log="music">Music</button>

<button data-log="other">Other</button>

</div>

<input id="winLogNote" type="text" placeholder="Optional note…" />

<div class="winlog-footer">

<button id="winLogSave">Save</button>

<button id="winLogDismiss" class="secondary">Dismiss</button>
document.querySelectorAll(".neuro-checklist__item-label").forEach(label=>{
  label.addEventListener("click",()=>{
    const duration=parseInt(label.textContent.match(/\d+/)?.[0]||25,10);
    openOverlay("focusOverlay");        // existing helper
    startFocusSprint(duration);
  });
});
</div>

</div>

</section>
        <section
          id="routineOverlay"
          class="routine-overlay hidden"
          role="dialog"
          aria-modal="true"
          aria-hidden="true"
          aria-labelledby="routineOverlayTitle"
        >
          <div class="routine-overlay__backdrop" data-routine-overlay-dismiss></div>
          <div class="routine-overlay__sheet" role="document" tabindex="-1">
            <header class="routine-overlay__header">
              <h2 id="routineOverlayTitle" class="routine-overlay__title">Healthy Habits Routines</h2>
              <button type="button" class="routine-overlay__close" data-routine-overlay-close>Close</button>
            </header>
            <div class="routine-overlay__body">
            <div class="routine-stack" id="routineTileStack">
                    <div class="routine-grid-shell">
                      <div class="routine-feature-grid recovery-routines-container">
                        <article
                          id="morningLaunchModule"
                          class="routine-tile"
                          data-module-id="morningLaunchModule"
                          data-routine-id="morning"
                          role="group"
                          aria-label="AM Start"
                        >
                          <div class="routine-tile__surface routine-theme--morning" data-routine-surface>
                            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                              <span class="routine-accent" aria-hidden="true">
                                <span class="routine-accent__icon" data-accent-icon>🌅</span>
                              </span>
                              <div class="routine-tile__info">
                                <span class="routine-tile__title" data-routine-title>🌅 AM Start</span>
                                <span class="routine-tile__prompt" data-routine-prompt>Ready for takeoff? Start your day ritual.</span>
                              </div>
                              <div class="routine-tile__meta">
                                <span class="routine-info-dot" title="Prime your brain for dopamine, cortisol, and clarity with a 60-minute guided ramp into the day." aria-hidden="true">i</span>
                                <span class="routine-reminder" data-routine-reminder></span>
                                <span class="routine-tile__chevron" aria-hidden="true"></span>
                              </div>
                            </button>
                            <div class="routine-quick-overlay" data-routine-quick-overlay>
                              <div class="routine-quick-overlay__content">
                                <h3 class="routine-quick-overlay__title">AM Start Preview</h3>
                                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                              </div>
                            </div>
                            <div class="routine-tile__body" data-routine-body hidden>
                              <div class="routine-tile__actions">
                                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                                <div class="routine-quick-actions" role="group" aria-label="AM Start quick actions">
                                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                                </div>
                              </div>
                              <div class="routine-tile__content">
                                <div class="module-body" data-routine-content>
                                  <div class="module-toggle">
                                    <label for="morningLaunchToggle">Enable Morning Launch</label>
                                    <input type="checkbox" id="morningLaunchToggle" />
                                  </div>
                                  <div class="routine-affirmation">No-phone pledge: leave your device in another room overnight and wake up with an analog alarm.</div>
                                  <div id="morningLaunchContent" class="hidden" aria-hidden="true">
                                    <div class="progress-strip" aria-hidden="true">
                                      <span id="morningLaunchProgress"></span>
                                    </div>
                                    <div id="morningLaunchStatus" class="score"></div>
                                    <div class="module-inline-actions">
                                      <button id="morningLaunchResetBtn" type="button">Reset morning blocks</button>
                                      <button id="morningLaunchSkipBtn" type="button">Skip today</button>
                                    </div>
                                    <div class="morning-blocks">
                                      <article class="routine-block" data-block="move">
                                        <h3>MOVE — Light Aerobic + Sunlight</h3>
                                        <small>Take a brisk walk, 50 jumping jacks, and soak in 5 minutes of direct sunlight.</small>
                                        <div class="countdown-display" id="moveCountdown">20:00</div>
                                        <div class="module-inline-actions">
                                          <button id="moveStartBtn" type="button">Start 20-min timer</button>
                                          <button id="moveCompleteBtn" type="button">Mark MOVE complete</button>
                                        </div>
                                      </article>
                                      <article class="routine-block" data-block="reflect">
                                        <h3>REFLECT — Cold Splash + Intention</h3>
                                        <small>Reset with a cold rinse, then name the tone for your day.</small>
                                        <div class="intention-buttons">
                                          <button type="button" data-intention="Calm &amp; steady">Calm &amp; steady</button>
                                          <button type="button" data-intention="Playful &amp; connected">Playful &amp; connected</button>
                                          <button type="button" data-intention="Focused craftsmanship">Focused craftsmanship</button>
                                        </div>
                                        <label for="morningIntention" style="margin:0;">
                                          <textarea id="morningIntention" rows="2" placeholder="How do I want today to feel? What would make it meaningful?" style="margin-top:0.35rem;"></textarea>
                                        </label>
                                        <div class="module-inline-actions">
                                          <button id="reflectCompleteBtn" type="button">Save intention</button>
                                        </div>
                                      </article>
                                      <article class="routine-block" data-block="plan">
                                        <h3>PLAN — Process Anchors</h3>
                                        <small>Lock in process-based actions and block time before the day takes over.</small>
                                        <textarea id="morningPlanNotes" rows="2" placeholder="Ex: Draft progress notes for 2 patients before noon."></textarea>
                                        <div class="module-inline-actions">
                                          <button id="planCompleteBtn" type="button">Plan locked in</button>
                                        </div>
                                      </article>
                                    </div>
                                    <div class="energy-rating">
                                      <label for="morningEnergy" style="margin:0;">Energy check-in</label>
                                      <input id="morningEnergy" data-field="energy-level" type="range" min="1" max="5" step="1" value="3" />
                                      <span id="morningEnergyLabel">--</span>
                                      <button id="morningEnergySave" type="button">Log energy</button>
                                    </div>
                                    <div class="morning-chart-wrapper">
                                      <canvas
                                        id="morningLaunchChart"
                                        class="chart-canvas"
                                        width="360"
                                        height="160"
                                        role="img"
                                        aria-label="Line chart of morning launch completion and energy trends"
                                      ></canvas>
                                      <div class="chart-legend" aria-hidden="true">
                                        <span><span class="legend-swatch completion"></span>Ready progress</span>
                                        <span><span class="legend-swatch energy"></span>Energy (1–5 scaled)</span>
                                      </div>
                                      <div id="morningLaunchChartSummary" class="module-note"></div>
                                    </div>
                                    <ul id="morningLaunchHistory" class="history-list" aria-live="polite"></ul>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </article>

                        <article
                          id="launchPadModule"
                          class="routine-tile"
                          data-module-id="launchPadModule"
                          data-routine-id="environment"
                          role="group"
                          aria-label="Launch Pad"
                        >
                          <div class="routine-tile__surface routine-theme--environment" data-routine-surface>
                            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                              <span class="routine-accent" aria-hidden="true">
                                <span class="routine-accent__icon" data-accent-icon>🚀</span>
                              </span>
                              <div class="routine-tile__info">
                                <span class="routine-tile__title" data-routine-title>🚀 Launch Pad</span>
                                <span class="routine-tile__prompt" data-routine-prompt>Tap to reset your surroundings.</span>
                              </div>
                              <div class="routine-tile__meta">
                                <span class="routine-info-dot" title="Curate a nightly launch pad so tomorrow starts calm, stocked, and on time." aria-hidden="true">i</span>
                                <span class="routine-reminder" data-routine-reminder></span>
                                <span class="routine-tile__chevron" aria-hidden="true"></span>
                              </div>
                            </button>
                            <div class="routine-quick-overlay" data-routine-quick-overlay>
                              <div class="routine-quick-overlay__content">
                                <h3 class="routine-quick-overlay__title">Launch Pad Preview</h3>
                                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                              </div>
                            </div>
                            <div class="routine-tile__body" data-routine-body hidden>
                              <div class="routine-tile__actions">
                                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                                <div class="routine-quick-actions" role="group" aria-label="Launch Pad quick actions">
                                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                                </div>
                              </div>
                              <div class="routine-tile__content">
                                <div class="module-body" data-routine-content>
                                  <div class="module-toggle">
                                    <label for="launchPadReminderTime">Reminder time</label>
                                    <input type="time" id="launchPadReminderTime" />
                                  </div>
                                  <div class="launch-pad-summary" id="launchPadSummary"></div>
                                  <div class="module-inline-actions">
                                    <button id="openLaunchPadModal" type="button">Evening checklist</button>
                                    <button id="launchPadMorningReview" type="button">Morning review</button>
                                  </div>
                                  <div class="launch-pad-settings">
                                    <label for="launchPadSiteSelect">Clinic / environment
                                      <select id="launchPadSiteSelect"></select>
                                    </label>
                                    <div class="module-inline-actions">
                                      <input type="text" id="launchPadNewItem" placeholder="Add launch pad item" />
                                      <button id="launchPadAddItem" type="button">Add Item</button>
                                      <button id="launchPadLoadPreset" type="button">Reset to preset</button>
                                    </div>
                                    <div id="launchPadItemList" class="launch-pad-list" aria-live="polite"></div>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </article>

                        <article
                          id="sleepToolkitModule"
                          class="routine-tile"
                          data-module-id="sleepToolkitModule"
                          data-routine-id="sleep"
                          role="group"
                          aria-label="Sleep Toolkit"
                        >
                          <div class="routine-tile__surface routine-theme--sleep" data-routine-surface>
                            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                              <span class="routine-accent" aria-hidden="true">
                                <span class="routine-accent__icon" data-accent-icon>😴</span>
                              </span>
                              <div class="routine-tile__info">
                                <span class="routine-tile__title" data-routine-title>😴 Sleep Toolkit</span>
                                <span class="routine-tile__prompt" data-routine-prompt>Wind down mode is ready.</span>
                              </div>
                              <div class="routine-tile__meta">
                                <span class="routine-info-dot" title="Stabilize melatonin and cortisol rhythms with gentle wind-down and light cues." aria-hidden="true">i</span>
                                <span class="routine-reminder" data-routine-reminder></span>
                                <span class="routine-tile__chevron" aria-hidden="true"></span>
                              </div>
                            </button>
                            <div class="routine-quick-overlay" data-routine-quick-overlay>
                              <div class="routine-quick-overlay__content">
                                <h3 class="routine-quick-overlay__title">Sleep Toolkit Preview</h3>
                                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                              </div>
                            </div>
                            <div class="routine-tile__body" data-routine-body hidden>
                              <div class="routine-tile__actions">
                                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                                <div class="routine-quick-actions" role="group" aria-label="Sleep Toolkit quick actions">
                                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                                </div>
                              </div>
                              <div class="routine-tile__content">
                                <div class="module-body" data-routine-content>
                                  <div class="module-toggle">
                                    <label for="sleepToolkitToggle">Enable toolkit</label>
                                    <input type="checkbox" id="sleepToolkitToggle" />
                                  </div>
                                  <div id="sleepToolkitContent" class="hidden" aria-hidden="true">
                                    <div class="sleep-checklist" id="sleepChecklist"></div>
                                    <div id="sleepCompletionSummary" class="sleep-summary"></div>
                                    <div id="sleepMorningRating" class="energy-rating"></div>
                                    <div id="sleepCorrelationSummary" class="sleep-summary"></div>
                                    <div class="sleep-tips" id="sleepTips"></div>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </article>

                        <article
                          id="dopamineModule"
                          class="routine-tile"
                          data-module-id="dopamineModule"
                          data-routine-id="dopamine"
                          role="group"
                          aria-label="Dopa-Me"
                        >
                          <div class="routine-tile__surface routine-theme--dopamine" data-routine-surface>
                            <button class="routine-tile__trigger" type="button" aria-expanded="false" role="button" data-routine-trigger>
                              <span class="routine-accent" aria-hidden="true">
                                <span class="routine-accent__icon" data-accent-icon>🎵</span>
                              </span>
                              <div class="routine-tile__info">
                                <span class="routine-tile__title" data-routine-title>🎵 Dopa-Me</span>
                                <span class="routine-tile__prompt" data-routine-prompt>Train focus with a 5-min win.</span>
                              </div>
                              <div class="routine-tile__meta">
                                <span class="routine-info-dot" title="Stretch reward intervals with a playlist of micro-celebrations." aria-hidden="true">i</span>
                                <span class="routine-reminder" data-routine-reminder></span>
                                <span class="routine-tile__chevron" aria-hidden="true"></span>
                              </div>
                            </button>
                            <div class="routine-quick-overlay" data-routine-quick-overlay>
                              <div class="routine-quick-overlay__content">
                                <h3 class="routine-quick-overlay__title">Dopa-Me Preview</h3>
                                <ol class="routine-quick-overlay__list" data-quick-preview></ol>
                                <button class="routine-quick-overlay__action" type="button" data-quick-launch>Quick Launch</button>
                              </div>
                            </div>
                            <div class="routine-tile__body" data-routine-body hidden>
                              <div class="routine-tile__actions">
                                <button class="routine-start-btn start-action" type="button" data-routine-start>Start Routine</button>
                                <div class="routine-quick-actions" role="group" aria-label="Dopa-Me quick actions">
                                  <button class="routine-chip" type="button" data-quick-action="refresh">Refresh</button>
                                  <button class="routine-chip" type="button" data-quick-action="adjust">Adjust</button>
                                  <button class="routine-chip" type="button" data-quick-action="stuck">I'm stuck</button>
                                </div>
                              </div>
                              <div class="routine-tile__content">
                                <div class="module-body" data-routine-content>
                                  <div class="dopamine-playlist">
                                    <label for="dopamineReward">Reward style
                                      <select id="dopamineReward">
                                        <option value="music">Music stinger</option>
                                        <option value="confetti">GIF confetti</option>
                                        <option value="coin">Coin sound</option>
                                        <option value="stretch">Stretch cue</option>
                                      </select>
                                    </label>
                                    <div class="dopamine-intervals" id="dopamineIntervals" aria-live="polite"></div>
                                    <div class="dopamine-progress" aria-hidden="true">
                                      <span id="dopamineProgressFill"></span>
                                    </div>
                                    <div class="conflict-actions">
                                      <button id="dopamineStart" type="button" class="btn btn-primary">Start playlist</button>
                                      <button id="dopamineStop" type="button" class="btn btn-ghost" disabled>Stop</button>
                                    </div>
                                    <div id="dopamineStatus" class="score" aria-live="polite"></div>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </article>
                      </div>
                    </div>

                  </div>
            </div>
          </div>
        </section>
<!-- === Phase 5 – Weekly Insights Overlay === -->
<section id="insightOverlay" class="insight-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="insightTitle">
  <div class="insight-card">
    <h3 id="insightTitle">Weekly Insights</h3>
    <canvas id="insightChart" width="360" height="180"></canvas>
    <div id="insightStats" class="insight-stats"></div>
    <div class="insight-footer">
      <button id="closeInsights">Close</button>
    </div>
  </div>
</section>

      <section class="card quick-tasks-card hidden" aria-live="polite" data-quick-tasks-card id="quickTasksCard">
        <span id="quickTasksAnchor" class="zone-anchor" aria-hidden="true"></span>
        <header class="quick-tasks-header">
          <h2 class="focus-title">Quick Tasks</h2>
        </header>
        <p class="quick-task-empty hidden" id="quickTaskEmpty">No quick tasks yet.</p>
        <div class="quick-task-list" id="quickTaskList" role="list"></div>
      </section>

          </div>
        </section>
        <section id="recoveryZone" class="momentum-zone" data-zone="recovery">
          <header class="zone-header" data-zone-tab>
            <span class="zone-header__icon" aria-hidden="true">🌙</span>
            <div class="zone-header__text">
              <h2 class="zone-header__title">Recovery Zone</h2>
              <p class="zone-header__subtitle">Resolve conflicts, reset your nervous system, refuel dopamine</p>
            </div>
          </header>
          <div class="zone-body">
            <span id="reset-zone" class="zone-anchor" aria-hidden="true"></span>
            
      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>
      </div>

  <div
    id="templatesOverlay"
    class="modal-overlay hidden templates-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="templatesOverlayTitle"
  >
    <div class="modal-card templates-card" role="document">
      <div class="modal-card__header">
        <h3 id="templatesOverlayTitle">🧩 Templates</h3>
        <button id="templatesOverlayClose" class="modal__close" type="button" aria-label="Close templates">✕</button>
      </div>
      <div class="templates-overlay__body">
        <div class="template-module__actions">
          <button id="blockBatchOpen" class="btn btn-secondary" type="button">Block Batch</button>
        </div>
        <div id="templateButtons"></div>
      </div>
    </div>
  </div>

  <div
    id="conflictOverlay"
    class="modal-overlay hidden conflict-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="conflictOverlayTitle"
  >
    <div class="modal-card conflict-card" role="document">
      <div class="modal-card__header">
        <h3 id="conflictOverlayTitle">🥊 3-v-3 Conflict Resolver</h3>
        <button id="conflictOverlayClose" class="modal__close" type="button" aria-label="Close conflict resolver">✕</button>
      </div>
      <div class="conflict-overlay__body" id="conflictResolverModule">
        <div class="conflict-grid">
          <div class="conflict-column">
            <h3>Top 3 should-do</h3>
            <div id="conflictShouldList" class="conflict-list" aria-live="polite"></div>
          </div>
          <div class="conflict-column">
            <h3>Top 3 want-to</h3>
            <div id="conflictWantList" class="conflict-list" aria-live="polite"></div>
          </div>
        </div>
        <div
          id="conflictArena"
          class="conflict-arena"
          role="application"
          aria-live="polite"
          aria-label="Drag contenders here"
        >
          <div id="conflictArenaPrompt">Drag a contender from each side into the arena.</div>
        </div>
        <div class="conflict-actions">
          <button id="conflictReset" type="button" class="btn btn-ghost">Reset arena</button>
        </div>
        <div id="conflictResult" class="score" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <div id="template-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="templateModalTitle">
    <div class="modal__content">
      <div class="modal__head"><strong id="templateModalTitle">Choose a template</strong><button class="modal__close" type="button">✕</button></div>
      <div class="template-grid" id="template-grid"></div>
    </div>
  </div>

  <div
    id="block-batch-modal"
    class="modal hidden"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="blockBatchModalTitle"
  >
    <div class="modal__content">
      <div class="modal__head">
        <strong id="blockBatchModalTitle">Block Batch Menu</strong>
        <button class="modal__close" type="button">✕</button>
      </div>
      <div class="block-batch-layout">
        <div class="block-batch-list" id="blockBatchList" role="listbox" aria-label="Batch types"></div>
        <div>
          <div class="block-batch-counts" id="blockBatchCounts"></div>
          <div id="blockBatchEditor" class="block-batch-editor hidden" aria-live="polite">
            <div class="block-batch-editor__head">
              <h3 id="blockBatchEditorTitle">Edit default profile</h3>
              <button type="button" class="link-button" id="blockBatchEditorClose">Done</button>
            </div>
            <div class="block-batch-editor__grid">
              <label for="blockBatchCategory">Category
                <select id="blockBatchCategory">
                  <option value="General">General</option>
                  <option value="Admin">Admin</option>
                  <option value="Chart">Chart</option>
                  <option value="Inbox">Inbox</option>
                  <option value="Calls">Calls</option>
                  <option value="Teaching">Teaching</option>
                  <option value="Personal">Personal</option>
                </select>
              </label>
              <label for="blockBatchAuthor">Chart Author
                <select id="blockBatchAuthor">
                  <option value="attending">Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="blockBatchPatient">Patient Type
                <select id="blockBatchPatient">
                  <option value="Non-Complex">Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="blockBatchVisit">Visit Type
                <select id="blockBatchVisit">
                  <option value="Follow-Up">Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="blockBatchClinic">Clinic Site
                <select id="blockBatchClinic">
                  <option value="General Clinic">General Clinic</option>
                  <option value="St PJ’s Shelter">St PJ’s Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="blockBatchImportance">Importance (1–5)
                <select id="blockBatchImportance">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchUrgency">Urgency (1–5)
                <select id="blockBatchUrgency">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchNovelty">Novelty (1–5)
                <select id="blockBatchNovelty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchInterest">Interest (1–5)
                <select id="blockBatchInterest">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchExternalPressure">External Pressure (1–5)
                <select id="blockBatchExternalPressure">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchTimeToStart">Time to Start (1–5)
                <select id="blockBatchTimeToStart">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
              <label for="blockBatchDifficulty">Difficulty (1–5)
                <select id="blockBatchDifficulty">
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                </select>
              </label>
            </div>
            <label for="blockBatchSubtasks">Default subtasks
              <textarea id="blockBatchSubtasks" placeholder="One subtask per line"></textarea>
            </label>
            <label class="sound-toggle" for="blockBatchUseChartTemplate">
              <input type="checkbox" id="blockBatchUseChartTemplate" /> Use chart smart defaults
            </label>
            <div class="block-batch-editor__actions">
              <button id="blockBatchResetProfile" type="button" class="btn btn-ghost">Reset to default</button>
              <button id="blockBatchSaveProfile" type="button" class="btn btn-primary">Save profile</button>
            </div>
          </div>
        </div>
      </div>
      <div class="block-batch-footer">
        <label for="blockBatchDate">Service date
          <input type="date" id="blockBatchDate" />
        </label>
        <button id="blockBatchAdd" class="btn btn-primary" type="button">Add</button>
      </div>
    </div>
  </div>

  <div id="firstThreeWizard" class="wizard-overlay hidden" aria-hidden="true">
    <div class="wizard-content" role="dialog" aria-modal="true" aria-labelledby="firstThreeTitle">
      <h3 id="firstThreeTitle">🪜 First-Three-Steps Wizard</h3>
      <p>Break the project into tiny, guaranteed-win actions to get moving.</p>
      <div class="wizard-steps">
        <label>Step 1
          <input type="text" id="firstThreeStep1" placeholder="Open patient chart" />
        </label>
        <label>Step 2
          <input type="text" id="firstThreeStep2" placeholder="Skim last visit notes" />
        </label>
        <label>Step 3
          <input type="text" id="firstThreeStep3" placeholder="Draft first paragraph" />
        </label>
      </div>
      <div class="wizard-actions">
        <button id="firstThreeSkip" type="button">Skip for this task</button>
        <button id="firstThreeCancel" type="button">Cancel</button>
        <button id="firstThreeSave" type="button">Save steps</button>
      </div>
    </div>
  </div>

  <div id="launchPadModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="launchPadModalTitle">
      <h3 id="launchPadModalTitle">🚀 Prep Tomorrow's Launch Pad</h3>
      <p>Gather items tonight so future-you can walk out the door calm.</p>
      <div id="launchPadModalList" class="sleep-checklist" aria-live="polite"></div>
      <div class="modal-actions">
        <button id="launchPadModalClose" type="button">Done</button>
      </div>
    </div>
  </div>

  <div id="quickCaptureOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="quickCaptureTitle">
      <h3 id="quickCaptureTitle">✍️ Quick capture</h3>
      <label for="quickCaptureInput">Task name
        <input id="quickCaptureInput" type="text" placeholder="What's the very next action?" />
      </label>
      <div class="modal-actions">
        <button id="quickCaptureCancel" type="button" class="btn btn-ghost">Cancel</button>
        <button id="quickCaptureSave" type="button" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <div id="addTaskOverlay" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal-card modal-card--wide" role="dialog" aria-modal="true" aria-labelledby="addTaskTitle">
      <div class="modal-scroll-content modal-scroll-content--task-builder">
        <header class="modal-card__header">
          <h3 id="addTaskTitle">Add task</h3>
          <button id="addTaskClose" class="modal__close" type="button" aria-label="Close task builder">✕</button>
        </header>
        <div class="card-body" id="addTaskCardBody" aria-hidden="false">
          <div class="task-form-group">
            <span class="task-form-group__label">New task</span>
            <p id="quickTaskTemplateHint" class="quick-task-hint hidden">Quick task mode: name it and tap Add.</p>
            <label for="name">Task name
              <input id="name" type="text" placeholder="3/14 – J.M. – Complex Care Follow-Up (Resident)" />
            </label>
            <label><input id="humorizeName" type="checkbox"> Playful name</label>
            <label for="taskCategory">Category
              <select id="taskCategory">
                <option value="General" selected>General</option>
                <option value="Admin">Admin</option>
                <option value="Chart">Chart</option>
                <option value="Inbox">Inbox</option>
                <option value="Calls">Calls</option>
                <option value="Teaching">Teaching</option>
                <option value="Personal">Personal</option>
                <option value="Quick Task">Quick Task</option>
              </select>
            </label>
            <div class="task-inline-actions" aria-label="Task helpers">
              <button type="button" class="link-button" id="btn-use-template">Use template</button>
              <button type="button" class="link-button" id="btn-save-template">Add as template</button>
              <button
                type="button"
                class="link-button"
                id="expandTaskDetailsButton"
                aria-controls="taskDetails"
                aria-expanded="false"
              >
                Show details
              </button>
            </div>
          <div id="taskDetails" class="task-details-panel" data-collapsed="true">
            <div id="chartFields" class="chart-fields is-hidden" aria-hidden="true">
              <label for="authorType">Chart Author
                <select id="authorType">
                  <option value="attending" selected>Attending</option>
                  <option value="resident">Resident</option>
                </select>
              </label>
              <label for="patientType" title="Complex = medically fragile, multi-specialty, or DME-dependent.">Patient Type
                <select id="patientType">
                  <option value="Non-Complex" selected>Non-Complex</option>
                  <option value="Complex">Complex</option>
                </select>
              </label>
              <label for="visitType" title="Determines estimated chart complexity and time to complete.">Visit Type
                <select id="visitType">
                  <option value="Follow-Up" selected>Follow-Up</option>
                  <option value="Establish Care">Establish Care</option>
                  <option value="Well Child Visit">Well Child Visit</option>
                  <option value="Acute Visit">Acute Visit</option>
                </select>
              </label>
              <label for="clinicSite" title="Same-day notes from St PJ’s or Craniofacial automatically rise to the top.">Clinic Site
                <select id="clinicSite">
                  <option value="General Clinic" selected>General Clinic</option>
                  <option value="St PJ’s Shelter">St PJ’s Shelter</option>
                  <option value="Craniofacial Clinic">Craniofacial Clinic</option>
                </select>
              </label>
              <label for="dateOfService" title="Select the date of the encounter; defaults to today.">Date of Service
                <input type="date" id="dateOfService" />
              </label>
              <small id="chartAgeDisplay" class="chart-age"></small>
            </div>
            <label for="importance">Importance (1–5) <select id="importance"></select></label>
            <label for="urgency">Urgency (1–5)
              <select id="urgency"></select>
            </label>
            <small id="urgencyHint" class="urgency-hint"></small>
            <label for="novelty">Novelty (1–5) <select id="novelty"></select></label>
            <label for="interest">Interest (1–5) <select id="interest"></select></label>
            <label for="externalPressure">External Pressure (1–5)
              <select id="externalPressure"></select>
            </label>
            <label for="timeToStart">Time to Start (1–5) <select id="timeToStart"></select></label>
            <label for="difficulty">Difficulty (1–5) <select id="difficulty"></select></label>
            <label for="dueDate" title="Optional specific target date; used for personal scheduling.">Due Date (Optional)
              <input type="date" id="dueDate" />
            </label>
            <label for="initialSubTasks">Subtasks
              <textarea id="initialSubTasks" rows="3" placeholder="One subtask per line."></textarea>
            </label>
            <label class="sound-toggle" for="focusSoundToggle">
              <input type="checkbox" id="focusSoundToggle" checked />
              Enable focus mode ping
            </label>
          </div>
        </div>
      </div>
      <div class="card-sticky-actions" aria-hidden="false">
        <div class="card-sticky-actions__primary">
          <button id="addTaskBtn" class="btn btn-primary" type="button" onclick="addTask()">Add Task</button>
          <button id="saveUpdateBtn" class="btn btn-primary hidden" type="button" onclick="saveTaskUpdate()">Save Update</button>
          <button id="cancelEditBtn" class="btn btn-ghost hidden" type="button" onclick="cancelEdit()">Cancel</button>
        </div>
      </div>
      </div>
    </div>
  </div>
</div>

  <div id="focusLaunchBackdrop" class="focus-sheet__backdrop" hidden></div>
  <section
    id="focusLaunchSheet"
    class="focus-sheet"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="focusLaunchTitle"
  >
    <button id="focusLaunchHandle" class="focus-sheet__handle" type="button" aria-label="Close focus launcher"></button>
    <div class="focus-sheet__content">
      <header class="focus-sheet__header">
        <h2 id="focusLaunchTitle">Start Focus</h2>
        <p class="focus-sheet__preview">
          Next suggested: <span id="focusSuggestionText">Add a task to unlock focus.</span>
        </p>
      </header>
      <div class="focus-sheet__options">
        <button
          type="button"
          class="focus-sheet__option focus-sheet__option--primary start-action"
          data-focus-mode="sprint"
        >
          5-min Sprint
        </button>
        <button type="button" class="focus-sheet__option" data-focus-mode="session">Full Session</button>
        <button
          type="button"
          id="focusSuggestionButton"
          class="focus-sheet__option focus-sheet__option--suggestion"
          data-focus-mode="suggestion"
          disabled
          aria-disabled="true"
        >
          <span class="focus-sheet__option-label">Next Suggested Task</span>
          <span id="focusSuggestionDetail" class="focus-sheet__option-detail">Add a task to unlock focus.</span>
        </button>
      <div id="routineEditSheet" class="routine-sheet" role="dialog" aria-modal="true" aria-labelledby="routineEditTitle">
        <div class="routine-sheet__scrim" data-routine-sheet-dismiss></div>
        <div class="routine-sheet__panel" role="document">
          <h3 id="routineEditTitle" class="routine-sheet__title">Edit routine</h3>
          <div class="routine-sheet__field">
            <label for="routineNameInput">Routine name</label>
            <input id="routineNameInput" type="text" autocomplete="off" />
          </div>
          <div class="routine-sheet__field">
            <label for="routineStepsInput">Steps (one per line)</label>
            <textarea id="routineStepsInput" rows="4"></textarea>
          </div>
          <div class="routine-sheet__field">
            <label for="routineQuickSelect">Default quick launch</label>
            <select id="routineQuickSelect"></select>
          </div>
          <div class="routine-sheet__field">
            <label for="routineReminderTime">Reminder time</label>
            <input id="routineReminderTime" type="time" />
          </div>
          <div class="routine-sheet__field">
            <label class="routine-preferences__toggle" for="routineHapticsInSheet">
              <input type="checkbox" id="routineHapticsInSheet" />
              <span class="routine-preferences__label">Enable haptic nudges</span>
            </label>
          </div>
          <div class="routine-sheet__actions">
            <button type="button" class="routine-sheet__cancel" data-routine-sheet-cancel>Cancel</button>
            <button type="button" class="routine-sheet__save" data-routine-sheet-save>Save</button>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>

  <section class="card schedule-card" id="weeklyScheduleCard" aria-label="Weekly clinic schedule">
    <div class="schedule-card__header">
      <div class="schedule-card__title-group">
        <h2 class="schedule-card__title">Care I will Provide Today</h2>
        <div class="schedule-card__mode-buttons" data-schedule-mode></div>
      </div>
    </div>
    <div class="schedule-card__content">
      <div class="schedule-card__column schedule-card__column--schedule">
        <header class="schedule-card__column-head">
          <h3 class="schedule-card__column-title">Patient schedule</h3>
          <span class="schedule-card__column-meta" data-schedule-summary>—</span>
        </header>
        <div class="schedule-card__grid-wrapper">
          <div
            class="weekly-grid"
            id="weeklyScheduleGrid"
            data-weekly-grid
            role="grid"
            aria-label="Clinic schedule for selected day"
          ></div>
        </div>
      </div>
      <aside class="schedule-card__column schedule-card__column--basket">
        <div class="clinic-basket" data-clinic-basket>
          <header class="clinic-basket__header">
            <h3 class="clinic-basket__title">Clinic Basket</h3>
            <time class="clinic-basket__updated" data-clinic-basket-updated datetime="">last updated —</time>
          </header>
          <form class="clinic-basket__list" data-clinic-basket-form>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Patient Calls</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="patientCalls"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Results Follow up</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="resultsFollowUp"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Results</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="results"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Chart Completion</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="chartCompletion"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Patient Advice</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="patientAdvice"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Pending Orders</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="pendingOrders"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Hospital Admits</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="hospitalAdmits"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">CC'd charts</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="ccdCharts"
                />
              </span>
            </label>
            <label class="clinic-basket__row">
              <span class="clinic-basket__label">Staff Messages</span>
              <span class="clinic-basket__value">
                <input
                  class="clinic-basket__input"
                  type="number"
                  min="0"
                  step="1"
                  inputmode="numeric"
                  pattern="[0-9]*"
                  value="0"
                  data-basket-input="staffMessages"
                />
              </span>
            </label>
          </form>
          <p class="clinic-basket__hint">Numbers save automatically when updated.</p>
        </div>
      </aside>
    </div>
    <div
      class="day-overlay"
      data-day-overlay
      role="dialog"
      aria-modal="true"
      tabindex="-1"
      hidden
    >
      <div class="day-overlay__dialog" role="document">
        <button
          type="button"
          class="day-overlay__close"
          data-day-overlay-close
          aria-label="Close day overlay"
        >
          &times;
        </button>
        <header class="day-overlay__header">
          <h3 class="day-overlay__title" data-day-overlay-title></h3>
          <p class="day-overlay__subtitle" data-day-overlay-subtitle></p>
        </header>
        <div class="day-overlay__slots" data-day-overlay-slots></div>
        <div class="day-overlay__actions">
          <button type="button" class="day-overlay__add-patient" data-day-overlay-add-patient>
            + Add patient
          </button>
          <button type="button" class="day-overlay__confirm" data-day-overlay-confirm>
            Confirm Patients
          </button>
        </div>
      </div>
    </div>
  </section>

  <div id="resourcesBackdrop" class="drawer-backdrop" hidden></div>
  <aside
    id="resourcesDrawer"
    class="resources-drawer"
    aria-hidden="true"
    aria-labelledby="resourcesTitle"
    data-view="list"
    tabindex="-1"
  >
    <header class="resources-drawer__header">
      <h2 id="resourcesTitle">Quick Access Partners</h2>
      <div class="resources-drawer__actions">
        <button id="resourcesClose" class="resources-drawer__close" type="button" aria-label="Close resources">✕</button>
        <button
          id="resourcesViewToggle"
          class="resources-drawer__toggle"
          type="button"
          aria-label="Add a resource"
        >📘</button>
      </div>
    </header>
    <div class="resources-drawer__body" data-resources-list></div>
    <form id="addResourceForm" class="resources-drawer__form" autocomplete="off">
      <fieldset>
        <legend>Add a quick link</legend>
        <label for="resourceTitle">Resource title
          <input id="resourceTitle" name="resourceTitle" type="text" required placeholder="Example: Clinic Handbook" />
        </label>
        <label for="resourceUrl">Link URL
          <input id="resourceUrl" name="resourceUrl" type="url" required placeholder="https://" inputmode="url" />
        </label>
        <label for="resourceLabel">Badge label (optional)
          <input id="resourceLabel" name="resourceLabel" type="text" maxlength="32" placeholder="e.g., workflow" />
        </label>
        <label for="resourceDescription">Description (optional)
          <textarea id="resourceDescription" name="resourceDescription" rows="2" placeholder="What will this link help with?" maxlength="160"></textarea>
        </label>
        <label for="resourceTheme">Accent color
          <select id="resourceTheme" name="resourceTheme">
            <option value="custom" selected>Custom</option>
            <option value="planning">Planning</option>
            <option value="strategies">Strategies</option>
            <option value="digest">Digest</option>
            <option value="vault">Vault</option>
          </select>
        </label>
      </fieldset>
      <p class="resources-drawer__form-message" data-resource-form-message aria-live="polite"></p>
      <div class="resources-drawer__form-actions">
        <button type="submit">Add item</button>
      </div>
    </form>
  </aside>

  <div
    id="sosOverlay"
    class="sos-overlay hidden"
    role="dialog"
    aria-modal="true"
    aria-labelledby="sosOverlayTitle"
  >
    <div class="sos-card">
      <header class="sos-card__header">
        <h2 id="sosOverlayTitle">Crisis Support</h2>
        <button id="sosOverlayClose" class="sos-card__close" type="button" aria-label="Close crisis support">✕</button>
      </header>
      <div class="sos-card__actions">
        <div class="sos-card__action-group">
          <button id="worstDayButton" class="sos-card__action start-action" type="button">😵‍💫 Worst-Day Mode</button>
          <p id="worstDayHint" class="sos-card__detail"></p>
        </div>
        <button id="sosDefuse" class="sos-card__action" type="button">🧘 DEFUSE Mode</button>
        <button id="sosConflict" class="sos-card__action" type="button">🥊 3-v-3 Conflict Resolver</button>
        <button id="sosShield" class="sos-card__action" type="button">🛡️ Meltdown Shield</button>
      </div>
      <p class="sos-card__hint">Need a reset? These stay ready until you close them.</p>
    </div>
  </div>

  <!-- Focus mode -->
  <div id="ganttSnapshotOverlay" class="modal-overlay hidden" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="ganttSnapshotTitle">
    <div class="gantt-card">
      <div class="gantt-card__header">
        <h3 id="ganttSnapshotTitle">⏳ Next 3-hour snapshot</h3>
        <button id="ganttCloseButton" class="modal__close" type="button" aria-label="Close snapshot">✕</button>
      </div>
      <p class="gantt-intro">Blocks sized by estimated minutes so you can see what will actually fit.</p>
      <div class="gantt-blocks-wrapper">
        <div id="ganttProgressBar" class="gantt-progress"></div>
        <div id="ganttBlocks" class="gantt-blocks" role="list"></div>
      </div>
      <div id="ganttStatus" class="gantt-status"></div>
    </div>
  </div>

  <div id="worstDayOverlay" class="modal-overlay hidden worst-day-overlay" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="worstDayHeading">
    <div class="worst-day-card">
      <button id="worstDayClose" class="modal__close" type="button" aria-label="Close Worst-Day mode">✕</button>
      <h3 id="worstDayHeading">😵‍💫 Worst-Day Mode</h3>
      <p class="worst-day-subheading">One soft five-minute pass on your most meaningful project.</p>
      <div class="worst-day-focus-line">
        <span class="worst-day-label">Focus</span>
        <strong id="worstDayFocus"></strong>
      </div>
      <div id="worstDayTimer" class="worst-day-timer">05:00</div>
      <p id="worstDayPrompt" class="worst-day-prompt">Move gently. Drift happens — we'll reset together.</p>
      <div id="worstDayActions" class="worst-day-actions hidden">
        <p class="worst-day-complete">Sprint complete! Pick your next micro-reward.</p>
        <div class="worst-day-celebrations" role="group" aria-label="Worst-Day celebration choices">
          <button type="button" data-worst-day-choice="laugh">😂 Laugh</button>
          <button type="button" data-worst-day-choice="stretch">🙆 Stretch</button>
          <button type="button" data-worst-day-choice="stop">🛑 Stop proudly</button>
        </div>
        <div id="worstDayCelebration" class="worst-day-celebration" aria-live="polite"></div>
      </div>
      <button id="worstDayExit" class="link-button" type="button">Leave Worst-Day Mode</button>
    </div>
  </div>

  <div
    id="defuseOverlay"
    class="modal-overlay hidden defuse-overlay"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="defuseOverlayTitle"
  >
    <div class="defuse-modal">
      <header class="defuse-modal__header">
        <h3 id="defuseOverlayTitle">🧘 DEFUSE Mode</h3>
        <button id="defuseClose" class="defuse-modal__close" type="button" aria-label="Close DEFUSE mode">✕</button>
      </header>
      <div id="defuseModule" class="defuse-modal__body" data-module-id="defuseModule">
        <div class="defuse-grid">
          <div class="defuse-steps">
            <strong>Preflight (90s)</strong>
            <div id="defusePrompt">Feeling ≠ instruction. You can feel tired and still send the email.</div>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseProgressFill"></span>
            </div>
            <div class="score">Countdown: <span id="defuseCountdown">90s</span></div>
          </div>
          <div>
            <strong>Fake it action</strong>
            <div class="intention-buttons">
              <button type="button" data-defuse-action="Open the doc & type the title">Open doc + type title</button>
              <button type="button" data-defuse-action="Write one bullet in the note">Draft one bullet</button>
              <button type="button" data-defuse-action="Send the 2-sentence update">Send the 2-sentence update</button>
            </div>
            <p id="defuseActionPreview" class="score">Action picked: Open the doc & type the title</p>
          </div>
          <div>
            <strong>Zone locks</strong>
            <div id="defuseLocks" class="defuse-locks">
              <label><input type="checkbox" value="Messages" /> Messages</label>
              <label><input type="checkbox" value="Email" /> Email</label>
              <label><input type="checkbox" value="Instagram" /> Instagram</label>
              <label><input type="checkbox" value="YouTube" /> YouTube</label>
            </div>
          </div>
          <div>
            <strong>Uptime sprint</strong>
            <p id="defuseUptime" class="score">Next sprint: 10 minutes</p>
            <div class="defuse-progress" aria-hidden="true">
              <span id="defuseUptimeFill"></span>
            </div>
          </div>
          <div class="conflict-actions">
            <button id="defuseStart" type="button" class="btn btn-primary">Start DEFUSE</button>
            <button id="defuseCancel" type="button" class="btn btn-ghost" disabled>Cancel</button>
          </div>
          <div id="defuseStatus" class="score" aria-live="polite"></div>
        </div>
      </div>
    </div>
  </div>

  <section id="focus" class="focus-overlay hidden" aria-hidden="true">
    <div class="focus-overlay__backdrop" data-focus-dismiss></div>
    <div class="focus-overlay__sheet" role="dialog" aria-modal="true" aria-labelledby="focusTimer" tabindex="-1">
      <header class="focus-overlay__header">
        <div id="focusTimer" aria-live="polite">🧭 Focus Time: 0:00</div>
        <div class="focus-overlay__progress" aria-hidden="true">
          <span id="focusProgressFill" class="focus-overlay__progress-fill"></span>
        </div>
      </header>
      <div class="focus-overlay__body">
        <div class="focus-overlay__summary" id="focusTaskSummary">
          <div class="focus" tabindex="0" aria-live="polite"></div>
          <div class="score task-counter" id="scoreView"></div>
        </div>
        <div id="focusFitHint" class="focus-overlay__hint" aria-live="polite"></div>
        <div id="subTaskView"></div>
        <div id="distractionTools" class="distraction-tools">
          <div class="distraction-tools__header">
            <strong>Distraction cheat sheet</strong>
            <button id="caughtMeButton" type="button" disabled aria-disabled="true">“Caught me”</button>
          </div>
          <div id="distractionPrompt" class="distraction-prompt hidden">
            <span>What pulled you off course?</span>
            <div class="distraction-options" role="group" aria-label="Distraction triggers">
              <button type="button" data-distraction-trigger="tab">Tab hop</button>
              <button type="button" data-distraction-trigger="ping">Notification ping</button>
              <button type="button" data-distraction-trigger="thought">Thought spiral</button>
            </div>
          </div>
          <ul id="distractionLog" class="distraction-log" aria-live="polite" aria-label="Logged distractions"></ul>
          <div id="doorwayReset" class="doorway-reset hidden" aria-live="polite">
            <p id="doorwayResetMessage"></p>
            <div class="doorway-reset-actions">
              <button id="doorwayStartButton" type="button">Start 60-second reset</button>
              <button id="doorwaySkipButton" type="button" class="link-button">Not now</button>
            </div>
            <div id="doorwayCountdown" class="doorway-countdown hidden"></div>
          </div>
        </div>
      </div>
      <footer class="focus-overlay__actions">
        <button id="focusExtendButton" type="button" class="btn btn-secondary">Add 5 more min</button>
        <button id="focusAbortButton" type="button" class="btn btn-ghost">Abort</button>
        <button id="focusCompleteButton" type="button" class="btn hero-cta">Task complete</button>
      </footer>
    </div>
  </section>

  <section
    id="AllTasksOverlay"
    class="all-tasks-overlay hidden"
    aria-hidden="true"
    data-all-tasks-screen
  >
    <div class="all-tasks-overlay__backdrop" data-all-tasks-dismiss></div>
    <div
      class="all-tasks-overlay__sheet"
      role="dialog"
      aria-modal="true"
      aria-labelledby="AllTasksOverlayTitle"
      tabindex="-1"
    >
      <button type="button" class="all-tasks-overlay__close" data-all-tasks-close aria-label="Close All Tasks">
        ✕
      </button>
      <div class="all-tasks-overlay__body">
        <section class="card all-tasks-card" aria-live="polite" data-all-tasks-card>
          <button
            class="all-tasks-toggle"
            type="button"
            data-all-tasks-toggle
            aria-expanded="false"
            data-all-tasks-heading
          >
            <span id="AllTasksOverlayTitle" class="all-tasks-toggle__title" data-all-tasks-title>All Tasks</span>
            <span class="all-tasks-toggle__meta">
              <span data-all-tasks-category>All categories</span>
              <span class="all-tasks-header__divider" data-all-tasks-divider aria-hidden="true">•</span>
              <span data-all-tasks-summary-text>0 active</span>
            </span>
            <span class="all-tasks-toggle__chevron" aria-hidden="true">▸</span>
          </button>
          <div class="all-tasks-panel" data-all-tasks-panel hidden aria-hidden="true">
            <div class="task-list-header" id="taskListHeader">
              <label class="task-filter-field">
                <span class="task-filter-field__title">View</span>
                <select id="taskViewMode" class="task-view-select">
                  <option value="active" selected>Active Tasks</option>
                  <option value="completed">Completed Tasks</option>
                </select>
              </label>
              <label class="task-filter-field">
                <span class="task-filter-field__title">Category</span>
                <select id="taskCategoryFilter" class="task-view-select"></select>
              </label>
              <label class="task-filter-field">
                <span class="task-filter-field__title">Sort</span>
                <select id="taskSortMode" class="task-view-select">
                  <option value="priority" selected>Priority</option>
                  <option value="date-added-desc">Date added (newest)</option>
                  <option value="date-due-asc">Due date (soonest)</option>
                </select>
              </label>
              <label class="time-budget-control" for="timeBudget">
                I have
                <select id="timeBudget" data-field="time-budget">
                  <option value="">--</option>
                  <option value="15">15</option>
                  <option value="30">30</option>
                  <option value="60">60</option>
                </select>
                minutes
              </label>
            </div>
            <div class="ready-to-launch">
              <div class="task-section-head">
                <h3 class="task-section-title" data-ready-to-launch-title>Ready to Launch</h3>
              </div>
              <div id="taskList"></div>
              <button id="readyToLaunchMoreBtn" class="task-list-more-btn" type="button" aria-hidden="true">Show 5 more</button>
            </div>
          </div>
        </section>
      </div>
    </div>
  </section>

  <nav class="command-bar" aria-label="Momentum shortcuts">
    <a href="#focus-engine" class="command-link">
      <span class="command-link__icon" aria-hidden="true">⚡</span>
      <span>Focus</span>
    </a>
    <button
      id="openAllTasksButton"
      class="command-link"
      type="button"
      aria-haspopup="dialog"
      aria-controls="AllTasksOverlay"
      aria-expanded="false"
      data-command-all-tasks="true"
    >
      <span class="command-link__icon" aria-hidden="true">🩺</span>
      <span>Tasks</span>
    </button>
    <button
      id="resourcesToggle"
      class="command-link command-link--drawer"
      type="button"
      aria-haspopup="dialog"
      aria-controls="resourcesDrawer"
    >
      <span class="command-link__icon" aria-hidden="true">📘</span>
      <span>Resources</span>
    </button>
    <button id="insightButton" class="command-link" type="button" aria-label="View weekly insights">📈 Insights</button>
    <a href="#reset-zone" class="command-link">
      <span class="command-link__icon" aria-hidden="true">🌙</span>
      <span>Reset</span>
    </a>
    <button
      id="routineOverlayToggle"
      class="command-link"
      type="button"
      aria-haspopup="dialog"
      aria-controls="routineOverlay"
      aria-expanded="false"
    >
      <span class="command-link__icon" aria-hidden="true">💗</span>
      <span>Routines</span>
    </button>
  </nav>

  <script type="module" src="./taskStorage.js"></script>  
  <script type="module" src="./scheduleCard.js"></script>
  <script type="module" src="./scheduleBridge.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module">
    import generateAdaptiveItinerary from "./timeBlockEngine.js";

    window.TaskerDaily = Object.assign(window.TaskerDaily || {}, {
      generateAdaptiveItinerary,
    });
  </script>
  <script>
  const $ = id => document.getElementById(id);

  let openResourcesDrawer = () => {};
  let closeResourcesDrawer = () => {};

  const QUICK_TASK_CATEGORY = "Quick Task";
  const categories = ["General","Admin","Chart","Inbox","Calls","Teaching","Personal", QUICK_TASK_CATEGORY];
  let activeCategory = "All";
  const TASK_LIST_MODES = { ACTIVE: "active", COMPLETED: "completed" };
  const TASK_SORT_MODES = {
    PRIORITY: "priority",
    DATE_ADDED_DESC: "date-added-desc",
    DATE_DUE_ASC: "date-due-asc"
  };
  let taskSortMode = TASK_SORT_MODES.PRIORITY;
  let taskListMode = TASK_LIST_MODES.ACTIVE;
  const READY_TO_LAUNCH_INITIAL_COUNT = 3;
  const READY_TO_LAUNCH_INCREMENT = 5;
  let readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
  let readyToLaunchRevealBaseline = READY_TO_LAUNCH_INITIAL_COUNT;
  let derivedDaysSinceVisit = null;
  let urgencyAuto = true;
  const runningTimers = new Map();
  let sprintDurationMinutes = null;
  let sprintEndTime = null;
  let nextTaskId = null;
  let lastFocusedBeforeTemplateModal = null;
  let lastFocusedBeforeAllTasksOverlay = null;
  const MODULE_STATE_PREFIX = "moduleState_";
  const ADD_TASK_CARD_STATE_KEY = "ui.addTask.collapsed";
  const LEGACY_ADD_TASK_CARD_STATE_KEY = "addTaskCardState";
  const TEMPLATE_STORAGE_KEY = "tasker5000.templates";
  const LEGACY_TEMPLATE_STORAGE_KEY = "templates";
  const ALL_TASKS_CARD_STATE_KEY = "ui.allTasks.collapsed";
  const COLLAPSIBLE_MODULE_IDS = [];
  const ROUTINE_STATE_KEY = "ui.routines.metadata";
  const ROUTINE_HAPTIC_KEY = "ui.routines.haptics";
  const ROUTINE_REMINDER_TIMERS = new Map();
  const ROUTINE_CONTEXT_RECENT_MS = 2 * 60 * 60 * 1000;

  function attachTaskRecoveryActions(panel, raw, diagnostics) {
    const status = panel.querySelector('[data-status]');
    const setStatus = message => {
      if (status) {
        status.textContent = message;
      }
    };

    const downloadButton = panel.querySelector('[data-download]');
    if (downloadButton) {
      downloadButton.addEventListener('click', () => {
        const downloader = window.TaskerStorage?.downloadTaskBackup;
        const ok = typeof downloader === 'function' ? downloader(raw) : false;
        if (!ok) {
          setStatus('Unable to trigger a download automatically. Long-press the copied data below to save it.');
        } else {
          setStatus('Backup download triggered — check your downloads folder.');
        }
      });
    }

    const copyButton = panel.querySelector('[data-copy]');
    if (copyButton) {
      copyButton.addEventListener('click', async () => {
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(raw);
          } else {
            const textarea = document.createElement('textarea');
            textarea.value = raw;
            textarea.style.position = 'fixed';
            textarea.style.top = '-9999px';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            document.execCommand('copy');
            textarea.remove();
          }
          setStatus('Raw task data copied to your clipboard. Paste it into a safe note for backup.');
        } catch (error) {
          console.warn('Unable to copy task data to clipboard.', error);
          setStatus('Copy failed — long-press the text in the diagnostics block to select it manually.');
        }
      });
    }

    const logButton = panel.querySelector('[data-log]');
    if (logButton) {
      logButton.addEventListener('click', () => {
        console.groupCollapsed('Tasker 5000 › Task recovery diagnostics');
        console.log('Raw length', raw.length);
        console.log('Raw preview', raw.slice(0, 180));
        console.log('Diagnostics', diagnostics);
        console.groupEnd();
        setStatus('Diagnostics logged to the console. Attach them when you reach out for help.');
      });
    }

    const diagPre = panel.querySelector('[data-diag]');
    if (diagPre) {
      const summary = diagnostics ? JSON.stringify(diagnostics, null, 2) : 'No diagnostics available.';
      diagPre.textContent = summary;
    }
  }

  function showTaskRecoveryPanel(raw, diagnostics) {
    if (!raw) return;
    const existing = document.querySelector('.task-recovery-panel');
    if (existing) {
      existing.remove();
    }

    const panel = document.createElement('section');
    panel.className = 'task-recovery-panel';
    const truncatedPreview = raw.length > 320 ? `${raw.slice(0, 320)}…` : raw;
    const escapePreview = value =>
      value.replace(/[<&]/g, char => (char === '<' ? '&lt;' : '&amp;'));
    panel.innerHTML = `
      <h2>We found saved tasks, but something blocked the restore.</h2>
      <p>Your browser still has a copy of the tasks entry in local storage. Use the options below to back it up and capture diagnostics we can review together.</p>
      <div class="task-recovery-panel__actions">
        <button type="button" class="btn" data-download>Download backup</button>
        <button type="button" class="btn" data-copy>Copy raw data</button>
        <button type="button" class="link-button" data-log>Log details to console</button>
      </div>
      <p data-status role="status" aria-live="polite"></p>
      <details>
        <summary>Show technical diagnostics</summary>
        <p>
          Share this block if you need help from a developer. You can also run
          <code>window.TaskerStorage.collectTaskDiagnostics()</code> in the console for the latest snapshot.
        </p>
        <p><strong>Raw preview:</strong> ${truncatedPreview ? `<code>${escapePreview(truncatedPreview)}</code>` : 'No data detected.'}</p>
        <pre data-diag></pre>
      </details>
    `;

    document.body.insertBefore(panel, document.body.firstChild);
    attachTaskRecoveryActions(panel, raw, diagnostics);
  }

  const ROUTINE_DEFINITIONS = [
    {
      id: "morning",
      moduleId: "morningLaunchModule",
      title: "AM Start",
      emoji: "🌅",
      microPrompt: "Ready for takeoff? Start your day ritual.",
      defaultSteps: [
        "Move — Light aerobic + sunlight",
        "Reflect — Cold splash + intention",
        "Plan — Process anchors"
      ],
      previewSteps: [
        "Move — Light aerobic + sunlight",
        "Reflect — Cold splash + intention"
      ],
      quickLaunchRef: "moveStartBtn",
      category: "morning",
      reminderBody: "Ready for takeoff?",
      stuckMessage: "Take a sunrise peek and breathe for four counts — then try the first step."
    },
    {
      id: "environment",
      moduleId: "launchPadModule",
      title: "Launch Pad",
      emoji: "🚀",
      microPrompt: "Tap to reset your surroundings.",
      defaultSteps: [
        "Stage tomorrow's essentials",
        "Reset work surface",
        "Preview morning checklist"
      ],
      previewSteps: [
        "Stage tomorrow's essentials",
        "Preview morning checklist"
      ],
      quickLaunchRef: "openLaunchPadModal",
      category: "environment",
      reminderBody: "Tap to reset your surroundings.",
      stuckMessage: "Focus on just one surface — toss clutter into a quick bin sprint."
    },
    {
      id: "sleep",
      moduleId: "sleepToolkitModule",
      title: "Sleep Toolkit",
      emoji: "😴",
      microPrompt: "Wind down mode is ready.",
      defaultSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch",
        "Morning sunlight reminder"
      ],
      previewSteps: [
        "Dim lights & park screens",
        "Stack melatonin + stretch"
      ],
      quickLaunchRef: "sleepToolkitToggle",
      category: "sleep",
      reminderBody: "Wind down mode is ready.",
      stuckMessage: "Try a 2-minute legs-up-the-wall reset before continuing."
    },
    {
      id: "conflict",
      moduleId: "conflictResolverModule",
      title: "3-v-3 Conflict Resolver",
      emoji: "🥊",
      microPrompt: "Reframe your mind in 3x3 steps.",
      defaultSteps: [
        "List top 3 should-do",
        "List top 3 want-to",
        "Drag contenders into the arena"
      ],
      previewSteps: [
        "List top 3 should-do",
        "List top 3 want-to"
      ],
      quickLaunchRef: null,
      category: "conflict",
      reminderBody: "Reframe with a quick 3x3.",
      stuckMessage: "Limit the duel to one should-do vs one want-to — jot both before deciding."
    },
    {
      id: "dopamine",
      moduleId: "dopamineModule",
      title: "Dopa-Me",
      emoji: "🎵",
      microPrompt: "Train focus with a 5-min win.",
      defaultSteps: [
        "Pick a reward style",
        "Start the playlist timer",
        "Stretch the victory window"
      ],
      previewSteps: [
        "Pick a reward style",
        "Start the playlist timer"
      ],
      quickLaunchRef: "dopamineStart",
      category: "dopamine",
      reminderBody: "Train focus with a 5-min win.",
      stuckMessage: "Take one song-length pause, then restart the timer with a micro goal."
    },
    {
      id: "templates",
      moduleId: "templateModule",
      title: "Templates",
      emoji: "🧩",
      microPrompt: "Quick launch your best blueprints.",
      defaultSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      previewSteps: [
        "Open Block Batch",
        "Apply saved template"
      ],
      quickLaunchRef: "blockBatchOpen",
      category: "utility",
      allowReminder: false,
      reminderBody: "Blueprints are ready.",
      stuckMessage: "Pick the template that covers 80% and tweak only the edges."
    }
  ];
  const RESOURCE_LINKS = [
    {
      href: "https://chatgpt.com/g/g-p-68feee841e7081919a28fe9b3083e9f0-karl/project",
      label: "planning ally",
      title: "Chat with Karl",
      description: "ADHD-tailored task partner ready to map out your day.",
      theme: "planning"
    },
    {
      href: "https://chatgpt.com/g/g-p-6836a5682d0481918484506cbc1f3082-epic-companion/project",
      label: "strategies",
      title: "EPIC Companion",
      description: "Brainstorm workflows to move faster inside the EHR.",
      theme: "strategies"
    },
    {
      href: "https://notebooklm.google.com/",
      label: "digest",
      title: "NotebookLM",
      description: "Summarize research and notes in a focused workspace.",
      theme: "digest"
    },
    {
      href: "https://www.notion.so/Assessments-and-Plans-28131b26f81f803088bad074ee0e00fb?source=copy_link",
      label: "vault",
      title: "Assessments & Plans",
      description: "Review ready-made assessment and plan examples.",
      theme: "vault"
    },
    {
      href: "https://chatgpt.com/g/g-p-68feff1f73ac819189dcf556e573c912-assessments-plans/project",
      label: "document builder",
      title: "Create Assessments & Plans",
      description: "Draft new assessments from your history and physical notes.",
      theme: "vault"
    }
  ];
  const CUSTOM_RESOURCE_STORAGE_KEY = "ui.resources.customLinks.v1";
  const RESOURCE_THEME_OPTIONS = new Set(["planning", "strategies", "digest", "vault"]);

  function normalizeResourceTheme(theme) {
    if (!theme) return "custom";
    const normalized = String(theme).trim().toLowerCase();
    return RESOURCE_THEME_OPTIONS.has(normalized) ? normalized : "custom";
  }

  function sanitizeResourceText(value) {
    return typeof value === "string" ? value.trim() : "";
  }

  function loadCustomResources() {
    try {
      const stored = localStorage.getItem(CUSTOM_RESOURCE_STORAGE_KEY);
      if (!stored) {
        return [];
      }
      const parsed = JSON.parse(stored);
      if (!Array.isArray(parsed)) {
        return [];
      }
      return parsed
        .filter(item => item && typeof item.href === "string" && typeof item.title === "string")
        .map(item => ({
          id: item.id || `custom-${Math.random().toString(36).slice(2, 10)}`,
          href: item.href,
          title: sanitizeResourceText(item.title) || item.href,
          label: sanitizeResourceText(item.label) || undefined,
          description: sanitizeResourceText(item.description) || undefined,
          theme: normalizeResourceTheme(item.theme),
          ariaLabel: sanitizeResourceText(item.ariaLabel) || undefined,
          isCustom: true,
        }));
    } catch (error) {
      console.warn("[Resources] Unable to load saved links", error);
      return [];
    }
  }

  function saveCustomResources(resources) {
    try {
      localStorage.setItem(CUSTOM_RESOURCE_STORAGE_KEY, JSON.stringify(resources));
    } catch (error) {
      console.warn("[Resources] Unable to save links", error);
    }
  }

  let customResourceLinks = loadCustomResources();
  let setResourcesDrawerView = () => {};

  function getAllResourceLinks() {
    return [...RESOURCE_LINKS, ...customResourceLinks];
  }

  function addResourceLink(resource, target = document.querySelector("[data-resources-list]")) {
    if (!target || !resource) return null;
    const { href, title, label, description, theme, ariaLabel } = resource;
    if (!href || !title) return null;

    const link = document.createElement("a");
    const themeClass = typeof theme === "string" && theme.trim() ? `resource-button--${theme.trim()}` : "resource-button--custom";
    link.className = ["resource-button", themeClass].filter(Boolean).join(" ");
    link.href = href;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    if (ariaLabel) {
      link.setAttribute("aria-label", ariaLabel);
    }

    if (label) {
      const labelEl = document.createElement("small");
      labelEl.textContent = label;
      link.appendChild(labelEl);
    }

    const titleEl = document.createElement("strong");
    titleEl.textContent = title;
    link.appendChild(titleEl);

    if (description) {
      const descriptionEl = document.createElement("span");
      descriptionEl.textContent = description;
      link.appendChild(descriptionEl);
    }

    target.appendChild(link);
    return link;
  }

  function renderResourceLinks(resources = getAllResourceLinks()) {
    const list = document.querySelector("[data-resources-list]");
    if (!list) return;
    list.innerHTML = "";
    resources.forEach(resource => {
      addResourceLink(resource, list);
    });
  }

  function addCustomResourceLink(resource) {
    if (!resource) return null;
    const href = sanitizeResourceText(resource.href);
    const title = sanitizeResourceText(resource.title);
    if (!href || !title) {
      return null;
    }

    let url;
    try {
      url = new URL(href, window.location.origin);
    } catch (error) {
      return null;
    }

    if (url.protocol !== "http:" && url.protocol !== "https:") {
      return null;
    }

    const entry = {
      id: resource.id || `custom-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`,
      href: url.toString(),
      title,
      theme: normalizeResourceTheme(resource.theme),
      isCustom: true,
    };

    const label = sanitizeResourceText(resource.label);
    const description = sanitizeResourceText(resource.description);
    const ariaLabel = sanitizeResourceText(resource.ariaLabel);
    if (label) entry.label = label;
    if (description) entry.description = description;
    if (ariaLabel) entry.ariaLabel = ariaLabel;

    const existingIndex = customResourceLinks.findIndex(item => item.href === entry.href);
    if (existingIndex >= 0) {
      entry.id = customResourceLinks[existingIndex].id || entry.id;
      customResourceLinks[existingIndex] = entry;
    } else {
      customResourceLinks.push(entry);
    }

    saveCustomResources(customResourceLinks);
    renderResourceLinks();
    return entry;
  }

  function initializeResourceCreation() {
    const form = document.getElementById("addResourceForm");
    if (!form) return;
    const messageEl = form.querySelector("[data-resource-form-message]");
    const setMessage = (text, status = "neutral") => {
      if (!messageEl) return;
      messageEl.textContent = text || "";
      messageEl.dataset.status = status;
    };
    const focusFirstField = () => {
      const first = form.querySelector("input, textarea, select");
      if (first) {
        first.focus();
      }
    };

    form.addEventListener("submit", event => {
      event.preventDefault();
      const data = new FormData(form);
      const result = addCustomResourceLink({
        href: data.get("resourceUrl"),
        title: data.get("resourceTitle"),
        label: data.get("resourceLabel"),
        description: data.get("resourceDescription"),
        theme: data.get("resourceTheme"),
      });

      if (result) {
        form.reset();
        setResourcesDrawerView("form");
        setMessage("Resource added to Quick Access.", "success");
        window.requestAnimationFrame(() => focusFirstField());
      } else {
        setMessage("Please provide a title and a valid https:// link.", "error");
      }
    });

    form.addEventListener("input", () => {
      setMessage("", "neutral");
    });
  }

  if (typeof window !== "undefined") {
    window.addCustomResourceLink = addCustomResourceLink;
  }

  let routineState = {};
  let routineHapticsEnabled = true;
  const routineTiles = new Map();
  let openRoutineId = null;
  let routineContextIntervalId = null;

  function getRoutineDefinition(id) {
    return ROUTINE_DEFINITIONS.find(def => def.id === id) || null;
  }

  function loadRoutineState() {
    let stored = {};
    try {
      const raw = localStorage.getItem(ROUTINE_STATE_KEY);
      if (raw) {
        stored = JSON.parse(raw);
      }
    } catch (error) {
      stored = {};
    }
    const state = {};
    ROUTINE_DEFINITIONS.forEach(def => {
      const data = stored && typeof stored === "object" ? stored[def.id] : null;
      const storedSteps = Array.isArray(data?.steps) ? data.steps.filter(Boolean).map(step => String(step)) : [];
      const steps = storedSteps.length ? storedSteps : [...def.defaultSteps];
      state[def.id] = {
        id: def.id,
        title: typeof data?.title === "string" && data.title.trim() ? data.title.trim() : def.title,
        lastUsed: typeof data?.lastUsed === "string" ? data.lastUsed : null,
        usageCount: Number.isFinite(data?.usageCount) ? Number(data.usageCount) : 0,
        streak: Number.isFinite(data?.streak) ? Number(data.streak) : 0,
        reminderTime: typeof data?.reminderTime === "string" ? data.reminderTime : null,
        steps,
        quickLaunch: typeof data?.quickLaunch === "string" && steps.includes(data.quickLaunch)
          ? data.quickLaunch
          : steps[0] || null
      };
    });
    return state;
  }

  function saveRoutineState() {
    try {
      localStorage.setItem(ROUTINE_STATE_KEY, JSON.stringify(routineState));
    } catch (error) {
      // ignore persistence errors
    }
  }

  function formatRoutineTimeAgo(iso) {
    const date = new Date(iso);
    if (!iso || Number.isNaN(date.getTime())) {
      return "just now";
    }
    const diff = Date.now() - date.getTime();
    if (diff < 0) return "just now";
    const minute = 60000;
    const hour = 3600000;
    const day = 86400000;
    if (diff < minute) {
      return "just now";
    }
    if (diff < hour) {
      const mins = Math.max(1, Math.round(diff / minute));
      return `${mins} min${mins === 1 ? "" : "s"} ago`;
    }
    if (diff < day) {
      const hours = Math.max(1, Math.round(diff / hour));
      return `${hours} hour${hours === 1 ? "" : "s"} ago`;
    }
    const days = Math.max(1, Math.round(diff / day));
    return `${days} day${days === 1 ? "" : "s"} ago`;
  }

  function computeRoutinePrompt(def, meta) {
    if (!meta) return def.microPrompt;
    if (Number(meta.streak) >= 3) {
      return `${meta.streak}-day streak — keep it going!`;
    }
    if (meta.lastUsed) {
      return `Last used: ${formatRoutineTimeAgo(meta.lastUsed)}. Ready again?`;
    }
    return def.microPrompt;
  }

  function populateRoutineOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (!overlay) return;
    const list = overlay.querySelector('[data-quick-preview]');
    const button = overlay.querySelector('[data-quick-launch]');
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (list) {
      list.innerHTML = "";
      const steps = (meta?.steps && meta.steps.length ? meta.steps : def.defaultSteps).slice(0, 2);
      steps.forEach(step => {
        const li = document.createElement("li");
        li.textContent = step;
        list.appendChild(li);
      });
    }
    if (button) {
      button.textContent = `Quick launch ${meta?.title || def.title}`;
    }
  }

  function updateRoutineTile(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    const titleEl = tile.querySelector('[data-routine-title]');
    const promptEl = tile.querySelector('[data-routine-prompt]');
    const reminderEl = tile.querySelector('[data-routine-reminder]');
    const startBtn = tile.querySelector('[data-routine-start]');
    if (titleEl) {
      titleEl.textContent = `${def.emoji} ${meta.title || def.title}`;
    }
    if (promptEl) {
      promptEl.textContent = computeRoutinePrompt(def, meta);
    }
    if (reminderEl) {
      reminderEl.textContent = meta.reminderTime && def.allowReminder !== false ? `Reminder • ${meta.reminderTime}` : "";
    }
    if (startBtn && tile.dataset.running !== "true") {
      startBtn.textContent = "Start Routine";
    }
    populateRoutineOverlay(id);
  }

  function toggleRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    if (tile.classList.contains("routine-tile--open")) {
      closeRoutineTile(id);
    } else {
      openRoutineTile(id);
    }
  }

  function openRoutineTile(id, options = {}) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = $("routineOverlay");
    if (overlay && overlay.classList.contains("hidden")) {
      openRoutineOverlay();
    }
    if (openRoutineId && openRoutineId !== id) {
      closeRoutineTile(openRoutineId);
    }
    openRoutineId = id;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    body.hidden = false;
    const targetHeight = body.scrollHeight;
    body.style.maxHeight = `${targetHeight}px`;
    tile.classList.add("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "true");
      trigger.classList.add("is-active");
      trigger.setAttribute("aria-current", "true");
    }
    window.setTimeout(() => {
      if (tile.classList.contains("routine-tile--open")) {
        body.style.maxHeight = "none";
      }
    }, 260);
    if (options.scrollIntoView !== false) {
      tile.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
  }

  function closeRoutineTile(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const body = tile.querySelector('[data-routine-body]');
    const trigger = tile.querySelector('[data-routine-trigger]');
    if (!body) return;
    tile.classList.remove("routine-tile--open");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "false");
      trigger.classList.remove("is-active");
      trigger.removeAttribute("aria-current");
    }
    const currentHeight = body.scrollHeight;
    body.style.maxHeight = `${currentHeight}px`;
    requestAnimationFrame(() => {
      body.style.maxHeight = "0px";
    });
    window.setTimeout(() => {
      if (!tile.classList.contains("routine-tile--open")) {
        body.hidden = true;
      }
    }, 260);
    if (openRoutineId === id) {
      openRoutineId = null;
    }
  }

  function closeRoutineQuickOverlay(id) {
    const tile = routineTiles.get(id);
    if (!tile) return;
    const overlay = tile.querySelector('[data-routine-quick-overlay]');
    if (overlay) {
      overlay.classList.remove("is-visible");
    }
  }

  function quickLaunchRoutine(id) {
    const def = getRoutineDefinition(id);
    if (!def) return;
    if (def.quickLaunchRef) {
      const target = document.getElementById(def.quickLaunchRef);
      if (target) {
        target.click();
      }
    }
    startRoutine(id, { source: "quickLaunch" });
    closeRoutineQuickOverlay(id);
  }

  function attachRoutineGestures(tile, def) {
    const surface = tile.querySelector('[data-routine-surface]');
    if (!surface) return;
    const LONG_PRESS_MS = 600;
    let pointerId = null;
    let startX = 0;
    let startY = 0;
    let isSwipe = false;
    let longPressTimer = null;
    let longPressTriggered = false;

    const clearTimers = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    surface.addEventListener("pointerdown", event => {
      if (event.button !== 0) return;
      pointerId = event.pointerId;
      startX = event.clientX;
      startY = event.clientY;
      isSwipe = false;
      longPressTriggered = false;
      tile.dataset.ignoreNextClick = "false";
      surface.setPointerCapture(pointerId);
      clearTimers();
      longPressTimer = window.setTimeout(() => {
        longPressTriggered = true;
        tile.dataset.ignoreNextClick = "true";
        populateRoutineOverlay(def.id);
        const overlay = tile.querySelector('[data-routine-quick-overlay]');
        if (overlay) {
          overlay.classList.add("is-visible");
        }
        triggerRoutineHaptic([10]);
      }, LONG_PRESS_MS);
    });

    surface.addEventListener("pointermove", event => {
      if (event.pointerId !== pointerId) return;
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      if (Math.abs(dy) > 10) {
        clearTimers();
      }
      if (!isSwipe && Math.abs(dx) > 18 && Math.abs(dx) > Math.abs(dy)) {
        isSwipe = true;
        clearTimers();
        surface.classList.add("swiping");
      }
      if (isSwipe) {
        event.preventDefault();
        const clamped = Math.max(-120, Math.min(120, dx));
        surface.style.transform = `translateX(${clamped}px)`;
      }
    });

    const release = event => {
      if (event.pointerId !== pointerId) return;
      surface.releasePointerCapture(pointerId);
      clearTimers();
      const dx = event.clientX - startX;
      const dy = event.clientY - startY;
      surface.classList.remove("swiping");
      surface.style.transform = "";
      pointerId = null;
      if (isSwipe) {
        if (dx > 80) {
          tile.dataset.ignoreNextClick = "true";
          startRoutine(def.id, { source: "swipe" });
        } else if (dx < -80) {
          tile.dataset.ignoreNextClick = "true";
          openRoutineEdit(def.id);
        }
        return;
      }
      if (longPressTriggered) {
        return;
      }
    };

    surface.addEventListener("pointerup", release);
    surface.addEventListener("pointercancel", release);
    surface.addEventListener("pointerleave", event => {
      if (event.pointerId === pointerId) {
        clearTimers();
      }
    });
  }

  function triggerRoutineHaptic(pattern = [12]) {
    if (!routineHapticsEnabled) return;
    if (navigator?.vibrate) {
      try {
        navigator.vibrate(pattern);
      } catch (error) {
        // ignore vibration errors
      }
    }
  }

  function startRoutine(id, options = {}) {
    const def = getRoutineDefinition(id);
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!def || !tile || !meta) return;
    closeRoutineQuickOverlay(id);
    const shouldExpand = !options.source || options.source === "tap";
    if (shouldExpand) {
      openRoutineTile(id, { scrollIntoView: options.source !== "quickLaunch" });
    }
    const previous = {
      lastUsed: meta.lastUsed,
      usageCount: meta.usageCount,
      streak: meta.streak
    };
    const now = new Date();
    const todayKey = getDateKey(now);
    const previousKey = meta.lastUsed ? getDateKey(new Date(meta.lastUsed)) : null;
    meta.lastUsed = now.toISOString();
    meta.usageCount = (meta.usageCount || 0) + 1;
    if (previousKey === todayKey) {
      meta.streak = meta.streak || 1;
    } else if (previousKey === getOffsetDateKey(todayKey, -1)) {
      meta.streak = (meta.streak || 0) + 1;
    } else {
      meta.streak = 1;
    }
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "true";
    tile.classList.add("is-running");
    const surface = tile.querySelector('[data-routine-surface]');
    if (surface) {
      surface.classList.add("is-pulsing");
      window.setTimeout(() => surface.classList.remove("is-pulsing"), 250);
    }
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Mark complete";
    }
    triggerRoutineHaptic();
    if (typeof playFocusPing === "function") {
      playFocusPing();
    }
    window.setTimeout(() => tile.classList.remove("is-running"), 1800);
    const message = options.source === "swipe"
      ? `${def.emoji} ${meta.title || def.title} started — undo?`
      : `${def.emoji} Routine started.`;
    const toastOptions = options.source === "swipe"
      ? {
          action: {
            label: "Undo",
            onClick: () => undoRoutineStart(id, previous)
          },
          position: "bottom",
          timeout: 4000
        }
      : { timeout: 3500 };
    showToast(meta.title || def.title, message, toastOptions);
    updateRoutineContextGlow();
  }

  function undoRoutineStart(id, previous) {
    const tile = routineTiles.get(id);
    const meta = routineState[id];
    if (!tile || !meta) return;
    meta.lastUsed = previous.lastUsed || null;
    meta.usageCount = Number.isFinite(previous.usageCount) ? previous.usageCount : 0;
    meta.streak = Number.isFinite(previous.streak) ? previous.streak : 0;
    saveRoutineState();
    updateRoutineTile(id);
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    updateRoutineContextGlow();
  }

  function completeRoutine(id) {
    const tile = routineTiles.get(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!tile || !def || !meta) return;
    tile.dataset.running = "false";
    tile.classList.remove("is-running");
    tile.classList.add("routine-tile--celebrate");
    window.setTimeout(() => tile.classList.remove("routine-tile--celebrate"), 900);
    const startBtn = tile.querySelector('[data-routine-start]');
    if (startBtn) {
      startBtn.textContent = "Start Routine";
    }
    triggerRoutineHaptic([16, 32, 16]);
    showToast(meta.title || def.title, "Routine done — nice work!", { timeout: 4200 });
    updateRoutineContextGlow();
  }

  function handleRoutineQuickAction(id, action) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    switch (action) {
      case "refresh":
        meta.lastUsed = null;
        meta.streak = 0;
        saveRoutineState();
        updateRoutineTile(id);
        showToast(meta.title || def.title, "Micro prompt refreshed.", { timeout: 2500 });
        updateRoutineContextGlow();
        break;
      case "adjust":
        openRoutineEdit(id);
        break;
      case "stuck":
        showToast(meta.title || def.title, def.stuckMessage || "Take one tiny step toward the next action.", { timeout: 4000 });
        break;
      default:
        break;
    }
  }

  let activeRoutineEditId = null;

  function openRoutineEdit(id) {
    const sheet = document.getElementById("routineEditSheet");
    const meta = routineState[id];
    const def = getRoutineDefinition(id);
    if (!sheet || !meta || !def) return;
    closeRoutineQuickOverlay(id);
    activeRoutineEditId = id;
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    if (nameField) nameField.value = meta.title || def.title;
    if (stepsField) stepsField.value = meta.steps.join("\n");
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
      if (meta.quickLaunch && meta.steps.includes(meta.quickLaunch)) {
        quickSelect.value = meta.quickLaunch;
      }
    }
    if (reminderField) {
      reminderField.value = meta.reminderTime || "";
      reminderField.disabled = def.allowReminder === false;
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.checked = routineHapticsEnabled;
    }
    sheet.classList.add("is-visible");
    const panel = sheet.querySelector('.routine-sheet__panel');
    if (panel) {
      panel.setAttribute("tabindex", "-1");
      panel.focus({ preventScroll: true });
    }
  }

  function closeRoutineEdit() {
    const sheet = document.getElementById("routineEditSheet");
    if (!sheet) return;
    sheet.classList.remove("is-visible");
    activeRoutineEditId = null;
  }

  function setRoutineHaptics(enabled) {
    routineHapticsEnabled = Boolean(enabled);
    try {
      localStorage.setItem(ROUTINE_HAPTIC_KEY, routineHapticsEnabled ? "true" : "false");
    } catch (error) {
      // ignore
    }
    const toggle = document.getElementById("routineHapticsToggle");
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (toggle) toggle.checked = routineHapticsEnabled;
    if (sheetToggle) sheetToggle.checked = routineHapticsEnabled;
  }

  async function saveRoutineEdit() {
    if (!activeRoutineEditId) {
      closeRoutineEdit();
      return;
    }
    const def = getRoutineDefinition(activeRoutineEditId);
    const meta = routineState[activeRoutineEditId];
    if (!def || !meta) {
      closeRoutineEdit();
      return;
    }
    const nameField = document.getElementById("routineNameInput");
    const stepsField = document.getElementById("routineStepsInput");
    const quickSelect = document.getElementById("routineQuickSelect");
    const reminderField = document.getElementById("routineReminderTime");
    meta.title = nameField?.value?.trim() || def.title;
    const steps = (stepsField?.value || "")
      .split(/\n+/)
      .map(step => step.trim())
      .filter(Boolean);
    meta.steps = steps.length ? steps : [...def.defaultSteps];
    if (quickSelect) {
      quickSelect.innerHTML = "";
      meta.steps.forEach(step => {
        const option = document.createElement("option");
        option.value = step;
        option.textContent = step;
        quickSelect.appendChild(option);
      });
    }
    const selectedQuick = quickSelect?.value && meta.steps.includes(quickSelect.value) ? quickSelect.value : meta.steps[0] || null;
    meta.quickLaunch = selectedQuick;
    if (def.allowReminder !== false && reminderField) {
      const timeValue = reminderField.value || null;
      meta.reminderTime = timeValue;
      if (timeValue) {
        const granted = await ensureNotificationPermission();
        if (!granted) {
          meta.reminderTime = null;
          reminderField.value = "";
          showToast(meta.title, "Notifications blocked. Reminder cleared.", { timeout: 3500 });
        }
      }
      scheduleRoutineReminder(activeRoutineEditId);
    }
    saveRoutineState();
    updateRoutineTile(activeRoutineEditId);
    closeRoutineEdit();
    showToast(meta.title, "Routine updated", { timeout: 2600 });
    updateRoutineContextGlow();
  }

  function syncRoutineReminderDisplays() {
    ROUTINE_DEFINITIONS.forEach(def => updateRoutineTile(def.id));
  }

  async function ensureNotificationPermission() {
    if (!("Notification" in window)) return false;
    if (Notification.permission === "granted") return true;
    if (Notification.permission === "denied") return false;
    try {
      const result = await Notification.requestPermission();
      return result === "granted";
    } catch (error) {
      return false;
    }
  }

  function cancelRoutineReminder(id) {
    const timer = ROUTINE_REMINDER_TIMERS.get(id);
    if (timer) {
      window.clearTimeout(timer);
      ROUTINE_REMINDER_TIMERS.delete(id);
    }
  }

  function scheduleRoutineReminder(id) {
    cancelRoutineReminder(id);
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta || def.allowReminder === false || !meta.reminderTime) return;
    const [hours, minutes] = meta.reminderTime.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return;
    const now = new Date();
    const next = new Date();
    next.setHours(hours, minutes, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    const delay = Math.max(0, next.getTime() - now.getTime());
    const timerId = window.setTimeout(() => {
      deliverRoutineReminder(id);
      ROUTINE_REMINDER_TIMERS.delete(id);
      scheduleRoutineReminder(id);
    }, delay);
    ROUTINE_REMINDER_TIMERS.set(id, timerId);
  }

  async function deliverRoutineReminder(id) {
    const def = getRoutineDefinition(id);
    const meta = routineState[id];
    if (!def || !meta) return;
    const title = `${def.emoji} ${meta.title || def.title}`;
    const body = def.reminderBody || def.microPrompt;
    if (document.visibilityState !== "hidden") {
      openRoutineTile(id, { scrollIntoView: true });
      showToast(title, body, {
        action: { label: "Open", onClick: () => openRoutineTile(id) },
        timeout: 5000,
        className: "toast--inline"
      });
      return;
    }
    if (!("serviceWorker" in navigator)) return;
    try {
      const registration = await navigator.serviceWorker.ready;
      if (Notification.permission === "granted") {
        registration.showNotification(title, {
          body,
          tag: `routine-${id}`,
          data: { routineId: id },
          renotify: true
        });
      }
    } catch (error) {
      // ignore notification failures
    }
  }

  function updateRoutineContextGlow() {
    const priority = computeRoutinePriority();
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = routineTiles.get(def.id);
      if (!tile) return;
      const surface = tile.querySelector('[data-routine-surface]');
      if (priority === def.id) {
        tile.classList.add("routine-tile--context");
        const meta = routineState[def.id];
        const alpha = computeRoutineGlowAlpha(meta);
        if (surface) {
          surface.style.setProperty("--routine-context-glow-alpha", alpha.toFixed(2));
        }
      } else {
        tile.classList.remove("routine-tile--context");
        if (surface) {
          surface.style.removeProperty("--routine-context-glow-alpha");
        }
      }
    });
  }

  function computeRoutinePriority() {
    const hour = new Date().getHours();
    if (hour >= 6 && hour <= 11) return "morning";
    if (hour >= 19 || hour <= 23) return "sleep";
    const conflict = routineState.conflict;
    if (conflict?.lastUsed) {
      const last = new Date(conflict.lastUsed).getTime();
      if (!Number.isNaN(last) && Date.now() - last < ROUTINE_CONTEXT_RECENT_MS) {
        return "conflict";
      }
    }
    return null;
  }

  function computeRoutineGlowAlpha(meta) {
    const base = 0.18;
    if (!meta) return base;
    const now = Date.now();
    const hour = 60 * 60 * 1000;
    const day = 24 * hour;
    let alpha = base;
    if (!meta.lastUsed) {
      alpha = 0.26;
    } else {
      const last = new Date(meta.lastUsed).getTime();
      if (!Number.isNaN(last)) {
        const diff = Math.max(0, now - last);
        if (diff < 3 * hour) {
          alpha = 0.14;
        } else if (diff < 12 * hour) {
          alpha = 0.18;
        } else if (diff < day) {
          alpha = 0.22;
        } else {
          alpha = 0.26;
        }
      } else {
        alpha = 0.22;
      }
    }
    if (Number(meta.streak) >= 3) {
      alpha = Math.max(0.12, alpha - 0.02);
    }
    return Math.min(0.28, Math.max(0.12, alpha));
  }

  function initializeRoutineTiles() {
    routineState = loadRoutineState();
    try {
      const storedHaptics = localStorage.getItem(ROUTINE_HAPTIC_KEY);
      if (storedHaptics !== null) {
        routineHapticsEnabled = storedHaptics === "true";
      }
    } catch (error) {
      routineHapticsEnabled = true;
    }
    ROUTINE_DEFINITIONS.forEach(def => {
      const tile = document.querySelector(`[data-routine-id="${def.id}"]`);
      if (!tile) return;
      routineTiles.set(def.id, tile);
      tile.dataset.running = "false";
      const trigger = tile.querySelector('[data-routine-trigger]');
      const startBtn = tile.querySelector('[data-routine-start]');
      const quickActions = tile.querySelectorAll('[data-quick-action]');
      const overlay = tile.querySelector('[data-routine-quick-overlay]');
      if (trigger) {
        trigger.setAttribute("role", "button");
        trigger.setAttribute("aria-expanded", "false");
        trigger.addEventListener("click", () => {
          if (tile.dataset.ignoreNextClick === "true") {
            tile.dataset.ignoreNextClick = "false";
            return;
          }
          toggleRoutineTile(def.id);
        });
      }
      if (startBtn) {
        startBtn.addEventListener("click", () => {
          if (tile.dataset.running === "true") {
            completeRoutine(def.id);
          } else {
            startRoutine(def.id, { source: "tap" });
          }
        });
      }
      quickActions.forEach(button => {
        button.addEventListener("click", () => handleRoutineQuickAction(def.id, button.getAttribute("data-quick-action")));
      });
      if (overlay) {
        const quickLaunchBtn = overlay.querySelector('[data-quick-launch]');
        if (quickLaunchBtn) {
          quickLaunchBtn.addEventListener("click", () => quickLaunchRoutine(def.id));
        }
        overlay.addEventListener("click", event => {
          if (event.target === overlay) {
            closeRoutineQuickOverlay(def.id);
          }
        });
      }
      attachRoutineGestures(tile, def);
      updateRoutineTile(def.id);
      if (def.allowReminder !== false) {
        scheduleRoutineReminder(def.id);
      }
    });
    setRoutineHaptics(routineHapticsEnabled);
    const hapticsToggle = document.getElementById("routineHapticsToggle");
    if (hapticsToggle) {
      hapticsToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheetToggle = document.getElementById("routineHapticsInSheet");
    if (sheetToggle) {
      sheetToggle.addEventListener("change", event => setRoutineHaptics(event.target.checked));
    }
    const sheet = document.getElementById("routineEditSheet");
    if (sheet) {
      const scrim = sheet.querySelector('[data-routine-sheet-dismiss]');
      const cancelBtn = sheet.querySelector('[data-routine-sheet-cancel]');
      const saveBtn = sheet.querySelector('[data-routine-sheet-save]');
      if (scrim) scrim.addEventListener("click", () => closeRoutineEdit());
      if (cancelBtn) cancelBtn.addEventListener("click", () => closeRoutineEdit());
      if (saveBtn) saveBtn.addEventListener("click", () => saveRoutineEdit());
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.getElementById("routineEditSheet")?.classList.contains("is-visible")) {
        closeRoutineEdit();
      }
    });
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js").catch(() => {});
    }
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener("message", event => {
        const data = event.data || {};
        if (data.type === "routine-reminder" && data.routineId) {
          openRoutineTile(data.routineId, { scrollIntoView: true });
        }
      });
    }
    const hashMatch = window.location.hash && window.location.hash.match(/^#routine-(.+)$/);
    if (hashMatch && routineTiles.has(hashMatch[1])) {
      openRoutineTile(hashMatch[1], { scrollIntoView: true });
    }
    updateRoutineContextGlow();
    if (routineContextIntervalId) {
      window.clearInterval(routineContextIntervalId);
    }
    routineContextIntervalId = window.setInterval(updateRoutineContextGlow, 60 * 1000);
  }

  const chartFieldIds = ["authorType", "patientType", "visitType", "clinicSite", "dateOfService"];
  let storedChartFieldValues = null;
  let currentScaleDescriptorCategory = "general";
  const FOCUS_PING_INTERVAL_MS = 10 * 60 * 1000;
  const DISTRACTION_TRIGGER_OPTIONS = [
    { value: "tab", label: "Tab hop" },
    { value: "ping", label: "Notification ping" },
    { value: "thought", label: "Thought spiral" }
  ];
  const DOORWAY_RESET_THRESHOLD = 2;
  const DOORWAY_RESET_DURATION_MS = 60 * 1000;
  const GANTT_WINDOW_MINUTES = 180;
  const WORST_DAY_DURATION_MS = 5 * 60 * 1000;
  const WORST_DAY_LAUGHS = [
    "You just taught your nervous system a new party trick.",
    "That five-minute win still counts on your CV.",
    "Future-you is slow clapping right now."
  ];
  const WORST_DAY_STRETCHES = [
    "Shake out wrists, roll shoulders, slow neck circles.",
    "Stand tall, inhale for four, exhale for six.",
    "Touch the door frame, feel the reset, come back in."
  ];
  const AUDIT_STORAGE_PREFIX = "audit_";
  const AUDIT_SHOWN_SUFFIX = "_shown";
  const MORNING_LAUNCH_KEY = "morningLaunchState";
  const LAUNCH_PAD_KEY = "launchPadState";
  const SLEEP_TOOLKIT_KEY = "sleepToolkitState";
  let lastFocusEnergyLevel = null;
  let lastFocusTimeBudget = null;
  let syncingEnergySliders = false;
  let conflictArenaSelection = { should: null, want: null };
  const DEFUSE_MINUTES_MIN = 10;
  const DEFUSE_MINUTES_MAX = 30;
  const DEFAULT_DEFUSE_ACTION = "Open the doc & type the title";
  let defuseState = {
    active: false,
    countdown: 90,
    intervalId: null,
    uptime: DEFUSE_MINUTES_MIN,
    uptimeIntervalId: null,
    selectedAction: DEFAULT_DEFUSE_ACTION
  };
  let dopamineState = null;
  const FIRST_THREE_KEYWORDS = [
    "report",
    "project",
    "backlog",
    "chart",
    "presentation",
    "summary",
    "documentation",
    "analysis",
    "panel",
    "prep"
  ];
  const FIRST_THREE_WORD_THRESHOLD = 5;
  const DEFAULT_MORNING_TIMER_MINUTES = 20;
  const MORNING_BLOCKS = ["move", "reflect", "plan"];
  const MORNING_CHART_LIMIT = 10;
  const MORNING_CHART_COLORS = {
    completion: "#0a84ff",
    energy: "#f97316",
    grid: "rgba(148, 163, 184, 0.25)",
    axis: "rgba(148, 163, 184, 0.4)"
  };
  const DEFAULT_LAUNCH_PAD_REMINDER = "20:00";
  const DEFAULT_MELATONIN_TIME = "21:30";
  const DEFAULT_SUNLIGHT_TIME = "08:00";
  const DEFAULT_LAUNCH_PAD_SITE = "General Clinic";
  const NEXT_BEST_STORAGE_KEY = "nextBest.inputs";
  const PREFLIGHT_TOGGLES_KEY = "preflight.toggles";
  const DEFUSE_BASE_MINUTES_KEY = "defuse.baseMinutes";
  const DEFUSE_ACTION_KEY = "defuse.action";
  const DEFUSE_LOCKS_KEY = "defuse.locks";
  const DOPAMINE_REWARD_KEY = "dopamine.reward";
  const DOPAMINE_INTERVALS = [2, 6, 12];
  const BLOCK_BATCH_STORAGE_KEY = "blockBatch.profiles";
  const LAST_ZONE_STORAGE_KEY = "momentum.lastZone";
  const BRIEF_MODE_STORAGE_KEY = "momentum.briefMode";

  let latestNextBestPicks = {};
  let nextBestUpdatePending = false;
  let lastActiveZoneId = null;
  let focusLaunchOpen = false;
  let scrollCalmTimer = null;
  let taskGestureObserver = null;
  let lastDefuseOpener = null;
  let lastSosTrigger = null;
  let lastTemplatesOpener = null;
  let lastConflictOpener = null;

  function isElementMostlyInView(element, ratio = 0.3) {
    if (!element) return false;
    const rect = element.getBoundingClientRect();
    const viewHeight = window.innerHeight || document.documentElement.clientHeight;
    if (rect.height <= 0 || rect.bottom <= 0 || rect.top >= viewHeight) return false;
    const visibleTop = Math.max(0, -rect.top);
    const visibleBottom = Math.max(0, Math.min(viewHeight, rect.bottom) - Math.max(0, rect.top));
    const visibleHeight = Math.max(0, visibleBottom - visibleTop);
    return visibleHeight / rect.height >= ratio;
  }

  function scrollToZone(zoneId, options = {}) {
    if (!zoneId) return;
    const target = document.getElementById(zoneId);
    if (!target) return;
    const behavior = options.behavior || "smooth";
    target.scrollIntoView({ behavior, block: "start" });
  }

  function applyBriefMode(enabled, { silent = false } = {}) {
    document.body.classList.toggle("brief-mode", Boolean(enabled));
    try {
      localStorage.setItem(BRIEF_MODE_STORAGE_KEY, enabled ? "1" : "0");
    } catch (error) {
      console.warn("Unable to persist brief mode", error);
    }
    if (!silent) {
      showToast("Brief mode", enabled ? "Minimal view on." : "Full detail restored.");
    }
  }

  function toggleBriefMode() {
    const nextState = !document.body.classList.contains("brief-mode");
    applyBriefMode(nextState);
  }

  function restoreBriefModePreference() {
    try {
      const stored = localStorage.getItem(BRIEF_MODE_STORAGE_KEY);
      if (stored === "1") {
        applyBriefMode(true, { silent: true });
      }
    } catch (error) {
      console.warn("Unable to load brief mode preference", error);
    }
  }

  function setFocusLaunchOpen(open) {
    focusLaunchOpen = Boolean(open);
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    if (fab) {
      fab.setAttribute("aria-expanded", focusLaunchOpen ? "true" : "false");
    }
    if (sheet) {
      sheet.classList.toggle("is-open", focusLaunchOpen);
      sheet.setAttribute("aria-hidden", focusLaunchOpen ? "false" : "true");
    }
    if (backdrop) {
      if (focusLaunchOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!focusLaunchOpen) {
            backdrop.hidden = true;
          }
        }, 220);
      }
    }
    if (!focusLaunchOpen && fab) {
      fab.focus();
    }
  }

  function updateCommandLinkStates(activeZoneId) {
    const overlayActive = document.body.classList.contains("all-tasks-overlay-active");
    const links = document.querySelectorAll(".command-bar .command-link");
    links.forEach(link => {
      const isAllTasksTrigger = link.dataset.commandAllTasks === "true";
      if (isAllTasksTrigger && overlayActive) {
        link.classList.add("is-active");
        link.setAttribute("aria-current", "true");
        return;
      }
      const hash = link.getAttribute("href") || "";
      const targetId = hash.startsWith("#") ? hash.slice(1) : null;
      const anchor = targetId ? document.getElementById(targetId) : null;
      const zone = anchor ? anchor.closest(".momentum-zone") : null;
      const isActive = Boolean(zone && zone.id === activeZoneId);
      link.classList.toggle("is-active", isActive);
      if (isActive) {
        link.setAttribute("aria-current", "true");
      } else {
        link.removeAttribute("aria-current");
        if (isAllTasksTrigger) {
          link.classList.remove("is-active");
        }
      }
    });
  }

  function persistLastActiveZone(zoneId) {
    if (!zoneId) return;
    lastActiveZoneId = zoneId;
    try {
      localStorage.setItem(LAST_ZONE_STORAGE_KEY, zoneId);
    } catch (error) {
      console.warn("Unable to persist last active zone", error);
    }
  }

  function handleActiveZoneChange(zoneId) {
    if (!zoneId) return;
    persistLastActiveZone(zoneId);
    updateCommandLinkStates(zoneId);
  }

  function setupMomentumZones() {
    const zones = Array.from(document.querySelectorAll(".momentum-zone"));
    if (!zones.length) return;

    let storedZoneId = null;
    try {
      storedZoneId = localStorage.getItem(LAST_ZONE_STORAGE_KEY);
    } catch (error) {
      console.warn("Unable to read last zone", error);
    }

    const fallbackZone =
      document.getElementById("actionZone") ||
      document.getElementById("launchZone") ||
      zones[0];
    const initialZone = zones.find(zone => zone.id === storedZoneId) || fallbackZone;
    if (initialZone) {
      handleActiveZoneChange(initialZone.id);
    }

    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              handleActiveZoneChange(entry.target.id);
            }
          });
        },
        { threshold: 0.35 }
      );
      zones.forEach(zone => observer.observe(zone));
    }

    const commandLinks = document.querySelectorAll(".command-bar .command-link");
    commandLinks.forEach(link => {
      link.addEventListener("click", event => {
        if (link.dataset.commandAllTasks === "true") {
          return;
        }
        if (document.body.classList.contains("all-tasks-overlay-active")) {
          closeAllTasksOverlay({ restoreFocus: false });
        }
        const hash = link.getAttribute("href") || "";
        if (!hash.startsWith("#")) return;
        event.preventDefault();
        const targetId = hash.slice(1);
        if (!targetId) return;
        scrollToZone(targetId);
        const anchor = document.getElementById(targetId);
        const zone = anchor ? anchor.closest(".momentum-zone") : null;
        if (zone) {
          handleActiveZoneChange(zone.id);
        }
      });
    });

    const handleScrollEffects = () => {
      document.body.classList.add("is-scrolling");
      if (scrollCalmTimer) {
        window.clearTimeout(scrollCalmTimer);
      }
      scrollCalmTimer = window.setTimeout(() => {
        document.body.classList.remove("is-scrolling");
      }, 180);
    };

    window.addEventListener("scroll", handleScrollEffects, { passive: true });
    window.addEventListener("resize", handleScrollEffects);
    handleScrollEffects();
  }

  function setupNextBestObserver() {
    const target = $("nextBestEngineCard");
    if (!target || typeof IntersectionObserver === "undefined") return;
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting && nextBestUpdatePending) {
            updateNextBestOptions({ force: true });
          }
        });
      },
      { threshold: 0.3 }
    );
    observer.observe(target);
  }

  function setupSmartCollapse() {
    if (!window.matchMedia) return;
    const media = window.matchMedia("(max-width: 768px)");

    const resetCards = () => {
      document.querySelectorAll('.card[data-smart-collapsed="true"]').forEach(card => {
        card.classList.remove("collapsed");
        card.removeAttribute("data-smart-collapsed");
      });
    };

    const evaluateCards = () => {
      if (!media.matches) {
        resetCards();
        return;
      }
      const cards = document.querySelectorAll(".card");
      cards.forEach(card => {
        if (!card.isConnected) return;
        const rect = card.getBoundingClientRect();
        if (rect.height <= 0) return;
        if (rect.top < -100) {
          if (card.getAttribute("data-smart-collapsed") !== "true") {
            card.classList.add("collapsed");
            card.setAttribute("data-smart-collapsed", "true");
          }
        } else if (card.getAttribute("data-smart-collapsed") === "true" && rect.top > -80) {
          card.classList.remove("collapsed");
          card.removeAttribute("data-smart-collapsed");
        }
      });
    };

    let scheduled = false;
    const scheduleEvaluation = () => {
      if (!media.matches) return;
      if (scheduled) return;
      scheduled = true;
      window.requestAnimationFrame(() => {
        scheduled = false;
        evaluateCards();
      });
    };

    const handleMediaChange = event => {
      if (event.matches) {
        evaluateCards();
      } else {
        resetCards();
      }
    };

    if (typeof media.addEventListener === "function") {
      media.addEventListener("change", handleMediaChange);
    } else if (typeof media.addListener === "function") {
      media.addListener(handleMediaChange);
    }

    window.addEventListener("scroll", scheduleEvaluation, { passive: true });
    window.addEventListener("resize", scheduleEvaluation);
    evaluateCards();

    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(scheduleEvaluation);
      observer.observe(document.body, { childList: true, subtree: true });
    }
  }

  function refreshTaskGestureTargets() {
    const list = $("taskList");
    if (!list) return;
    const cards = list.querySelectorAll(".task-card[data-task-id]");
    cards.forEach(card => {
      const mode = card.classList.contains("is-completed") ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      attachTaskGestureHandlers(card, card.dataset.taskId, mode);
    });
  }

  function attachTaskGestureHandlers(card, taskId, mode = TASK_LIST_MODES.ACTIVE) {
    if (!card || !taskId || mode !== TASK_LIST_MODES.ACTIVE) return;
    if (!window.PointerEvent) return;
    if (card.dataset.gesturesAttached === "true") return;
    card.dataset.gesturesAttached = "true";

    const normalizedId = String(taskId);
    let pointerActive = false;
    let startX = 0;
    let startY = 0;
    let pointerId = null;
    let handled = false;
    let longPressTimer = null;
    const LONG_PRESS_MS = 550;
    const SWIPE_THRESHOLD = 56;
    const MAX_VERTICAL_DRIFT = 28;

    const clearLongPress = () => {
      if (longPressTimer) {
        window.clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    const resetState = () => {
      pointerActive = false;
      handled = false;
      pointerId = null;
      clearLongPress();
    };

    const handlePointerDown = event => {
      if (!event.isPrimary || event.button !== 0) return;
      if (event.target.closest("button") || event.target.closest("a")) return;
      pointerActive = true;
      handled = false;
      startX = event.clientX;
      startY = event.clientY;
      pointerId = event.pointerId;
      clearLongPress();
      longPressTimer = window.setTimeout(() => {
        handled = true;
        startEditTask(normalizedId);
        showToast("Task details", "Opening task editor.");
      }, LONG_PRESS_MS);
      if (card.setPointerCapture) {
        card.setPointerCapture(pointerId);
      }
    };

    const handlePointerMove = event => {
      if (!pointerActive || pointerId !== event.pointerId) return;
      const dx = event.clientX - startX;
      const dy = Math.abs(event.clientY - startY);
      if (dy > MAX_VERTICAL_DRIFT) {
        clearLongPress();
        return;
      }
      if (!handled && Math.abs(dx) >= SWIPE_THRESHOLD) {
        handled = true;
        clearLongPress();
        if (card.releasePointerCapture && pointerId !== null) {
          card.releasePointerCapture(pointerId);
        }
        pointerActive = false;
        if (dx > 0) {
          startFiveMinuteSprint(normalizedId);
          showToast("Sprint", "Starting a 5-minute focus pass.");
        } else {
          markTaskDoneFromPeek(normalizedId);
          showToast("Task complete", "Marked as done.");
        }
      }
    };

    const handlePointerEnd = event => {
      if (pointerActive && pointerId === event.pointerId && card.releasePointerCapture) {
        card.releasePointerCapture(pointerId);
      }
      resetState();
    };

    card.addEventListener("pointerdown", handlePointerDown);
    card.addEventListener("pointermove", handlePointerMove);
    card.addEventListener("pointerup", handlePointerEnd);
    card.addEventListener("pointerleave", handlePointerEnd);
    card.addEventListener("pointercancel", handlePointerEnd);
  }

  function setupTaskGestures() {
    if (!window.PointerEvent) return;
    const list = $("taskList");
    if (!list) return;
    refreshTaskGestureTargets();
    if (typeof MutationObserver === "undefined") return;
    if (taskGestureObserver) {
      taskGestureObserver.disconnect();
    }
    taskGestureObserver = new MutationObserver(() => refreshTaskGestureTargets());
    taskGestureObserver.observe(list, { childList: true });
  }

  function setupFocusOverlay() {
    const extendBtn = $("focusExtendButton");
    if (extendBtn) {
      extendBtn.addEventListener("click", () => extendSprintBy(5));
    }

    const abortBtn = $("focusAbortButton");
    if (abortBtn) {
      abortBtn.addEventListener("click", () => {
        backToCapture();
        setFocusLaunchOpen(false);
      });
    }

    const completeBtn = $("focusCompleteButton");
    if (completeBtn) {
      completeBtn.addEventListener("click", () => completeTask());
    }

    const overlay = $("focus");
    if (overlay) {
      overlay.addEventListener("click", event => {
        const dismissTarget = event.target.closest("[data-focus-dismiss]");
        if (dismissTarget) {
          backToCapture();
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && document.body.classList.contains("focus-overlay-active")) {
        backToCapture();
      }
    });
  }

  function setupLazyMedia() {
    const nodes = document.querySelectorAll('img:not([loading]), iframe:not([loading])');
    nodes.forEach(node => {
      node.setAttribute("loading", "lazy");
    });
  }

  const DEFAULT_BLOCK_BATCHES = [
    {
      id: "complex-care",
      label: "Complex Care",
      prefix: "CLX",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "General Clinic",
        importance: 4,
        urgency: 4,
        novelty: 2,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Review vitals and growth chart",
          "Summarize specialty updates",
          "Draft plan and follow-up steps"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "st-pjs",
      label: "St. PJ’s Shelter",
      prefix: "SPJ",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "St PJ’s Shelter",
        importance: 4,
        urgency: 5,
        novelty: 3,
        interest: 3,
        externalPressure: 4,
        timeToStart: 2,
        difficulty: 3,
        subTasks: [
          "Confirm shelter coordination notes",
          "Capture social work updates",
          "List pending referrals"
        ],
        useChartTemplate: true
      }
    },
    {
      id: "craniofacial",
      label: "Craniofacial Clinic",
      prefix: "CRN",
      defaultProfile: {
        category: "Chart",
        authorType: "attending",
        patientType: "Complex",
        visitType: "Follow-Up",
        clinicSite: "Craniofacial Clinic",
        importance: 5,
        urgency: 4,
        novelty: 3,
        interest: 4,
        externalPressure: 4,
        timeToStart: 3,
        difficulty: 3,
        subTasks: [
          "Pull imaging summary",
          "Outline surgical recommendations",
          "Document caregiver education"
        ],
        useChartTemplate: true
      }
    }
  ];
  let blockBatchProfiles = {};
  let blockBatchState = {
    activeId: DEFAULT_BLOCK_BATCHES.length ? DEFAULT_BLOCK_BATCHES[0].id : null,
    counts: {}
  };
  let blockBatchIdCounter = 0;
  const ENERGY_LABELS = {
    1: "Foggy",
    2: "Sleepy",
    3: "Steady",
    4: "Energized",
    5: "Lit up"
  };
  const SLEEP_RATING_LABELS = {
    1: "Exhausted",
    2: "Restless",
    3: "Adequate",
    4: "Rested",
    5: "Recharged"
  };
  const NEXT_BEST_FRICTION_RULES = {
    start: task => (Number(task.timeToStart) || 3) <= 3,
    perfection: task => estimateTaskMinutes(task) <= 25,
    social: task => !["Calls", "Inbox"].includes(task.category || ""),
    focus: task => {
      const remaining = Array.isArray(task.subTasks) ? task.subTasks.filter(sub => !sub.completed).length : 0;
      return remaining <= 4;
    }
  };
  const DEFUSE_PROMPTS = [
    { threshold: 60, message: "Feeling ≠ instruction. You can feel tired and still send the email." },
    { threshold: 30, message: "Fake it: open the doc, type the title, breathe." },
    { threshold: 0, message: "Zone check: distractions locked. You're cleared for takeoff." }
  ];
  const MMP_MIN_MINUTES = 10;
  const MMP_MAX_MINUTES = 20;
  const CONFLICT_DEFAULT_SPRINT = 12;
  const LAUNCH_PAD_PRESETS = {
    "General Clinic": [
      "Stethoscope",
      "Laptop + charger",
      "Clinic badge",
      "Progress note templates",
      "Snacks / water"
    ],
    "St PJ’s Shelter": [
      "ID badge",
      "Warm layers",
      "Resource handouts",
      "Portable charger",
      "Snacks"
    ],
    "Craniofacial Clinic": [
      "Care plan binders",
      "Growth charts",
      "Camera / tablet",
      "Consent forms",
      "Comfort items"
    ]
  };
  const SLEEP_CHECKLIST_ITEMS = [
    {
      id: "warmShower",
      label: "Warm shower or bath 1–2 hours before bed",
      tip: "Warm water triggers a cooling rebound that cues melatonin."
    },
    {
      id: "blueLight",
      label: "Blue-light blocker on screens",
      tip: "Filtering blue light reduces melatonin suppression from devices."
    },
    {
      id: "activity",
      label: "Light physical activity earlier today",
      tip: "Daytime movement builds sleep pressure for smoother nights."
    },
    {
      id: "caffeine",
      label: "Caffeine curfew observed (last sip by 2 PM)",
      tip: "Caffeine has a ~6 hour half-life—curbing it prevents bedtime jitters."
    },
    {
      id: "magnesium",
      label: "Optional magnesium or electrolytes",
      tip: "Magnesium calms the nervous system and supports muscle recovery."
    }
  ];
  const WEEKDAY_OPTIONS = [
    { label: "Any day", value: "any" },
    { label: "Weekdays", value: "weekdays" },
    { label: "Monday", value: "1" },
    { label: "Tuesday", value: "2" },
    { label: "Wednesday", value: "3" },
    { label: "Thursday", value: "4" },
    { label: "Friday", value: "5" },
    { label: "Saturday", value: "6" },
    { label: "Sunday", value: "0" }
  ];

  function getChartFields() {
    return chartFieldIds
      .map(id => $(id))
      .filter(Boolean);
  }

  function setChartFieldsDisabled(isDisabled) {
    getChartFields().forEach(field => {
      field.disabled = isDisabled;
    });
  }

  function storeChartFieldValues() {
    storedChartFieldValues = {};
    chartFieldIds.forEach(id => {
      const field = $(id);
      if (field) {
        storedChartFieldValues[id] = field.value;
      }
    });
  }

  function restoreChartFieldValues() {
    if (!storedChartFieldValues) return;
    chartFieldIds.forEach(id => {
      if (Object.prototype.hasOwnProperty.call(storedChartFieldValues, id)) {
        const field = $(id);
        if (field) {
          field.value = storedChartFieldValues[id];
        }
      }
    });
    storedChartFieldValues = null;
  }

  function showChartFields() {
    const container = $("chartFields");
    if (!container) return;
    container.classList.remove("is-hidden");
    container.setAttribute("aria-hidden", "false");
    setChartFieldsDisabled(false);
    restoreChartFieldValues();
    updateDerivedFields();
  }

  function hideChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storeChartFieldValues();
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  function getToastContainer() {
    return $("toastContainer");
  }

  function showToast(title, message, options = {}) {
    const container = getToastContainer();
    const useContainer = options.position !== "bottom";
    if (useContainer && !container) return;
    const toast = document.createElement("div");
    toast.className = `toast${options.className ? ` ${options.className}` : ""}`;
    if (options.position === "bottom") {
      toast.classList.add("toast--bottom");
    }
    toast.setAttribute("role", "status");
    if (typeof title === "string" && title.trim()) {
      const heading = document.createElement("strong");
      heading.textContent = title;
      toast.appendChild(heading);
    }
    const body = document.createElement("div");
    body.textContent = message;
    toast.appendChild(body);
    if (options.action && typeof options.action.onClick === "function") {
      const actionBtn = document.createElement("button");
      actionBtn.type = "button";
      actionBtn.className = "toast__action";
      actionBtn.textContent = options.action.label || "Action";
      actionBtn.addEventListener("click", () => {
        options.action.onClick();
        toast.remove();
      });
      toast.appendChild(actionBtn);
    }
    if (useContainer) {
      container.appendChild(toast);
    } else {
      document.body.appendChild(toast);
    }
    const timeout = Number.isFinite(options.timeout) ? options.timeout : 6000;
    const hide = () => {
      toast.classList.add("hidden");
      window.setTimeout(() => toast.remove(), 350);
      if (typeof options.onClose === "function") {
        options.onClose();
      }
    };
    if (timeout > 0) {
      window.setTimeout(hide, timeout);
    }
    return toast;
  }

  let taskAddedToastTimer = null;
  let taskAddedToastRemoveTimer = null;

  function showTaskAddedConfirmation(count = 1) {
    let toast = document.querySelector(".task-added-toast");
    if (!toast) {
      toast = document.createElement("div");
      toast.className = "task-added-toast";
      document.body.appendChild(toast);
    }
    toast.textContent = count > 1 ? `${count} tasks added` : "Task added";
    window.requestAnimationFrame(() => toast.classList.add("task-added-toast--visible"));
    if (taskAddedToastTimer) {
      window.clearTimeout(taskAddedToastTimer);
    }
    if (taskAddedToastRemoveTimer) {
      window.clearTimeout(taskAddedToastRemoveTimer);
    }
    taskAddedToastTimer = window.setTimeout(() => {
      toast.classList.remove("task-added-toast--visible");
      taskAddedToastRemoveTimer = window.setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 320);
    }, 1800);
  }

  function getDateKey(date = new Date()) {
    const dt = new Date(date);
    dt.setHours(0, 0, 0, 0);
    const year = dt.getFullYear();
    const month = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function getTodayKey() {
    return getDateKey(new Date());
  }

  function getTomorrowKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() + 1);
    return getDateKey(dt);
  }

  function getOffsetDateKey(dateKey, offsetDays = 0) {
    if (!dateKey || typeof dateKey !== "string") return null;
    const parts = dateKey.split("-").map(part => Number(part));
    if (parts.length !== 3) return null;
    const [year, month, day] = parts;
    if (![year, month, day].every(Number.isFinite)) return null;
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return null;
    const offset = Number(offsetDays);
    if (Number.isFinite(offset) && offset !== 0) {
      dt.setDate(dt.getDate() + offset);
    }
    return getDateKey(dt);
  }

  function getYesterdayKey() {
    const dt = new Date();
    dt.setDate(dt.getDate() - 1);
    return getDateKey(dt);
  }

  function formatFriendlyDate(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function formatShortDateLabel(dateKey) {
    if (!dateKey) return "";
    const parts = dateKey.split("-");
    if (parts.length !== 3) return dateKey;
    const [year, month, day] = parts.map(part => Number(part));
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return dateKey;
    }
    const dt = new Date(year, month - 1, day);
    if (Number.isNaN(dt.getTime())) return dateKey;
    return dt.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  function getDateKeyFromIso(isoString) {
    if (!isoString) return null;
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) return null;
    return getDateKey(date);
  }

  function getDefaultMorningEntry() {
    return {
      completed: {
        move: false,
        reflect: false,
        plan: false
      },
      intention: "",
      planNotes: "",
      energy: null,
      skip: false,
      countdownBlock: null,
      countdownEnd: null,
      celebrated: false,
      lastUpdated: null
    };
  }

  function getDefaultMorningState() {
    return {
      enabled: false,
      entries: {}
    };
  }

  function loadMorningLaunchState() {
    if (morningLaunchState) return morningLaunchState;
    try {
      const raw = localStorage.getItem(MORNING_LAUNCH_KEY);
      if (!raw) {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        morningLaunchState = getDefaultMorningState();
        return morningLaunchState;
      }
      const state = { ...getDefaultMorningState(), ...parsed };
      if (!state.entries || typeof state.entries !== "object") {
        state.entries = {};
      }
      Object.keys(state.entries).forEach(key => {
        state.entries[key] = { ...getDefaultMorningEntry(), ...state.entries[key] };
      });
      morningLaunchState = state;
    } catch (error) {
      console.error("Unable to load morning launch state", error);
      morningLaunchState = getDefaultMorningState();
    }
    return morningLaunchState;
  }

  function persistMorningLaunchState() {
    if (!morningLaunchState) return;
    try {
      if (morningLaunchState.entries) {
        const keys = Object.keys(morningLaunchState.entries).sort();
        if (keys.length > 60) {
          const toRemove = keys.slice(0, keys.length - 60);
          toRemove.forEach(key => delete morningLaunchState.entries[key]);
        }
      }
      const serialized = JSON.stringify(morningLaunchState);
      localStorage.setItem(MORNING_LAUNCH_KEY, serialized);
    } catch (error) {
      console.error("Unable to persist morning launch state", error);
    }
  }

  function getMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    if (!state.entries) state.entries = {};
    if (!state.entries[dateKey]) {
      state.entries[dateKey] = getDefaultMorningEntry();
    }
    return state.entries[dateKey];
  }

  function resetMorningEntry(dateKey = getTodayKey()) {
    const state = loadMorningLaunchState();
    state.entries[dateKey] = getDefaultMorningEntry();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function setMorningSkip(dateKey = getTodayKey(), skip = true) {
    const entry = getMorningEntry(dateKey);
    entry.skip = skip;
    if (skip) {
      MORNING_BLOCKS.forEach(block => {
        entry.completed[block] = false;
      });
      entry.celebrated = false;
    }
    clearMorningCountdown(entry);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
  }

  function clearMorningCountdown(entry) {
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = null;
    if (entry) {
      entry.countdownBlock = null;
      entry.countdownEnd = null;
    }
  }

  function formatCountdown(msRemaining) {
    if (!Number.isFinite(msRemaining) || msRemaining <= 0) {
      return "00:00";
    }
    const totalSeconds = Math.ceil(msRemaining / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }

  function updateMoveCountdownDisplay(remainingMs) {
    const display = $("moveCountdown");
    if (!display) return;
    if (!Number.isFinite(remainingMs) || remainingMs <= 0) {
      display.textContent = "20:00";
      return;
    }
    display.textContent = formatCountdown(remainingMs);
  }

  function resumeMorningCountdown(entry) {
    if (!entry || !entry.countdownBlock || !entry.countdownEnd) {
      updateMoveCountdownDisplay(null);
      return;
    }
    const remaining = entry.countdownEnd - Date.now();
    if (remaining <= 0) {
      clearMorningCountdown(entry);
      updateMoveCountdownDisplay(null);
      showToast("MOVE timer", "20 minutes are up. Celebrate the endorphins!");
      return;
    }
    updateMoveCountdownDisplay(remaining);
    if (morningCountdown && morningCountdown.intervalId) {
      clearInterval(morningCountdown.intervalId);
    }
    morningCountdown = {
      block: entry.countdownBlock,
      intervalId: setInterval(() => {
        const nowRemaining = entry.countdownEnd - Date.now();
        if (nowRemaining <= 0) {
          clearMorningCountdown(entry);
          updateMoveCountdownDisplay(null);
          showToast("MOVE timer", "20 minutes are up. Nice job getting sunlight and motion!");
        } else {
          updateMoveCountdownDisplay(nowRemaining);
        }
      }, 1000)
    };
  }

  function startMorningCountdown(block = "move") {
    const entry = getMorningEntry();
    entry.skip = false;
    entry.countdownBlock = block;
    entry.countdownEnd = Date.now() + DEFAULT_MORNING_TIMER_MINUTES * 60 * 1000;
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    resumeMorningCountdown(entry);
  }

  function setMorningBlockCompleted(block, data = {}) {
    const entry = getMorningEntry();
    entry.skip = false;
    if (!entry.completed) {
      entry.completed = { move: false, reflect: false, plan: false };
    }
    entry.completed[block] = true;
    if (block === "reflect" && data.intention !== undefined) {
      entry.intention = data.intention;
    }
    if (block === "plan" && data.planNotes !== undefined) {
      entry.planNotes = data.planNotes;
    }
    if (block === "move") {
      clearMorningCountdown(entry);
    }
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    showToast("Morning Launch", `Nice momentum! ${block.toUpperCase()} locked in.`);
  }

  function logMorningEnergy(value) {
    const entry = getMorningEntry();
    entry.energy = Number(value);
    entry.lastUpdated = new Date().toISOString();
    persistMorningLaunchState();
    updateMorningLaunchUI();
    if (Number.isFinite(entry.energy)) {
      const label = ENERGY_LABELS[entry.energy] || entry.energy;
      showToast("Energy logged", `Morning energy set to ${label}.`);
    }
  }

  function getMorningHistory(limit = 10) {
    const state = loadMorningLaunchState();
    const entries = Object.entries(state.entries || {});
    return entries
      .sort((a, b) => (a[0] > b[0] ? -1 : 1))
      .slice(0, limit)
      .map(([dateKey, entry]) => ({ dateKey, entry }));
  }

  function buildMorningStatus(entry) {
    if (entry.skip) {
      return "Launch skipped today. Reset whenever you’re ready.";
    }
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed[block]);
    if (!completedBlocks.length) {
      return "Start with MOVE to flood dopamine and sunlight cues.";
    }
    if (completedBlocks.length === MORNING_BLOCKS.length) {
      if (!entry.celebrated) {
        entry.celebrated = true;
        persistMorningLaunchState();
        showToast("Morning Launch", "All three blocks complete. Notice your focus surge later today.");
      }
      return "🌟 All three blocks complete. Anchor this momentum into your next action.";
    }
    if (completedBlocks.length === 1) {
      return `Great job completing ${completedBlocks[0].toUpperCase()}! Next up: ${completedBlocks[0] === "move" ? "REFLECT" : "PLAN"}.`;
    }
    return "Great job completing MOVE and REFLECT! Lock in a process-based PLAN next.";
  }

  function updateMorningHistoryList() {
    const list = $("morningLaunchHistory");
    if (!list) return;
    const history = getMorningHistory(7);
    list.innerHTML = "";
    if (!history.length) {
      const item = document.createElement("li");
      item.textContent = "No mornings logged yet.";
      list.appendChild(item);
      return;
    }
    history.forEach(({ dateKey, entry }) => {
      const item = document.createElement("li");
      const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
      const energyLabel = entry.energy ? ENERGY_LABELS[entry.energy] || entry.energy : "--";
      item.textContent = `${formatFriendlyDate(dateKey)} — ${completedCount}/${MORNING_BLOCKS.length} blocks • Energy: ${energyLabel}`;
      list.appendChild(item);
    });
  }

  function calculateMorningCompletionPercent(entry) {
    if (!entry || entry.skip) return 0;
    const totalBlocks = MORNING_BLOCKS.length || 1;
    const completedBlocks = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    return Math.round((completedBlocks / totalBlocks) * 100);
  }

  function renderMorningLaunchChart(limit = MORNING_CHART_LIMIT) {
    const canvas = $("morningLaunchChart");
    const summaryEl = $("morningLaunchChartSummary");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const width = canvas.clientWidth || canvas.width || 360;
    const height = canvas.clientHeight || canvas.height || 160;
    canvas.width = width;
    canvas.height = height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const history = getMorningHistory(limit);
    if (!history.length) {
      ctx.fillStyle = "#6b7280";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Complete your morning launch to unlock insights.", canvas.width / 2, canvas.height / 2);
      if (summaryEl) {
        summaryEl.textContent = "Complete your morning launch to unlock momentum and energy trends.";
      }
      return;
    }
    const chronological = [...history].reverse();
    const padding = 28;
    const graphWidth = canvas.width - padding * 2;
    const graphHeight = canvas.height - padding * 2;
    const xStep = chronological.length > 1 ? graphWidth / (chronological.length - 1) : 0;
    const completionPoints = [];
    const energyPoints = [];
    chronological.forEach((item, index) => {
      const { entry, dateKey } = item;
      completionPoints.push({
        index,
        value: calculateMorningCompletionPercent(entry),
        dateKey
      });
      const energy = Number(entry.energy);
      energyPoints.push({
        index,
        value: Number.isFinite(energy) ? Math.round(Math.max(0, Math.min(100, ((energy - 1) / 4) * 100))) : null,
        energy: Number.isFinite(energy) ? energy : null,
        dateKey
      });
    });
    const project = value => {
      const safeValue = Math.max(0, Math.min(100, Number(value) || 0));
      return canvas.height - padding - (safeValue / 100) * graphHeight;
    };
    ctx.strokeStyle = MORNING_CHART_COLORS.axis;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    const gridValues = [25, 50, 75, 100];
    ctx.setLineDash([4, 4]);
    gridValues.forEach(value => {
      const y = project(value);
      ctx.strokeStyle = MORNING_CHART_COLORS.grid;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      ctx.fillStyle = "#7f8a9c";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      ctx.fillText(`${value}%`, padding - 6, y + 3);
    });
    ctx.setLineDash([]);
    ctx.fillStyle = "#9aa6b8";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    chronological.forEach((item, index) => {
      const x = padding + xStep * index;
      ctx.fillText(formatShortDateLabel(item.dateKey), x, canvas.height - padding + 14);
    });
    ctx.fillStyle = "#8893a5";
    ctx.textAlign = "left";
    ctx.fillText("Energy line scaled so top = level 5", padding, padding - 10);
    const drawLine = (points, color, dashed = false) => {
      const valid = points.filter(point => Number.isFinite(point.value));
      if (!valid.length) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dashed ? [6, 4] : []);
      ctx.beginPath();
      valid.forEach((point, idx) => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      ctx.setLineDash([]);
      valid.forEach(point => {
        const x = padding + xStep * point.index;
        const y = project(point.value);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });
      ctx.restore();
    };
    drawLine(completionPoints, MORNING_CHART_COLORS.completion, false);
    drawLine(energyPoints, MORNING_CHART_COLORS.energy, true);
    if (summaryEl) {
      const completionSum = completionPoints.reduce((sum, point) => sum + (Number.isFinite(point.value) ? point.value : 0), 0);
      const completionAvg = completionPoints.length
        ? Math.round(completionSum / completionPoints.length)
        : 0;
      const energyValid = energyPoints.filter(point => Number.isFinite(point.energy));
      let summary = `Last ${chronological.length}-day average completion: ${completionAvg}%`;
      if (energyValid.length) {
        const avgEnergy = energyValid.reduce((sum, point) => sum + point.energy, 0) / energyValid.length;
        const label = ENERGY_LABELS[Math.round(avgEnergy)] || "";
        summary += ` • Energy ≈ ${avgEnergy.toFixed(1)}${label ? ` (${label})` : ""}`;
      } else {
        summary += " • Log energy to compare how rested mornings drive completion";
      }
      summaryEl.textContent = `${summary}.`;
    }
  }

  function updateMorningLaunchUI() {
    const state = loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    const content = $("morningLaunchContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      clearMorningCountdown(getMorningEntry());
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const summary = $("morningLaunchChartSummary");
      if (summary) {
        summary.textContent = "Enable Morning Launch to start tracking your morning momentum.";
      }
      const chart = $("morningLaunchChart");
      if (chart) {
        const ctx = chart.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, chart.width, chart.height);
        }
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    const entry = getMorningEntry();
    const intentionField = $("morningIntention");
    const planField = $("morningPlanNotes");
    if (intentionField) {
      intentionField.value = entry.intention || "";
    }
    if (planField) {
      planField.value = entry.planNotes || "";
    }
    const completedCount = MORNING_BLOCKS.filter(block => entry.completed?.[block]).length;
    const progress = $("morningLaunchProgress");
    if (progress) {
      const width = Math.round((completedCount / MORNING_BLOCKS.length) * 100);
      progress.style.width = `${width}%`;
    }
    const status = $("morningLaunchStatus");
    if (status) {
      status.textContent = buildMorningStatus(entry);
    }
    MORNING_BLOCKS.forEach(block => {
      const blockEl = document.querySelector(`.routine-block[data-block="${block}"]`);
      if (blockEl) {
        blockEl.classList.toggle("completed", Boolean(entry.completed?.[block]));
      }
    });
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      const value = Number.isFinite(entry.energy) ? entry.energy : 3;
      energySlider.value = String(value);
      if (energyLabel) {
        const label = ENERGY_LABELS[value] || value;
        energyLabel.textContent = `${label}`;
      }
      alignEnergySliders(value, "morning");
    }
    resumeMorningCountdown(entry);
    updateMorningHistoryList();
    renderMorningLaunchChart();
  }

  function initializeMorningLaunchModule() {
    loadMorningLaunchState();
    const toggle = $("morningLaunchToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadMorningLaunchState();
        state.enabled = event.target.checked;
        persistMorningLaunchState();
        updateMorningLaunchUI();
      });
    }
    const resetBtn = $("morningLaunchResetBtn");
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        if (confirm("Reset today's launch blocks?")) {
          resetMorningEntry();
        }
      });
    }
    const skipBtn = $("morningLaunchSkipBtn");
    if (skipBtn) {
      skipBtn.addEventListener("click", () => setMorningSkip(getTodayKey(), true));
    }
    const moveStart = $("moveStartBtn");
    if (moveStart) {
      moveStart.addEventListener("click", () => startMorningCountdown("move"));
    }
    const moveComplete = $("moveCompleteBtn");
    if (moveComplete) {
      moveComplete.addEventListener("click", () => setMorningBlockCompleted("move"));
    }
    const reflectSave = $("reflectCompleteBtn");
    if (reflectSave) {
      reflectSave.addEventListener("click", () => {
        const intention = $("morningIntention")?.value.trim() || "";
        setMorningBlockCompleted("reflect", { intention });
      });
    }
    const planSave = $("planCompleteBtn");
    if (planSave) {
      planSave.addEventListener("click", () => {
        const planNotes = $("morningPlanNotes")?.value.trim() || "";
        setMorningBlockCompleted("plan", { planNotes });
      });
    }
    const energySlider = $("morningEnergy");
    const energyLabel = $("morningEnergyLabel");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || 3);
        if (energyLabel) {
          const label = ENERGY_LABELS[value] || value;
          energyLabel.textContent = label;
        }
        alignEnergySliders(value, "morning");
      });
    }
    const energySave = $("morningEnergySave");
    if (energySave) {
      energySave.addEventListener("click", () => {
        const value = Number($("morningEnergy")?.value || 3);
        logMorningEnergy(value);
      });
    }
    const intentionButtons = document.querySelectorAll(".intention-buttons button[data-intention]");
    if (intentionButtons.length) {
      intentionButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const intention = btn.getAttribute("data-intention") || "";
          const field = $("morningIntention");
          if (field) {
            field.value = intention;
            field.focus();
          }
        });
      });
    }
    updateMorningLaunchUI();
  }

  function generateLaunchPadItemId() {
    return `lp_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`;
  }

  function getDefaultLaunchPadState() {
    return {
      reminderTime: DEFAULT_LAUNCH_PAD_REMINDER,
      activeSite: DEFAULT_LAUNCH_PAD_SITE,
      items: {},
      status: {},
      lastReminderDate: null,
      lastMorningNudge: null
    };
  }

  function normalizeLaunchPadState(state) {
    const base = { ...getDefaultLaunchPadState(), ...state };
    if (!base.items || typeof base.items !== "object") {
      base.items = {};
    }
    if (!base.status || typeof base.status !== "object") {
      base.status = {};
    }
    Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
      if (!Array.isArray(base.items[site]) || !base.items[site].length) {
        base.items[site] = LAUNCH_PAD_PRESETS[site].map(name => ({
          id: generateLaunchPadItemId(),
          name,
          dayRule: "any",
          isCustom: false
        }));
      } else {
        base.items[site] = base.items[site].map(item => ({
          id: item.id || generateLaunchPadItemId(),
          name: item.name || "Item",
          dayRule: item.dayRule || "any",
          isCustom: Boolean(item.isCustom)
        }));
      }
    });
    if (!base.items[base.activeSite]) {
      base.activeSite = DEFAULT_LAUNCH_PAD_SITE;
    }
    return base;
  }

  function loadLaunchPadState() {
    if (launchPadState) return launchPadState;
    try {
      const raw = localStorage.getItem(LAUNCH_PAD_KEY);
      if (!raw) {
        launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
        return launchPadState;
      }
      const parsed = JSON.parse(raw);
      launchPadState = normalizeLaunchPadState(parsed || {});
    } catch (error) {
      console.error("Unable to load launch pad state", error);
      launchPadState = normalizeLaunchPadState(getDefaultLaunchPadState());
    }
    return launchPadState;
  }

  function persistLaunchPadState() {
    if (!launchPadState) return;
    try {
      if (launchPadState.status) {
        const keys = Object.keys(launchPadState.status).sort();
        if (keys.length > 90) {
          const toRemove = keys.slice(0, keys.length - 90);
          toRemove.forEach(key => delete launchPadState.status[key]);
        }
      }
      localStorage.setItem(LAUNCH_PAD_KEY, JSON.stringify(launchPadState));
    } catch (error) {
      console.error("Unable to persist launch pad state", error);
    }
    updateLaunchPadSummary();
  }

  function ensureLaunchPadSite(site) {
    const state = loadLaunchPadState();
    if (!state.items[site]) {
      const preset = LAUNCH_PAD_PRESETS[site] || [];
      state.items[site] = preset.map(name => ({
        id: generateLaunchPadItemId(),
        name,
        dayRule: "any",
        isCustom: false
      }));
    }
    return state.items[site];
  }

  function setLaunchPadActiveSite(site) {
    const state = loadLaunchPadState();
    state.activeSite = site;
    ensureLaunchPadSite(site);
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function loadPresetForActiveSite() {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const preset = LAUNCH_PAD_PRESETS[site] || [];
    state.items[site] = preset.map(name => ({
      id: generateLaunchPadItemId(),
      name,
      dayRule: "any",
      isCustom: false
    }));
    persistLaunchPadState();
    renderLaunchPadSettings();
    showToast("Launch pad reset", `${site} preset restored.`);
  }

  function addLaunchPadItem(name) {
    const trimmed = (name || "").trim();
    if (!trimmed) return;
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    ensureLaunchPadSite(site);
    state.items[site].push({
      id: generateLaunchPadItemId(),
      name: trimmed,
      dayRule: "any",
      isCustom: true
    });
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function removeLaunchPadItem(itemId) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const next = list.filter(item => item.id !== itemId);
    state.items[site] = next;
    persistLaunchPadState();
    renderLaunchPadSettings();
  }

  function updateLaunchPadDayRule(itemId, dayRule) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const item = list.find(entry => entry.id === itemId);
    if (item) {
      item.dayRule = dayRule;
      persistLaunchPadState();
    }
  }

  function shouldIncludeLaunchPadItemOnDate(item, dateKey) {
    if (!item || !dateKey) return false;
    if (!item.dayRule || item.dayRule === "any") return true;
    const dt = new Date(`${dateKey}T00:00:00`);
    if (Number.isNaN(dt.getTime())) return true;
    const weekday = dt.getDay();
    if (item.dayRule === "weekdays") {
      return weekday >= 1 && weekday <= 5;
    }
    return String(weekday) === String(item.dayRule);
  }

  function getLaunchPadStatus(dateKey) {
    const state = loadLaunchPadState();
    if (!state.status[dateKey]) {
      state.status[dateKey] = {};
    }
    return state.status[dateKey];
  }

  function setLaunchPadItemReady(dateKey, itemId, ready) {
    const status = getLaunchPadStatus(dateKey);
    status[itemId] = Boolean(ready);
    persistLaunchPadState();
    updateLaunchPadSummary();
  }

  function computeLaunchPadReadiness(dateKey) {
    const state = loadLaunchPadState();
    const site = state.activeSite || DEFAULT_LAUNCH_PAD_SITE;
    const list = ensureLaunchPadSite(site);
    const relevant = list.filter(item => shouldIncludeLaunchPadItemOnDate(item, dateKey));
    const status = getLaunchPadStatus(dateKey);
    const readyCount = relevant.filter(item => status[item.id]).length;
    return {
      total: relevant.length,
      ready: readyCount,
      items: relevant,
      status
    };
  }

  function updateLaunchPadSummary() {
    const summary = $("launchPadSummary");
    if (!summary) return;
    const todayKey = getTodayKey();
    const readiness = computeLaunchPadReadiness(todayKey);
    if (readiness.total === 0) {
      summary.textContent = "No launch pad items scheduled for today.";
      return;
    }
    summary.innerHTML = "";
    const header = document.createElement("strong");
    header.textContent = `Launch Pad: ${readiness.ready}/${readiness.total} items ready`;
    summary.appendChild(header);
    const hint = document.createElement("div");
    if (readiness.ready === readiness.total) {
      hint.textContent = "Everything is staged — future you says thanks!";
    } else {
      const remaining = readiness.total - readiness.ready;
      hint.textContent = `${remaining} item(s) still need attention before heading out.`;
    }
    summary.appendChild(hint);
  }

  function renderLaunchPadSettings() {
    const state = loadLaunchPadState();
    const siteSelect = $("launchPadSiteSelect");
    if (siteSelect) {
      siteSelect.innerHTML = "";
      Object.keys(LAUNCH_PAD_PRESETS).forEach(site => {
        const option = document.createElement("option");
        option.value = site;
        option.textContent = site;
        if (site === state.activeSite) {
          option.selected = true;
        }
        siteSelect.appendChild(option);
      });
      siteSelect.onchange = event => {
        setLaunchPadActiveSite(event.target.value);
      };
    }
    const timeInput = $("launchPadReminderTime");
    if (timeInput) {
      timeInput.value = state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER;
      timeInput.onchange = event => {
        state.reminderTime = event.target.value || DEFAULT_LAUNCH_PAD_REMINDER;
        persistLaunchPadState();
      };
    }
    const listContainer = $("launchPadItemList");
    if (listContainer) {
      listContainer.innerHTML = "";
      const items = ensureLaunchPadSite(state.activeSite || DEFAULT_LAUNCH_PAD_SITE);
      if (!items.length) {
        const empty = document.createElement("p");
        empty.className = "score";
        empty.textContent = "No launch pad items yet.";
        listContainer.appendChild(empty);
      } else {
        items.forEach(item => {
          const row = document.createElement("div");
          row.className = "launch-pad-item";
          const name = document.createElement("div");
          name.textContent = item.name;
          if (item.isCustom) {
            const custom = document.createElement("small");
            custom.textContent = "custom";
            name.appendChild(document.createElement("br"));
            name.appendChild(custom);
          }
          const select = document.createElement("select");
          WEEKDAY_OPTIONS.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            if (option.value === item.dayRule) {
              opt.selected = true;
            }
            select.appendChild(opt);
          });
          select.addEventListener("change", event => {
            updateLaunchPadDayRule(item.id, event.target.value);
          });
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "🗑";
          removeBtn.title = "Remove item";
          removeBtn.addEventListener("click", () => {
            if (confirm(`Remove ${item.name}?`)) {
              removeLaunchPadItem(item.id);
            }
          });
          row.appendChild(name);
          row.appendChild(select);
          row.appendChild(removeBtn);
          listContainer.appendChild(row);
        });
      }
    }
    updateLaunchPadSummary();
  }

  function renderLaunchPadModalList(targetDateKey) {
    const container = $("launchPadModalList");
    if (!container) return;
    container.innerHTML = "";
    const readiness = computeLaunchPadReadiness(targetDateKey);
    if (!readiness.total) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No items needed for that day.";
      container.appendChild(empty);
      return;
    }
    readiness.items.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(readiness.status[item.id]);
      checkbox.addEventListener("change", event => {
        setLaunchPadItemReady(targetDateKey, item.id, event.target.checked);
      });
      const span = document.createElement("span");
      span.textContent = item.name;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function setModalVisibility(modalId, isVisible) {
    const overlay = $(modalId);
    if (!overlay) return;
    if (isVisible) {
      overlay.classList.remove("hidden");
      overlay.setAttribute("aria-hidden", "false");
    } else {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
  }

  function openLaunchPadModal(options = {}) {
    const { targetDateKey = getTomorrowKey() } = options;
    renderLaunchPadModalList(targetDateKey);
    const overlay = $("launchPadModal");
    if (!overlay) return;
    overlay.dataset.targetDate = targetDateKey;
    setModalVisibility("launchPadModal", true);
  }

  function closeLaunchPadModal() {
    setModalVisibility("launchPadModal", false);
  }

  function initializeLaunchPadModule() {
    loadLaunchPadState();
    renderLaunchPadSettings();
    const addBtn = $("launchPadAddItem");
    if (addBtn) {
      addBtn.addEventListener("click", () => {
        const field = $("launchPadNewItem");
        addLaunchPadItem(field?.value || "");
        if (field) field.value = "";
      });
    }
    const presetBtn = $("launchPadLoadPreset");
    if (presetBtn) {
      presetBtn.addEventListener("click", () => {
        if (confirm("Reset this site's launch pad to the curated preset?")) {
          loadPresetForActiveSite();
        }
      });
    }
    const openEvening = $("openLaunchPadModal");
    if (openEvening) {
      openEvening.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTomorrowKey() }));
    }
    const morningReview = $("launchPadMorningReview");
    if (morningReview) {
      morningReview.addEventListener("click", () => openLaunchPadModal({ targetDateKey: getTodayKey() }));
    }
    const modalClose = $("launchPadModalClose");
    if (modalClose) {
      modalClose.addEventListener("click", () => {
        closeLaunchPadModal();
      });
    }
    const overlay = $("launchPadModal");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeLaunchPadModal();
        }
      });
    }
    updateLaunchPadSummary();
  }

  function getDefaultSleepState() {
    return {
      enabled: false,
      checklist: {},
      melatonin: {
        enabled: false,
        time: DEFAULT_MELATONIN_TIME,
        lastPrompt: null
      },
      sunlight: {
        enabled: false,
        time: DEFAULT_SUNLIGHT_TIME,
        lastPrompt: null
      },
      restRatings: {}
    };
  }

  function loadSleepToolkitState() {
    if (sleepToolkitState) return sleepToolkitState;
    try {
      const raw = localStorage.getItem(SLEEP_TOOLKIT_KEY);
      if (!raw) {
        sleepToolkitState = getDefaultSleepState();
        return sleepToolkitState;
      }
      const parsed = JSON.parse(raw);
      sleepToolkitState = { ...getDefaultSleepState(), ...parsed };
      if (!sleepToolkitState.checklist || typeof sleepToolkitState.checklist !== "object") {
        sleepToolkitState.checklist = {};
      }
      if (!sleepToolkitState.restRatings || typeof sleepToolkitState.restRatings !== "object") {
        sleepToolkitState.restRatings = {};
      }
    } catch (error) {
      console.error("Unable to load sleep toolkit state", error);
      sleepToolkitState = getDefaultSleepState();
    }
    return sleepToolkitState;
  }

  function persistSleepToolkitState() {
    if (!sleepToolkitState) return;
    try {
      if (sleepToolkitState.checklist) {
        const keys = Object.keys(sleepToolkitState.checklist).sort();
        if (keys.length > 120) {
          const toRemove = keys.slice(0, keys.length - 120);
          toRemove.forEach(key => delete sleepToolkitState.checklist[key]);
        }
      }
      if (sleepToolkitState.restRatings) {
        const ratingKeys = Object.keys(sleepToolkitState.restRatings).sort();
        if (ratingKeys.length > 180) {
          const prune = ratingKeys.slice(0, ratingKeys.length - 180);
          prune.forEach(key => delete sleepToolkitState.restRatings[key]);
        }
      }
      localStorage.setItem(SLEEP_TOOLKIT_KEY, JSON.stringify(sleepToolkitState));
    } catch (error) {
      console.error("Unable to persist sleep toolkit state", error);
    }
  }

  function getSleepChecklistEntry(dateKey = getTodayKey()) {
    const state = loadSleepToolkitState();
    if (!state.checklist[dateKey]) {
      const entry = {};
      SLEEP_CHECKLIST_ITEMS.forEach(item => {
        entry[item.id] = false;
      });
      state.checklist[dateKey] = entry;
    }
    return state.checklist[dateKey];
  }

  function toggleSleepChecklistItem(itemId, value, dateKey = getTodayKey()) {
    const checklist = getSleepChecklistEntry(dateKey);
    if (!Object.prototype.hasOwnProperty.call(checklist, itemId)) return;
    checklist[itemId] = Boolean(value);
    persistSleepToolkitState();
    updateSleepToolkitUI();
  }

  function computeSleepCompletionFromChecklist(checklist) {
    const total = SLEEP_CHECKLIST_ITEMS.length;
    if (!checklist) {
      return { total, completed: 0, percent: 0 };
    }
    const completed = SLEEP_CHECKLIST_ITEMS.filter(item => checklist[item.id]).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function computeSleepCompletion(dateKey = getTodayKey(), options = {}) {
    const { createIfMissing = true } = options || {};
    let checklist;
    if (createIfMissing) {
      checklist = getSleepChecklistEntry(dateKey);
    } else {
      const state = loadSleepToolkitState();
      checklist = state.checklist?.[dateKey];
    }
    return computeSleepCompletionFromChecklist(checklist);
  }

  function renderSleepChecklist(dateKey = getTodayKey()) {
    const container = $("sleepChecklist");
    if (!container) return;
    const checklist = getSleepChecklistEntry(dateKey);
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const label = document.createElement("label");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = Boolean(checklist[item.id]);
      checkbox.addEventListener("change", event => {
        toggleSleepChecklistItem(item.id, event.target.checked, dateKey);
      });
      const span = document.createElement("div");
      const title = document.createElement("strong");
      title.textContent = item.label;
      const tip = document.createElement("div");
      tip.textContent = item.tip;
      tip.style.fontSize = "0.78rem";
      tip.style.color = "#9aa0a6";
      span.appendChild(title);
      span.appendChild(tip);
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }

  function updateSleepCompletionSummary(dateKey = getTodayKey()) {
    const summary = $("sleepCompletionSummary");
    if (!summary) return;
    const { total, completed, percent } = computeSleepCompletion(dateKey);
    summary.textContent = `You set ${completed}/${total} sleep steps ready – ${percent}% of the plan primed.`;
  }

  function renderSleepTips() {
    const container = $("sleepTips");
    if (!container) return;
    container.innerHTML = "";
    SLEEP_CHECKLIST_ITEMS.forEach(item => {
      const tip = document.createElement("div");
      tip.textContent = `• ${item.tip}`;
      container.appendChild(tip);
    });
  }

  function recordSleepRating(dateKey, rating) {
    const state = loadSleepToolkitState();
    state.restRatings[dateKey] = Number(rating);
    persistSleepToolkitState();
    updateSleepToolkitUI();
    const label = SLEEP_RATING_LABELS[rating] || rating;
    showToast("Sleep logged", `Restfulness marked as ${label}.`);
  }

  function countChartTasksCompletedOn(dateKey) {
    if (!dateKey) return 0;
    return tasks.filter(task => {
      if (!isChartTask(task)) return false;
      const completionKey = getDateKeyFromIso(task.completedAt);
      return completionKey === dateKey;
    }).length;
  }

  function updateSleepCorrelationSummary() {
    const summary = $("sleepCorrelationSummary");
    if (!summary) return;
    const state = loadSleepToolkitState();
    const fragments = [];

    const ratingEntries = Object.entries(state.restRatings || {});
    if (!ratingEntries.length) {
      fragments.push("Log rest ratings to see how sleep fuels charting momentum.");
    } else {
      let highCount = 0;
      let highCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      ratingEntries.forEach(([dateKey, rating]) => {
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (Number(rating) >= 4) {
          highCount += 1;
          highCharts += charts;
        } else {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      const restedAvgValue = highCount ? highCharts / highCount : null;
      const draggyAvgValue = lowCount ? lowCharts / lowCount : null;
      const restedAvg = restedAvgValue !== null ? restedAvgValue.toFixed(1) : "—";
      const draggyAvg = draggyAvgValue !== null ? draggyAvgValue.toFixed(1) : "—";
      let ratingText = `Rest rating impact → Rested mornings (≥4) yielded ${restedAvg} next-day chart(s); low-energy mornings (≤3) managed ${draggyAvg}.`;
      if (restedAvgValue !== null && draggyAvgValue !== null) {
        const delta = restedAvgValue - draggyAvgValue;
        if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
          ratingText += ` (≈${delta > 0 ? "+" : ""}${delta.toFixed(1)} boost when you're rested)`;
        }
      } else {
        ratingText += " Keep logging a mix of scores to sharpen this insight.";
      }
      fragments.push(ratingText);
    }

    const checklistEntries = Object.entries(state.checklist || {});
    if (!checklistEntries.length) {
      fragments.push("Check off sleep steps to measure how consistency drives next-day charting.");
    } else {
      let strongCount = 0;
      let strongCharts = 0;
      let lowCount = 0;
      let lowCharts = 0;
      checklistEntries.forEach(([dateKey, checklist]) => {
        const { percent } = computeSleepCompletionFromChecklist(checklist);
        const nextDayKey = getOffsetDateKey(dateKey, 1);
        if (!nextDayKey) return;
        const charts = countChartTasksCompletedOn(nextDayKey);
        if (percent >= 80) {
          strongCount += 1;
          strongCharts += charts;
        } else if (percent <= 40) {
          lowCount += 1;
          lowCharts += charts;
        }
      });
      if (!strongCount && !lowCount) {
        fragments.push("Track both dialed-in and skipped nights to see how the checklist nudges tomorrow's throughput.");
      } else {
        const strongAvgValue = strongCount ? strongCharts / strongCount : null;
        const lowAvgValue = lowCount ? lowCharts / lowCount : null;
        const strongAvg = strongAvgValue !== null ? strongAvgValue.toFixed(1) : "—";
        const lowAvg = lowAvgValue !== null ? lowAvgValue.toFixed(1) : "—";
        let checklistText = `Sleep steps impact → Nights hitting ≥80% of steps led to ${strongAvg} chart(s) the next day; nights under 40% slid to ${lowAvg}.`;
        if (strongAvgValue !== null && lowAvgValue !== null) {
          const delta = strongAvgValue - lowAvgValue;
          if (Number.isFinite(delta) && Math.abs(delta) >= 0.1) {
            checklistText += ` (≈${delta > 0 ? "+" : ""}${delta.toFixed(1)} chart swing when you protect the routine)`;
          }
        } else {
          checklistText += " Keep collecting data on both ends to firm up the comparison.";
        }
        fragments.push(checklistText);
      }
    }

    if (fragments.length === 0) {
      fragments.push("Log sleep data to let the system prove that care rituals beat pushing through fatigue.");
    } else {
      fragments.push("Let these cues remind you: honoring circadian rhythms outruns brute-force catch-up.");
    }

    summary.innerHTML = fragments.join("<br/>");
  }

  function renderSleepMorningRating() {
    const container = $("sleepMorningRating");
    if (!container) return;
    container.innerHTML = "";
    const state = loadSleepToolkitState();
    const targetKey = getYesterdayKey();
    if (!targetKey) return;
    const existing = state.restRatings[targetKey];
    const label = document.createElement("label");
    label.style.margin = "0";
    label.textContent = `How rested do you feel this morning (${formatFriendlyDate(targetKey)})?`;
    container.appendChild(label);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "1";
    slider.max = "5";
    slider.step = "1";
    slider.value = String(existing || 3);
    slider.style.flex = "1";
    const valueLabel = document.createElement("span");
    valueLabel.textContent = SLEEP_RATING_LABELS[slider.value] || slider.value;
    slider.addEventListener("input", event => {
      const val = Number(event.target.value);
      valueLabel.textContent = SLEEP_RATING_LABELS[val] || val;
    });
    const save = document.createElement("button");
    save.textContent = existing ? "Update rating" : "Log rating";
    save.addEventListener("click", () => {
      recordSleepRating(targetKey, Number(slider.value));
    });
    container.appendChild(slider);
    container.appendChild(valueLabel);
    container.appendChild(save);
  }

  function updateSleepToolkitUI() {
    const state = loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    const content = $("sleepToolkitContent");
    if (toggle) {
      toggle.checked = Boolean(state.enabled);
    }
    if (!content) return;
    if (!state.enabled) {
      content.classList.add("hidden");
      content.setAttribute("aria-hidden", "true");
      const alert = $("sunlightAlert");
      if (alert) {
        alert.classList.add("hidden");
        alert.setAttribute("aria-hidden", "true");
      }
      if (sunlightAlertTimeoutId) {
        clearTimeout(sunlightAlertTimeoutId);
        sunlightAlertTimeoutId = null;
      }
      return;
    }
    content.classList.remove("hidden");
    content.setAttribute("aria-hidden", "false");
    renderSleepChecklist();
    updateSleepCompletionSummary();
    renderSleepTips();
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.checked = Boolean(state.melatonin?.enabled);
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.value = state.melatonin?.time || DEFAULT_MELATONIN_TIME;
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.checked = Boolean(state.sunlight?.enabled);
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.value = state.sunlight?.time || DEFAULT_SUNLIGHT_TIME;
    }
    renderSleepMorningRating();
    updateSleepCorrelationSummary();
  }

  function initializeSleepToolkitModule() {
    loadSleepToolkitState();
    const toggle = $("sleepToolkitToggle");
    if (toggle) {
      toggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.enabled = event.target.checked;
        persistSleepToolkitState();
        updateSleepToolkitUI();
      });
    }
    const melatoninToggle = $("melatoninReminderToggle");
    if (melatoninToggle) {
      melatoninToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const melatoninTime = $("melatoninReminderTime");
    if (melatoninTime) {
      melatoninTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.melatonin.time = event.target.value || DEFAULT_MELATONIN_TIME;
        persistSleepToolkitState();
      });
    }
    const sunlightToggle = $("sunlightReminderToggle");
    if (sunlightToggle) {
      sunlightToggle.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.enabled = event.target.checked;
        persistSleepToolkitState();
      });
    }
    const sunlightTime = $("sunlightReminderTime");
    if (sunlightTime) {
      sunlightTime.addEventListener("change", event => {
        const state = loadSleepToolkitState();
        state.sunlight.time = event.target.value || DEFAULT_SUNLIGHT_TIME;
        persistSleepToolkitState();
      });
    }
    updateSleepToolkitUI();
  }

  function getMinutesFromTimeString(timeString) {
    if (!timeString || typeof timeString !== "string") return null;
    const [hours, minutes] = timeString.split(":").map(part => Number(part));
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) return null;
    return hours * 60 + minutes;
  }

  function showSunlightBanner(message) {
    const alert = $("sunlightAlert");
    if (!alert) return;
    alert.textContent = message;
    alert.classList.remove("hidden");
    alert.setAttribute("aria-hidden", "false");
    if (sunlightAlertTimeoutId) {
      clearTimeout(sunlightAlertTimeoutId);
    }
    sunlightAlertTimeoutId = setTimeout(() => {
      alert.classList.add("hidden");
      alert.setAttribute("aria-hidden", "true");
    }, 5 * 60 * 1000);
  }

  function checkLaunchPadReminder() {
    const state = loadLaunchPadState();
    const timeMinutes = getMinutesFromTimeString(state.reminderTime || DEFAULT_LAUNCH_PAD_REMINDER);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.lastReminderDate !== todayKey) {
      state.lastReminderDate = todayKey;
      persistLaunchPadState();
      showToast("Launch pad", "Prepare tomorrow's kit? Check your evening checklist.");
    }
  }

  function checkMelatoninReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.melatonin?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.melatonin.time || DEFAULT_MELATONIN_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.melatonin.lastPrompt !== todayKey) {
      state.melatonin.lastPrompt = todayKey;
      persistSleepToolkitState();
      showToast("Melatonin reminder", "Dim the lights and consider your melatonin routine.");
    }
  }

  function checkSunlightReminder() {
    const state = loadSleepToolkitState();
    if (!state.enabled || !state.sunlight?.enabled) return;
    const timeMinutes = getMinutesFromTimeString(state.sunlight.time || DEFAULT_SUNLIGHT_TIME);
    if (timeMinutes === null) return;
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const todayKey = getTodayKey();
    if (currentMinutes >= timeMinutes && state.sunlight.lastPrompt !== todayKey) {
      state.sunlight.lastPrompt = todayKey;
      persistSleepToolkitState();
      showSunlightBanner("Sunlight exposure due — step outside for 10 minutes to halt melatonin.");
      showToast("Sunlight cue", "Morning light = cortisol boost + melatonin shutoff.");
    }
  }

  function checkAllReminders() {
    checkLaunchPadReminder();
    checkMelatoninReminder();
    checkSunlightReminder();
  }

  function startReminderLoop() {
    if (reminderIntervalId) {
      clearInterval(reminderIntervalId);
    }
    checkAllReminders();
    reminderIntervalId = setInterval(checkAllReminders, 60 * 1000);
  }

  function setQuickTaskTemplateMode(enabled) {
    const overlay = $("addTaskOverlay");
    const hint = $("quickTaskTemplateHint");
    const state = enabled ? "true" : "false";
    if (overlay) {
      if (enabled) {
        overlay.setAttribute("data-quick-task-mode", state);
      } else {
        overlay.removeAttribute("data-quick-task-mode");
      }
    }
    if (hint) {
      hint.classList.toggle("hidden", !enabled);
    }
    if (enabled) {
      setTaskDetailsCollapsed(true);
    }
  }

  function handleCategoryChange(value) {
    const resolvedCategory = (value ?? $("taskCategory")?.value ?? "").toString();
    populateScalesForCategory(resolvedCategory);
    if (resolvedCategory.toLowerCase() === "chart") {
      showChartFields();
    } else {
      hideChartFields();
    }
    setQuickTaskTemplateMode(isQuickTaskCategory(resolvedCategory));
    renderTemplates();
  }

  function initializeChartFields() {
    const container = $("chartFields");
    if (!container) return;
    storedChartFieldValues = null;
    container.classList.add("is-hidden");
    container.setAttribute("aria-hidden", "true");
    setChartFieldsDisabled(true);
  }

  const NUMERIC_SCALE_FIELDS = ["importance","novelty","interest","timeToStart","difficulty"];
  const SCALE_FIELDS = [...NUMERIC_SCALE_FIELDS, "urgency", "externalPressure"];
  const BASIC_NUMERIC_DESCRIPTORS = [1, 2, 3, 4, 5].map(value => ({
    value,
    text: String(value)
  }));

  const DEFAULT_DESCRIPTOR_SET = {
    importance: BASIC_NUMERIC_DESCRIPTORS,
    urgency: [
      { value: 5, text: "5 – Critical Billing Window or Immediate Patient Need" },
      { value: 4, text: "4 – High Priority – Near-Term Deadline" },
      { value: 3, text: "3 – Moderate Priority – Monthly Closure" },
      { value: 2, text: "2 – Low Billing Value – Ready today" },
      { value: 1, text: "1 – Routine Follow-Up Work" }
    ],
    novelty: BASIC_NUMERIC_DESCRIPTORS,
    interest: BASIC_NUMERIC_DESCRIPTORS,
    externalPressure: [
      { value: 1, text: "1 – Solo responsibility" },
      { value: 2, text: "2 – Soft deadline / courtesy check" },
      { value: 3, text: "3 – Peer or team waiting" },
      { value: 4, text: "4 – Leadership expectation" },
      { value: 5, text: "5 – Patient or compliance critical" }
    ],
    timeToStart: BASIC_NUMERIC_DESCRIPTORS,
    difficulty: BASIC_NUMERIC_DESCRIPTORS
  };

  const CATEGORY_DESCRIPTOR_SETS = {
    chart: {
      importance: [
        { value: 1, text: "1 – Chart adds minimal new information or duplicates an existing note." },
        { value: 2, text: "2 – Routine follow-up with limited clinical or legal relevance." },
        { value: 3, text: "3 – Contains moderate clinical content or affects internal workflow (e.g., continuity documentation)." },
        { value: 4, text: "4 – Impacts care coordination, billing, or orders being released." },
        { value: 5, text: "5 – Critical legal or clinical documentation—such as a new complex care note, DME letter, or therapy order summary." }
      ],
      urgency: [
        { value: 1, text: "1 – No immediate consequence if delayed more than a week." },
        { value: 2, text: "2 – Should be completed within five to seven days to keep the workflow moving." },
        { value: 3, text: "3 – Approaching the expected three-day chart completion window." },
        { value: 4, text: "4 – Actively holding up orders, referrals, or communication with other providers." },
        { value: 5, text: "5 – Must be completed within 24 hours—blocking patient care, billing, or compliance." }
      ],
      novelty: [
        { value: 1, text: "1 – Repetitive, nearly identical to prior encounters—mental autopilot work." },
        { value: 2, text: "2 – Familiar patient with predictable updates." },
        { value: 3, text: "3 – Some variation or new findings but overall routine." },
        { value: 4, text: "4 – Clearly different or updated scenario (new comorbidity, new specialist input)." },
        { value: 5, text: "5 – Entirely new case or patient; requires full synthesis and high cognitive effort." }
      ],
      interest: [
        { value: 1, text: "1 – Emotionally draining, tedious, or disengaging." },
        { value: 2, text: "2 – Slightly more tolerable but still repetitive." },
        { value: 3, text: "3 – Neutral—acceptable task without resistance or enthusiasm." },
        { value: 4, text: "4 – Personally engaging or meaningful (e.g., rewarding outcome, interesting complexity)." },
        { value: 5, text: "5 – Highly interesting or affirming—feels worth your energy investment." }
      ],
      externalPressure: [
        { value: 1, text: "1 – No one waiting on this; purely internal backlog." },
        { value: 2, text: "2 – Minimal outside awareness—perhaps a resident awaiting co-signature." },
        { value: 3, text: "3 – Family or administrative team may soon follow up." },
        { value: 4, text: "4 – Directly affects nursing, therapy, or resident progress if left undone." },
        { value: 5, text: "5 – Leadership, family, or compliance risk if not completed immediately." }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major prep—multiple subspecialty notes or context review needed." },
        { value: 2, text: "2 – Some setup required; moderate amount of data gathering first." },
        { value: 3, text: "3 – Ready to begin with basic template or SmartPhrase already open." },
        { value: 4, text: "4 – Mostly drafted or pre-filled by a resident." },
        { value: 5, text: "5 – One click from completion—review and sign only." }
      ],
      difficulty: [
        { value: 1, text: "1 – Very complex visit—multiple specialists, high stakes." },
        { value: 2, text: "2 – High cognitive load—multiple notes or CareEverywhere data to merge." },
        { value: 3, text: "3 – Moderate effort—some review of orders, results, or medication changes." },
        { value: 4, text: "4 – Small amount of synthesis or clean-up work." },
        { value: 5, text: "5 – Straightforward chart; minimal thought required." }
      ]
    },
    admin: {
      importance: [
        { value: 1, text: "1: Low-value clerical item — informational only, not linked to care or billing (e.g., generic record release)." },
        { value: 2, text: "2: Routine paperwork (e.g., school letter, general clearance) with limited medical impact." },
        { value: 3, text: "3: Moderately important — ensures continuity of services or avoids family confusion." },
        { value: 4, text: "4: Affects patient function, equipment use, or continuity of home health/therapy services." },
        { value: 5, text: "5: Legally, financially, or clinically critical (e.g., DME or home nursing orders, time-sensitive medical necessity forms)." }
      ],
      urgency: [
        { value: 1, text: "1: No time constraint; backlog cleanup or batch task." },
        { value: 2, text: "2: Preferred within a week to prevent workflow pileup." },
        { value: 3, text: "3: Due soon — flagged or requested multiple times (within 72 hours)." },
        { value: 4, text: "4: Time-sensitive — blocking care, equipment renewal, or external agency action." },
        { value: 5, text: "5: Immediate deadline — service interruption or patient safety risk if not completed today." }
      ],
      novelty: [
        { value: 1, text: "1: Routine, repetitive — identical to previous letters or forms." },
        { value: 2, text: "2: Minor variation (same patient, slightly different form)." },
        { value: 3, text: "3: Moderate variation — new formatting or service type but same structure." },
        { value: 4, text: "4: Requires rethinking or rewriting — new medical justification or appeal." },
        { value: 5, text: "5: Entirely new or unusual form requiring research, collaboration, or creative framing." }
      ],
      interest: [
        { value: 1, text: "1: Utterly draining paperwork with no personal reward." },
        { value: 2, text: "2: Mildly tolerable — repetitive but manageable." },
        { value: 3, text: "3: Neutral task; emotionally flat but not difficult." },
        { value: 4, text: "4: Slightly satisfying — clear, finite, ‘box checked’ gratification." },
        { value: 5, text: "5: Emotionally rewarding — high-impact document that feels meaningful or helps a deserving family." }
      ],
      externalPressure: [
        { value: 1, text: "1: No one waiting; background task only." },
        { value: 2, text: "2: Requested once, no follow-up." },
        { value: 3, text: "3: Family, therapist, or vendor has followed up once or twice." },
        { value: 4, text: "4: Repeated requests or escalating frustration from external partner." },
        { value: 5, text: "5: Time-sensitive escalation — multiple stakeholders involved, risk of complaint or service disruption." }
      ],
      timeToStart: [
        { value: 1, text: "1: Fully prepped or pre-filled — literally one click to sign, fax, or send." },
        { value: 2, text: "2: Nearly complete — requires signatures or minor edits." },
        { value: 3, text: "3: Ready to draft — information accessible, no major digging needed." },
        { value: 4, text: "4: Some setup required — gathering diagnostic codes, reviewing notes." },
        { value: 5, text: "5: Requires locating old versions or supporting documents (e.g., past forms, letters)." }
      ],
      difficulty: [
        { value: 1, text: "1: Straightforward — fill in basic info, minimal judgment." },
        { value: 2, text: "2: Simple but tedious — multiple checkboxes or sign-offs." },
        { value: 3, text: "3: Moderate — requires referencing recent visits or clinical notes." },
        { value: 4, text: "4: High cognitive effort — must summarize complex clinical picture concisely." },
        { value: 5, text: "5: Very complex — appeals, multidisciplinary coordination, or justification requiring clinical precision." }
      ]
    },
    personal: {
      importance: [
        { value: 1, text: "1 – Trivial — doesn’t really matter if done" },
        { value: 2, text: "2 – Mildly useful — minor quality-of-life improvement" },
        { value: 3, text: "3 – Helpful — meaningful progress toward a goal" },
        { value: 4, text: "4 – Significant — affects well-being or relationships" },
        { value: 5, text: "5 – Critical — has serious emotional, financial, or health consequences" }
      ],
      urgency: [
        { value: 1, text: "1 – No time pressure — can wait indefinitely" },
        { value: 2, text: "2 – Slight — would be good to do soon" },
        { value: 3, text: "3 – Moderate — needs attention within a few days" },
        { value: 4, text: "4 – High — needs to be done today" },
        { value: 5, text: "5 – Immediate — must be addressed now" }
      ],
      interest: [
        { value: 1, text: "1 – Dreaded — pure avoidance energy" },
        { value: 2, text: "2 – Unpleasant but tolerable" },
        { value: 3, text: "3 – Neutral — neither appealing nor aversive" },
        { value: 4, text: "4 – Mildly engaging" },
        { value: 5, text: "5 – Genuinely energizing or rewarding" }
      ],
      difficulty: [
        { value: 1, text: "1 – Very hard — high resistance, many steps, or emotionally draining" },
        { value: 2, text: "2 – Challenging — mentally or logistically demanding" },
        { value: 3, text: "3 – Moderate — manageable with steady focus" },
        { value: 4, text: "4 – Mild effort — easy, straightforward, minimal resistance" },
        { value: 5, text: "5 – Simple — effortless, can be done on autopilot" }
      ],
      timeToStart: [
        { value: 1, text: "1 – Requires major setup or emotional readiness" },
        { value: 2, text: "2 – Some prep work before starting" },
        { value: 3, text: "3 – Can start with minimal prep" },
        { value: 4, text: "4 – Ready to begin immediately" },
        { value: 5, text: "5 – Already in motion / one click from done" }
      ]
    }
  };

  function getCategoryDescriptorKey(category) {
    const normalized = (category || "").toString().trim().toLowerCase();
    return normalized || "general";
  }

  function getScaleOptions(fieldId, categoryKey) {
    const key = categoryKey || "general";
    const descriptorSet = CATEGORY_DESCRIPTOR_SETS[key];
    if (descriptorSet && Array.isArray(descriptorSet[fieldId])) {
      return descriptorSet[fieldId];
    }
    const defaults = DEFAULT_DESCRIPTOR_SET[fieldId];
    if (defaults) {
      return defaults;
    }
    return BASIC_NUMERIC_DESCRIPTORS;
  }

  function populateScaleSelect(fieldId, categoryKey) {
    const select = $(fieldId);
    if (!select) return;
    const previousValue = select.value;
    const options = getScaleOptions(fieldId, categoryKey);
    select.innerHTML = "";
    options.forEach(option => {
      const opt = document.createElement("option");
      opt.value = String(option.value);
      opt.textContent = option.text || String(option.value);
      select.appendChild(opt);
    });
    const previous = previousValue !== undefined && previousValue !== null
      ? String(previousValue)
      : "";
    const hasPrevious = options.some(option => String(option.value) === previous);
    if (hasPrevious) {
      select.value = previous;
    } else if (options.length > 0) {
      select.value = String(options[0].value);
    }
  }

  function populateScalesForCategory(category) {
    const key = getCategoryDescriptorKey(category);
    currentScaleDescriptorCategory = key;
    SCALE_FIELDS.forEach(fieldId => populateScaleSelect(fieldId, key));
    updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
  }

  const BASE_CHART_STEPS = [
    "Load Abridge (dictation)",
    "Review/modify HPI",
    "Review/modify PE",
    "Review/modify A/P",
    "Review/submit orders",
    "Enter billing code",
    "Sign off"
  ];
  const RESIDENT_ATTESTATION_STEP = "Add Attestation";
  let currentFocusTaskIndex = null;

  function generateSubTaskId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  }

  function isChartTask(task) {
    return task && String(task.category).toLowerCase() === "chart";
  }

  function isQuickTaskCategory(value) {
    return String(value || "").toLowerCase() === QUICK_TASK_CATEGORY.toLowerCase();
  }

  function isQuickTask(task) {
    return task && isQuickTaskCategory(task.category);
  }

  function buildChartSteps(authorType) {
    const steps = [...BASE_CHART_STEPS];
    if (String(authorType).toLowerCase() === "resident") {
      const billingIndex = steps.indexOf("Enter billing code");
      const insertIndex = billingIndex === -1 ? steps.length - 1 : billingIndex;
      steps.splice(insertIndex, 0, RESIDENT_ATTESTATION_STEP);
    }
    return steps;
  }

  function calculateDurationMinutes(start, end) {
    if (!start || !end) return null;
    const startDate = new Date(start);
    const endDate = new Date(end);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
    const diff = endDate.getTime() - startDate.getTime();
    if (diff < 0) return null;
    return Number((diff / (1000 * 60)).toFixed(2));
  }

  function isTaskCompleted(task) {
    if (!task) return false;
    return Boolean(task.completed || task.completedAt);
  }

  function getCompletionTimestamp(task) {
    if (!task) return null;
    return task.completedAt || task.completionTime || null;
  }

  function formatDateTime(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  }

  function formatDuration(minutes) {
    if (minutes === null || minutes === undefined) return "--";
    const num = Number(minutes);
    if (!Number.isFinite(num)) return "--";
    return `${num.toFixed(2)} min`;
  }

  function formatElapsedMs(ms) {
    if (!Number.isFinite(ms) || ms < 0) return "--";
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}m ${seconds.toString().padStart(2, "0")}s`;
  }

  function estimateTaskMinutes(task) {
    if (!task) return 0;
    const subTasks = Array.isArray(task.subTasks) ? task.subTasks : [];
    const remaining = subTasks.filter(sub => !sub.completed);
    const remainingCount = remaining.length > 0 ? remaining.length : 1;
    const recordedDurations = subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value) && value > 0);
    if (recordedDurations.length) {
      const avg = recordedDurations.reduce((sum, value) => sum + value, 0) / recordedDurations.length;
      return Math.max(1, Math.ceil(avg * remainingCount));
    }
    const n = subTasks.length;
    const difficulty = Number(task.difficulty || 3);
    const startFriction = Number(task.timeToStart || 3);
    const estimate = Math.round((10 + 2 * n) * (0.7 + 0.15 * difficulty) + (startFriction - 3) * 2);
    return Math.max(5, estimate);
  }

  function getEnergyLevel() {
    const el = document.querySelector('[data-field="energy-level"]');
    if (el) {
      const value = Number(el.value || el.getAttribute('data-value'));
      if (Number.isFinite(value)) return value;
    }
    return 3;
  }

  function getTimeBudgetMinutes() {
    const el = document.querySelector('[data-field="time-budget"]');
    if (!el) return Infinity;
    const value = Number(el.value);
    return Number.isFinite(value) && value > 0 ? value : Infinity;
  }

  function alignEnergySliders(value, source = "next") {
    const resolved = clampScale(value, 3);
    if (syncingEnergySliders) {
      return resolved;
    }
    syncingEnergySliders = true;
    const nextSlider = $("nextBestEnergy");
    if (nextSlider && source !== "next" ) {
      nextSlider.value = String(resolved);
      nextSlider.setAttribute("data-value", String(resolved));
    }
    const nextLabel = $("nextBestEnergyLabel");
    if (nextLabel) {
      const label = ENERGY_LABELS[resolved] || resolved;
      nextLabel.textContent = label;
    }
    const morningSlider = $("morningEnergy");
    if (morningSlider && source !== "morning") {
      morningSlider.value = String(resolved);
      const morningLabel = $("morningEnergyLabel");
      if (morningLabel) {
        const label = ENERGY_LABELS[resolved] || resolved;
        morningLabel.textContent = label;
      }
    }
    const nextField = document.querySelector('#nextBestEnergy');
    if (nextField) {
      nextField.setAttribute('data-value', String(resolved));
    }
    if (source !== "sheet") {
      const sheet = document.getElementById("energySheet");
      const refresh = sheet && typeof sheet.__refreshEnergySheet === "function"
        ? sheet.__refreshEnergySheet
        : null;
      if (refresh) {
        refresh(resolved);
      } else {
        const sheetSlider = document.getElementById("energySheetSlider");
        if (sheetSlider) {
          sheetSlider.value = String(resolved);
          sheetSlider.setAttribute("data-value", String(resolved));
        }
        const sheetValue = document.getElementById("energySheetValue");
        if (sheetValue) {
          const label = ENERGY_LABELS[resolved] || resolved;
          sheetValue.textContent = `${resolved} • ${label}`;
        }
      }
    }
    syncingEnergySliders = false;
    return resolved;
  }

  function energyFit(task, energyLevel) {
    if (!Number.isFinite(energyLevel)) return 1;
    const est = estimateTaskMinutes(task);
    const difficulty = Number(task?.difficulty || 3);
    const lowEnergyWeight = energyLevel <= 2 ? (est > 20 ? 0.85 : 1) * (difficulty >= 4 ? 0.85 : 1) : 1;
    const highEnergyWeight = energyLevel >= 4 ? 1.05 : 1;
    return lowEnergyWeight * highEnergyWeight;
  }

  function timeFit(task, budgetMinutes) {
    if (!Number.isFinite(budgetMinutes)) return 1;
    const est = estimateTaskMinutes(task);
    if (!Number.isFinite(est) || est <= 0) return 1;
    if (est <= budgetMinutes) {
      const ratio = est / (budgetMinutes * 0.85);
      return Math.max(0.85, Math.min(1.05, 1.05 - Math.abs(1 - ratio) * 0.3));
    }
    const overRatio = est / budgetMinutes;
    return Math.max(0.55, 1 - (overRatio - 1) * 0.6);
  }


  function getEffectiveEnergyLevel() {
    let level = null;
    try {
      if (typeof getMorningEntry === "function") {
        const entry = getMorningEntry();
        if (entry && Number.isFinite(Number(entry.energy))) {
          level = clampScale(entry.energy, 3);
        }
      }
    } catch (error) {
      console.warn("Unable to read morning energy entry", error);
    }
    if (!Number.isFinite(level)) {
      const slider = $("morningEnergy");
      if (slider) {
        const sliderValue = Number(slider.value);
        if (Number.isFinite(sliderValue)) {
          level = clampScale(sliderValue, 3);
        }
      }
    }
    if (!Number.isFinite(level)) {
      level = 3;
    }
    return level;
  }

  function computeEnergyFit(task, energyLevel) {
    return energyFit(task, energyLevel);
  }

  function computeTimeFit(task, budgetMinutes) {
    return timeFit(task, budgetMinutes);
  }

  function createSubTask(name, priority, options = {}) {
    return {
      id: generateSubTaskId(),
      name,
      completed: false,
      priority,
      startTime: null,
      completionTime: null,
      durationMinutes: null,
      activeDurationMs: 0,
      lastResumedAt: null,
      isPaused: false,
      isFirstThree: Boolean(options.isFirstThree),
      deferredUntilUnlock: Boolean(options.deferredUntilUnlock)
    };
  }

  function normalizeSubTask(sub, basePriority) {
    if (!sub) {
      return createSubTask("Step", basePriority);
    }
    const normalized = {
      id: sub.id || generateSubTaskId(),
      name: sub.name || "Step",
      completed: Boolean(sub.completed),
      priority: toNumber(sub.priority, basePriority),
      startTime: sub.startTime || null,
      completionTime: sub.completionTime || null,
      durationMinutes: sub.durationMinutes !== undefined && sub.durationMinutes !== null && Number.isFinite(Number(sub.durationMinutes))
        ? Number(sub.durationMinutes)
        : null,
      activeDurationMs: Number.isFinite(Number(sub.activeDurationMs)) ? Number(sub.activeDurationMs) : 0,
      lastResumedAt: sub.lastResumedAt || null,
      isPaused: Boolean(sub.isPaused),
      isFirstThree: Boolean(sub.isFirstThree),
      deferredUntilUnlock: Boolean(sub.deferredUntilUnlock)
    };
    if (normalized.durationMinutes === null && normalized.startTime && normalized.completionTime) {
      normalized.durationMinutes = calculateDurationMinutes(normalized.startTime, normalized.completionTime);
    }
    if (normalized.completed) {
      normalized.isPaused = false;
      normalized.lastResumedAt = null;
    }
    return normalized;
  }

  function shouldTriggerFirstThreeWizard(taskName, subLines, category) {
    const normalizedName = (taskName || "").toLowerCase();
    const wordCount = normalizedName.split(/\s+/).filter(Boolean).length;
    const hasKeyword = FIRST_THREE_KEYWORDS.some(keyword => normalizedName.includes(keyword));
    const isChart = (category || "").toLowerCase() === "chart";
    if (Array.isArray(subLines) && subLines.length > 0) {
      return false;
    }
    return wordCount >= FIRST_THREE_WORD_THRESHOLD || hasKeyword || isChart;
  }

  function applyFirstThreeSteps(task, steps, basePriority) {
    if (!task) return;
    const trimmed = Array.isArray(steps)
      ? steps.map(step => step.trim()).filter(Boolean)
      : [];
    while (trimmed.length < 3) {
      const defaults = ["Open workspace", "Outline first move", "Start five-minute draft"];
      trimmed.push(defaults[trimmed.length] || `Micro step ${trimmed.length + 1}`);
    }
    task.firstThreeMode = true;
    task.firstThreeUnlocked = Boolean(task.firstThreeUnlocked);
    task.firstThreeSteps = trimmed.slice(0, 3);
    const firstThreeSubs = trimmed.slice(0, 3).map(step => createSubTask(step, basePriority, { isFirstThree: true }));
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const deferred = !task.firstThreeUnlocked;
    const remainder = existingSubs.map(sub => ({
      ...sub,
      deferredUntilUnlock: deferred && !sub.isFirstThree
    }));
    task.subTasks = [...firstThreeSubs, ...remainder];
  }

  function getVisibleSubTasks(task) {
    if (!task || !Array.isArray(task.subTasks)) return [];
    if (!task.firstThreeMode || task.firstThreeUnlocked) {
      return task.subTasks;
    }
    return task.subTasks.filter(sub => sub.isFirstThree || !sub.deferredUntilUnlock);
  }

  function maybeUnlockFirstThree(task, { silent = false } = {}) {
    if (!task || !task.firstThreeMode) return;
    const subs = Array.isArray(task.subTasks) ? task.subTasks : [];
    const firstThreeSubs = subs.filter(sub => sub.isFirstThree);
    if (firstThreeSubs.length === 0) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      return;
    }
    const allComplete = firstThreeSubs.every(sub => sub.completed);
    if (allComplete && !task.firstThreeUnlocked) {
      task.firstThreeUnlocked = true;
      task.subTasks = subs.map(sub => ({ ...sub, deferredUntilUnlock: false }));
      if (!silent) {
        showToast("Momentum!", "Nice momentum! Here's what's next.");
      }
    }
  }

  function computeTotalChartDuration(subTasks) {
    if (!Array.isArray(subTasks) || subTasks.length === 0) return 0;
    return Number(subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0).toFixed(2));
  }

  function getTaskTotalDuration(task) {
    if (!task) return null;
    if (isChartTask(task)) {
      const value = Number(task.chartDurationMinutes);
      return Number.isFinite(value) && value > 0 ? value : null;
    }
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.reduce((sum, sub) => {
      const value = Number(sub.durationMinutes);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);
    if (total <= 0) return null;
    return Number(total.toFixed(2));
  }

  function updateChartDurationForTask(task) {
    if (!isChartTask(task)) {
      delete task.chartDurationMinutes;
      return;
    }
    task.chartDurationMinutes = computeTotalChartDuration(task.subTasks);
  }

  function clearRunningTimers() {
    runningTimers.forEach(intervalId => clearInterval(intervalId));
    runningTimers.clear();
  }

  function stopTimerForSubTask(subId) {
    const intervalId = runningTimers.get(subId);
    if (intervalId) {
      clearInterval(intervalId);
      runningTimers.delete(subId);
    }
  }

  function getSubTaskElapsedMs(sub, includeRunning = true) {
    if (!sub) return 0;
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    if (!includeRunning) {
      return base;
    }
    if (!sub.startTime || sub.completed || sub.isPaused) {
      return base;
    }
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    if (Number.isNaN(resumeDate.getTime())) {
      return base;
    }
    return base + Math.max(0, Date.now() - resumeDate.getTime());
  }

  function dispatchFocusStepEvent(eventName, detail) {
    const target = $("focus") || document;
    target.dispatchEvent(new CustomEvent(eventName, { bubbles: true, detail }));
  }

  function trackTimer(sub, timerEl) {
    if (!timerEl) return;
    stopTimerForSubTask(sub.id);
    if (sub.completed) {
      timerEl.textContent = `Completed – ${formatDuration(sub.durationMinutes)}`;
      return;
    }
    if (!sub.startTime) {
      timerEl.textContent = "Timer: --";
      return;
    }
    if (sub.isPaused) {
      const pausedElapsed = getSubTaskElapsedMs(sub, false);
      timerEl.textContent = `Paused – ${formatElapsedMs(pausedElapsed)}`;
      return;
    }
    const update = () => {
      const elapsedMs = getSubTaskElapsedMs(sub);
      if (!Number.isFinite(elapsedMs) || elapsedMs < 0) {
        timerEl.textContent = "Timer: --";
        return;
      }
      timerEl.textContent = `Timer: ${formatElapsedMs(elapsedMs)}`;
    };
    update();
    const intervalId = setInterval(update, 1000);
    runningTimers.set(sub.id, intervalId);
  }

  function setSprintVisualState(active) {
    const bodyEl = document.body;
    if (!bodyEl) return;
    bodyEl.classList.toggle("sprint-active", Boolean(active));
  }

  function stopFocusTimer(resetDisplay = true) {
    if (focusTimerId) {
      clearInterval(focusTimerId);
      focusTimerId = null;
    }
    focusTimerStart = null;
    focusTimerLastPing = null;
    sprintEndTime = null;
    if (resetDisplay) {
      sprintDurationMinutes = null;
      resetDistractionTracking();
      setSprintVisualState(false);
    }
    setCaughtMeEnabled(false);
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    timerEl.classList.remove("pulse");
    if (resetDisplay) {
      timerEl.textContent = "🧭 Focus Time: 0:00";
      setFocusProgress(0);
    }
  }

  function setFocusProgress(percent) {
    const fill = $("focusProgressFill");
    if (!fill) return;
    const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
    fill.style.width = `${clamped}%`;
  }

  function updateFocusTimerDisplay(elapsedMs) {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0 && sprintEndTime) {
      const remaining = Math.max(0, sprintEndTime - Date.now());
      if (remaining > 0) {
        const minutesLeft = Math.floor(remaining / 60000);
        const secondsLeft = Math.floor((remaining % 60000) / 1000);
        timerEl.textContent = `⏱️ Sprint: ${minutesLeft}:${String(secondsLeft).padStart(2, "0")}`;
        const total = sprintDurationMinutes * 60000;
        const elapsed = Math.max(0, total - remaining);
        setFocusProgress(total > 0 ? (elapsed / total) * 100 : 0);
        return;
      }
      sprintDurationMinutes = null;
      sprintEndTime = null;
      timerEl.textContent = "✅ Sprint complete";
      setFocusProgress(100);
      triggerFocusPing();
      openWinLogPrompt();
      return;
    }
    const minutes = Math.floor(elapsedMs / 60000);
    const seconds = Math.floor((elapsedMs % 60000) / 1000);
    timerEl.textContent = `🧭 Focus Time: ${minutes}:${String(seconds).padStart(2, "0")}`;
    const gentlePercent = Math.min(100, (elapsedMs / (25 * 60000)) * 100);
    setFocusProgress(gentlePercent);
  }

  function playFocusPing() {
    if (!focusSoundEnabled) return;
    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextCtor) return;
    if (!focusAudioContext) {
      try {
        focusAudioContext = new AudioContextCtor();
      } catch (error) {
        focusAudioContext = null;
        return;
      }
    }
    if (focusAudioContext.state === "suspended") {
      focusAudioContext.resume().catch(() => {});
    }
    const duration = 0.4;
    const oscillator = focusAudioContext.createOscillator();
    const gain = focusAudioContext.createGain();
    oscillator.type = "sine";
    oscillator.frequency.setValueAtTime(880, focusAudioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, focusAudioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, focusAudioContext.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, focusAudioContext.currentTime + duration);
    oscillator.connect(gain);
    gain.connect(focusAudioContext.destination);
    oscillator.start();
    oscillator.stop(focusAudioContext.currentTime + duration);
  }

  function triggerFocusPing() {
    const timerEl = $("focusTimer");
    if (timerEl) {
      timerEl.classList.add("pulse");
      setTimeout(() => timerEl.classList.remove("pulse"), 1000);
    }
    playFocusPing();
  }

  function startFocusTimer() {
    const timerEl = $("focusTimer");
    if (!timerEl) return;
    stopFocusTimer(false);
    focusTimerStart = Date.now();
    focusTimerLastPing = focusTimerStart;
    if (Number.isFinite(sprintDurationMinutes) && sprintDurationMinutes > 0) {
      sprintEndTime = focusTimerStart + sprintDurationMinutes * 60000;
    } else {
      sprintEndTime = null;
    }
    updateFocusTimerDisplay(0);
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0) {
      setFocusProgress(0);
    }
    focusTimerId = setInterval(() => {
      if (focusTimerStart === null) return;
      const now = Date.now();
      const elapsed = now - focusTimerStart;
      updateFocusTimerDisplay(elapsed);
      if (!focusTimerLastPing || now - focusTimerLastPing >= FOCUS_PING_INTERVAL_MS) {
        triggerFocusPing();
        focusTimerLastPing = now;
      }
    }, 1000);
    setCaughtMeEnabled(true);
  }

  function setCaughtMeEnabled(enabled) {
    const button = $("caughtMeButton");
    if (!button) return;
    button.disabled = !enabled;
    button.setAttribute("aria-disabled", enabled ? "false" : "true");
    if (!enabled) {
      hideDistractionPrompt();
    }
  }

  function hideDistractionPrompt() {
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.classList.add("hidden");
    }
  }

  function toggleDistractionPrompt() {
    if (!focusTimerStart) return;
    const prompt = $("distractionPrompt");
    if (!prompt) return;
    prompt.classList.toggle("hidden");
  }

  function resetDistractionTracking() {
    focusDistractionLog = [];
    distractionTriggersSinceReset = 0;
    updateDistractionLogUI();
    hideDistractionPrompt();
    clearDoorwayResetState({ hidePrompt: true });
  }

  function updateDistractionLogUI() {
    const list = $("distractionLog");
    if (!list) return;
    list.innerHTML = "";
    if (!focusDistractionLog.length) {
      const empty = document.createElement("li");
      empty.className = "distraction-empty";
      empty.textContent = "Clear runway. Keep cruising.";
      list.appendChild(empty);
      return;
    }
    const entries = focusDistractionLog.slice().reverse();
    entries.forEach(entry => {
      const item = document.createElement("li");
      const time = document.createElement("span");
      time.className = "distraction-log__time";
      if (Number.isFinite(entry.offset)) {
        time.textContent = formatElapsedMs(entry.offset);
      } else {
        time.textContent = new Date(entry.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
      const label = document.createElement("div");
      label.className = "distraction-log__label";
      label.textContent = entry.label;
      item.appendChild(time);
      item.appendChild(label);
      list.appendChild(item);
    });
  }

  function logDistractionTrigger(triggerValue) {
    if (!focusTimerStart) return;
    const option = DISTRACTION_TRIGGER_OPTIONS.find(entry => entry.value === triggerValue);
    const label = option ? option.label : String(triggerValue || "Trigger");
    const timestamp = Date.now();
    const offset = focusTimerStart ? Math.max(0, timestamp - focusTimerStart) : null;
    focusDistractionLog.push({ label, timestamp, offset });
    if (focusDistractionLog.length > 8) {
      focusDistractionLog = focusDistractionLog.slice(focusDistractionLog.length - 8);
    }
    distractionTriggersSinceReset += 1;
    updateDistractionLogUI();
    hideDistractionPrompt();
    maybePromptDoorwayReset();
  }

  function maybePromptDoorwayReset() {
    if (doorwayResetState.active || doorwayResetState.pending) return;
    if (distractionTriggersSinceReset < DOORWAY_RESET_THRESHOLD) return;
    showDoorwayResetPrompt();
  }

  function showDoorwayResetPrompt() {
    const container = $("doorwayReset");
    const message = $("doorwayResetMessage");
    if (!container || !message) return;
    container.classList.remove("hidden");
    message.textContent = "Two distractions logged. Take a 60-second doorway reset?";
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: true, endTime: null, countdownId: null };
    showToast("Doorway reset", "Stand, walk to the doorway, clear the mental cache, then glide back.");
  }

  function startDoorwayResetCountdown() {
    const container = $("doorwayReset");
    if (!container) return;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Stand, walk to the doorway, and let the reset happen.";
    }
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: true, pending: false, endTime: Date.now() + DOORWAY_RESET_DURATION_MS, countdownId: null };
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Reset running…";
      startBtn.disabled = true;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Skip reset";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.classList.remove("hidden");
    }
    updateDoorwayCountdownUI();
    doorwayResetState.countdownId = setInterval(updateDoorwayCountdownUI, 250);
  }

  function updateDoorwayCountdownUI() {
    if (!doorwayResetState.active) return;
    const countdown = $("doorwayCountdown");
    if (!countdown) return;
    const remaining = Math.max(0, doorwayResetState.endTime - Date.now());
    const seconds = Math.ceil(remaining / 1000);
    countdown.textContent = `⏳ ${seconds}s remaining`;
    if (remaining <= 0) {
      completeDoorwayReset();
    }
  }

  function completeDoorwayReset() {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    distractionTriggersSinceReset = 0;
    const message = $("doorwayResetMessage");
    if (message) {
      message.textContent = "Doorway reset complete. Notice what feels lighter.";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "✅ Reset done";
      countdown.classList.remove("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Do it again";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Close";
    }
    setTimeout(() => clearDoorwayResetState({ hidePrompt: true }), 6000);
  }

  function clearDoorwayResetState({ hidePrompt = false } = {}) {
    if (doorwayResetState.countdownId) {
      clearInterval(doorwayResetState.countdownId);
    }
    doorwayResetState = { active: false, pending: false, endTime: null, countdownId: null };
    const container = $("doorwayReset");
    if (!container) return;
    if (hidePrompt) {
      container.classList.add("hidden");
    }
    const message = $("doorwayResetMessage");
    if (message && hidePrompt) {
      message.textContent = "";
    }
    const countdown = $("doorwayCountdown");
    if (countdown) {
      countdown.textContent = "";
      countdown.classList.add("hidden");
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.textContent = "Start 60-second reset";
      startBtn.disabled = false;
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.textContent = "Not now";
    }
  }

  function skipDoorwayResetPrompt() {
    clearDoorwayResetState({ hidePrompt: true });
    distractionTriggersSinceReset = 0;
  }

  function initializeDistractionTools() {
    const button = $("caughtMeButton");
    if (button) {
      button.addEventListener("click", () => {
        if (button.disabled) return;
        toggleDistractionPrompt();
      });
    }
    const prompt = $("distractionPrompt");
    if (prompt) {
      prompt.addEventListener("click", event => {
        const target = event.target.closest('[data-distraction-trigger]');
        if (!target) return;
        const value = target.getAttribute('data-distraction-trigger');
        if (value) {
          logDistractionTrigger(value);
        }
      });
    }
    const startBtn = $("doorwayStartButton");
    if (startBtn) {
      startBtn.addEventListener("click", startDoorwayResetCountdown);
    }
    const skipBtn = $("doorwaySkipButton");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipDoorwayResetPrompt);
    }
    updateDistractionLogUI();
    setCaughtMeEnabled(false);
  }

  function setFocusSoundPreference(enabled) {
    focusSoundEnabled = Boolean(enabled);
    localStorage.setItem("focusSoundEnabled", focusSoundEnabled ? "true" : "false");
  }

  function getAuditStorageKey(date = new Date()) {
    return `${AUDIT_STORAGE_PREFIX}${date.toISOString().split("T")[0]}`;
  }

  function getAuditShownKey(storageKey) {
    return `${storageKey}${AUDIT_SHOWN_SUFFIX}`;
  }

  function loadAuditEntries(storageKey) {
    if (!storageKey) return [];
    const raw = localStorage.getItem(storageKey);
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  }

  function recordTaskCompletion(task) {
    if (!task) return;
    const storageKey = getAuditStorageKey();
    const entries = loadAuditEntries(storageKey);
    const subDetails = Array.isArray(task.subTasks)
      ? task.subTasks.map(sub => {
          const rawDuration = Number(sub?.durationMinutes);
          const normalizedDuration = Number.isFinite(rawDuration) && rawDuration > 0
            ? Number(rawDuration.toFixed(2))
            : null;
          return {
            name: sub?.name || "Step",
            duration: normalizedDuration
          };
        })
      : [];
    let totalDuration = getTaskTotalDuration(task);
    if (Number.isFinite(totalDuration) && totalDuration > 0) {
      totalDuration = Number(totalDuration.toFixed(2));
    } else {
      const fallbackTotal = subDetails.reduce((sum, sub) => {
        return Number.isFinite(sub.duration) ? sum + sub.duration : sum;
      }, 0);
      totalDuration = fallbackTotal > 0 ? Number(fallbackTotal.toFixed(2)) : null;
    }
    entries.push({
      name: task.name || "Task",
      subDetails,
      totalDuration,
      completedAt: getCompletionTimestamp(task) || new Date().toISOString()
    });
    localStorage.setItem(storageKey, JSON.stringify(entries));
  }

  function showEndOfDayAudit(entries = null, shownKeyOverride = null) {
    const storageKey = getAuditStorageKey();
    const auditEntries = entries || loadAuditEntries(storageKey);
    if (!auditEntries.length) return;
    const shownKey = shownKeyOverride || getAuditShownKey(storageKey);

    const overlay = document.createElement("div");
    overlay.className = "audit-backdrop";
    overlay.setAttribute("role", "dialog");
    overlay.setAttribute("aria-modal", "true");
    overlay.setAttribute("aria-labelledby", "auditModalTitle");

    const modal = document.createElement("div");
    modal.className = "audit-modal";

    const title = document.createElement("h3");
    title.id = "auditModalTitle";
    title.textContent = "End of Day Audit";
    modal.appendChild(title);

    const totalMinutes = auditEntries.reduce((sum, entry) => {
      const value = Number(entry?.totalDuration);
      return Number.isFinite(value) ? sum + value : sum;
    }, 0);

    let longestSubtask = null;
    auditEntries.forEach(entry => {
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      details.forEach(sub => {
        const duration = Number(sub?.duration);
        if (!Number.isFinite(duration)) return;
        if (!longestSubtask || duration > longestSubtask.duration) {
          longestSubtask = {
            taskName: entry?.name || "Task",
            name: sub?.name || "Step",
            duration
          };
        }
      });
    });

    const summary = document.createElement("div");
    summary.className = "audit-summary";
    const summaryLines = [
      `Tasks completed: ${auditEntries.length}`,
      `Productive minutes: ${formatDuration(totalMinutes)}`,
      longestSubtask
        ? `Longest subtask: ${longestSubtask.name} (${formatDuration(longestSubtask.duration)}) — ${longestSubtask.taskName}`
        : "Longest subtask: --"
    ];
    summaryLines.forEach(text => {
      const line = document.createElement("div");
      line.textContent = text;
      summary.appendChild(line);
    });
    modal.appendChild(summary);

    const list = document.createElement("ul");
    list.className = "audit-task-list";
    auditEntries.forEach(entry => {
      const item = document.createElement("li");
      const header = document.createElement("strong");
      header.textContent = `${entry?.name || "Task"} — ${formatDuration(entry?.totalDuration)}`;
      item.appendChild(header);
      const details = Array.isArray(entry?.subDetails) ? entry.subDetails : [];
      if (details.length) {
        const subList = document.createElement("ul");
        subList.className = "audit-task-subtasks";
        details.forEach(sub => {
          const subItem = document.createElement("li");
          subItem.textContent = `${sub?.name || "Step"}: ${formatDuration(sub?.duration)}`;
          subList.appendChild(subItem);
        });
        item.appendChild(subList);
      }
      list.appendChild(item);
    });
    modal.appendChild(list);

    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "Close";

    const closeModal = () => {
      overlay.remove();
      document.removeEventListener("keydown", onKeyDown);
    };

    const onKeyDown = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeModal();
      }
    };

    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeModal();
      }
    });
    document.addEventListener("keydown", onKeyDown);

    modal.appendChild(closeBtn);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    requestAnimationFrame(() => closeBtn.focus());
    if (shownKey) {
      localStorage.setItem(shownKey, "true");
    }
  }

  function maybeShowEndOfDayAudit() {
    const remainingActive = tasks.filter(task => !isTaskCompleted(task)).length;
    if (remainingActive > 0) return;
    const storageKey = getAuditStorageKey();
    const shownKey = getAuditShownKey(storageKey);
    if (localStorage.getItem(shownKey) === "true") return;
    const entries = loadAuditEntries(storageKey);
    if (!entries.length) return;
    showEndOfDayAudit(entries, shownKey);
  }

  function initializeSoundPreference() {
    const saved = localStorage.getItem("focusSoundEnabled");
    if (saved !== null) {
      focusSoundEnabled = saved === "true";
    }
    const toggle = $("focusSoundToggle");
    if (!toggle) return;
    toggle.checked = focusSoundEnabled;
    toggle.addEventListener("change", event => {
      setFocusSoundPreference(event.target.checked);
      if (focusSoundEnabled && focusAudioContext && focusAudioContext.state === "suspended") {
        focusAudioContext.resume().catch(() => {});
      }
    });
  }

  function ensureChartSubTasks(task, options = {}) {
    if (!isChartTask(task)) return false;
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    const basePriority = options.basePriority !== undefined
      ? options.basePriority
      : computePriority({ ...task, subTasks: [] });
    if (task.useChartTemplate === false) {
      task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      return false;
    }
    const defaults = buildChartSteps(task.authorType);
    const lowerDefaults = defaults.map(step => step.toLowerCase());
    const requiredSet = new Set(lowerDefaults);
    const attestationKey = RESIDENT_ATTESTATION_STEP.toLowerCase();
    let changed = false;

    if (!requiredSet.has(attestationKey)) {
      const filtered = task.subTasks.filter(sub => String(sub?.name || "").toLowerCase() !== attestationKey);
      if (filtered.length !== task.subTasks.length) {
        task.subTasks = filtered;
        changed = true;
      }
    }

    const existingByName = new Map();
    task.subTasks.forEach((sub, index) => {
      const key = String(sub?.name || "").toLowerCase();
      if (!existingByName.has(key)) {
        existingByName.set(key, { sub, index });
      }
    });

    const orderedDefaults = defaults.map(step => {
      const key = step.toLowerCase();
      const existing = existingByName.get(key);
      if (existing) {
        existingByName.delete(key);
        return existing.sub;
      }
      changed = true;
      return createSubTask(step, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    const extras = task.subTasks.filter(sub => {
      const key = String(sub?.name || "").toLowerCase();
      return !requiredSet.has(key);
    });

    const nextSubTasks = [...orderedDefaults, ...extras];
    const sameOrder = nextSubTasks.length === task.subTasks.length
      && nextSubTasks.every((sub, idx) => sub === task.subTasks[idx]);
    if (!sameOrder) {
      task.subTasks = nextSubTasks;
      if (!changed) changed = true;
    }

    task.subTasks.forEach(sub => {
      if (sub.priority !== basePriority) {
        sub.priority = basePriority;
        changed = true;
      }
      if (task.firstThreeMode) {
        sub.deferredUntilUnlock = !task.firstThreeUnlocked && !sub.isFirstThree;
      } else if (sub.deferredUntilUnlock) {
        sub.deferredUntilUnlock = false;
      }
    });

    return changed;
  }

  function resolveTaskAndSub(taskIndex, subIndex, options = {}) {
    let resolvedIndex = taskIndex;
    let task = tasks[resolvedIndex];
    if ((!task || resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && options.taskId) {
      resolvedIndex = tasks.findIndex(t => t.id === options.taskId);
      task = tasks[resolvedIndex];
    }
    if (!task) {
      return { task: null, taskIndex: -1, sub: null, subIndex: -1 };
    }
    let resolvedSubIndex = subIndex;
    let sub = Array.isArray(task.subTasks) ? task.subTasks[resolvedSubIndex] : undefined;
    if ((!sub || resolvedSubIndex === undefined || resolvedSubIndex === null || resolvedSubIndex < 0) && options.subId && Array.isArray(task.subTasks)) {
      resolvedSubIndex = task.subTasks.findIndex(s => s.id === options.subId);
      sub = task.subTasks[resolvedSubIndex];
    }
    return { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex };
  }

  function renderChartSummary(task) {
    const container = document.createElement("div");
    container.className = "chart-summary";
    const heading = document.createElement("h4");
    heading.textContent = "Chart Summary";
    container.appendChild(heading);
    const list = document.createElement("ul");
    const durations = task.subTasks
      .map(sub => Number(sub.durationMinutes))
      .filter(value => Number.isFinite(value));
    const longest = durations.length ? Math.max(...durations) : null;
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      item.textContent = `${sub.name}: ${formatDuration(sub.durationMinutes)}`;
      if (longest !== null && Number(sub.durationMinutes) === longest) {
        item.classList.add("longest-step");
      }
      list.appendChild(item);
    });
    container.appendChild(list);
    const total = Number.isFinite(Number(task.chartDurationMinutes))
      ? Number(task.chartDurationMinutes)
      : computeTotalChartDuration(task.subTasks);
    const totalLabel = document.createElement("div");
    totalLabel.className = "chart-total";
    totalLabel.textContent = `Total duration: ${formatDuration(total)}`;
    container.appendChild(totalLabel);
    return container;
  }

  function refreshAfterSubTaskChange(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    persist();
    const focusActive = !$("focus").classList.contains("hidden");
    if (focusActive) {
      const currentFocusTask = focusQueue[0];
      if ((resolvedIndex !== -1 && currentFocusTaskIndex === resolvedIndex)
        || (options.taskId && currentFocusTask && currentFocusTask.id === options.taskId)) {
        renderFocusTask(task, resolvedIndex);
      }
    }
    if (!focusActive && !options.focusOnly) {
      updateUI();
    }
  }

  function startSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const nowIso = new Date().toISOString();
    sub.startTime = nowIso;
    sub.lastResumedAt = nowIso;
    sub.activeDurationMs = 0;
    sub.isPaused = false;
    sub.completed = false;
    sub.completionTime = null;
    sub.durationMinutes = null;
    stopTimerForSubTask(sub.id);
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function pauseSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || !sub.startTime || sub.completed || sub.isPaused) return;
    const resumeReference = sub.lastResumedAt || sub.startTime;
    const resumeDate = new Date(resumeReference);
    const base = Math.max(0, Number(sub.activeDurationMs) || 0);
    const now = Date.now();
    const additional = Number.isNaN(resumeDate.getTime()) ? 0 : Math.max(0, now - resumeDate.getTime());
    sub.activeDurationMs = base + additional;
    sub.lastResumedAt = null;
    sub.isPaused = true;
    stopTimerForSubTask(sub.id);
    dispatchFocusStepEvent("focus:step-paused", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function resumeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub || sub.completed) return;
    const nowIso = new Date().toISOString();
    if (!sub.startTime) {
      sub.startTime = nowIso;
      sub.activeDurationMs = Math.max(0, Number(sub.activeDurationMs) || 0);
    }
    sub.lastResumedAt = nowIso;
    sub.isPaused = false;
    dispatchFocusStepEvent("focus:step-resumed", {
      taskId: task.id,
      subId: sub.id,
      taskIndex: resolvedIndex,
      subIndex: resolvedSubIndex
    });
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function toggleSubTaskCompletion(taskIndex, subIndex, isCompleted, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    if (isCompleted) {
      if (!sub.startTime) {
        const nowIso = new Date().toISOString();
        sub.startTime = nowIso;
        sub.lastResumedAt = nowIso;
        sub.activeDurationMs = 0;
      }
      const completionTimestamp = new Date().toISOString();
      const elapsedMs = getSubTaskElapsedMs(sub);
      sub.completed = true;
      sub.completionTime = completionTimestamp;
      sub.durationMinutes = Number.isFinite(elapsedMs) && elapsedMs > 0 ? Number((elapsedMs / 60000).toFixed(2)) : 0;
      sub.activeDurationMs = Math.max(0, elapsedMs);
      sub.lastResumedAt = null;
      sub.isPaused = false;
      stopTimerForSubTask(sub.id);
      if (task.firstThreeMode) {
        maybeUnlockFirstThree(task);
      }
    } else {
      sub.completed = false;
      sub.completionTime = null;
      sub.durationMinutes = null;
      sub.isPaused = false;
      sub.lastResumedAt = null;
      if (task.firstThreeMode && sub.isFirstThree) {
        task.firstThreeUnlocked = false;
        task.subTasks.forEach(step => {
          if (!step.isFirstThree) {
            step.deferredUntilUnlock = true;
          }
        });
      }
      stopTimerForSubTask(sub.id);
    }
    const nextOptions = { ...options, taskId: task.id, subId: sub.id };
    refreshAfterSubTaskChange(resolvedIndex, nextOptions);
  }

  function editSubTaskName(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, sub } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !sub) return;
    const newName = prompt("Rename step", sub.name);
    if (!newName) return;
    sub.name = newName.trim();
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id, subId: sub.id });
  }

  function removeSubTask(taskIndex, subIndex, options = {}) {
    const { task, taskIndex: resolvedIndex, subIndex: resolvedSubIndex } = resolveTaskAndSub(taskIndex, subIndex, options);
    if (!task || !Array.isArray(task.subTasks)) return;
    if (!confirm("Remove this step?")) return;
    const removed = task.subTasks.splice(resolvedSubIndex, 1);
    if (removed.length) {
      stopTimerForSubTask(removed[0].id);
    }
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function addSubTaskToTask(taskIndex, options = {}) {
    const { task, taskIndex: resolvedIndex } = resolveTaskAndSub(taskIndex, null, options);
    if (!task) return;
    const name = prompt("New step name");
    if (!name) return;
    const base = computePriority({ ...task, subTasks: [] });
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    task.subTasks.push(createSubTask(name.trim(), base, {
      deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
    }));
    refreshAfterSubTaskChange(resolvedIndex, { ...options, focusOnly: true, taskId: task.id });
  }

  function renderChartTask(task, taskIndex) {
    const container = document.createElement("div");
    container.style.width = "100%";
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No steps configured.";
      container.appendChild(empty);
      return container;
    }
    const progressElement = createProgressElement(task);
    if (progressElement) {
      container.appendChild(progressElement);
    }
    const visibleSubs = getVisibleSubTasks(task);
    const hiddenCount = task.firstThreeMode && !task.firstThreeUnlocked
      ? task.subTasks.length - visibleSubs.length
      : 0;
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row focus-overlay__task";
      if (sub.completed) row.classList.add("completed");

      const titleWrapper = document.createElement("label");
      titleWrapper.className = "task-title";

      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { focusOnly: true, taskId: task.id, subId: sub.id });

      const nameSpan = document.createElement("span");
      nameSpan.className = "subtask-name";
      nameSpan.textContent = sub.name;

      titleWrapper.appendChild(chk);
      titleWrapper.appendChild(nameSpan);

      const actions = document.createElement("div");
      actions.className = "subtask-actions task-actions";

      const startBtn = document.createElement("button");
      startBtn.type = "button";
      startBtn.textContent = sub.startTime ? "🔁" : "▶️";
      startBtn.title = "Start or restart timer";
      startBtn.setAttribute("aria-label", sub.startTime ? "Restart timer" : "Start timer");
      startBtn.onclick = () => startSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(startBtn);

      const pauseBtn = document.createElement("button");
      pauseBtn.type = "button";
      const updatePauseButton = () => {
        const paused = Boolean(sub.isPaused);
        pauseBtn.textContent = paused ? "▶️" : "⏸️";
        pauseBtn.title = paused ? "Resume step timer" : "Pause step timer";
        pauseBtn.setAttribute("aria-label", paused ? "Resume step timer" : "Pause step timer");
        pauseBtn.setAttribute("aria-pressed", paused ? "true" : "false");
        pauseBtn.disabled = !sub.startTime || sub.completed;
      };
      pauseBtn.onclick = () => {
        if (!sub.startTime || sub.completed) {
          return;
        }
        if (sub.isPaused) {
          resumeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        } else {
          pauseSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
        }
      };
      updatePauseButton();
      actions.appendChild(pauseBtn);

      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Rename step";
      editBtn.setAttribute("aria-label", "Rename step");
      editBtn.onclick = () => editSubTaskName(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(editBtn);

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Remove step";
      deleteBtn.setAttribute("aria-label", "Remove step");
      deleteBtn.onclick = () => removeSubTask(taskIndex, subIndex, { taskId: task.id, subId: sub.id });
      actions.appendChild(deleteBtn);

      const timer = document.createElement("span");
      timer.className = "timer-label task-counter";
      trackTimer(sub, timer);

      row.appendChild(titleWrapper);
      row.appendChild(timer);
      row.appendChild(actions);
      row.dataset.paused = sub.isPaused ? "true" : "false";
      container.appendChild(row);
    });

    if (hiddenCount > 0) {
      const gate = document.createElement("div");
      gate.className = "celebration";
      gate.textContent = "Complete the first three micro-steps to reveal the rest of the chart flow.";
      container.appendChild(gate);
    }

    const controls = document.createElement("div");
    controls.className = "chart-step-controls";

    const addBtn = document.createElement("button");
    addBtn.textContent = "➕ Add Step";
    addBtn.onclick = () => addSubTaskToTask(taskIndex, { taskId: task.id });
    controls.appendChild(addBtn);

    const resetTimersBtn = document.createElement("button");
    resetTimersBtn.textContent = "⏱️ Reset Timers";
    resetTimersBtn.onclick = () => {
      task.subTasks.forEach(sub => {
        stopTimerForSubTask(sub.id);
        sub.startTime = null;
        sub.completionTime = null;
        sub.durationMinutes = null;
        sub.completed = false;
        sub.activeDurationMs = 0;
        sub.lastResumedAt = null;
        sub.isPaused = false;
      });
      refreshAfterSubTaskChange(taskIndex, { focusOnly: true, taskId: task.id });
    };
    controls.appendChild(resetTimersBtn);

    container.appendChild(controls);

    if (task.subTasks.every(sub => sub.completed)) {
      container.appendChild(renderChartSummary(task));
    }

    return container;
  }

  function renderSimpleSubTasks(task, taskIndex) {
    const container = document.createElement("div");
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) {
      container.textContent = "No sub-tasks for this task.";
      return container;
    }
    const completedCount = task.subTasks.filter(sub => sub.completed).length;
    const progressSummary = document.createElement("div");
    progressSummary.className = "task-progress";
    progressSummary.textContent = `${completedCount}/${task.subTasks.length} steps done`;
    container.appendChild(progressSummary);
    const visibleSubs = getVisibleSubTasks(task);
    visibleSubs.forEach(sub => {
      const subIndex = task.subTasks.findIndex(entry => entry.id === sub.id);
      const row = document.createElement("div");
      row.className = "subtask-row";
      if (sub.completed) row.classList.add("completed");
      const chk = document.createElement("input");
      chk.type = "checkbox";
      chk.checked = sub.completed;
      chk.onchange = event => toggleSubTaskCompletion(taskIndex, subIndex, event.target.checked, { taskId: task.id, subId: sub.id });
      const label = document.createElement("span");
      label.className = "subtask-name";
      label.textContent = sub.name;
      row.appendChild(chk);
      row.appendChild(label);
      container.appendChild(row);
    });
    if (task.firstThreeMode && !task.firstThreeUnlocked) {
      const hint = document.createElement("div");
      hint.className = "celebration";
      hint.textContent = "Unlock the remaining steps by completing your first three micro-actions.";
      container.appendChild(hint);
    }
    return container;
  }

  function renderFocusTask(task, taskIndex) {
    const subTaskView = $("subTaskView");
    if (!subTaskView) return;
    let resolvedIndex = taskIndex;
    if ((resolvedIndex === undefined || resolvedIndex === null || resolvedIndex < 0) && task) {
      resolvedIndex = tasks.findIndex(t => t.id === task.id);
    }
    const referenceTask = (resolvedIndex !== undefined && resolvedIndex !== null && resolvedIndex >= 0)
      ? tasks[resolvedIndex]
      : task;
    currentFocusTaskIndex = resolvedIndex;
    subTaskView.innerHTML = "";
    clearRunningTimers();
    let createdDefaults = false;
    if (isChartTask(referenceTask)) {
      createdDefaults = ensureChartSubTasks(referenceTask);
    }
    if (createdDefaults) {
      updateChartDurationForTask(referenceTask);
      referenceTask.priority = computePriority(referenceTask);
      persist();
    }
    const content = isChartTask(referenceTask)
      ? renderChartTask(referenceTask, resolvedIndex)
      : renderSimpleSubTasks(referenceTask, resolvedIndex);
    subTaskView.appendChild(content);
  }

  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }

  function addDays(date, amount) {
    const base = date instanceof Date && !Number.isNaN(date.getTime()) ? new Date(date) : new Date();
    const offset = Number.isFinite(Number(amount)) ? Number(amount) : 0;
    base.setDate(base.getDate() + offset);
    return base;
  }

  function calculateDaysSince(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = today.getTime() - parsed.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
  }

  function calculateDaysUntil(dateString) {
    if (!dateString) return null;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffMs = parsed.getTime() - today.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  }

  function isDateInCurrentMonth(dateString) {
    if (!dateString) return false;
    const parsed = new Date(dateString + "T00:00:00");
    if (Number.isNaN(parsed.getTime())) return false;
    const today = new Date();
    return parsed.getFullYear() === today.getFullYear()
      && parsed.getMonth() === today.getMonth();
  }

  function getUrgencyDescriptor(value) {
    const options = getScaleOptions("urgency", currentScaleDescriptorCategory);
    const option = options.find(opt => Number(opt.value) === Number(value));
    return option ? option.text : null;
  }

  function getSuggestedUrgency(days) {
    if (days === null || days === undefined || Number.isNaN(days)) return 3;
    if (days < 0) return 3;
    if (days >= 90 && days <= 95) return 5;
    if (days > 95) return 2;
    if (days >= 30 && days < 90) return 1;
    if (days >= 2 && days <= 4) return 4;
    if (days < 30) return 3;
    return 3;
  }

  function updateChartAgeDisplay(days) {
    const display = $("chartAgeDisplay");
    if (!display) return;
    if (days === null || days === undefined) {
      display.textContent = "";
      return;
    }
    if (days < 0) {
      display.textContent = `Service date is ${Math.abs(days)} day(s) in the future.`;
      return;
    }
    display.textContent = `Chart age: ${days} day(s) since visit.`;
  }

  function updateUrgencyHint(suggested) {
    const hint = $("urgencyHint");
    const urgencyField = $("urgency");
    if (!hint || !urgencyField) return;
    const current = Number(urgencyField.value || 3);
    const suggestedDescriptor = getUrgencyDescriptor(suggested);
    const currentDescriptor = getUrgencyDescriptor(current);
    if (!suggestedDescriptor) {
      hint.textContent = currentDescriptor ? `Urgency set to ${currentDescriptor}.` : "";
      return;
    }
    if (current !== suggested) {
      hint.textContent = `Suggested: ${suggestedDescriptor}. (Current: ${currentDescriptor || current})`;
    } else {
      hint.textContent = `Suggested: ${suggestedDescriptor}.`;
    }
  }

  function updateDerivedFields() {
    const dateField = $("dateOfService");
    if (!dateField) return;
    const value = dateField.value;
    const days = calculateDaysSince(value);
    derivedDaysSinceVisit = days;
    updateChartAgeDisplay(days);
    const suggested = getSuggestedUrgency(days);
    const urgencyField = $("urgency");
    if (urgencyField && (urgencyAuto || !urgencyField.value)) {
      urgencyField.value = String(suggested);
    }
    updateUrgencyHint(suggested);
  }

  function setDefaultFieldValues() {
    const nameField = $("name");
    if (nameField) nameField.value = "";
    const categoryField = $("taskCategory");
    if (categoryField) categoryField.value = "General";
    const authorField = $("authorType");
    if (authorField) authorField.value = "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = "Non-Complex";
    const visitField = $("visitType");
    if (visitField) visitField.value = "Follow-Up";
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = "General Clinic";
    NUMERIC_SCALE_FIELDS.forEach(id => {
      const field = $(id);
      if (field) field.value = "1";
    });
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = "3";
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = "1";
    const dueDateField = $("dueDate");
    if (dueDateField) dueDateField.value = "";
    const subField = $("initialSubTasks");
    if (subField) {
      subField.value = "";
      delete subField.dataset.quickPreset;
      delete subField.dataset.allowChartTemplate;
    }
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.value = formatDateForInput(new Date());
    }
    derivedDaysSinceVisit = calculateDaysSince($("dateOfService")?.value || null);
    urgencyAuto = true;
    updateDerivedFields();
    handleCategoryChange($("taskCategory")?.value);
    setQuickTaskTemplateMode(false);
  }

  let templates = [];
  let tasks = [];
  let isHydratingTasks = true;
  function normalizeStoredTemplate(template) {
    if (!template || typeof template !== "object") {
      return null;
    }
    const name = typeof template.name === "string" ? template.name.trim() : "";
    if (!name) {
      return null;
    }
    const category = typeof template.category === "string" && template.category.trim()
      ? template.category
      : "General";
    return {
      name,
      category,
      authorType: template.authorType || "attending",
      patientType: normalizePatientType(template.patientType),
      visitType: normalizeVisitType(template.visitType),
      clinicSite: normalizeClinicSite(template.clinicSite),
      importance: clampScale(template.importance, 1),
      urgency: clampScale(template.urgency, 3),
      novelty: clampScale(template.novelty, 1),
      interest: clampScale(template.interest, 1),
      externalPressure: clampScale(template.externalPressure, 1),
      timeToStart: clampScale(template.timeToStart, 1),
      difficulty: clampScale(template.difficulty, 1)
    };
  }

  function readTemplatesFromStorage() {
    if (typeof localStorage === "undefined") {
      return { templates: [], migrated: false };
    }
    const sources = [
      { key: TEMPLATE_STORAGE_KEY, migrated: false },
      { key: LEGACY_TEMPLATE_STORAGE_KEY, migrated: true }
    ];
    for (const source of sources) {
      let raw;
      try {
        raw = localStorage.getItem(source.key);
      } catch (error) {
        console.warn("Unable to read templates from storage.", error);
        return { templates: [], migrated: false };
      }
      if (raw === null) {
        continue;
      }
      if (raw === "") {
        return { templates: [], migrated: source.migrated };
      }
      if (typeof raw !== "string") {
        continue;
      }
      try {
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          continue;
        }
        const normalized = parsed.map(normalizeStoredTemplate).filter(Boolean);
        return { templates: normalized, migrated: source.migrated };
      } catch (error) {
        console.warn("Unable to parse saved templates.", error);
      }
    }
    return { templates: [], migrated: false };
  }

  function persistTemplates() {
    if (typeof localStorage === "undefined") {
      return;
    }
    const payload = templates.map(normalizeStoredTemplate).filter(Boolean);
    templates.length = 0;
    payload.forEach(template => {
      templates.push({ ...template });
    });
    try {
      const serialized = JSON.stringify(payload);
      localStorage.setItem(TEMPLATE_STORAGE_KEY, serialized);
      localStorage.setItem(LEGACY_TEMPLATE_STORAGE_KEY, serialized);
    } catch (error) {
      console.warn("Unable to persist templates.", error);
    }
  }

  function hydrateTemplatesFromStorage() {
    const { templates: storedTemplates, migrated } = readTemplatesFromStorage();
    if (Array.isArray(storedTemplates)) {
      templates = storedTemplates;
      if (migrated) {
        persistTemplates();
      }
    }
  }
  let focusQueue = [];
  let editingTaskId = null;
  let focusTimerId = null;
  let focusTimerStart = null;
  let focusTimerLastPing = null;
  let focusDistractionLog = [];
  let distractionTriggersSinceReset = 0;
  let doorwayResetState = { active: false, pending: false, countdownId: null, endTime: null };
  let ganttPlanState = { entries: [], totalMinutes: 0 };
  let ganttOverlayStartTime = null;
  let ganttProgressIntervalId = null;
  let worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
  let focusSoundEnabled = true;
  let focusAudioContext = null;
  let morningLaunchState = null;
  let launchPadState = null;
  let sleepToolkitState = null;
  let morningCountdown = null;
  let reminderIntervalId = null;
  let pendingTaskDraft = null;
  let sunlightAlertTimeoutId = null;

  const meltdownShieldState = {
    stepIndex: 0
  };

  const MELTDOWN_STEPS = [
    {
      title: "Noise Reduction",
      description: "Close all other browser tabs to eliminate competing stimuli."
    },
    {
      title: "4–4–4 Breathing",
      description: "Take three cycles: inhale for four seconds, hold for four, exhale for four."
    },
    {
      title: "Verbal Grounding",
      description: "Say aloud: ‘I am safe. I can pick one thing.’"
    },
    {
      title: "Task Narrowing",
      descriptionBuilder: () => {
        const topTaskName = getTopTaskName();
        const fragment = document.createDocumentFragment();
        const intro = document.createElement("span");
        intro.textContent = "Remember there is just one next step. Top priority task:";
        const nameEl = document.createElement("span");
        nameEl.className = "meltdown-top-task";
        nameEl.textContent = topTaskName || "No active tasks available.";
        fragment.appendChild(intro);
        fragment.appendChild(document.createElement("br"));
        fragment.appendChild(nameEl);
        return fragment;
      }
    },
    {
      title: "5-Minute Action Timer",
      description: "Set a five-minute timer and commit to only the first subtask for this session."
    },
    {
      title: "Body Movement",
      description: "Stand up, shake out your arms, and loosen your shoulders."
    },
    {
      title: "Music Cue",
      description: "Play a favorite upbeat song to pair with your movement."
    },
    {
      title: "Re-entry",
      description: "Slide back into Focus Mode ready to attack the task with reduced anxiety."
    }
  ];

  function resolvePriorityValue(value) {
    const num = Number(value);
    return Number.isFinite(num) ? num : 0;
  }

  function getTopTaskName() {
    const sourceTasks = Array.isArray(tasks) ? tasks : [];
    const activeTasks = sourceTasks
      .filter(task => !isTaskCompleted(task))
      .sort((a, b) => resolvePriorityValue(b.priority) - resolvePriorityValue(a.priority));

    if (activeTasks.length > 0) {
      return activeTasks[0]?.name || null;
    }

    try {
      const saved = localStorage.getItem("tasks");
      if (!saved) return null;

      let storedTasks = [];
      const parser = window.TaskerStorage?.parseStoredTasks;

      if (typeof parser === "function") {
        const snapshot = parser(saved);
        if (snapshot?.error) {
          console.error("Unable to parse saved tasks for Meltdown Shield.", snapshot.error);
          return null;
        }
        storedTasks = Array.isArray(snapshot?.tasks) ? snapshot.tasks : [];
      } else {
        const parsed = JSON.parse(saved);
        const isPlainObject = parsed && typeof parsed === "object" && !Array.isArray(parsed);
        storedTasks = Array.isArray(parsed)
          ? parsed
          : (isPlainObject && Array.isArray(parsed.allTasks)
            ? parsed.allTasks
            : (isPlainObject && Array.isArray(parsed.tasks)
              ? parsed.tasks
              : []));
      }

      if (!storedTasks.length) {
        return null;
      }

      const fallbackActive = storedTasks
        .filter(task => task && !isTaskCompleted(task))
        .map(task => ({
          ...task,
          priority: resolvePriorityValue(task?.priority)
        }))
        .sort((a, b) => b.priority - a.priority);

      return fallbackActive.length > 0 ? (fallbackActive[0].name || null) : null;
    } catch (error) {
      console.error("Unable to parse saved tasks for Meltdown Shield.", error);
      return null;
    }
  }

  function buildMeltdownDescription(step) {
    if (typeof step.descriptionBuilder === "function") {
      return step.descriptionBuilder();
    }
    const span = document.createElement("span");
    span.textContent = step.description;
    return span;
  }

  function resetMeltdownShieldProgress() {
    meltdownShieldState.stepIndex = 0;
    const list = $("meltdownShieldSteps");
    if (list) {
      list.innerHTML = "";
    }
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.disabled = false;
      nextBtn.textContent = "▶️ Next";
    }
    updateMeltdownPrompt();
  }

  function updateMeltdownPrompt() {
    const prompt = $("meltdownShieldPrompt");
    const nextBtn = $("meltdownShieldNext");
    if (!prompt || !nextBtn) return;

    prompt.innerHTML = "";

    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      const finalMessage = document.createElement("strong");
      finalMessage.textContent = "System stabilized. Ready for Focus Mode.";
      prompt.appendChild(finalMessage);
      nextBtn.disabled = true;
      nextBtn.textContent = "Complete";
      return;
    }

    const currentStep = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const heading = document.createElement("strong");
    heading.textContent = `Step ${meltdownShieldState.stepIndex + 1}: ${currentStep.title}`;
    const description = buildMeltdownDescription(currentStep);
    prompt.appendChild(heading);
    prompt.appendChild(description);
    nextBtn.disabled = false;
    nextBtn.textContent = "▶️ Next";
  }

  function activateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.remove("hidden");
    panel.setAttribute("aria-hidden", "false");
    document.body.classlist.add("calm backdrop")
    recordEvent("meltdown_start");
    resetMeltdownShieldProgress();
    const nextBtn = $("meltdownShieldNext");
    if (nextBtn) {
      nextBtn.focus();
    }
  }

  function deactivateShield() {
    const panel = $("meltdownShield");
    if (!panel) return;
    panel.classList.add("hidden");
    panel.setAttribute("aria-hidden", "true");
    document.body.classlist.add("calm backdrop")
    recordEvent("meltdown_end");
    resetMeltdownShieldProgress();
    const focusTarget =
      lastSosTrigger ||
      $("rescueLaunchButton") ||
      $("meltdownSosButton");
    if (focusTarget) {
      window.requestAnimationFrame(() => focusTarget.focus());
    }
  }

  function completeCurrentMeltdownStep() {
    if (meltdownShieldState.stepIndex >= MELTDOWN_STEPS.length) {
      updateMeltdownPrompt();
      return;
    }

    const list = $("meltdownShieldSteps");
    if (!list) return;

    const step = MELTDOWN_STEPS[meltdownShieldState.stepIndex];
    const listItem = document.createElement("li");
    const stepLabel = document.createElement("strong");
    stepLabel.textContent = `${step.title}`;
    listItem.appendChild(stepLabel);
    listItem.appendChild(document.createElement("br"));
    listItem.appendChild(buildMeltdownDescription(step));
    list.appendChild(listItem);

    meltdownShieldState.stepIndex += 1;
    updateMeltdownPrompt();
  }

  function clearFormFields() {
    setDefaultFieldValues();
  }

  function toggleEditMode(isEditing) {
    const addBtn = $("addTaskBtn");
    const saveBtn = $("saveUpdateBtn");
    const cancelBtn = $("cancelEditBtn");
    if (!addBtn || !saveBtn || !cancelBtn) return;
    addBtn.classList.toggle("hidden", isEditing);
    saveBtn.classList.toggle("hidden", !isEditing);
    cancelBtn.classList.toggle("hidden", !isEditing);
  }

  function toNumber(value, fallback = 0) {
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function clampScale(value, fallback = 1) {
    const base = toNumber(value, fallback);
    return Math.min(5, Math.max(1, base));
  }

  function normalizePatientType(value) {
    const normalized = (value || "").toString().toLowerCase();
    return normalized === "complex" ? "Complex" : "Non-Complex";
  }

  function getPatientTypeWeight(patientType) {
    return normalizePatientType(patientType) === "Complex" ? 1.2 : 1;
  }

  function normalizeVisitType(value) {
    const normalized = (value || "").toString().toLowerCase();
    if (normalized === "establish" || normalized === "establish care") return "Establish Care";
    if (normalized === "well-child" || normalized === "well child visit") return "Well Child Visit";
    if (normalized === "acute" || normalized === "acute visit") return "Acute Visit";
    return "Follow-Up";
  }

  function getVisitTypeWeight(visitType) {
    const normalized = normalizeVisitType(visitType);
    if (normalized === "Establish Care") return 1.3;
    if (normalized === "Well Child Visit") return 1.1;
    if (normalized === "Acute Visit") return 0.9;
    return 1;
  }

  function normalizeClinicSite(value) {
    const normalized = (value || "").toString().toLowerCase().replace(/[’]/g, "'").trim();
    if (normalized.includes("cranio")) return "Craniofacial Clinic";
    if (normalized.includes("pj")) return "St PJ’s Shelter";
    if (normalized.includes("general")) return "General Clinic";
    return "General Clinic";
  }

  function isSameLocalDay(dateA, dateB) {
    if (!(dateA instanceof Date) || !(dateB instanceof Date)) return false;
    if (Number.isNaN(dateA.getTime()) || Number.isNaN(dateB.getTime())) return false;
    return dateA.getFullYear() === dateB.getFullYear()
      && dateA.getMonth() === dateB.getMonth()
      && dateA.getDate() === dateB.getDate();
  }

  function getSameDayBonus(clinicSite, createdAt) {
    const normalizedClinic = normalizeClinicSite(clinicSite);
    if (normalizedClinic !== "St PJ’s Shelter" && normalizedClinic !== "Craniofacial Clinic") {
      return 1;
    }
    if (!createdAt) return 1;
    const createdDate = new Date(createdAt);
    if (Number.isNaN(createdDate.getTime())) return 1;
    const now = new Date();
    return isSameLocalDay(createdDate, now) ? 2 : 1;
  }

  function computeRawPriorityScore(t) {
    const importance = clampScale(t.importance, 1);
    const urgency = clampScale(t.urgency, 3);
    const novelty = clampScale(t.novelty, 1);
    const interest = clampScale(t.interest, 1);
    const pressure = Math.min(4.2, clampScale(t.externalPressure, 1));
    const timeToStart = clampScale(t.timeToStart, 1);
    const difficulty = clampScale(t.difficulty, 1);
    const dopamine = novelty + interest;
    const friction = (6 - timeToStart) + (6 - difficulty);
    const baseScore = (importance * 2)
         + (urgency * 2)
         + (dopamine * 2)
         + (pressure * 5)
         + (friction * 1.5);
    const patientWeight = getPatientTypeWeight(t.patientType);
    const visitWeight = getVisitTypeWeight(t.visitType);
    const sameDayBonus = getSameDayBonus(t.clinicSite, t.createdAt);
    const daysSinceVisit = Number.isFinite(Number(t.daysSinceVisit))
      ? Number(t.daysSinceVisit)
      : (t.dateOfService ? calculateDaysSince(t.dateOfService) : null);
    const daysUntilDue = t.dueDate ? calculateDaysUntil(t.dueDate) : null;
    const overdueDays = Number.isFinite(daysUntilDue) && daysUntilDue < 0 ? Math.abs(daysUntilDue) : 0;
    const positiveAging = Number.isFinite(daysSinceVisit) && daysSinceVisit > 0 ? daysSinceVisit : 0;
    const agingBoost = 1 + Math.min(0.2, (positiveAging / 90) + (overdueDays / 30));
    return baseScore * patientWeight * visitWeight * sameDayBonus * agingBoost;
  }

  function computeTimeWeight(task) {
    if (!task) return 1;
    if (isQuickTask(task)) return 1;
    const isChart = isChartTask(task);
    const parsedDays = Number(task.daysSinceVisit);
    const daysSince = Number.isFinite(parsedDays)
      ? parsedDays
      : (task.dateOfService ? calculateDaysSince(task.dateOfService) : null);
    const daysUntilDue = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
    const currentMonth = isDateInCurrentMonth(task.dateOfService)
      || isDateInCurrentMonth(task.dueDate);

    if (!isChart) {
      if (daysUntilDue !== null && Number.isFinite(daysUntilDue) && daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.2;
      }
      return 1.0;
    }

    if (daysSince !== null && Number.isFinite(daysSince)) {
      if (daysSince > 95) return 0.5;
      if (daysSince >= 90 && daysSince <= 95) return 2.0;
      if (daysSince >= 0 && daysSince < 3) return 1.8;
      if (daysSince >= 3 && currentMonth) return 1.3;
    }

    if (daysUntilDue !== null && Number.isFinite(daysUntilDue)) {
      if (daysUntilDue <= 3 && daysUntilDue >= 0) {
        return 1.8;
      }
      if (daysUntilDue < 0 && daysSince === null) {
        return currentMonth ? 1.3 : 1.0;
      }
      if (currentMonth) {
        return 1.3;
      }
    }

    return 1.0;
  }

  function computePriority(t) {
    if (isQuickTask(t)) {
      return 1;
    }
    const weightedBase = computeRawPriorityScore(t) * computeTimeWeight(t);
    if (Array.isArray(t.subTasks) && t.subTasks.length) {
      const remaining = t.subTasks.filter(s => !s.completed);
      if (remaining.length === 0) return 0;
      const total = remaining.reduce((sum, s) => {
        const value = Number(s.priority);
        return Number.isFinite(value) ? sum + value : sum + weightedBase;
      }, 0);
      return total / remaining.length;
    }
    return weightedBase;
  }

  function recalcTaskPriority(task) {
    if (!task) return task;
    task.authorType = task.authorType || "attending";
    task.patientType = normalizePatientType(task.patientType);
    task.visitType = normalizeVisitType(task.visitType);
    task.clinicSite = normalizeClinicSite(task.clinicSite);
    task.dateOfService = task.dateOfService || null;
    task.createdAt = task.createdAt || task.addedAt || new Date().toISOString();
    if (task.category === "Charts") task.category = "Chart";
    task.firstThreeMode = Boolean(task.firstThreeMode);
    if (!Array.isArray(task.firstThreeSteps)) {
      task.firstThreeSteps = [];
    }
    if (!task.firstThreeMode) {
      task.firstThreeUnlocked = true;
      task.firstThreeSteps = [];
    } else if (task.firstThreeUnlocked === undefined) {
      task.firstThreeUnlocked = false;
    }
    if (task.dateOfService) {
      task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    } else {
      const parsedDays = Number(task.daysSinceVisit);
      task.daysSinceVisit = (task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === "" || !Number.isFinite(parsedDays))
        ? null
        : parsedDays;
    }
    task.urgency = clampScale(task.urgency, 3);
    task.importance = clampScale(task.importance, 1);
    task.novelty = clampScale(task.novelty, 1);
    task.interest = clampScale(task.interest, 1);
    task.externalPressure = clampScale(task.externalPressure, 1);
    task.timeToStart = clampScale(task.timeToStart, 1);
    task.difficulty = clampScale(task.difficulty, 1);
    if (!Array.isArray(task.subTasks)) {
      task.subTasks = [];
    }
    if (isQuickTask(task)) {
      task.subTasks = [];
      task.firstThreeMode = false;
      task.firstThreeSteps = [];
      task.firstThreeUnlocked = true;
    }
    task.completedAt = task.completedAt || null;
    if (task.completed && !task.completedAt) {
      task.completedAt = null;
    }
    if (task.completedAt && !task.completed) {
      task.completed = true;
    } else {
      task.completed = Boolean(task.completed);
    }
    if (isChartTask(task) && task.useChartTemplate === undefined) {
      const defaults = new Set(buildChartSteps(task.authorType).map(step => step.toLowerCase()));
      const hasCustomSteps = Array.isArray(task.subTasks)
        ? task.subTasks.some(sub => !defaults.has(String(sub?.name || "").toLowerCase()))
        : false;
      task.useChartTemplate = !hasCustomSteps;
    }
    const baseRaw = computeRawPriorityScore({ ...task, subTasks: [] });
    const timeWeight = computeTimeWeight(task);
    task.timeWeight = timeWeight;
    const base = baseRaw * timeWeight;
    if (isChartTask(task)) {
      ensureChartSubTasks(task, { basePriority: base });
    }
    if (task.subTasks.length) {
      task.subTasks = task.subTasks.map(sub => {
        const normalizedSub = normalizeSubTask(sub, base);
        normalizedSub.priority = base;
        return normalizedSub;
      });
      if (task.firstThreeMode) {
        if (!task.firstThreeSteps.length) {
          task.firstThreeSteps = task.subTasks.slice(0, 3).map(sub => sub.name);
        } else {
          task.firstThreeSteps = task.firstThreeSteps.slice(0, 3);
        }
        task.subTasks.forEach((sub, index) => {
          const isFirst = index < 3;
          sub.isFirstThree = isFirst;
          sub.deferredUntilUnlock = !task.firstThreeUnlocked && !isFirst;
        });
        maybeUnlockFirstThree(task, { silent: true });
      } else {
        task.subTasks.forEach(sub => {
          sub.isFirstThree = false;
          sub.deferredUntilUnlock = false;
        });
      }
    }
    updateChartDurationForTask(task);
    task.priority = computePriority(task);
    return task;
  }

  function buildTaskStoragePayload(taskList) {
    const api = window.TaskerStorage;
    if (api && typeof api.buildTaskStoragePayload === "function") {
      return api.buildTaskStoragePayload(taskList);
    }
    const allTasks = Array.isArray(taskList)
      ? taskList.map(task => ({ ...task }))
      : [];
    const quickTasksSnapshot = allTasks.filter(task => isQuickTask(task));
    return {
      allTasks,
      quickTasks: quickTasksSnapshot,
    };
  }

  function persist() {
    if (isHydratingTasks) {
      return;
    }
    const api = window.TaskerStorage;
    const payload = buildTaskStoragePayload(tasks);
    if (api && typeof api.saveTasksToStorage === "function") {
      const result = api.saveTasksToStorage(tasks);
      if (!result?.success && result?.error) {
        console.warn("Unable to persist tasks", result.error);
      }
      if (result?.success) {
        return;
      }
    }
    try {
      localStorage.setItem("tasks", JSON.stringify(payload));
    } catch (error) {
      console.warn("Unable to persist tasks", error);
    }
  }

  function normalizeTasksFromStorage(restoredTasks = []) {
    const normalizedTasks = [];
    if (!Array.isArray(restoredTasks)) {
      return normalizedTasks;
    }

    restoredTasks.forEach((task, index) => {
      try {
        const normalizedTask = {
          ...task,
          authorType: task?.authorType || "attending",
          patientType: normalizePatientType(task?.patientType),
          visitType: normalizeVisitType(task?.visitType),
          clinicSite: normalizeClinicSite(task?.clinicSite),
          dateOfService: task?.dateOfService || null,
          createdAt: task?.createdAt || task?.addedAt || new Date().toISOString(),
        };
        if (normalizedTask.dateOfService) {
          normalizedTask.daysSinceVisit = calculateDaysSince(normalizedTask.dateOfService);
        }
        normalizedTasks.push(recalcTaskPriority(normalizedTask));
      } catch (error) {
        console.warn(`Unable to normalize stored task at index ${index}; skipping.`, error);
      }
    });

    return normalizedTasks;
  }

  function mergeTaskCollections(existingTasks, incomingTasks) {
    const merged = [];
    const seen = new Set();

    const append = task => {
      if (!task || typeof task !== "object") {
        return;
      }
      let id = typeof task.id === "string" ? task.id.trim() : "";
      if (!id) {
        id = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
        task.id = id;
      }
      if (seen.has(id)) {
        return;
      }
      seen.add(id);
      merged.push(task);
    };

    if (Array.isArray(existingTasks)) {
      existingTasks.forEach(append);
    }
    if (Array.isArray(incomingTasks)) {
      incomingTasks.forEach(append);
    }

    return merged;
  }

    function hydrateTasksFromStorage() {
      const api = window.TaskerStorage;
      const hydrationResult = {
        primaryRestored: 0,
        quickRestored: 0,
        totalRestored: 0,
        discarded: 0,
        quickDiscarded: 0,
        scheduledUpdate: false,
        storageAvailable: true,
        error: null,
      };

      const scheduleHydratedRender = () => {
        if (hydrationResult.totalRestored <= 0) {
          return;
        }
        const render = () => {
          try {
            updateUI();
          } catch (renderError) {
            console.error("Unable to render hydrated tasks after load.", renderError);
            // TODO: Validate hydrated task rendering across supported browsers.
          }
        };
        try {
          if (typeof window !== "undefined" && typeof window.requestAnimationFrame === "function") {
            window.requestAnimationFrame(render);
          } else {
            setTimeout(render, 0);
          }
          hydrationResult.scheduledUpdate = true;
        } catch (scheduleError) {
          console.warn("Unable to schedule hydrated task render", scheduleError);
        }
      };

      try {
        if (api && typeof api.loadStoredTasks === "function") {
          const snapshot = api.loadStoredTasks();
          if (snapshot?.error) {
            console.error("Unable to restore saved tasks from localStorage.", snapshot.error);
            hydrationResult.error = snapshot.error;
            tasks = [];
            return hydrationResult;
          }
          if (!snapshot || snapshot.storageAvailable === false) {
            tasks = [];
            hydrationResult.storageAvailable = Boolean(snapshot?.storageAvailable);
            return hydrationResult;
          }
          const normalizedPrimary = normalizeTasksFromStorage(snapshot.tasks);
          const normalizedQuick = normalizeTasksFromStorage(snapshot.quickTasks || []);
          tasks = mergeTaskCollections(normalizedPrimary, normalizedQuick);
          hydrationResult.primaryRestored = normalizedPrimary.length;
          hydrationResult.quickRestored = normalizedQuick.length;
          hydrationResult.totalRestored = tasks.length;
          hydrationResult.discarded = snapshot.discarded || 0;
          hydrationResult.quickDiscarded = snapshot.quickDiscarded || 0;
          if (snapshot.discarded) {
            console.warn(`Skipped ${snapshot.discarded} invalid task ${snapshot.discarded === 1 ? "entry" : "entries"} while restoring saved tasks.`);
          }
          if (snapshot.quickDiscarded) {
            console.warn(`Skipped ${snapshot.quickDiscarded} invalid quick task ${snapshot.quickDiscarded === 1 ? "entry" : "entries"} while restoring saved tasks.`);
          }
          return hydrationResult;
        }

        const saved = (() => {
          try {
            return localStorage.getItem("tasks");
          } catch (error) {
            console.warn("Unable to read saved tasks from localStorage.", error);
            hydrationResult.error = error;
            return null;
          }
        })();

        if (!saved) {
          tasks = [];
          return hydrationResult;
        }

        const parser = api?.parseStoredTasks;
        let parseResult = null;

        if (typeof parser === "function") {
          parseResult = parser(saved);
        } else {
          try {
            const parsed = JSON.parse(saved);
            const isPlainObject = parsed && typeof parsed === "object" && !Array.isArray(parsed);
            const taskEntries = Array.isArray(parsed)
              ? parsed
              : (isPlainObject && Array.isArray(parsed.allTasks)
                ? parsed.allTasks
                : (isPlainObject && Array.isArray(parsed.tasks)
                  ? parsed.tasks
                  : []));
            const quickEntries = isPlainObject && Array.isArray(parsed.quickTasks)
              ? parsed.quickTasks
              : [];
            parseResult = { tasks: taskEntries, quickTasks: quickEntries, discarded: 0, quickDiscarded: 0, error: null };
          } catch (error) {
            console.error("Unable to parse saved tasks.", error);
            hydrationResult.error = error;
            tasks = [];
            return hydrationResult;
          }
        }

        if (!parseResult || parseResult.error) {
          if (parseResult?.error) {
            console.error("Unable to restore saved tasks from localStorage.", parseResult.error);
            hydrationResult.error = parseResult.error;
          }
          tasks = [];
          return hydrationResult;
        }

        const normalizedPrimary = normalizeTasksFromStorage(parseResult.tasks);
        const normalizedQuick = normalizeTasksFromStorage(parseResult.quickTasks || []);
        tasks = mergeTaskCollections(normalizedPrimary, normalizedQuick);
        hydrationResult.primaryRestored = normalizedPrimary.length;
        hydrationResult.quickRestored = normalizedQuick.length;
        hydrationResult.totalRestored = tasks.length;
        hydrationResult.discarded = parseResult.discarded || 0;
        hydrationResult.quickDiscarded = parseResult.quickDiscarded || 0;

        if (parseResult.discarded) {
          console.warn(`Skipped ${parseResult.discarded} invalid task ${parseResult.discarded === 1 ? "entry" : "entries"} while restoring saved tasks.`);
        }
        if (parseResult.quickDiscarded) {
          console.warn(`Skipped ${parseResult.quickDiscarded} invalid quick task ${parseResult.quickDiscarded === 1 ? "entry" : "entries"} while restoring saved tasks.`);
        }
      } finally {
        isHydratingTasks = false;
        scheduleHydratedRender();
      }

      return hydrationResult;
    }

  function exportTasksBackup() {
    const payload = buildTaskStoragePayload(tasks);
    const downloader = window.TaskerStorage?.downloadTaskBackup;
    if (typeof downloader === "function") {
      downloader(payload);
      return;
    }
    try {
      const serialized = JSON.stringify(payload, null, 2);
      const blob = new Blob([serialized], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      anchor.download = `task-backup-${timestamp}.json`;
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.warn("Unable to export tasks backup", error);
    }
  }

  function processImportedBackup(serialized) {
    if (typeof serialized !== "string" || !serialized.trim()) {
      return { success: false, message: "The selected backup file is empty." };
    }

    const parser = window.TaskerStorage?.parseStoredTasks;
    let parseResult = null;

    if (typeof parser === "function") {
      parseResult = parser(serialized);
    } else {
      try {
        const parsed = JSON.parse(serialized);
        const isPlainObject = parsed && typeof parsed === "object" && !Array.isArray(parsed);
        const taskEntries = Array.isArray(parsed)
          ? parsed
          : (isPlainObject && Array.isArray(parsed.allTasks)
            ? parsed.allTasks
            : (isPlainObject && Array.isArray(parsed.tasks)
              ? parsed.tasks
              : []));
        parseResult = { tasks: taskEntries, error: null };
      } catch (error) {
        return { success: false, message: "Unable to read the backup file. It may not be valid JSON." };
      }
    }

    if (parseResult.error) {
      return { success: false, message: "The backup file could not be parsed." };
    }

    const normalizedIncoming = normalizeTasksFromStorage(parseResult.tasks);
    if (!normalizedIncoming.length) {
      return { success: false, message: "No tasks were found inside the backup file." };
    }

    const existingCount = tasks.length;
    const merged = mergeTaskCollections(tasks, normalizedIncoming);
    const addedCount = merged.length - existingCount;

    tasks = merged;
    persist();
    updateUI();

    return { success: true, addedCount };
  }

  function handleBackupFileSelection(event) {
    const input = event?.target;
    if (!input || !input.files || !input.files.length) {
      return;
    }
    const file = input.files[0];
    if (!file) {
      input.value = "";
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      try {
        const rawResult = reader.result;
        const text = typeof rawResult === "string" ? rawResult : String(rawResult ?? "");
        const outcome = processImportedBackup(text);
        if (outcome.success) {
          const added = outcome.addedCount || 0;
          const label = added === 1 ? "task" : "tasks";
          alert(added > 0
            ? `Backup imported successfully. Added ${added} ${label}.`
            : "Backup imported successfully. No new tasks were added.");
        } else if (outcome.message) {
          alert(outcome.message);
        }
      } catch (error) {
        console.error("Unable to import tasks backup", error);
        alert("Unable to import tasks backup. Please verify the file and try again.");
      } finally {
        input.value = "";
      }
    };
    reader.onerror = () => {
      console.error("Unable to read the selected backup file", reader.error);
      alert("Unable to read the selected backup file.");
      input.value = "";
    };
    reader.readAsText(file);
  }

  function initializeTaskBackupControls() {
    const exportBtn = $("exportTasksBackupButton");
    const importBtn = $("importTasksBackupButton");
    const input = $("importTasksBackupInput");
    if (!exportBtn || !importBtn || !input) {
      return;
    }

    exportBtn.addEventListener("click", () => {
      if (!tasks.length) {
        const confirmExport = confirm("Your task list is empty. Export an empty backup anyway?");
        if (!confirmExport) {
          return;
        }
      }
      exportTasksBackup();
    });

    importBtn.addEventListener("click", () => {
      input.value = "";
      input.click();
    });

    input.addEventListener("change", handleBackupFileSelection);
  }

  function buildTaskDraftFromForm() {
    const nameField = $("name");
    if (!nameField) return null;
    const name = nameField.value.trim();
    if (!name) return null;
    const category = $("taskCategory").value || "General";
    const quickMode = isQuickTaskCategory(category);
    const authorField = $("authorType");
    const authorType = quickMode ? "attending" : (authorField ? (authorField.value || "attending") : "attending");
    const patientField = $("patientType");
    const patientType = quickMode ? "Non-Complex" : normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = quickMode ? "Follow-Up" : normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = quickMode ? "General Clinic" : normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const dateField = $("dateOfService");
    const dateOfService = quickMode ? null : (dateField && dateField.value ? dateField.value : null);
    const daysSinceVisit = quickMode ? null : calculateDaysSince(dateOfService);
    const task = {
      id: Date.now().toString(),
      name,
      category,
      authorType,
      patientType,
      visitType,
      clinicSite,
      dateOfService,
      daysSinceVisit,
      importance: quickMode ? 1 : clampScale($("importance").value, 1),
      urgency: quickMode ? 1 : clampScale($("urgency").value, 3),
      novelty: quickMode ? 1 : clampScale($("novelty").value, 1),
      interest: quickMode ? 1 : clampScale($("interest").value, 1),
      externalPressure: quickMode ? 1 : clampScale($("externalPressure").value, 1),
      timeToStart: quickMode ? 1 : clampScale($("timeToStart").value, 1),
      difficulty: quickMode ? 1 : clampScale($("difficulty").value, 1),
      dueDate: quickMode ? null : ($("dueDate").value || null),
      completed: false,
      completedAt: null,
      createdAt: new Date().toISOString(),
      addedAt: new Date().toISOString(),
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: []
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subField = $("initialSubTasks");
    const subLines = (subField ? subField.value : "").split('\n')
      .map(line => line.trim())
      .filter(Boolean);
    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      const allowChartTemplate = subField?.dataset.allowChartTemplate === "true";
      task.useChartTemplate = allowChartTemplate ? true : !hasCustomSubTasks;
    }
    return { task, basePriority, subLines };
  }

  function finalizeNewTask(draft, options = {}) {
    if (!draft) return;
    const { task, basePriority, subLines } = draft;
    const firstThreeSteps = Array.isArray(options.firstThreeSteps) ? options.firstThreeSteps : null;
    const deferred = task.firstThreeMode && !task.firstThreeUnlocked;
    task.subTasks = Array.isArray(subLines)
      ? subLines.map(line => createSubTask(line, basePriority, {
          deferredUntilUnlock: deferred
        }))
      : [];
    if (firstThreeSteps && firstThreeSteps.length) {
      task.firstThreeMode = true;
      task.firstThreeUnlocked = false;
      applyFirstThreeSteps(task, firstThreeSteps, basePriority);
    } else {
      if (!task.firstThreeMode) {
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
      }
    }
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    showTaskAddedConfirmation();
    persist();
    clearFormFields();
    toggleEditMode(false);
    editingTaskId = null;
    updateUI();
  }

  // create a new task with optional sub‑tasks from textarea
  function addTask() {
    const draft = buildTaskDraftFromForm();
    if (!draft) return;
    const triggerWizard = shouldTriggerFirstThreeWizard(
      draft.task.name,
      draft.subLines,
      draft.task.category
    );
    if (triggerWizard) {
      pendingTaskDraft = draft;
      openFirstThreeWizard();
      return;
    }
    finalizeNewTask(draft);
  }

  function generateFirstThreeSuggestions(taskName) {
    const anchor = (taskName || "").split(/[–—:-]/)[0].trim() || "this work";
    return [
      `Open materials for ${anchor}`,
      "List three micro-actions in your notebook",
      "Start a 5-minute draft or outline"
    ];
  }

  function setFirstThreeInputs(values) {
    const ids = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"];
    ids.forEach((id, index) => {
      const field = $(id);
      if (field) {
        field.value = values[index] || "";
      }
    });
  }

  function openFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    const suggestions = generateFirstThreeSuggestions(pendingTaskDraft?.task?.name);
    setFirstThreeInputs(suggestions);
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const firstInput = $("firstThreeStep1");
    if (firstInput) {
      firstInput.focus();
      firstInput.select();
    }
  }

  function closeFirstThreeWizard() {
    const overlay = $("firstThreeWizard");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }

  function submitFirstThreeWizard() {
    if (!pendingTaskDraft) {
      closeFirstThreeWizard();
      return;
    }
    const steps = ["firstThreeStep1", "firstThreeStep2", "firstThreeStep3"]
      .map(id => $(id)?.value || "")
      .map(value => value.trim())
      .filter(Boolean);
    finalizeNewTask(pendingTaskDraft, { firstThreeSteps: steps });
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function skipFirstThreeWizard() {
    if (pendingTaskDraft) {
      pendingTaskDraft.task.firstThreeMode = false;
      pendingTaskDraft.task.firstThreeUnlocked = true;
      pendingTaskDraft.task.firstThreeSteps = [];
      finalizeNewTask(pendingTaskDraft);
      pendingTaskDraft = null;
    }
    closeFirstThreeWizard();
  }

  function cancelFirstThreeWizard() {
    pendingTaskDraft = null;
    closeFirstThreeWizard();
  }

  function initializeFirstThreeWizard() {
    const saveBtn = $("firstThreeSave");
    if (saveBtn) {
      saveBtn.addEventListener("click", submitFirstThreeWizard);
    }
    const skipBtn = $("firstThreeSkip");
    if (skipBtn) {
      skipBtn.addEventListener("click", skipFirstThreeWizard);
    }
    const cancelBtn = $("firstThreeCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelFirstThreeWizard);
    }
    const overlay = $("firstThreeWizard");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          cancelFirstThreeWizard();
        }
      });
    }
  }

  function startEditTask(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;
    editingTaskId = taskId;
    $("name").value = task.name;
    $("taskCategory").value = task.category || "General";
    handleCategoryChange(task.category || "General");
    $("importance").value = String(task.importance || 1);
    $("urgency").value = String(task.urgency || 3);
    $("novelty").value = String(task.novelty || 1);
    $("interest").value = String(task.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = task.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(task.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(task.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(task.clinicSite);
    const dateField = $("dateOfService");
    if (dateField) {
      if (task.dateOfService) {
        dateField.value = task.dateOfService;
      } else {
        dateField.value = formatDateForInput(new Date());
      }
    }
    urgencyAuto = false;
    derivedDaysSinceVisit = task.daysSinceVisit ?? calculateDaysSince($("dateOfService")?.value || null);
    updateDerivedFields();
    const pressureField = $("externalPressure");
    if (pressureField) {
      const pressureValue = task.externalPressure;
      pressureField.value = String(pressureValue || 1);
    }
    $("timeToStart").value = String(task.timeToStart || 1);
    $("difficulty").value = String(task.difficulty || 1);
    $("dueDate").value = task.dueDate || "";
    const subs = Array.isArray(task.subTasks) ? task.subTasks.map(sub => sub.name).join("\n") : "";
    $("initialSubTasks").value = subs;
    toggleEditMode(true);
    $("name").focus();
  }

  function saveTaskUpdate() {
    if (!editingTaskId) return;
    const idx = tasks.findIndex(t => t.id === editingTaskId);
    if (idx === -1) return;
    const name = $("name").value.trim();
    if (!name) return;

    const task = tasks[idx];
    task.name = name;
    task.category = $("taskCategory").value || "General";
    const authorField = $("authorType");
    task.authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    task.patientType = normalizePatientType(patientField ? patientField.value : task.patientType);
    const visitField = $("visitType");
    task.visitType = normalizeVisitType(visitField ? visitField.value : task.visitType);
    const clinicField = $("clinicSite");
    task.clinicSite = normalizeClinicSite(clinicField ? clinicField.value : task.clinicSite);
    const dateField = $("dateOfService");
    task.dateOfService = dateField && dateField.value ? dateField.value : null;
    task.daysSinceVisit = calculateDaysSince(task.dateOfService);
    task.importance = clampScale($("importance").value, 1);
    task.urgency = clampScale($("urgency").value, 3);
    task.novelty = clampScale($("novelty").value, 1);
    task.interest = clampScale($("interest").value, 1);
    task.externalPressure = clampScale($("externalPressure").value, 1);
    task.timeToStart = clampScale($("timeToStart").value, 1);
    task.difficulty = clampScale($("difficulty").value, 1);
    task.dueDate = $("dueDate").value || null;
    task.updatedAt = new Date().toISOString();

    const subLines = $("initialSubTasks").value.split('\n')
      .map(line => line.trim())
      .filter(Boolean);

    const hasCustomSubTasks = subLines.length > 0;
    if (isChartTask(task)) {
      task.useChartTemplate = !hasCustomSubTasks;
    } else if (task.useChartTemplate !== undefined) {
      delete task.useChartTemplate;
    }

    const basePriority = computePriority({ ...task, subTasks: [] });
    const existingSubs = Array.isArray(task.subTasks) ? task.subTasks.slice() : [];
    const newSubTasks = subLines.map(line => {
      const matchIndex = existingSubs.findIndex(sub => sub.name === line);
      if (matchIndex !== -1) {
        const existing = existingSubs.splice(matchIndex, 1)[0];
        const normalizedExisting = normalizeSubTask(existing, basePriority);
        normalizedExisting.name = line;
        normalizedExisting.priority = basePriority;
        return normalizedExisting;
      }
      return createSubTask(line, basePriority, {
        deferredUntilUnlock: task.firstThreeMode && !task.firstThreeUnlocked
      });
    });

    task.subTasks = newSubTasks;
    if (task.firstThreeMode) {
      const firstThreeSubset = task.subTasks.slice(0, 3);
      if (firstThreeSubset.length < 3) {
        task.firstThreeMode = false;
        task.firstThreeUnlocked = true;
        task.firstThreeSteps = [];
        task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
      } else {
        task.firstThreeSteps = firstThreeSubset.map(sub => sub.name);
        task.subTasks = task.subTasks.map((sub, index) => {
          const isFirst = index < 3;
          return {
            ...sub,
            isFirstThree: isFirst,
            deferredUntilUnlock: !task.firstThreeUnlocked && !isFirst
          };
        });
        maybeUnlockFirstThree(task, { silent: true });
      }
    } else {
      task.subTasks = task.subTasks.map(sub => ({ ...sub, isFirstThree: false, deferredUntilUnlock: false }));
    }
    if (isChartTask(task)) {
      const defaultsChanged = ensureChartSubTasks(task, { basePriority });
      if (defaultsChanged) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    if (task.firstThreeMode) {
      maybeUnlockFirstThree(task, { silent: true });
    }
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    persist();

    toggleEditMode(false);
    clearFormFields();
    editingTaskId = null;
    updateUI();
  }

  function cancelEdit() {
    editingTaskId = null;
    toggleEditMode(false);
    clearFormFields();
  }

  // render filter bar
  function renderCategoryFilter() {
    const select = $("taskCategoryFilter");
    if (!select) return;
    const options = ["All", ...categories];
    if (!options.includes(activeCategory)) {
      activeCategory = "All";
    }
    const previous = select.value;
    select.innerHTML = "";
    options.forEach(cat => {
      const option = document.createElement("option");
      option.value = cat;
      option.textContent = cat;
      select.appendChild(option);
    });
    const targetValue = options.includes(activeCategory) ? activeCategory : "All";
    select.value = options.includes(previous) ? previous : targetValue;
    if (select.value !== targetValue) {
      select.value = targetValue;
    }
  }

  // render chart-specific momentum progress
  function renderCategoryProgress() {
    const cont = $("categoryProgress");
    if (!cont) return;

    const labelEl = cont.querySelector('[data-chart-label]');
    const fillEl = cont.querySelector('[data-chart-fill]');
    const floatingEl = cont.querySelector('[data-chart-floating]');
    if (!labelEl || !fillEl) return;

    const chartTasks = tasks.filter(t => t.category === "Chart");
    const total = chartTasks.length;
    const done = chartTasks.filter(t => isTaskCompleted(t)).length;
    const percent = total === 0 ? 0 : (done / total) * 100;
    const clamped = Math.max(0, Math.min(100, percent));

    labelEl.textContent = `Chart: ${done}/${total} complete`;

    const previous = Number.parseFloat(cont.dataset.percent || "0");
    const progressIncreased = clamped > (Number.isFinite(previous) ? previous : 0);

    fillEl.style.width = `${clamped}%`;
    fillEl.classList.remove("is-warm", "is-complete");
    if (total > 0 && done === total) {
      fillEl.classList.add("is-complete");
    } else if (clamped > 50) {
      fillEl.classList.add("is-warm");
    }

    if (!fillEl.dataset.listened) {
      fillEl.addEventListener("animationend", event => {
        if (event.animationName === "chartGlowPulse") {
          fillEl.classList.remove("progress-glow");
        }
        if (event.animationName === "chartCompletePulse") {
          fillEl.classList.remove("complete-pulse");
        }
      });
      fillEl.dataset.listened = "true";
    }

    if (progressIncreased) {
      fillEl.classList.remove("progress-glow");
      void fillEl.offsetWidth;
      fillEl.classList.add("progress-glow");
      if (floatingEl) {
        floatingEl.textContent = `${Math.round(clamped)}% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1200);
      }
    } else if (floatingEl) {
      floatingEl.classList.remove("is-visible");
    }

    if (clamped >= 100 && (Number.isFinite(previous) ? previous : 0) < 100 && total > 0) {
      fillEl.classList.remove("complete-pulse");
      void fillEl.offsetWidth;
      fillEl.classList.add("complete-pulse");
      if (floatingEl) {
        floatingEl.textContent = `100% complete`;
        floatingEl.classList.add("is-visible");
        if (cont._floatingTimer) {
          clearTimeout(cont._floatingTimer);
        }
        cont._floatingTimer = setTimeout(() => {
          floatingEl.classList.remove("is-visible");
        }, 1500);
      }
    }

    cont.dataset.percent = clamped;
  }

  function renderQuickTasks() {
    const card = document.querySelector("[data-quick-tasks-card]");
    const list = $("quickTaskList");
    const empty = $("quickTaskEmpty");
    if (!card || !list || !empty) return;
    list.innerHTML = "";
    const quickTasks = tasks.filter(task => isQuickTask(task));
    const activeQuick = quickTasks.filter(task => !isTaskCompleted(task));
    const sorted = activeQuick.sort((a, b) => {
      const aTime = new Date(a.createdAt || a.addedAt || 0).getTime();
      const bTime = new Date(b.createdAt || b.addedAt || 0).getTime();
      return aTime - bTime;
    });
    sorted.forEach(task => {
      const item = document.createElement("div");
      item.className = "quick-task-item";
      item.setAttribute("role", "listitem");
      const name = document.createElement("span");
      name.className = "quick-task-name";
      name.textContent = task.name;
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "quick-task-checkbox";
      checkbox.setAttribute("aria-label", `Complete quick task: ${task.name}`);
      checkbox.addEventListener("change", () => {
        checkbox.disabled = true;
        const completed = completeTaskById(task.id);
        if (!completed) {
          checkbox.checked = false;
          checkbox.disabled = false;
        }
      });
      item.appendChild(name);
      item.appendChild(checkbox);
      list.appendChild(item);
    });
    const emptyMessage = sorted.length === 0
      ? (quickTasks.length
          ? "All quick tasks are cleared. Add a new one when you're ready."
          : "No quick tasks yet.")
      : "No quick tasks yet.";
    empty.textContent = emptyMessage;
    empty.classList.toggle("hidden", sorted.length > 0);
    card.classList.remove("hidden");
  }

  const CLINIC_BASKET_STORAGE_KEY = "clinicBasketState";
  const NEURO_CLINIC_LABEL_MAP = {
    Faculty: "Faculty Clinic",
    Continuity: "Continuity Clinic",
    "St. PJs": "St. PJ’s Foster Clinic",
    "Admin Time": "Administrative Time",
    Academics: "Didactics / Academics",
  };

  const NEURO_FALLBACK_BASKET_ITEMS = [
    { id: "patientCalls", label: "Patient Calls" },
    { id: "resultsFollowUp", label: "Results Follow up" },
    { id: "results", label: "Results" },
    { id: "chartCompletion", label: "Chart Completion" },
    { id: "patientAdvice", label: "Patient Advice" },
    { id: "pendingOrders", label: "Pending Orders" },
    { id: "hospitalAdmits", label: "Hospital Admits" },
    { id: "ccdCharts", label: "CC'd charts" },
    { id: "staffMessages", label: "Staff Messages" },
  ];

  function getClinicBasketItemsFromBridge() {
    const api = window.TaskerSchedule;
    if (api && typeof api.getClinicBasketItems === "function") {
      const items = api.getClinicBasketItems();
      if (Array.isArray(items) && items.length) {
        return items;
      }
    }
    return NEURO_FALLBACK_BASKET_ITEMS;
  }

  function getSlotBlocksFromBridge() {
    const api = window.TaskerSchedule;
    if (api && typeof api.getSlotBlocks === "function") {
      const blocks = api.getSlotBlocks();
      if (Array.isArray(blocks) && blocks.length) {
        return blocks;
      }
    }
    return ["AM", "PM"];
  }

  function getWeekScheduleFromBridge() {
    const api = window.TaskerSchedule;
    if (api && typeof api.getWeekSchedule === "function") {
      return api.getWeekSchedule();
    }
    return null;
  }

  function sanitizeClinicBasket(detail) {
    const values = {};
    if (detail && typeof detail === "object" && detail.values && typeof detail.values === "object") {
      Object.entries(detail.values).forEach(([key, value]) => {
        const parsed = Number.parseInt(value, 10);
        values[key] = Number.isFinite(parsed) && parsed >= 0 ? parsed : 0;
      });
    }
    const updatedAt = typeof detail?.updatedAt === "string" ? detail.updatedAt : null;
    return { values, updatedAt };
  }

  function generateClinicClusters(basket) {
    const EST = {
      "Chart Completion": 3,
      Results: 2,
      "Patient Calls": 5,
      "Patient Advice": 3,
    };
    const source = basket && typeof basket === "object" ? basket : {};
    return Object.entries(source)
      .filter(([, value]) => Number.isFinite(value) && value > 0)
      .map(([name, count]) => {
        const minutesPerItem = EST[name] || 3;
        return {
          id: `cluster-${name}`,
          name,
          count,
          estMinutesPerItem: minutesPerItem,
          totalEstMinutes: count * minutesPerItem,
          source: "clinicBasket",
        };
      });
  }

  function clusterTasks(tasks, basket) {
    const taskList = Array.isArray(tasks) ? tasks : [];
    const basketMap = basket && typeof basket === "object" ? basket : {};
    const clusters = generateClinicClusters(basketMap);
    const quickTasks = taskList
      .filter(task => isQuickTask(task))
      .sort((a, b) => (estimateTaskMinutes(a) || 5) - (estimateTaskMinutes(b) || 5));
    const easyCharts = taskList
      .filter(task => !isQuickTask(task) && /chart/i.test(task?.category || ""))
      .sort((a, b) => (estimateTaskMinutes(a) || 15) - (estimateTaskMinutes(b) || 15));
    const quickWins = [...quickTasks.slice(0, 3), ...easyCharts.slice(0, 3)];
    return { clusters, quickWins };
  }

  const CLINIC_ARCHETYPE_LOOKUP = new Map([
    ["faculty", "clinic"],
    ["continuity", "clinic"],
    ["st. pjs", "clinic"],
    ["st. pj's", "clinic"],
    ["st. pj’s", "clinic"],
    ["clinic", "clinic"],
    ["admin", "admin"],
    ["admin time", "admin"],
    ["administrative time", "admin"],
    ["admin / flex overflow", "admin"],
    ["academics", "academic"],
    ["academic", "academic"],
    ["didactics / academics", "academic"],
  ]);

  function resolveClinicArchetype(value) {
    if (typeof value !== "string") {
      return null;
    }
    const normalized = value.trim().toLowerCase();
    if (!normalized) {
      return null;
    }
    if (CLINIC_ARCHETYPE_LOOKUP.has(normalized)) {
      return CLINIC_ARCHETYPE_LOOKUP.get(normalized);
    }
    if (normalized.includes("admin")) {
      return "admin";
    }
    if (normalized.includes("academ")) {
      return "academic";
    }
    if (
      normalized.includes("clinic") ||
      normalized.includes("continuity") ||
      normalized.includes("faculty") ||
      normalized.includes("precept") ||
      normalized.includes("st.") ||
      normalized.includes("st ")
    ) {
      return "clinic";
    }
    return null;
  }

  function sanitizePatientSlots(detail, clinicSelections = {}, currentDay = null) {
    if (!detail || typeof detail !== "object") {
      return {};
    }
    const selectionMap = clinicSelections && typeof clinicSelections === "object"
      ? clinicSelections
      : {};
    const resolveSelectionForKey = key => {
      if (typeof key !== "string") {
        return null;
      }
      if (typeof selectionMap[key] === "string") {
        return selectionMap[key];
      }
      if (key.includes("|")) {
        const [dayPart, blockPart] = key.split("|");
        const combined = `${dayPart}|${blockPart}`;
        if (typeof selectionMap[combined] === "string") {
          return selectionMap[combined];
        }
      }
      if (currentDay) {
        const fallbackKey = `${currentDay}|${key}`;
        if (typeof selectionMap[fallbackKey] === "string") {
          return selectionMap[fallbackKey];
        }
      }
      return null;
    };

    return Object.fromEntries(
      Object.entries(detail).map(([key, slots]) => {
        const normalizedSlots = Array.isArray(slots)
          ? slots.map(slot => ({
              id: typeof slot?.id === "string" ? slot.id : "",
              time: typeof slot?.time === "string" ? slot.time : "",
              label: typeof slot?.label === "string" ? slot.label : "Visit",
              resident: slot?.resident === true,
              isCustom: slot?.isCustom === true,
            }))
          : [];
        const clinicSelection = resolveSelectionForKey(key);
        const archetype = resolveClinicArchetype(clinicSelection);
        if (archetype === "admin" || archetype === "academic") {
          const hasManualPatients = normalizedSlots.some(slot => slot.isCustom === true);
          if (!hasManualPatients) {
            return [key, []];
          }
        }
        return [key, normalizedSlots];
      }),
    );
  }

  function sanitizeDayStateSnapshot(detail) {
    if (!detail || typeof detail !== "object") {
      return {
        currentDay: null,
        currentBlock: null,
        clinicType: null,
        clinicSelections: {},
        blockResidentPresence: {},
        residentMap: {},
        patientSlots: {},
      };
    }
    return {
      currentDay: detail.currentDay || null,
      currentBlock: detail.currentBlock || null,
      clinicType: detail.clinicType || null,
      clinicSelections: { ...(detail.clinicSelections || {}) },
      blockResidentPresence: { ...(detail.blockResidentPresence || {}) },
      residentMap: { ...(detail.residentMap || {}) },
      patientSlots: sanitizePatientSlots(
        detail.patientSlots || {},
        detail.clinicSelections || {},
        detail.currentDay || null,
      ),
    };
  }

  function loadClinicBasketStateFromStorage() {
    try {
      const raw = localStorage.getItem(CLINIC_BASKET_STORAGE_KEY);
      if (!raw) {
        return sanitizeClinicBasket(null);
      }
      const parsed = JSON.parse(raw);
      return sanitizeClinicBasket(parsed);
    } catch (error) {
      return sanitizeClinicBasket(null);
    }
  }

  let neuroScheduleSnapshot = {
    clinicBasket: loadClinicBasketStateFromStorage(),
    dayState: sanitizeDayStateSnapshot(window.TaskerSchedule?.getDayState?.()),
  };

  function updateNeuroDayState(detail) {
    neuroScheduleSnapshot.dayState = sanitizeDayStateSnapshot(detail);
  }

  function updateNeuroClinicBasket(detail) {
    neuroScheduleSnapshot.clinicBasket = sanitizeClinicBasket(detail);
  }

  function mapClinicLabel(selection, fallback) {
    if (selection && NEURO_CLINIC_LABEL_MAP[selection]) {
      return NEURO_CLINIC_LABEL_MAP[selection];
    }
    if (selection) {
      return selection;
    }
    return fallback || "Clinic block";
  }

  function formatClinicBasketTimestamp(timestamp) {
    if (!timestamp) {
      return "Clinic basket —";
    }
    const date = new Date(timestamp);
    if (Number.isNaN(date.getTime())) {
      return "Clinic basket —";
    }
    const datePart = date.toLocaleDateString(undefined, { month: "short", day: "numeric" });
    const timePart = date.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
    return `Clinic basket • ${datePart} ${timePart}`;
  }

  function getTodayClinicInfo(weekSchedule, dayState) {
    const today = new Date();
    const schedule = weekSchedule || {};
    const todayName = today.toLocaleDateString("en-US", { weekday: "long" });
    const stateDay = typeof dayState?.currentDay === "string" ? dayState.currentDay : null;
    const preferredDay = stateDay && schedule[stateDay] ? stateDay : null;
    const fallbackDay = schedule[todayName] ? todayName : null;
    return {
      date: today,
      dayName: preferredDay || fallbackDay || null,
    };
  }

  function formatIsoDateLabel(value) {
    if (!value) return null;
    const date = new Date(`${value}T00:00:00`);
    if (Number.isNaN(date.getTime())) return null;
    return date.toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }

  function buildClinicFocusHint(info, backlog) {
    if (!info) return "";
    const backlogLabel = backlog && (backlog.label || backlog.name)
      ? String(backlog.label || backlog.name).trim()
      : "";
    if (info.isAdmin) {
      return backlogLabel
        ? `Focus: Design backlog sprint on ${backlogLabel}.`
        : "Focus: Protect deep-work admin window.";
    }
    if (info.patientCount === 0) {
      return "Focus: Use block for recovery or strategy planning.";
    }
    if (info.hasResident) {
      return backlogLabel
        ? `Focus: Pair resident downtime with ${backlogLabel}.`
        : "Focus: Pair resident downtime with quick backlog batches.";
    }
    return "Focus: Close visit notes before block transition.";
  }

  function createChecklistEntry(label, metaLines = []) {
    const li = document.createElement("li");
    const labelEl = document.createElement("span");
    labelEl.className = "neuro-checklist__item-label";
    labelEl.textContent = label;
    li.appendChild(labelEl);
    metaLines.filter(Boolean).forEach(text => {
      const meta = document.createElement("span");
      meta.className = "neuro-checklist__item-meta";
      meta.textContent = text;
      li.appendChild(meta);
    });
    /* === Phase 2 – Step 2 : Progress-bar + click animation === */
  const bar = document.createElement("div");
  bar.className = "progress-bar-fill";
  li.appendChild(bar);

  li.addEventListener("click", () => {
    // animate bar fill and pulse
    bar.style.width = "100%";
    li.classList.add("dopamine-check");
    playPositiveCue();
  });
    return li;
  }

  function renderMicroItinerary(host, blocks) {
    if (!host) return;
    host.innerHTML = "";
    (Array.isArray(blocks) ? blocks : []).forEach(block => {
      const label = `${block.start || ""}${block.end ? ` – ${block.end}` : ""} ${block.title || ""}`.trim();
      const meta = [];
      if (Array.isArray(block.meta)) {
        meta.push(...block.meta.filter(Boolean));
      }
      host.appendChild(createChecklistEntry(label, meta));
    });
  }

  function renderTimeline(host, blocks) {
    if (!host) return;
    host.innerHTML = "";
    const collection = Array.isArray(blocks) ? blocks : [];
    if (!collection.length) {
      return;

      /* === Phase 4 – richer timeline cards with controls === */

function renderTimeline(host, blocks) {

if (!host) return;

host.innerHTML = "";

(blocks || []).forEach(block => {

const row = document.createElement("div");

row.className = "itinerary-card";
const time = document.createElement("div");
time.className = "t-time";
time.textContent = `${block.start}–${block.end}`;
const main = document.createElement("div");
main.className = "t-main";
const title = document.createElement("div");
title.className = "t-title";
title.textContent = block.label || "Focused work";
const meta = document.createElement("div");
meta.className = "t-meta";
meta.textContent = block.goal ? `Goal: ${block.goal}` : "";
const rationale = document.createElement("div");

rationale.className = "t-rationale";

if (block.rationale) rationale.textContent = block.rationale;
const source = document.createElement("div");
source.className = "t-source";
if (block.source) source.textContent = `Source: ${block.source}`;
const controls = document.createElement("div");
controls.className = "t-controls";
controls.innerHTML = `
<button type="button" data-sprint="25">▶ 25</button>
<button type="button" data-sprint="50">▶ 50</button>
<button type="button" data-sprint="stop">■ Stop</button>
`;
const progress = document.createElement("div");
progress.className = "t-progress";
const fill = document.createElement("div");
fill.className = "fill";
progress.appendChild(fill);
controls.addEventListener("click", (e) => {
const btn = e.target.closest("button[data-sprint]");
if (!btn) return;
const mode = btn.dataset.sprint;
if (mode === "stop") {
stopFocusTimer(true);
return;
}
sprintDurationMinutes = Number(mode);
setSprintVisualState(true);
startFocusTimer();
});
main.appendChild(title);
if (meta.textContent) main.appendChild(meta);
if (rationale.textContent) main.appendChild(rationale);
if (source.textContent) main.appendChild(source);
main.appendChild(controls);
main.appendChild(progress);
row.appendChild(time);
row.appendChild(main);
host.appendChild(row);
});
}
    }
    const wrap = document.createElement("div");
    wrap.className = "itinerary-timeline";
    collection.forEach(block => {
      const row = document.createElement("div");
      row.className = "itinerary-row";
      row.innerHTML = `<div class="t-time">${block.start || ""}${block.end ? `–${block.end}` : ""}</div> <div class="t-bar"><div class="t-fill"></div></div> <div class="t-title">${block.title || ""}</div>`;
      wrap.appendChild(row);
    });
    host.appendChild(wrap);
  }

  const DEFAULT_QUOTAS = { AM: 0.4, PM: 0.8 };
  let checklistViewMode = null;
  const capacityAdjustmentsState = {};
  const CAPACITY_ADJUSTMENTS_STORAGE_KEY = "taskerCapacityAdjustments";
  let energySheetEscapeHandler = null;
  let capacitySheetEscapeHandler = null;
  let capacityAdjustmentSerial = 0;

  function hydrateCapacityAdjustmentsState() {
    if (typeof localStorage === "undefined") {
      return;
    }
    try {
      const raw = localStorage.getItem(CAPACITY_ADJUSTMENTS_STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return;
      let maxSerial = capacityAdjustmentSerial;
      Object.entries(parsed).forEach(([dayKey, entry]) => {
        if (!dayKey) return;
        const adjustments = Array.isArray(entry?.adjustments) ? entry.adjustments : [];
        const normalized = adjustments.map(item => {
          const kind = item?.kind === "gain" ? "gain" : "loss";
          const start = typeof item?.start === "string" ? item.start : "";
          const end = typeof item?.end === "string" ? item.end : "";
          const reason = typeof item?.reason === "string" ? item.reason : "";
          let id = typeof item?.id === "string" && item.id.trim() ? item.id.trim() : null;
          if (id) {
            const match = id.match(/cap-(\d+)/);
            if (match) {
              maxSerial = Math.max(maxSerial, Number(match[1]) || 0);
            }
          } else {
            maxSerial += 1;
            id = `cap-${maxSerial}`;
          }
          return { id, kind, start, end, reason };
        });
        capacityAdjustmentsState[dayKey] = { adjustments: normalized };
      });
      capacityAdjustmentSerial = Math.max(capacityAdjustmentSerial, maxSerial);
    } catch (error) {
      console.warn("Failed to load availability adjustments", error);
    }
  }

  function persistCapacityAdjustmentsState() {
    if (typeof localStorage === "undefined") {
      return;
    }
    try {
      const snapshot = {};
      Object.entries(capacityAdjustmentsState).forEach(([dayKey, entry]) => {
        if (!dayKey || !entry || !Array.isArray(entry.adjustments)) return;
        snapshot[dayKey] = {
          adjustments: entry.adjustments.map(item => ({
            id: typeof item?.id === "string" ? item.id : null,
            kind: item?.kind === "gain" ? "gain" : "loss",
            start: typeof item?.start === "string" ? item.start : "",
            end: typeof item?.end === "string" ? item.end : "",
            reason: typeof item?.reason === "string" ? item.reason : "",
          })),
        };
      });
      localStorage.setItem(CAPACITY_ADJUSTMENTS_STORAGE_KEY, JSON.stringify(snapshot));
    } catch (error) {
      console.warn("Failed to save availability adjustments", error);
    }
  }

  hydrateCapacityAdjustmentsState();

  function getCapacityDayKey() {
    const dayState = neuroScheduleSnapshot?.dayState;
    if (typeof dayState?.currentDay === "string" && dayState.currentDay.trim()) {
      return dayState.currentDay.trim();
    }
    const today = new Date();
    const dayName = today.toLocaleDateString("en-US", { weekday: "short" });
    const iso = today.toISOString().slice(0, 10);
    return `${dayName}|${iso}`;
  }

  function getTodayBlockKey(block = "PM") {
    const normalizedBlock = typeof block === "string" && block.trim() ? block.trim() : "PM";
    const dayKey = getCapacityDayKey();
    if (!dayKey) return null;
    return `${dayKey}|${normalizedBlock}`;
  }

  function ensureCapacityAdjustmentsEntry(dayKey = getCapacityDayKey()) {
    if (!dayKey) return null;
    if (!capacityAdjustmentsState[dayKey]) {
      capacityAdjustmentsState[dayKey] = { adjustments: [] };
    }
    return capacityAdjustmentsState[dayKey];
  }

  function getCapacityAdjustments(dayKey = getCapacityDayKey()) {
    const entry = dayKey ? capacityAdjustmentsState[dayKey] : null;
    if (!entry || !Array.isArray(entry.adjustments)) {
      return [];
    }
    return entry.adjustments;
  }

  function createCapacityAdjustment(kind) {
    capacityAdjustmentSerial += 1;
    return {
      id: `cap-${capacityAdjustmentSerial}`,
      kind: kind === "loss" ? "loss" : "gain",
      start: "",
      end: "",
      reason: "",
    };
  }

  function normalizeCapacityAdjustment(adjustment) {
    if (!adjustment || typeof adjustment !== "object") return null;
    const kind = adjustment.kind === "loss" ? "loss" : "gain";
    const start = typeof adjustment.start === "string" ? adjustment.start : "";
    const end = typeof adjustment.end === "string" ? adjustment.end : "";
    const reason = typeof adjustment.reason === "string" ? adjustment.reason : "";
    const startMinutes = getMinutesFromTimeString(start);
    const endMinutes = getMinutesFromTimeString(end);
    return {
      id: typeof adjustment.id === "string" ? adjustment.id : null,
      kind,
      start,
      end,
      reason,
      startMinutes: Number.isFinite(startMinutes) ? startMinutes : null,
      endMinutes: Number.isFinite(endMinutes) ? endMinutes : null,
    };
  }

  function getBlockFromMinutes(minutes) {
    if (!Number.isFinite(minutes)) return "PM";
    return minutes < 12 * 60 ? "AM" : "PM";
  }

  function sumWindowMinutes(windows) {
    return (Array.isArray(windows) ? windows : []).reduce((total, window) => {
      const start = getMinutesFromTimeString(window?.start);
      const end = getMinutesFromTimeString(window?.end);
      if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
        return total;
      }
      return total + (end - start);
    }, 0);
  }

  function getLatestWindowEndMinutes(windows) {
    if (!Array.isArray(windows) || windows.length === 0) {
      return null;
    }
    let latest = null;
    windows.forEach(window => {
      const endMinutes = getMinutesFromTimeString(window?.end);
      if (!Number.isFinite(endMinutes)) {
        return;
      }
      latest = latest === null ? endMinutes : Math.max(latest, endMinutes);
    });
    return latest;
  }

  function subtractIntervalFromWindows(windows, startMinutes, endMinutes, trackRemoved = true) {
    if (!Array.isArray(windows)) {
      return { updatedWindows: [], removedMinutes: 0 };
    }
    const updated = [];
    let removed = 0;
    windows.forEach(window => {
      const winStart = getMinutesFromTimeString(window?.start);
      const winEnd = getMinutesFromTimeString(window?.end);
      if (!Number.isFinite(winStart) || !Number.isFinite(winEnd) || winEnd <= winStart) {
        updated.push({ ...window });
        return;
      }
      if (endMinutes <= winStart || startMinutes >= winEnd) {
        updated.push({ ...window });
        return;
      }
      const overlapStart = Math.max(winStart, startMinutes);
      const overlapEnd = Math.min(winEnd, endMinutes);
      if (trackRemoved) {
        removed += Math.max(0, overlapEnd - overlapStart);
      }
      if (overlapStart > winStart) {
        updated.push({ ...window, end: minutesToTimeString(overlapStart) });
      }
      if (overlapEnd < winEnd) {
        updated.push({ ...window, start: minutesToTimeString(overlapEnd) });
      }
    });
    return { updatedWindows: updated, removedMinutes: trackRemoved ? removed : 0 };
  }

  function applyCapacityAdjustmentsToWindows(windows, adjustmentsState, dayKey = getCapacityDayKey()) {
    const baseWindows = Array.isArray(windows) ? windows.map(window => ({ ...window })) : [];
    const entry = dayKey ? adjustmentsState?.[dayKey] : null;
    const adjustments = Array.isArray(entry?.adjustments) ? entry.adjustments.map(normalizeCapacityAdjustment) : [];
    const losses = adjustments.filter(adj => adj && adj.kind === "loss" && adj.startMinutes !== null && adj.endMinutes !== null && adj.endMinutes > adj.startMinutes);
    const gains = adjustments.filter(adj => adj && adj.kind === "gain" && adj.startMinutes !== null && adj.endMinutes !== null && adj.endMinutes > adj.startMinutes);

    let workingWindows = baseWindows;
    let lossMinutes = 0;
    losses.forEach(loss => {
      const { updatedWindows, removedMinutes } = subtractIntervalFromWindows(
        workingWindows,
        loss.startMinutes,
        loss.endMinutes,
        true,
      );
      workingWindows = updatedWindows;
      lossMinutes += removedMinutes;
    });

    let gainMinutes = 0;
    gains.forEach(gain => {
      const { updatedWindows } = subtractIntervalFromWindows(
        workingWindows,
        gain.startMinutes,
        gain.endMinutes,
        false,
      );
      workingWindows = updatedWindows;
      const block = getBlockFromMinutes(gain.startMinutes);
      const nextWindow = {
        start: minutesToTimeString(gain.startMinutes),
        end: minutesToTimeString(gain.endMinutes),
        type: "Focus",
        block,
        adjustment: {
          kind: "gain",
          reason: gain.reason,
        },
      };
      workingWindows.push(nextWindow);
      gainMinutes += gain.endMinutes - gain.startMinutes;
    });

    const normalizedWindows = workingWindows
      .map(window => {
        const start = getMinutesFromTimeString(window?.start);
        const end = getMinutesFromTimeString(window?.end);
        if (!Number.isFinite(start) || !Number.isFinite(end) || end <= start) {
          return null;
        }
        return {
          ...window,
          start: minutesToTimeString(start),
          end: minutesToTimeString(end),
        };
      })
      .filter(Boolean)
      .sort((a, b) => {
        const aStart = getMinutesFromTimeString(a.start) ?? 0;
        const bStart = getMinutesFromTimeString(b.start) ?? 0;
        if (aStart === bStart) {
          const aEnd = getMinutesFromTimeString(a.end) ?? aStart;
          const bEnd = getMinutesFromTimeString(b.end) ?? bStart;
          return aEnd - bEnd;
        }
        return aStart - bStart;
      });

    return { windows: normalizedWindows, lossMinutes, gainMinutes };
  }

  function formatDuration(minutes) {
    if (!Number.isFinite(minutes)) return "0m";
    const abs = Math.abs(Math.round(minutes));
    const hours = Math.floor(abs / 60);
    const mins = abs % 60;
    const parts = [];
    if (hours > 0) {
      parts.push(`${hours}h`);
    }
    if (mins > 0 || parts.length === 0) {
      parts.push(`${mins}m`);
    }
    return parts.join(" ");
  }

  const SessionState = (typeof window !== "undefined" && window.SessionState)
    ? window.SessionState
    : {};

  if (!SessionState.contextLocation) {
    SessionState.contextLocation = "home_solo";
  }

  if (typeof window !== "undefined") {
    window.SessionState = SessionState;
  }

  const SOCIAL_SCORE_MAP = {
    home_solo: 0.0,
    clinic_open_door: 0.7,
    clinic_workroom: 0.5,
    cafe: 0.4,
    zoom_buddy: 1.0,
    clinic_closed: 0.5,
    clinic_with_door_open: 0.7,
  };

  const SOCIAL_CONTEXT_OPTIONS = [
    { value: "home_solo", label: "Charting at home", score: 0.0 },
    { value: "clinic_open_door", label: "Charting in exam room with door open", score: 0.7 },
    { value: "clinic_workroom", label: "Charting in workroom", score: 0.5 },
    { value: "cafe", label: "Charting in a cafe", score: 0.4 },
    { value: "zoom_buddy", label: "Charting with a zoom buddy", score: 1.0 },
  ];

  function getSocialContextScore() {
    const loc = SessionState.contextLocation || "home_solo";
    return SOCIAL_SCORE_MAP[loc] ?? 0;
  }

  function getSocialContextOption(loc = SessionState.contextLocation || "home_solo") {
    return SOCIAL_CONTEXT_OPTIONS.find(option => option.value === loc) || null;
  }

  function formatSocialContextLabel(loc = SessionState.contextLocation || "home_solo") {
    const option = getSocialContextOption(loc);
    return option?.label || loc.replace(/_/g, " ");
  }

  function ensureChecklistLayout(card) {
    if (!card) return null;
    if (card.__checklistRefs) {
      return card.__checklistRefs;
    }

    card.innerHTML = "";

    const header = document.createElement("header");
    header.className = "neuro-checklist__header";

    const title = document.createElement("h2");
    title.className = "neuro-checklist__title";
    title.textContent = "Capacity Center";

    const snapshotEl = document.createElement("p");
    snapshotEl.className = "neuro-checklist__snapshot";
    snapshotEl.dataset.checklistSnapshot = "";
    snapshotEl.textContent = "Clinic snapshot loading…";

    const controlGrid = document.createElement("div");
    controlGrid.className = "neuro-checklist__control-grid";
    controlGrid.id = "capacityControlGrid";
    controlGrid.setAttribute("role", "group");
    controlGrid.setAttribute("aria-label", "Capacity center controls");

    const metricsBox = document.createElement("div");
    metricsBox.className = "visually-hidden";
    const workloadEl = document.createElement("span");
    workloadEl.dataset.checklistWorkload = "";
    workloadEl.textContent = "—";
    const basketUpdatedEl = document.createElement("span");
    basketUpdatedEl.dataset.checklistBasketUpdated = "";
    basketUpdatedEl.textContent = "Clinic basket —";
    metricsBox.appendChild(workloadEl);
    metricsBox.appendChild(basketUpdatedEl);

    header.appendChild(title);
    header.appendChild(snapshotEl);
    header.appendChild(controlGrid);
    header.appendChild(metricsBox);

    const body = document.createElement("div");
    body.className = "neuro-checklist__body";

    const focusSection = document.createElement("section");
    focusSection.className = "neuro-checklist__section";
    const focusTitle = document.createElement("h3");
    focusTitle.className = "neuro-checklist__section-title";
    focusTitle.textContent = "Focus targets";
    const focusList = document.createElement("ol");
    focusList.className = "neuro-checklist__list neuro-checklist__list--ordered";
    focusList.dataset.checklistFocus = "";
    const focusEmpty = document.createElement("li");
    focusEmpty.className = "neuro-checklist__empty";
    focusEmpty.textContent = "Awaiting priority scan…";
    focusList.appendChild(focusEmpty);
    focusSection.appendChild(focusTitle);
    focusSection.appendChild(focusList);

    const itinerarySection = document.createElement("section");
    itinerarySection.className = "neuro-checklist__section neuro-checklist__section--itinerary";
    const itineraryTitle = document.createElement("h3");
    itineraryTitle.className = "neuro-checklist__section-title";
    itineraryTitle.textContent = "Visual workflow";
    const itineraryContainer = document.createElement("div");
    itineraryContainer.className = "neuro-checklist__itinerary";
    const itineraryList = document.createElement("ul");
    itineraryList.className = "neuro-checklist__list neuro-checklist__itinerary-list";
    itineraryList.dataset.checklistItineraryList = "";
    const itineraryTimeline = document.createElement("div");
    itineraryTimeline.className = "neuro-checklist__itinerary-timeline";
    itineraryTimeline.dataset.checklistItineraryTimeline = "";
    itineraryContainer.appendChild(itineraryList);
    itineraryContainer.appendChild(itineraryTimeline);
    const itineraryEmpty = document.createElement("p");
    itineraryEmpty.className = "neuro-checklist__itinerary-empty";
    itineraryEmpty.dataset.checklistItineraryEmpty = "";
    itineraryEmpty.textContent = "Generating adaptive workflow…";
    itinerarySection.appendChild(itineraryTitle);
    itinerarySection.appendChild(itineraryContainer);
    itinerarySection.appendChild(itineraryEmpty);

    body.appendChild(focusSection);
    body.appendChild(itinerarySection);

    card.appendChild(header);
    card.appendChild(body);

    const refs = {
      snapshotEl,
      workloadEl,
      basketUpdatedEl,
      controlGrid,
      focusList,
      itineraryList,
      itineraryTimeline,
      itineraryEmpty,
      itineraryContainer,
    };
    card.__checklistRefs = refs;
    return refs;
  }

  function mountChecklistControls(card) {
    const host = card.querySelector("#capacityControlGrid");
    if (!host || host.dataset.controlsMounted === "true") return;

    const createControl = (id, icon, label) => {
      const wrapper = document.createElement("div");
      wrapper.className = "neuro-checklist__control";

      const button = document.createElement("button");
      button.id = id;
      button.type = "button";
      button.setAttribute("aria-pressed", "false");
      button.textContent = icon;

      const caption = document.createElement("span");
      caption.textContent = label;

      wrapper.appendChild(button);
      wrapper.appendChild(caption);
      return { wrapper, button, caption };
    };

    const createContextLocationControl = () => {
      const wrapper = document.createElement("div");
      wrapper.className = "neuro-checklist__control neuro-checklist__control--dropdown";

      const caption = document.createElement("span");
      caption.dataset.contextLocationLabel = "";
      caption.textContent = "👨‍💻 Context";

      const button = document.createElement("button");
      button.id = "contextLocationButton";
      button.type = "button";
      button.className = "neuro-checklist__control-button";
      button.textContent = "👨‍💻";
      button.setAttribute("aria-haspopup", "listbox");
      button.setAttribute("aria-expanded", "false");

      const menu = document.createElement("div");
      menu.className = "neuro-checklist__dropdown";
      menu.hidden = true;
      menu.setAttribute("role", "listbox");
      menu.setAttribute("aria-label", "Select context location");

      SOCIAL_CONTEXT_OPTIONS.forEach(option => {
        const optionButton = document.createElement("button");
        optionButton.type = "button";
        optionButton.className = "neuro-checklist__dropdown-option";
        optionButton.dataset.value = option.value;
        optionButton.textContent = `${option.label} (${option.score.toFixed(1)})`;
        optionButton.setAttribute("role", "option");
        optionButton.setAttribute("aria-pressed", "false");
        menu.appendChild(optionButton);
      });

      wrapper.appendChild(button);
      wrapper.appendChild(menu);
      wrapper.appendChild(caption);
      return { wrapper, button, menu, caption };
    };

    const availability = createControl("capacityWrench", "🔧", "Availability");
    const energy = createControl("energyDial", "🔋", "Energy");
    const contextLocation = createContextLocationControl();

    host.append(
      availability.wrapper,
      energy.wrapper,
      contextLocation.wrapper,
    );

    host.dataset.controlsMounted = "true";

    if (typeof ensureEnergySheet === "function") {
      ensureEnergySheet();
    }
    if (typeof getCapacityBackdrop === "function") {
      getCapacityBackdrop();
    }

    availability.button.addEventListener("click", () => {
      openCapacitySheet();
    });

    energy.button.addEventListener("click", () => {
      openEnergySheet();
    });

    const toggleContextMenu = (forceState = null) => {
      const shouldOpen = forceState ?? contextLocation.menu.hidden;
      contextLocation.menu.hidden = !shouldOpen;
      contextLocation.menu.classList.toggle("is-open", shouldOpen);
      contextLocation.button.setAttribute("aria-expanded", shouldOpen ? "true" : "false");
      if (shouldOpen) {
        const active = contextLocation.menu.querySelector(".neuro-checklist__dropdown-option.is-active");
        active?.focus({ preventScroll: true });
      }
    };

    contextLocation.button.addEventListener("click", () => {
      toggleContextMenu();
    });

    contextLocation.menu.addEventListener("click", event => {
      const optionButton = event.target?.closest(".neuro-checklist__dropdown-option");
      if (!optionButton) return;
      const normalized = (optionButton.dataset.value || "home_solo").trim();
      SessionState.contextLocation = normalized || "home_solo";
      updateContextLocationControls();
      applyChecklistControlsState();
      toggleContextMenu(false);
    });

    document.addEventListener("click", event => {
      if (!contextLocation.wrapper.contains(event.target)) {
        toggleContextMenu(false);
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        toggleContextMenu(false);
      }
    });

    updateContextLocationControls();
  }

  function setChecklistViewMode(mode) {
    const card = document.getElementById("neuroChecklist");
    const shouldUpdate = checklistViewMode !== mode;
    checklistViewMode = mode;
    applyChecklistControlsState();
    if (shouldUpdate) {
      updateUI();
    }
    const refs = card?.__checklistRefs;
    let target = null;
    if (mode === "list") {
      target = refs?.focusList?.closest("section") || null;
    }
    if (mode === "timeline") {
      target = refs?.itineraryContainer || refs?.itineraryTimeline || null;
    }
    if (target instanceof HTMLElement) {
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  }

  function wireChecklistViewButtons() {
    const focusButton = document.getElementById("focusViewButton");
    if (focusButton && !focusButton.dataset.wired) {
      focusButton.dataset.wired = "true";
      focusButton.addEventListener("click", () => setChecklistViewMode("list"));
    }

    const workflowButton = document.getElementById("visualWorkflowButton");
    if (workflowButton && !workflowButton.dataset.wired) {
      workflowButton.dataset.wired = "true";
      workflowButton.addEventListener("click", () => setChecklistViewMode("timeline"));
    }
  }

  function updateContextLocationControls() {
    const button = document.getElementById("contextLocationButton");
    const caption = document.querySelector("[data-context-location-label]");
    const menu = document.querySelector(".neuro-checklist__dropdown");
    const desired = SessionState.contextLocation || "home_solo";
    const friendly = formatSocialContextLabel(desired);
    const score = Math.round(getSocialContextScore() * 100);

    if (caption) {
      caption.textContent = `👨‍💻 Context (${friendly} — ${score}% boost)`;
    }

    if (button) {
      button.textContent = `👨‍💻 ${friendly}`;
      button.setAttribute("aria-label", `Context location — ${friendly} (${score}% social boost)`);
    }

    if (menu) {
      menu.querySelectorAll(".neuro-checklist__dropdown-option").forEach(optionButton => {
        const isActive = optionButton.dataset.value === desired;
        optionButton.classList.toggle("is-active", isActive);
        optionButton.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }
  }

  function renderCapacityRows(sheet) {
    if (!sheet) return;
    const dayKey = getCapacityDayKey();
    const entry = ensureCapacityAdjustmentsEntry(dayKey);
    const adjustments = Array.isArray(entry?.adjustments) ? entry.adjustments : [];

    const renderList = (kind, host) => {
      if (!host) return;
      host.innerHTML = "";
      const filtered = adjustments.filter(adjustment => adjustment.kind === kind);
      if (!filtered.length) {
        const empty = document.createElement("p");
        empty.className = "capacity-adjustments__empty";
        empty.textContent = kind === "loss"
          ? "No time losses logged yet."
          : "No extra availability captured yet.";
        host.appendChild(empty);
        return;
      }
      filtered.forEach(adjustment => {
        if (!adjustment.id) {
          adjustment.id = `cap-${++capacityAdjustmentSerial}`;
        }
        const row = document.createElement("div");
        row.className = "capacity-adjustments__row";
        row.dataset.kind = kind;
        row.dataset.adjustmentId = adjustment.id;

        const icon = document.createElement("span");
        icon.className = "capacity-adjustments__icon";
        icon.textContent = kind === "loss" ? "🔻" : "🔺️";

        const startInput = document.createElement("input");
        startInput.type = "time";
        startInput.dataset.field = "start";
        startInput.value = adjustment.start || "";

        const label = document.createElement("span");
        label.className = "capacity-adjustments__label";
        label.textContent = "to";

        const endInput = document.createElement("input");
        endInput.type = "time";
        endInput.dataset.field = "end";
        endInput.value = adjustment.end || "";

        const reasonInput = document.createElement("input");
        reasonInput.type = "text";
        reasonInput.dataset.field = "reason";
        reasonInput.placeholder = "Reason (optional)";
        reasonInput.value = adjustment.reason || "";

        const remove = document.createElement("button");
        remove.type = "button";
        remove.className = "capacity-adjustments__remove";
        remove.dataset.action = "remove";
        remove.setAttribute("aria-label", "Remove time adjustment");
        remove.textContent = "✕";

        row.append(icon, startInput, label, endInput, reasonInput, remove);
        host.appendChild(row);
      });
    };

    renderList("loss", sheet.querySelector('[data-adjustment-list="loss"]'));
    renderList("gain", sheet.querySelector('[data-adjustment-list="gain"]'));
  }

  function renderCapacitySummary(sheet) {
    if (!sheet) return;
    const summary = sheet.querySelector("[data-capacity-summary]");
    if (!summary) return;
    const headlineEl = summary.querySelector("[data-capacity-summary-headline]");
    const baselineEl = summary.querySelector("[data-capacity-summary-baseline]");
    const lossEl = summary.querySelector("[data-capacity-summary-loss]");
    const gainEl = summary.querySelector("[data-capacity-summary-gain]");
    const netEl = summary.querySelector("[data-capacity-summary-net]");

    const metrics = calculateCapacityMetrics();
    if (!metrics) {
      if (headlineEl) headlineEl.textContent = "Availability data unavailable.";
      if (baselineEl) baselineEl.textContent = "—";
      if (lossEl) lossEl.textContent = "—";
      if (gainEl) gainEl.textContent = "—";
      if (netEl) netEl.textContent = "—";
      return;
    }

    const { baseMinutes, lossMinutes, gainMinutes, netMinutes, percentLabel } = metrics;

    if (headlineEl) {
      headlineEl.textContent = `Today's capacity — ${formatDuration(netMinutes)}`;
    }
    if (baselineEl) {
      baselineEl.textContent = `${formatDuration(baseMinutes)} scheduled`;
    }
    if (lossEl) {
      lossEl.textContent = lossMinutes > 0
        ? `−${formatDuration(lossMinutes)}`
        : "0m";
    }
    if (gainEl) {
      gainEl.textContent = gainMinutes > 0
        ? `+${formatDuration(gainMinutes)}`
        : "0m";
    }
    if (netEl) {
      netEl.textContent = percentLabel
        ? `${formatDuration(netMinutes)} (${percentLabel})`
        : formatDuration(netMinutes);
    }
  }

  function renderCapacitySheet(sheet) {
    renderCapacityRows(sheet);
    renderCapacitySummary(sheet);
  }

  function ensureEnergySheet() {
    let sheet = document.getElementById("energySheet");
    if (sheet) {
      return sheet;
    }

    const host = document.body || document.querySelector("body");
    if (!host) {
      if (!ensureEnergySheet.__pending) {
        ensureEnergySheet.__pending = true;
        document.addEventListener(
          "DOMContentLoaded",
          () => {
            ensureEnergySheet.__pending = false;
            ensureEnergySheet();
          },
          { once: true },
        );
      }
      return null;
    }

    sheet = document.createElement("div");
    sheet.id = "energySheet";
    sheet.className = "energy-sheet";
    sheet.setAttribute("role", "dialog");
    sheet.setAttribute("aria-modal", "true");
    sheet.setAttribute("aria-hidden", "true");
    sheet.innerHTML = `
      <div class="energy-sheet__header">
        <h4 class="energy-sheet__title">Energy check</h4>
        <p class="energy-sheet__subtitle">Pick the buckets that best match how you feel right now.</p>
      </div>
      <div class="energy-sheet__body energy-sheet__body--dual">
        <div class="energy-sheet__bucket" data-kind="physical">
          <div class="energy-sheet__bucket-heading">
            <div class="energy-sheet__bucket-title">Physical energy 💚</div>
            <div id="energySheetPhysicalValue" class="energy-sheet__value"></div>
          </div>
          <input
            id="energySheetPhysical"
            type="range"
            min="0"
            max="3"
            step="1"
            value="2"
            aria-label="Physical energy bucket"
          />
          <div class="energy-sheet__bucket-labels" id="energySheetPhysicalLabels"></div>
          <ul id="energySheetPhysicalNotes" class="energy-sheet__bucket-notes"></ul>
        </div>
        <div class="energy-sheet__bucket" data-kind="mental">
          <div class="energy-sheet__bucket-heading">
            <div class="energy-sheet__bucket-title">Mental energy 🧠</div>
            <div id="energySheetMentalValue" class="energy-sheet__value"></div>
          </div>
          <input
            id="energySheetMental"
            type="range"
            min="0"
            max="3"
            step="1"
            value="2"
            aria-label="Mental energy bucket"
          />
          <div class="energy-sheet__bucket-labels" id="energySheetMentalLabels"></div>
          <ul id="energySheetMentalNotes" class="energy-sheet__bucket-notes"></ul>
        </div>
        <div class="energy-sheet__summary" aria-live="polite">
          <div class="energy-sheet__summary-title">Overall focus fuel</div>
          <div id="energySheetValue" class="energy-sheet__summary-value"></div>
          <p class="energy-sheet__summary-detail" id="energySheetSummary"></p>
        </div>
        <input id="energySheetSlider" type="hidden" value="3" aria-hidden="true" />
        <div class="energy-sheet__actions">
          <button type="button" data-action="done">Done</button>
        </div>
      </div>`;

    const hiddenSlider = sheet.querySelector("#energySheetSlider");
    const overallValue = sheet.querySelector("#energySheetValue");
    const summaryDetail = sheet.querySelector("#energySheetSummary");
    const physicalSlider = sheet.querySelector("#energySheetPhysical");
    const mentalSlider = sheet.querySelector("#energySheetMental");
    const physicalValue = sheet.querySelector("#energySheetPhysicalValue");
    const mentalValue = sheet.querySelector("#energySheetMentalValue");
    const physicalLabels = sheet.querySelector("#energySheetPhysicalLabels");
    const mentalLabels = sheet.querySelector("#energySheetMentalLabels");
    const physicalNotes = sheet.querySelector("#energySheetPhysicalNotes");
    const mentalNotes = sheet.querySelector("#energySheetMentalNotes");

    const PHYSICAL_ENERGY_BUCKETS = [
      {
        label: "Trash fire",
        approx: 0.15,
        notes: [
          "< 3.5 h sleep",
          "Very poor hydration/eating/exercise for > 14 days",
          "Ill or migraine",
        ],
      },
      {
        label: "Heavy but functional",
        approx: 0.4,
        notes: [
          "3.5–5 h sleep",
          "Poor hydration/eating/exercise for > 7 days",
          "Maybe prodrome of illness",
        ],
      },
      {
        label: "Decent",
        approx: 0.7,
        notes: [
          "5–7 h sleep",
          "Hydration/eating/exercise at least every other day",
          "No illness",
        ],
      },
      {
        label: "Unicorn",
        approx: 0.95,
        notes: ["7 h sleep", "Good hydration/eating/exercise for > 7 days"],
      },
    ];

    const MENTAL_ENERGY_BUCKETS = [
      {
        label: "Storm",
        approx: 0.15,
        notes: [
          "Panic, high dread, unmedicated, or totally burnt",
          "Full panel of complex patients makes it worse",
          "Unlikely to start admin even during admin time unless external threat",
        ],
      },
      {
        label: "Noisy but possible",
        approx: 0.4,
        notes: [
          "Anxiety/burnout present",
          "Stars have to align to start",
          "Slightly more productive on half days and academic days",
        ],
      },
      {
        label: "Stable",
        approx: 0.7,
        notes: [
          "Meds on board",
          "Mood okay, mild dread",
          "High stakes tasks pending but doable",
        ],
      },
      {
        label: "Rare clear day",
        approx: 0.95,
        notes: [
          "No high stakes tasks hanging over you",
          "Feel effective and appreciated",
        ],
      },
    ];

    const pickClosestBucket = (buckets, target) => {
      let bestIndex = 0;
      let bestDistance = Number.POSITIVE_INFINITY;
      buckets.forEach((bucket, index) => {
        const distance = Math.abs(bucket.approx - target);
        if (distance < bestDistance) {
          bestIndex = index;
          bestDistance = distance;
        }
      });
      return bestIndex;
    };

    const normalizedToEnergyValue = normalized => {
      const clamped = Math.max(0, Math.min(1, normalized));
      if (clamped < 0.25) return 1;
      if (clamped < 0.55) return 2;
      if (clamped < 0.75) return 3;
      if (clamped < 0.9) return 4;
      return 5;
    };

    const clampBucketIndex = value => {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.min(3, Math.round(numeric)));
    };

    const renderBucketLabels = (container, buckets) => {
      if (!container) return;
      container.innerHTML = buckets
        .map((bucket, index) => `<span data-index="${index}">${bucket.label}</span>`)
        .join("");
    };

    renderBucketLabels(physicalLabels, PHYSICAL_ENERGY_BUCKETS);
    renderBucketLabels(mentalLabels, MENTAL_ENERGY_BUCKETS);

    const attachLabelSelection = (container, slider) => {
      if (!container || !slider) return;
      container.addEventListener("click", event => {
        const target = event.target instanceof HTMLElement ? event.target : null;
        if (!target || !target.dataset.index) return;
        slider.value = target.dataset.index;
        const energyValue = updateSheetFromBuckets();
        alignEnergySliders(energyValue, "sheet");
      });
    };

    const applyBucketNotes = (bucket, list) => {
      if (!bucket || !list) return;
      list.innerHTML = "";
      bucket.notes.forEach(note => {
        const item = document.createElement("li");
        item.textContent = note;
        list.appendChild(item);
      });
      const approx = document.createElement("li");
      approx.className = "energy-sheet__bucket-approx";
      approx.textContent = `→ Set R ≈ ${bucket.approx.toFixed(2)}`;
      list.appendChild(approx);
    };

    const syncBucketHighlight = (container, activeIndex) => {
      if (!container) return;
      container.querySelectorAll("span").forEach(label => {
        const index = Number(label.dataset.index || 0);
        label.classList.toggle("is-active", index === activeIndex);
      });
    };

    const updateSheetFromBuckets = overrideEnergyValue => {
      const physicalIndex = clampBucketIndex(physicalSlider?.value || 0);
      const mentalIndex = clampBucketIndex(mentalSlider?.value || 0);
      const physicalBucket = PHYSICAL_ENERGY_BUCKETS[physicalIndex] || PHYSICAL_ENERGY_BUCKETS[0];
      const mentalBucket = MENTAL_ENERGY_BUCKETS[mentalIndex] || MENTAL_ENERGY_BUCKETS[0];
      const combinedNormalized = (physicalBucket.approx + mentalBucket.approx) / 2;
      const energyValue = Number.isFinite(overrideEnergyValue)
        ? clampScale(overrideEnergyValue, 3)
        : normalizedToEnergyValue(combinedNormalized);
      const energyLabel = ENERGY_LABELS[energyValue] || `${energyValue}`;

      if (physicalValue) {
        physicalValue.textContent = `${physicalBucket.label} • ${physicalBucket.approx}`;
      }
      if (mentalValue) {
        mentalValue.textContent = `${mentalBucket.label} • ${mentalBucket.approx}`;
      }
      if (overallValue) {
        overallValue.textContent = `${energyValue} • ${energyLabel}`;
      }
      if (summaryDetail) {
        summaryDetail.textContent = `Physical: ${physicalBucket.label} (${physicalBucket.approx}) • Mental: ${mentalBucket.label} (${mentalBucket.approx})`;
      }
      if (hiddenSlider) {
        hiddenSlider.value = String(energyValue);
        hiddenSlider.setAttribute("data-value", String(energyValue));
      }
      applyBucketNotes(physicalBucket, physicalNotes);
      applyBucketNotes(mentalBucket, mentalNotes);
      syncBucketHighlight(physicalLabels, physicalIndex);
      syncBucketHighlight(mentalLabels, mentalIndex);

      return energyValue;
    };

    const refreshSheet = value => {
      const normalized = Math.max(0, Math.min(1, Number(value) / 5 || 0));
      const physicalIndex = pickClosestBucket(PHYSICAL_ENERGY_BUCKETS, normalized);
      const mentalIndex = pickClosestBucket(MENTAL_ENERGY_BUCKETS, normalized);
      if (physicalSlider) physicalSlider.value = String(physicalIndex);
      if (mentalSlider) mentalSlider.value = String(mentalIndex);
      updateSheetFromBuckets(value);
    };

    attachLabelSelection(physicalLabels, physicalSlider);
    attachLabelSelection(mentalLabels, mentalSlider);

    if (physicalSlider) {
      physicalSlider.addEventListener("input", () => {
        const energyValue = updateSheetFromBuckets();
        alignEnergySliders(energyValue, "sheet");
      });
      physicalSlider.addEventListener("change", () => {
        updateSheetFromBuckets();
        window.requestAnimationFrame(() => {
          closeEnergySheet();
        });
      });
    }

    if (mentalSlider) {
      mentalSlider.addEventListener("input", () => {
        const energyValue = updateSheetFromBuckets();
        alignEnergySliders(energyValue, "sheet");
      });
      mentalSlider.addEventListener("change", () => {
        updateSheetFromBuckets();
        window.requestAnimationFrame(() => {
          closeEnergySheet();
        });
      });
    }

    sheet.addEventListener("click", event => {
      const target = event.target instanceof HTMLElement ? event.target : null;
      if (!target) return;
      const action = target.dataset.action;
      if (action === "done") {
        closeEnergySheet();
      }
    });

    sheet.__refreshEnergySheet = refreshSheet;
    host.appendChild(sheet);
    updateSheetFromBuckets();
    return sheet;
  }

  function positionEnergySheet(sheet, anchor) {
    if (!(sheet instanceof HTMLElement)) return;

    const viewportWidth = window.innerWidth || document.documentElement?.clientWidth || 0;
    const viewportHeight = window.innerHeight || document.documentElement?.clientHeight || 0;
    const sheetRect = sheet.getBoundingClientRect();
    const sheetWidth = sheetRect.width || sheet.offsetWidth || 0;
    const sheetHeight = sheetRect.height || sheet.offsetHeight || 0;
    const margin = 16;

    const anchorRect = anchor instanceof HTMLElement ? anchor.getBoundingClientRect() : null;
    let centerX = anchorRect ? anchorRect.left + anchorRect.width / 2 : viewportWidth / 2;
    let centerY = anchorRect ? anchorRect.top + anchorRect.height / 2 : viewportHeight / 2;

    const halfWidth = sheetWidth / 2;
    const halfHeight = sheetHeight / 2;

    if (viewportWidth > 0 && halfWidth > 0) {
      const minCenterX = margin + halfWidth;
      const maxCenterX = viewportWidth - margin - halfWidth;
      if (maxCenterX >= minCenterX) {
        centerX = Math.min(Math.max(centerX, minCenterX), maxCenterX);
      } else {
        centerX = viewportWidth / 2;
      }
    }

    if (viewportHeight > 0 && halfHeight > 0) {
      const minCenterY = margin + halfHeight;
      const maxCenterY = viewportHeight - margin - halfHeight;
      if (maxCenterY >= minCenterY) {
        centerY = Math.min(Math.max(centerY, minCenterY), maxCenterY);
      } else {
        centerY = viewportHeight / 2;
      }
    }

    sheet.style.setProperty("--energy-sheet-left", `${Math.round(centerX)}px`);
    sheet.style.setProperty("--energy-sheet-top", `${Math.round(centerY)}px`);
  }

  function syncCapacityOverlayState() {
    const body = document.body;
    if (!body) return;
    const capacityOpen = document.getElementById("capacitySheet")?.classList.contains("is-open");
    const energyOpen = document.getElementById("energySheet")?.classList.contains("is-open");
    if (capacityOpen || energyOpen) {
      body.classList.add("capacity-overlay-active");
    } else {
      body.classList.remove("capacity-overlay-active");
    }
  }

  function openEnergySheet() {
    const card = document.getElementById("neuroChecklist");
    if (!card) {
      if (!openEnergySheet.__waitForCard) {
        const handleCardReady = () => {
          openEnergySheet.__waitForCard = null;
          openEnergySheet();
        };
        openEnergySheet.__waitForCard = handleCardReady;
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", handleCardReady, { once: true });
        } else {
          window.requestAnimationFrame(handleCardReady);
        }
      }
      return;
    }
    openEnergySheet.__waitForCard = null;

    const sheet = ensureEnergySheet();
    if (!sheet) {
      if (!openEnergySheet.__waitForSheet) {
        const handleSheetReady = () => {
          openEnergySheet.__waitForSheet = null;
          openEnergySheet();
        };
        openEnergySheet.__waitForSheet = handleSheetReady;
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", handleSheetReady, { once: true });
        } else {
          window.requestAnimationFrame(handleSheetReady);
        }
      }
      return;
    }
    openEnergySheet.__waitForSheet = null;

    const currentLevel = alignEnergySliders(getEnergyLevel(), "sheet");
    const refresh = typeof sheet.__refreshEnergySheet === "function" ? sheet.__refreshEnergySheet : null;
    if (refresh) {
      refresh(currentLevel);
    }

    const anchor = card.querySelector("#capacityControlGrid");
    positionEnergySheet(sheet, anchor instanceof HTMLElement ? anchor : card);

    sheet.classList.add("is-open");
    sheet.setAttribute("aria-hidden", "false");
    applyChecklistControlsState();
    syncCapacityOverlayState();

    const slider = sheet.querySelector("#energySheetPhysical");
    if (slider instanceof HTMLElement) {
      slider.focus();
    }

    const backdrop = typeof getCapacityBackdrop === "function" ? getCapacityBackdrop() : null;
    if (backdrop) {
      backdrop.classList.add("is-visible");
    }

    if (!energySheetEscapeHandler) {
      energySheetEscapeHandler = event => {
        if (event.key === "Escape") {
          closeEnergySheet();
          return;
        }
        if (event.key === "Tab") {
          const focusables = sheet.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
          );
          if (!focusables.length) return;
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          if (event.shiftKey && document.activeElement === first) {
            event.preventDefault();
            last.focus();
          } else if (!event.shiftKey && document.activeElement === last) {
            event.preventDefault();
            first.focus();
          }
        }
      };
      document.addEventListener("keydown", energySheetEscapeHandler);
    }
  }

  function closeEnergySheet() {
    const sheet = document.getElementById("energySheet");
    if (sheet) {
      sheet.classList.remove("is-open");
      sheet.setAttribute("aria-hidden", "true");
    }

    const capacityOpen = document.getElementById("capacitySheet")?.classList.contains("is-open");
    if (!capacityOpen) {
      const backdrop = document.getElementById("capacityBackdrop");
      if (backdrop) {
        backdrop.classList.remove("is-visible");
      }
    }

    if (energySheetEscapeHandler) {
      document.removeEventListener("keydown", energySheetEscapeHandler);
      energySheetEscapeHandler = null;
    }

    applyChecklistControlsState();
    syncCapacityOverlayState();
  }

  function ensureCapacitySheet(card) {
    if (!card) return null;
    let sheet = document.getElementById("capacitySheet");
    if (sheet) {
      renderCapacitySheet(sheet);
      return sheet;
    }

    sheet = document.createElement("div");
    sheet.id = "capacitySheet";
    sheet.className = "checklist-capacity-sheet";
    sheet.setAttribute("role", "dialog");
    sheet.setAttribute("aria-modal", "true");
    sheet.setAttribute("aria-hidden", "true");
    sheet.innerHTML = `
      <div class="checklist-capacity-sheet__header">
        <h4 class="checklist-capacity-sheet__title">Availability calibration</h4>
        <p class="checklist-capacity-sheet__subtitle">Add or subtract actual time gains and losses for today's workflow.</p>
      </div>
      <div class="checklist-capacity-sheet__summary" data-capacity-summary>
        <strong data-capacity-summary-headline>Today's capacity — loading…</strong>
        <div class="checklist-capacity-sheet__stats">
          <div class="checklist-capacity-sheet__stat">
            <strong>Baseline</strong>
            <span data-capacity-summary-baseline>—</span>
          </div>
          <div class="checklist-capacity-sheet__stat">
            <strong>Lost</strong>
            <span data-capacity-summary-loss>—</span>
          </div>
          <div class="checklist-capacity-sheet__stat">
            <strong>Gained</strong>
            <span data-capacity-summary-gain>—</span>
          </div>
          <div class="checklist-capacity-sheet__stat">
            <strong>Net availability</strong>
            <span data-capacity-summary-net>—</span>
          </div>
        </div>
      </div>
      <section class="capacity-adjustments" data-capacity-section="loss">
        <div class="capacity-adjustments__heading">
          <h5>Time lost</h5>
          <button type="button" class="capacity-adjustments__add" data-action="add" data-kind="loss">🔻 Add loss time</button>
        </div>
        <div class="capacity-adjustments__list" data-adjustment-list="loss"></div>
      </section>
      <section class="capacity-adjustments" data-capacity-section="gain">
        <div class="capacity-adjustments__heading">
          <h5>Time gained</h5>
          <button type="button" class="capacity-adjustments__add" data-action="add" data-kind="gain">🔺️ Add gained time</button>
        </div>
        <div class="capacity-adjustments__list" data-adjustment-list="gain"></div>
      </section>
      <div class="checklist-capacity-sheet__footer">
        <button type="button" data-action="save">Save</button>
        <button type="button" data-action="close">Done</button>
      </div>`;
    card.appendChild(sheet);

    renderCapacitySheet(sheet);

    sheet.addEventListener("click", event => {
      const target = event.target instanceof HTMLElement ? event.target : null;
      if (!target) return;
      const action = target.dataset.action;
      if (action === "close") {
        persistCapacityAdjustmentsState();
        closeCapacitySheet();
        return;
      }
      if (action === "save") {
        persistCapacityAdjustmentsState();
        renderCapacitySummary(sheet);
        if (typeof showToast === "function") {
          showToast("Availability calibration", "Availability adjustments saved.");
        } else {
          window.alert("Availability adjustments saved.");
        }
        return;
      }
      if (action === "add") {
        const kind = target.dataset.kind === "loss" ? "loss" : "gain";
        const entry = ensureCapacityAdjustmentsEntry();
        if (!entry) return;
        entry.adjustments.push(createCapacityAdjustment(kind));
        persistCapacityAdjustmentsState();
        renderCapacityRows(sheet);
        renderCapacitySummary(sheet);
        applyChecklistControlsState();
        renderNeuroChecklist();
        return;
      }
      if (action === "remove") {
        const row = target.closest("[data-adjustment-id]");
        const id = row?.getAttribute("data-adjustment-id");
        if (!id) return;
        const entry = ensureCapacityAdjustmentsEntry();
        if (!entry) return;
        entry.adjustments = entry.adjustments.filter(item => item.id !== id);
        persistCapacityAdjustmentsState();
        renderCapacitySheet(sheet);
        applyChecklistControlsState();
        renderNeuroChecklist();
      }
    });

    sheet.addEventListener("input", event => {
      const target = event.target instanceof HTMLInputElement ? event.target : null;
      if (!target) return;
      const row = target.closest("[data-adjustment-id]");
      const id = row?.getAttribute("data-adjustment-id");
      if (!id) return;
      const field = target.dataset.field;
      if (!field) return;
      const entry = ensureCapacityAdjustmentsEntry();
      if (!entry) return;
      const adjustment = entry.adjustments.find(item => item.id === id);
      if (!adjustment) return;
      adjustment[field] = target.value || "";
      persistCapacityAdjustmentsState();
      renderCapacitySummary(sheet);
      applyChecklistControlsState();
      renderNeuroChecklist();
    });

    return sheet;
  }

  function openCapacitySheet() {
    const card = document.getElementById("neuroChecklist");
    if (!card) return;
    const sheet = ensureCapacitySheet(card);
    if (!sheet) return;
    sheet.classList.add("is-open");
    sheet.setAttribute("aria-hidden", "false");
    renderCapacitySheet(sheet);
    applyChecklistControlsState();
    syncCapacityOverlayState();
    const backdrop = typeof getCapacityBackdrop === "function" ? getCapacityBackdrop() : null;
    if (backdrop) {
      backdrop.classList.add("is-visible");
    }
    const focusTarget = sheet.querySelector("[data-action='close']");
    if (focusTarget instanceof HTMLElement) {
      focusTarget.focus();
    }
    if (!capacitySheetEscapeHandler) {
      capacitySheetEscapeHandler = event => {
        if (event.key === "Escape") {
          closeCapacitySheet();
          return;
        }
        if (event.key === "Tab") {
          const focusables = sheet.querySelectorAll(
            "button, [href], input, select, textarea, [tabindex]:not([tabindex='-1'])",
          );
          if (!focusables.length) {
            return;
          }
          const list = Array.from(focusables).filter(element => !element.hasAttribute("disabled"));
          if (!list.length) return;
          const first = list[0];
          const last = list[list.length - 1];
          if (event.shiftKey) {
            if (document.activeElement === first || !sheet.contains(document.activeElement)) {
              last.focus();
              event.preventDefault();
            }
          } else if (document.activeElement === last) {
            first.focus();
            event.preventDefault();
          }
        }
      };
      document.addEventListener("keydown", capacitySheetEscapeHandler);
    }
  }

  function closeCapacitySheet() {
    const sheet = document.getElementById("capacitySheet");
    if (sheet) {
      sheet.classList.remove("is-open");
      sheet.setAttribute("aria-hidden", "true");
    }
    const energyOpen = document.getElementById("energySheet")?.classList.contains("is-open");
    if (!energyOpen) {
      const backdrop = document.getElementById("capacityBackdrop");
      if (backdrop) {
        backdrop.classList.remove("is-visible");
      }
    }
    if (capacitySheetEscapeHandler) {
      document.removeEventListener("keydown", capacitySheetEscapeHandler);
      capacitySheetEscapeHandler = null;
    }
    syncCapacityOverlayState();
  }

  function applyChecklistControlsState() {
    const metrics = calculateCapacityMetrics();
    const baseMinutes = metrics?.baseMinutes ?? 0;
    const netMinutes = metrics?.netMinutes ?? baseMinutes;

    const card = document.getElementById("neuroChecklist");
    if (card) {
      const isTimeline = checklistViewMode === "timeline";
      const isList = checklistViewMode === "list";
      const isCollapsed = !isTimeline && !isList;
      card.classList.toggle("neuro-checklist--timeline", isTimeline);
      card.classList.toggle("neuro-checklist--collapsed", isCollapsed);
      const refs = card.__checklistRefs;
      if (refs) {
        if (refs.focusList) {
          refs.focusList.setAttribute("aria-hidden", isList ? "false" : "true");
        }
        if (refs.itineraryList) {
          refs.itineraryList.setAttribute("aria-hidden", isList ? "false" : "true");
        }
        if (refs.itineraryTimeline) {
          refs.itineraryTimeline.setAttribute("aria-hidden", isTimeline ? "false" : "true");
        }
      }
      card.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
    }

    const focusButton = document.getElementById("focusViewButton");
    if (focusButton) {
      const isActive = checklistViewMode === "list";
      focusButton.classList.toggle("is-active", isActive);
      focusButton.setAttribute("aria-pressed", isActive ? "true" : "false");
      focusButton.setAttribute("aria-label", "Focus view");
    }

    const workflowButton = document.getElementById("visualWorkflowButton");
    if (workflowButton) {
      const isActive = checklistViewMode === "timeline";
      workflowButton.classList.toggle("is-active", isActive);
      workflowButton.setAttribute("aria-pressed", isActive ? "true" : "false");
      workflowButton.setAttribute("aria-label", "Visual workflow view");
    }

    updateContextLocationControls();

    const capacityButton = document.getElementById("capacityWrench");
    if (capacityButton) {
      const labelSummary = metrics?.percentLabel
        ? `${formatDuration(netMinutes)} (${metrics.percentLabel})`
        : formatDuration(netMinutes);
      capacityButton.setAttribute(
        "aria-label",
        `Availability / capacity — ${labelSummary}`,
      );
    }

    const energyButton = document.getElementById("energyDial");
    if (energyButton) {
      const level = clampScale(getEnergyLevel(), 3);
      const label = ENERGY_LABELS[level] || level;
      const sheetOpen = document.getElementById("energySheet")?.classList.contains("is-open");
      energyButton.setAttribute("aria-label", `Energy — ${level} (${label})`);
      energyButton.setAttribute("aria-pressed", sheetOpen ? "true" : "false");
      energyButton.classList.toggle("is-active", Boolean(sheetOpen));
    }
  }

  function minutesToTimeString(totalMinutes) {
    if (!Number.isFinite(totalMinutes)) {
      return "00:00";
    }
    const safe = Math.max(0, Math.round(totalMinutes));
    const hours = Math.floor(safe / 60) % 24;
    const minutes = safe % 60;
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
  }

  function slotsToParallelWindows(slots, block = "AM") {
    if (!Array.isArray(slots) || slots.length === 0) {
      return [];
    }
    const normalized = slots
      .map(slot => ({ minutes: getMinutesFromTimeString(slot?.time), slot }))
      .filter(entry => entry.minutes !== null)
      .sort((a, b) => a.minutes - b.minutes);
    if (!normalized.length) {
      return [];
    }
    const windows = [];
    let windowStart = normalized[0].minutes;
    let windowEnd = normalized[0].minutes + 45;

    normalized.forEach((entry, index) => {
      const startMinutes = entry.minutes;
      const nextStart = normalized[index + 1]?.minutes;
      let slotEnd = startMinutes + 45;
      if (Number.isFinite(nextStart) && nextStart < slotEnd) {
        slotEnd = nextStart;
      }
      if (startMinutes > windowEnd + 5) {
        windows.push({
          start: minutesToTimeString(windowStart),
          end: minutesToTimeString(windowEnd),
          type: "Parallel",
          block,
        });
        windowStart = startMinutes;
      }
      windowEnd = Math.max(windowEnd, slotEnd);
      if (index === normalized.length - 1) {
        windows.push({
          start: minutesToTimeString(windowStart),
          end: minutesToTimeString(windowEnd),
          type: "Parallel",
          block,
        });
      }
    });

    return windows;
  }

  const USER_END_TIME_STORAGE_KEY = "userDefinedEndTime";

  function getUserDefinedEndTime() {
    if (typeof window === "undefined" || !window.localStorage) {
      return null;
    }
    try {
      const value = window.localStorage.getItem(USER_END_TIME_STORAGE_KEY);
      if (typeof value !== "string") {
        return null;
      }
      const minutes = getMinutesFromTimeString(value);
      if (minutes === null) {
        return null;
      }
      return minutesToTimeString(minutes);
    } catch (error) {
      return null;
    }
  }

  function normalizeBlockPresenceMap(source) {
    const result = { AM: 0, PM: 0 };
    if (!source || typeof source !== "object") {
      return result;
    }
    const day = neuroScheduleSnapshot?.dayState?.currentDay;
    ["AM", "PM"].forEach(block => {
      if (typeof source[block] === "number") {
        result[block] = source[block];
      } else if (typeof source[block] === "boolean") {
        result[block] = source[block] ? 1 : 0;
      } else if (day) {
        const keyed = source[`${day}|${block}`];
        if (typeof keyed === "number") {
          result[block] = keyed;
        } else if (typeof keyed === "boolean") {
          result[block] = keyed ? 1 : 0;
        }
      }
    });
    return result;
  }

  function clonePatientSlot(slot) {
    return {
      id: typeof slot?.id === "string" ? slot.id : "",
      time: typeof slot?.time === "string" ? slot.time : "",
      label: typeof slot?.label === "string" ? slot.label : "Visit",
      resident: slot?.resident === true,
      isCustom: slot?.isCustom === true,
    };
  }

  function normalizePatientSlotMap(source) {
    const result = { AM: [], PM: [] };
    if (!source || typeof source !== "object") {
      return result;
    }
    const day = neuroScheduleSnapshot?.dayState?.currentDay;
    ["AM", "PM"].forEach(block => {
      const direct = source[block];
      if (Array.isArray(direct)) {
        result[block] = direct.map(clonePatientSlot);
        return;
      }
      if (day) {
        const keyed = source[`${day}|${block}`];
        if (Array.isArray(keyed)) {
          result[block] = keyed.map(clonePatientSlot);
        }
      }
    });
    return result;
  }

  function buildBaseAvailabilityWindows({ clinicType, residents, patientSlots, userEndTime }) {
    const make = (start, end, type, block) => ({ start, end, type, block });
    const windows = [];
    const archetype = resolveClinicArchetype(clinicType);
    const residentCounts = {
      AM: Number(residents?.AM) || 0,
      PM: Number(residents?.PM) || 0,
    };
    const slotsByBlock = {
      AM: Array.isArray(patientSlots?.AM) ? patientSlots.AM : [],
      PM: Array.isArray(patientSlots?.PM) ? patientSlots.PM : [],
    };
    const endTime = typeof userEndTime === "string" && userEndTime ? userEndTime : "17:00";

    if (archetype === "clinic") {
      windows.push(make("08:00", "08:15", "Clinical-Supervision", "AM"));
      if (residentCounts.AM >= 1) {
        windows.push(...slotsToParallelWindows(slotsByBlock.AM, "AM"));
      }
      windows.push(make("10:25", "11:45", "Clinical-Supervision", "AM"));
      windows.push(make("11:45", "12:00", "Transition", "AM"));
    }

    if (archetype === "admin") {
      windows.push(make("13:00", endTime, "Admin", "PM"));
    } else if (archetype === "academic") {
      windows.push(make("13:00", endTime, "Academic-Blackout", "PM"));
    } else if (archetype === "clinic") {
      windows.push(make("13:00", endTime, "Admin", "PM"));
    }

    return windows;
  }

  function computeAvailabilityWindows({
    clinicType,
    residents,
    patientSlots,
    userEndTime,
    capacityAdjustments,
  }) {
    const baseWindows = buildBaseAvailabilityWindows({ clinicType, residents, patientSlots, userEndTime });
    const { windows } = applyCapacityAdjustmentsToWindows(
      baseWindows,
      capacityAdjustments || capacityAdjustmentsState,
      getCapacityDayKey(),
    );
    return windows;
  }

  function calculateCapacityMetrics() {
    const dayState = neuroScheduleSnapshot?.dayState || {};
    const clinicType = dayState?.clinicSelections?.todayType || dayState?.clinicType || null;
    const residents = normalizeBlockPresenceMap(dayState?.blockResidentPresence);
    const patientSlots = normalizePatientSlotMap(dayState?.patientSlots);
    const userEndTime = getUserDefinedEndTime() || "17:00";
    const baseWindows = buildBaseAvailabilityWindows({ clinicType, residents, patientSlots, userEndTime });
    const { windows: adjustedWindows, lossMinutes, gainMinutes } = applyCapacityAdjustmentsToWindows(
      baseWindows,
      capacityAdjustmentsState,
      getCapacityDayKey(),
    );
    const baseMinutes = sumWindowMinutes(baseWindows);
    const netMinutes = sumWindowMinutes(adjustedWindows);
    const percent = baseMinutes > 0 ? Math.round((netMinutes / baseMinutes) * 100) : null;
    return {
      baseMinutes,
      lossMinutes,
      gainMinutes,
      netMinutes,
      percentLabel: Number.isFinite(percent) ? `${percent}%` : null,
      baseWindows,
      adjustedWindows,
    };
  }

  function getDailyContext() {
    const week = getWeekScheduleFromBridge() || {};
    const dayState = neuroScheduleSnapshot?.dayState || {};
    const basket = neuroScheduleSnapshot?.clinicBasket || {};
    const tasksSnapshot = Array.isArray(tasks) ? tasks.slice() : [];
    const activeTasks = tasksSnapshot.filter(task => !isTaskCompleted(task));
    const clinicType = dayState?.clinicSelections?.todayType || dayState?.clinicType || null;
    const residents = normalizeBlockPresenceMap(dayState?.blockResidentPresence);
    const patientSlots = normalizePatientSlotMap(dayState?.patientSlots);
    const userEndTime = getUserDefinedEndTime() || "17:00";
    const basketItems = getClinicBasketItemsFromBridge();
    const basketValues = basket?.values || {};
    const basketByLabel = Object.fromEntries(
      basketItems.map(item => {
        const raw = Number.parseInt(basketValues[item.id], 10);
        const count = Number.isFinite(raw) && raw > 0 ? raw : 0;
        return [item.label, count];
      }),
    );
    const triage = clusterTasks(activeTasks, basketByLabel);
    const windows = computeAvailabilityWindows({
      clinicType,
      residents,
      patientSlots,
      userEndTime,
      capacityAdjustments: capacityAdjustmentsState,
    });

    const latestWindowEnd = getLatestWindowEndMinutes(windows);
    const userEndMinutes = getMinutesFromTimeString(userEndTime);
    const hasLatestWindowEnd = typeof latestWindowEnd === "number" && Number.isFinite(latestWindowEnd);
    const hasUserEndMinutes = typeof userEndMinutes === "number" && Number.isFinite(userEndMinutes);
    let effectiveEndMinutes = hasUserEndMinutes ? userEndMinutes : null;
    if (hasLatestWindowEnd) {
      effectiveEndMinutes = hasUserEndMinutes
        ? Math.max(userEndMinutes, latestWindowEnd)
        : latestWindowEnd;
    }
    const effectiveUserEndTime = typeof effectiveEndMinutes === "number" && Number.isFinite(effectiveEndMinutes)
      ? minutesToTimeString(effectiveEndMinutes)
      : userEndTime;

    const context = {
      week,
      dayState,
      tasks: tasksSnapshot,
      activeTasks,
      basket,
      clinicType,
      residents,
      patientSlots,
      userEndTime: effectiveUserEndTime,
      quotas: DEFAULT_QUOTAS,
      triage,
      windows,
    };
    // === Phase 5 – Apply adaptive profile ===
    try {
      const bias = JSON.parse(localStorage.getItem("adaptiveProfile") || "{}");
      if (bias.defaultSprintMinutes) context.defaultSprintMinutes = bias.defaultSprintMinutes;
      if (bias.quickWinBias) context.quickWinBias = bias.quickWinBias;
      if (bias.shieldPromptTone) context.shieldPromptTone = bias.shieldPromptTone;
    } catch (e) {
      console.warn("Adaptive bias load failed", e);
    }
    return context;
  }

  if (typeof window !== "undefined") {
    window.TaskerDaily = Object.assign(window.TaskerDaily || {}, {
      getDailyContext,
      computeAvailabilityWindows,
    });
  }

  function buildClinicSnapshotLine(dailyContext, weekSchedule, dayName) {
    if (!dailyContext) {
      return null;
    }
    const scheduleForDay = dayName && weekSchedule ? weekSchedule[dayName] : null;
    const selections = dailyContext.dayState?.clinicSelections || {};
    const blockPresence = dailyContext.dayState?.blockResidentPresence || {};
    const patientSlots = dailyContext.patientSlots || {};
    const residents = dailyContext.residents || {};
    const blocks = ["AM", "PM"];
    const parts = [];
    let totalPatients = 0;

    blocks.forEach(blockName => {
      const blockKey = dayName ? `${dayName}|${blockName}` : blockName;
      const scheduleBlock = scheduleForDay?.[blockName] || null;
      const selection = selections[blockKey] || null;
      const label = mapClinicLabel(selection, scheduleBlock?.label);
      const slots = Array.isArray(patientSlots?.[blockName]) ? patientSlots[blockName] : [];
      const schedulePatients = Array.isArray(scheduleBlock?.patients) ? scheduleBlock.patients.length : 0;
      const patientCount = slots.length || schedulePatients;
      totalPatients += patientCount;
      const hasResident = Boolean(
        Number(residents?.[blockName]) > 0
        || blockPresence[blockKey] === true
        || scheduleBlock?.residentRequired === true,
      );
      const isAdmin = selection === "Admin Time"
        || /admin|didactic/i.test(String(label || ""))
        || patientCount === 0;
      const details = [];
      if (patientCount > 0) {
        details.push(`${patientCount} pt${patientCount === 1 ? "" : "s"}`);
      } else {
        details.push("0 pts");
      }
      if (hasResident && patientCount > 0) {
        details.push("Resident");
      }
      if (isAdmin) {
        details.push("Admin");
      }
      const blockLabel = label || "Clinic block";
      parts.push(`${blockName} • ${blockLabel} (${details.join(", ")})`);
    });

    const totalLabel = totalPatients === 1 ? "1 Total Patient" : `${totalPatients} Total Patients`;
    if (!parts.length) {
      return {
        totalLabel,
        blocks: ["No clinic blocks scheduled."],
      };
    }

    return {
      totalLabel,
      blocks: parts,
    };
  }

  function renderNeuroChecklist() {
    const card = document.getElementById("neuroChecklist");
    if (!card) return;
    const refs = ensureChecklistLayout(card);
    if (!refs) return;
    const {
      snapshotEl,
      workloadEl,
      basketUpdatedEl,
      focusList,
      itineraryList,
      itineraryTimeline,
      itineraryEmpty,
      itineraryContainer,
    } = refs;

    mountChecklistControls(card);
    wireChecklistViewButtons();
    applyChecklistControlsState();

    const dailyContext = getDailyContext();
    const weekSchedule = dailyContext.week;
    const { date: todayDate, dayName } = getTodayClinicInfo(weekSchedule, dailyContext.dayState);
    const formattedDate = todayDate
      ? todayDate.toLocaleDateString(undefined, {
          weekday: "long",
          month: "short",
          day: "numeric",
        })
      : null;
    if (snapshotEl) {
      const summary = buildClinicSnapshotLine(dailyContext, weekSchedule, dayName);
      if (summary) {
        const headerLine = formattedDate
          ? `${formattedDate} • ${summary.totalLabel}`
          : summary.totalLabel;
        const detailLines = Array.isArray(summary.blocks)
          ? summary.blocks.map(line => `• ${line}`)
          : [];
        const lines = headerLine ? [headerLine, ...detailLines] : detailLines;
        snapshotEl.textContent = lines.join("\n");
      } else {
        snapshotEl.textContent = "Clinic snapshot — Schedule unavailable.";
      }
    }

    basketUpdatedEl.textContent = formatClinicBasketTimestamp(dailyContext.basket.updatedAt);

    const activeTasks = Array.isArray(dailyContext.activeTasks)
      ? dailyContext.activeTasks
      : dailyContext.tasks.filter(task => !isTaskCompleted(task));
    const quickActive = activeTasks.filter(task => isQuickTask(task));
    if (activeTasks.length) {
      workloadEl.textContent = `${activeTasks.length} active • ${quickActive.length} quick • ${dailyContext.tasks.length} total`;
    } else {
      workloadEl.textContent = `${dailyContext.tasks.length} total tasks`;
    }

    const basketItems = getClinicBasketItemsFromBridge();
    const basketValues = dailyContext.basket.values || {};
    const basketByLabel = Object.fromEntries(
      basketItems.map(item => {
        const raw = Number.parseInt(basketValues[item.id], 10);
        const count = Number.isFinite(raw) && raw > 0 ? raw : 0;
        return [item.label, count];
      }),
    );
    const triage = dailyContext.triage || clusterTasks(activeTasks, basketByLabel);
    const clusters = Array.isArray(triage?.clusters) ? triage.clusters : [];
    const sortedClusters = clusters
      .slice()
      .sort((a, b) => (Number.isFinite(b.totalEstMinutes) ? b.totalEstMinutes : 0) - (Number.isFinite(a.totalEstMinutes) ? a.totalEstMinutes : 0));

    focusList.innerHTML = "";
    const focusCandidates = sortTasksByMode(
      activeTasks.filter(task => !isQuickTask(task)),
      TASK_SORT_MODES.PRIORITY,
    ).slice(0, 3);

    if (!focusCandidates.length) {
      const empty = document.createElement("li");
      empty.className = "neuro-checklist__empty";
      empty.textContent = "All core tasks cleared for now.";
      focusList.appendChild(empty);
    } else {
      focusCandidates.forEach(task => {
        const label = task.name || "Task";
        const descriptors = buildTaskDescriptors(task);
        const descriptorText = descriptors.join(" • ");
        const estimate = estimateTaskMinutes(task);
        const metaParts = [];
        if (descriptorText) {
          metaParts.push(descriptorText);
        }
        if (Number.isFinite(estimate) && estimate > 0) {
          metaParts.push(`~${Math.round(estimate)} min`);
        }
        if (task.dueDate) {
          const dueLabel = formatIsoDateLabel(task.dueDate);
          if (dueLabel) {
            metaParts.push(`Due ${dueLabel}`);
          }
        }
        focusList.appendChild(createChecklistEntry(label, metaParts));
      });
    }

    if (itineraryList) {
      itineraryList.innerHTML = "";
    }
    if (itineraryTimeline) {
      itineraryTimeline.innerHTML = "";
    }
    if (itineraryEmpty) {
      itineraryEmpty.classList.add("hidden");
    }
    if (itineraryContainer) {
      itineraryContainer.classList.remove("hidden");
    }

    const itineraryGenerator = window.TaskerDaily?.generateAdaptiveItinerary;
    let itineraryBlocks = [];

    if (typeof itineraryGenerator === "function") {
      const itineraryTasks = activeTasks.map(task => {
        const estimate = estimateTaskMinutes(task);
        const safeMinutes = Number.isFinite(estimate) && estimate > 0 ? estimate : 30;
        const descriptors = buildTaskDescriptors(task);
        const metaSet = new Set(descriptors);
        if (task.dueDate) {
          const dueLabel = formatIsoDateLabel(task.dueDate);
          if (dueLabel) {
            metaSet.add(`Due ${dueLabel}`);
          }
        }
        if (task.category) {
          metaSet.add(task.category);
        }
        return {
          name: task.name || "Focused Block",
          minutes: safeMinutes,
          quickWin: isQuickTask(task),
          yield: Math.max(1, Math.round(Number(task.priority) || 1)),
          meta: Array.from(metaSet).filter(Boolean),
        };
      });

      const itineraryBasket = {};
      sortedClusters.forEach(cluster => {
        if (!cluster || !Number.isFinite(cluster.totalEstMinutes)) return;
        const minutes = Math.max(0, cluster.totalEstMinutes);
        if (minutes <= 0) return;
        const label = (cluster.name || "").toLowerCase();
        if (label.includes("result")) {
          itineraryBasket.Results = { minutes };
        } else if (label.includes("call")) {
          itineraryBasket.Calls = { minutes };
        } else if (label.includes("chart")) {
          itineraryBasket.Charts = { minutes };
        } else if (label.includes("advice")) {
          itineraryBasket.Advice = { minutes };
        }
      });

      const itineraryContext = {
        windows: Array.isArray(dailyContext.windows) ? dailyContext.windows : [],
        quotas: dailyContext.quotas || DEFAULT_QUOTAS,
        tasks: itineraryTasks,
        basket: itineraryBasket,
        clinicType: dailyContext.clinicType,
        userEndTime: dailyContext.userEndTime,
      };

      try {
        itineraryBlocks = itineraryGenerator(itineraryContext, {});
      } catch (error) {
        console.error("Failed to generate adaptive itinerary", error);
      }
    }

    const decoratedBlocks = (Array.isArray(itineraryBlocks) ? itineraryBlocks : []).map(block => {
      const metaSet = new Set();
      if (Array.isArray(block.meta)) {
        block.meta.filter(Boolean).forEach(item => metaSet.add(item));
      }
      if (Number.isFinite(block.minutes) && block.minutes > 0) {
        metaSet.add(`~${Math.round(block.minutes)} min`);
      }
      if (block.segment) {
        metaSet.add(`${block.segment} segment`);
      }
      if (block.why && typeof block.why === "string" && block.why !== "adaptive") {
        metaSet.add(block.why);
      }
      return {
        ...block,
        meta: Array.from(metaSet),
      };
    });

    if (decoratedBlocks.length && itineraryContainer) {
      if (itineraryList) {
        renderMicroItinerary(itineraryList, decoratedBlocks);
      }
      if (itineraryTimeline) {
        renderTimeline(itineraryTimeline, decoratedBlocks);
      }
    } else {
      if (itineraryContainer) {
        itineraryContainer.classList.add("hidden");
      }
      if (itineraryEmpty) {
        itineraryEmpty.textContent = typeof itineraryGenerator === "function"
          ? "Add tasks or adjust availability to generate a workflow."
          : "Timeline tools unavailable.";
        itineraryEmpty.classList.remove("hidden");
      }
    }
  }

  window.addEventListener("scheduleBridgeReady", event => {
    if (event?.detail?.dayState) {
      updateNeuroDayState(event.detail.dayState);
    }
    renderNeuroChecklist();
  });

  window.addEventListener("scheduleStateUpdated", event => {
    if (!event?.detail) return;
    if (event.detail.dayState) {
      updateNeuroDayState(event.detail.dayState);
    }
    if (event.detail.clinicBasket) {
      updateNeuroClinicBasket(event.detail.clinicBasket);
    }
    renderNeuroChecklist();
  });

  window.addEventListener("storage", event => {
    if (event.key === CLINIC_BASKET_STORAGE_KEY) {
      updateNeuroClinicBasket(loadClinicBasketStateFromStorage());
      renderNeuroChecklist();
    }
  });

  function buildTaskDescriptors(task) {
    const descriptors = [];
    if (task.patientType) descriptors.push(`Patient: ${task.patientType}`);
    if (task.visitType) descriptors.push(`Visit: ${task.visitType}`);
    if (task.clinicSite) descriptors.push(task.clinicSite);
    if (task.urgency) descriptors.push(`Urgency ${task.urgency}`);
    return descriptors;
  }

  function getSubTaskProgress(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const total = task.subTasks.length;
    const completed = task.subTasks.filter(sub => sub.completed).length;
    const percent = total === 0 ? 0 : Math.round((completed / total) * 100);
    return { total, completed, percent };
  }

  function createProgressElement(task) {
    const progressData = getSubTaskProgress(task);
    if (!progressData) return null;
    const container = document.createElement("div");
    container.className = "task-progress-group";

    const label = document.createElement("div");
    label.className = "task-progress";
    const stepsLabel = `${progressData.total} ${progressData.total === 1 ? "step" : "steps"}`;
    let statusText;
    if (progressData.completed === 0) {
      statusText = "first step ready.";
    } else if (progressData.completed >= progressData.total) {
      statusText = "plan complete.";
    } else {
      statusText = `${progressData.completed} done.`;
    }
    label.textContent = `${stepsLabel} • ${statusText}`;
    container.appendChild(label);

    const meter = document.createElement("div");
    meter.className = "task-progress-meter";
    const fill = document.createElement("span");
    fill.className = "fill";
    const fillPercent = progressData.percent <= 0 ? 1 : Math.max(progressData.percent, 1);
    fill.style.width = `${fillPercent}%`;
    meter.appendChild(fill);
    container.appendChild(meter);

    return container;
  }

  function createMetaItem(text) {
    const span = document.createElement("span");
    span.textContent = text;
    return span;
  }

  function createTaskDetails(task) {
    if (!Array.isArray(task.subTasks) || task.subTasks.length === 0) return null;
    const details = document.createElement("div");
    details.className = "task-details hidden";
    const heading = document.createElement("h5");
    heading.textContent = "Subtasks";
    details.appendChild(heading);
    const list = document.createElement("ul");
    task.subTasks.forEach(sub => {
      const item = document.createElement("li");
      const marker = sub.completed ? "✓" : "•";
      item.textContent = `${marker} ${sub.name}`;
      list.appendChild(item);
    });
    details.appendChild(list);
    return details;
  }

  function getTaskCreatedTime(task) {
    if (!task) return 0;
    const createdValue = task.createdAt || task.addedAt || null;
    if (!createdValue) return 0;
    const createdDate = new Date(createdValue);
    const timestamp = createdDate.getTime();
    return Number.isFinite(timestamp) ? timestamp : 0;
  }

  function getTaskDueTimestamp(task) {
    if (!task) return Number.POSITIVE_INFINITY;
    if (task.dueDate) {
      const dueDate = new Date(`${task.dueDate}T00:00:00`);
      const dueTime = dueDate.getTime();
      if (Number.isFinite(dueTime)) return dueTime;
    }
    if (task.dateOfService) {
      const serviceDate = new Date(`${task.dateOfService}T00:00:00`);
      const serviceTime = serviceDate.getTime();
      if (Number.isFinite(serviceTime)) {
        serviceDate.setDate(serviceDate.getDate() + 3);
        const fallbackTime = serviceDate.getTime();
        if (Number.isFinite(fallbackTime)) return fallbackTime;
      }
    }
    return Number.POSITIVE_INFINITY;
  }

  function sortTasksByMode(list, mode) {
    const items = Array.isArray(list) ? [...list] : [];
    switch (mode) {
      case TASK_SORT_MODES.DATE_ADDED_DESC:
        return items.sort((a, b) => getTaskCreatedTime(b) - getTaskCreatedTime(a));
      case TASK_SORT_MODES.DATE_DUE_ASC:
        return items.sort((a, b) => {
          const aDue = getTaskDueTimestamp(a);
          const bDue = getTaskDueTimestamp(b);
          if (aDue === bDue) {
            return getTaskCreatedTime(b) - getTaskCreatedTime(a);
          }
          return aDue - bDue;
        });
      case TASK_SORT_MODES.PRIORITY:
      default:
        return items.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    }
  }

  function renderTaskListCard(task, mode, timeBudgetMinutes = null) {
    const card = document.createElement("article");
    card.className = "task-card";
    if (task?.id) {
      card.dataset.taskId = String(task.id);
    }
    if (mode === TASK_LIST_MODES.COMPLETED) {
      card.classList.add("is-completed");
    }
    if (mode === TASK_LIST_MODES.ACTIVE && task?.id) {
      attachTaskGestureHandlers(card, task.id, mode);
    }

    const header = document.createElement("div");
    header.className = "task-card-header";

    const titleGroup = document.createElement("div");
    titleGroup.className = "task-card-title-group";

    const title = document.createElement("h4");
    title.className = "task-title";
    title.textContent = task.name;
    titleGroup.appendChild(title);

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const indicator = document.createElement("span");
      indicator.className = "task-complete-indicator";
      indicator.textContent = "✓ Completed";
      titleGroup.appendChild(indicator);
    }

    header.appendChild(titleGroup);

    const actions = document.createElement("div");
    actions.className = "task-card-actions";

    if (mode === TASK_LIST_MODES.ACTIVE) {
      const startNowBtn = document.createElement("button");
      startNowBtn.type = "button";
      startNowBtn.textContent = "🚀";
      startNowBtn.title = "Focus on this task";
      startNowBtn.setAttribute("aria-label", "Start task");
      startNowBtn.onclick = () => startFocus(task.id);
      actions.appendChild(startNowBtn);

      const completeBtn = document.createElement("button");
      completeBtn.type = "button";
      completeBtn.textContent = "✅";
      completeBtn.title = "Complete task";
      completeBtn.setAttribute("aria-label", "Complete task");
      completeBtn.onclick = () => markTaskDoneFromPeek(task.id);
      actions.appendChild(completeBtn);

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "✏️";
      editBtn.title = "Edit task";
      editBtn.onclick = () => startEditTask(task.id);
      actions.appendChild(editBtn);
    }

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.textContent = "🗑️";
    deleteBtn.title = "Delete task";
    deleteBtn.onclick = () => {
      if (!confirm("Delete this task?")) return;
      const idx = tasks.findIndex(t => t.id === task.id);
      if (idx !== -1) {
        if (editingTaskId === task.id) {
          cancelEdit();
        }
        tasks.splice(idx, 1);
        persist();
        updateUI();
      }
    };
    if (mode === TASK_LIST_MODES.COMPLETED) {
      const restoreBtn = document.createElement("button");
      restoreBtn.type = "button";
      restoreBtn.textContent = "♻️";
      restoreBtn.title = "Move back to active tasks";
      restoreBtn.setAttribute("aria-label", "Restore task to active list");
      restoreBtn.onclick = () => restoreTaskById(task.id);
      actions.appendChild(restoreBtn);
    }
    actions.appendChild(deleteBtn);

    card.appendChild(header);
    card.appendChild(actions);

    const descriptors = buildTaskDescriptors(task);
    if (descriptors.length) {
      const descriptorContainer = document.createElement("div");
      descriptorContainer.className = "task-descriptors";
      descriptors.forEach(text => {
        const span = document.createElement("span");
        span.textContent = text;
        descriptorContainer.appendChild(span);
      });
      card.appendChild(descriptorContainer);
    }

    if (task.firstThreeMode && !task.firstThreeUnlocked && mode === TASK_LIST_MODES.ACTIVE) {
      const nudge = document.createElement("div");
      nudge.className = "score";
      nudge.textContent = "Start with the first three micro-steps to unlock the rest.";
      card.appendChild(nudge);
    }

    const progress = createProgressElement(task);
    if (progress) {
      card.appendChild(progress);
    }

    const meta = document.createElement("div");
    meta.className = "task-meta";
    const metaItems = [];

    if (mode === TASK_LIST_MODES.ACTIVE) {
      metaItems.push(`Score ${task.priority.toFixed(1)}`);
      if (Number.isFinite(timeBudgetMinutes) && timeBudgetMinutes > 0) {
        const estimatedMinutes = estimateTaskMinutes(task);
        metaItems.push(`Est ${estimatedMinutes} min`);
      }
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
      if (task.addedAt) {
        const formatted = formatDateTime(task.addedAt);
        if (formatted) metaItems.push(`Added ${formatted}`);
      }
      const age = task.dateOfService ? calculateDaysSince(task.dateOfService) : (
        task.daysSinceVisit === null || task.daysSinceVisit === undefined || task.daysSinceVisit === ""
          ? null
          : Number(task.daysSinceVisit)
      );
      if (age !== null && Number.isFinite(age)) {
        const ageLabel = age < 0 ? `${Math.abs(age)} day(s) until visit` : `${age} day(s) since visit`;
        metaItems.push(ageLabel);
      }
      if (isChartTask(task) && Number.isFinite(Number(task.chartDurationMinutes)) && Number(task.chartDurationMinutes) > 0) {
        metaItems.push(`Chart time ${formatDuration(Number(task.chartDurationMinutes))}`);
      }
    } else {
      const completedAt = formatDateTime(getCompletionTimestamp(task));
      metaItems.push(`Completed ${completedAt || "--"}`);
      const totalDuration = getTaskTotalDuration(task);
      metaItems.push(`Duration ${formatDuration(totalDuration)}`);
      if (task.dueDate) metaItems.push(`Due ${task.dueDate}`);
    }

    metaItems.forEach(text => meta.appendChild(createMetaItem(text)));
    if (metaItems.length) {
      card.appendChild(meta);
    }

    if (mode === TASK_LIST_MODES.COMPLETED) {
      const details = createTaskDetails(task);
      if (details) {
        const toggle = document.createElement("button");
        toggle.className = "task-detail-toggle";
        toggle.textContent = "View details";
        toggle.onclick = () => {
          const isHidden = details.classList.contains("hidden");
          if (isHidden) {
            details.classList.remove("hidden");
            toggle.textContent = "Hide details";
          } else {
            details.classList.add("hidden");
            toggle.textContent = "View details";
          }
        };
        card.appendChild(toggle);
        card.appendChild(details);
      }
    }

    return card;
  }

  function computeFocusScore(task, energyLevel, timeBudget) {
    if (!task) return 0;
    const base = Number(task?.priority || 0);
    if (!Number.isFinite(base) || base <= 0) {
      return base || 0;
    }
    const energyWeight = computeEnergyFit(task, energyLevel);
    const timeWeight = computeTimeFit(task, timeBudget);
    return base * energyWeight * timeWeight;
  }

  function buildNextTaskInsights(task, energyLevel, timeBudget) {
    const insights = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(estimated) && estimated > 0) {
      insights.push(`Est. ${Math.max(1, Math.round(estimated))} min`);
    }
    if (Number.isFinite(timeBudget)) {
      const timeScore = timeFit(task, timeBudget);
      if (!Number.isFinite(estimated) || estimated <= 0) {
        insights.push(`${timeBudget}-min window`);
      } else if (timeScore > 1) {
        insights.push(`Fits ${timeBudget}-min`);
      } else if (estimated > timeBudget) {
        insights.push(`Stretch past ${timeBudget} min`);
      }
    }
    const energyScore = energyFit(task, energyLevel);
    if (energyScore < 1) {
      insights.push('Easy win');
    } else if (Number.isFinite(energyLevel) && ENERGY_LABELS && ENERGY_LABELS[energyLevel]) {
      insights.push(`Energy: ${ENERGY_LABELS[energyLevel]}`);
    }
    if (isChartTask(task) && Number.isFinite(Number(task.daysSinceVisit)) && Number(task.daysSinceVisit) > 0) {
      insights.push(`${task.daysSinceVisit}d since visit`);
    }
    if (task.category) {
      insights.push(task.category);
    }
    return insights.filter(Boolean).slice(0, 3);
  }

  function updateNextTaskCard() {
    const card = $("nextTaskCard");
    if (!card) return;
    const nameEl = $("nextTaskName");
    const substepEl = $("nextTaskSubstep");
    const chipsEl = $("nextTaskChips");
    const scoreEl = $("nextTaskScore");
    const emptyEl = $("nextTaskEmpty");
    const startActionBtn = $("nextTaskActionButton");

    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();

    const candidates = tasks
      .filter(task => !isTaskCompleted(task) && (activeCategory === "All" || task.category === activeCategory))
      .sort((a, b) => computeFocusScore(b, energyLevel, timeBudget) - computeFocusScore(a, energyLevel, timeBudget));

    const topTask = candidates[0] || null;
    nextTaskId = topTask ? topTask.id : null;

    card.classList.remove("hidden");
    if (!topTask) {
      if (nameEl) nameEl.textContent = "";
      if (substepEl) substepEl.textContent = "";
      if (chipsEl) chipsEl.innerHTML = "";
      if (scoreEl) {
        scoreEl.textContent = "";
        scoreEl.classList.add("hidden");
      }
      if (emptyEl) emptyEl.classList.remove("hidden");
      if (startActionBtn) startActionBtn.disabled = true;
      return;
    }

    if (emptyEl) emptyEl.classList.add("hidden");
    if (nameEl) nameEl.textContent = topTask.name;
    const firstSub = Array.isArray(topTask.subTasks)
      ? topTask.subTasks.find(sub => !sub.completed)
      : null;
    if (substepEl) {
      substepEl.textContent = firstSub
        ? `Next substep: ${firstSub.name}`
        : "Set your first micro-step.";
    }
    if (chipsEl) {
      chipsEl.innerHTML = "";
      buildNextTaskInsights(topTask, energyLevel, timeBudget).forEach(text => {
        const chip = document.createElement("span");
        chip.className = "chip";
        chip.textContent = text;
        chipsEl.appendChild(chip);
      });
    }
    if (scoreEl) {
      scoreEl.innerHTML = "";
      const scoreText = document.createElement("span");
      const rawScore = Number(topTask.priority);
      const displayScore = Number.isFinite(rawScore) ? Math.round(rawScore) : 0;
      scoreText.textContent = `Fit ${displayScore}`;
      const info = document.createElement("span");
      info.className = "next-task-fit__info";
      info.textContent = "i";
      info.title = "Just a nudge, not a grade.";
      info.setAttribute("aria-label", "Just a nudge, not a grade.");
      scoreEl.appendChild(scoreText);
      scoreEl.appendChild(info);
      const srOnly = document.createElement("span");
      srOnly.className = "visually-hidden";
      srOnly.textContent = "Fit guidance. Just a nudge, not a grade.";
      scoreEl.appendChild(srOnly);
      scoreEl.classList.remove("hidden");
    }
    if (startActionBtn) startActionBtn.disabled = false;
  }

  const DEFAULT_NEXT_BEST_INPUTS = {
    time: 15,
    energy: 3,
    deadline: 3,
    size: "any",
    frictions: []
  };
  const DEFAULT_PREFLIGHT_TOGGLES = {
    focusMusic: false,
    dnd: false,
    timer: false
  };

  function loadPreflightToggles() {
    try {
      const stored = JSON.parse(localStorage.getItem(PREFLIGHT_TOGGLES_KEY) || "null");
      if (stored && typeof stored === "object") {
        return { ...DEFAULT_PREFLIGHT_TOGGLES, ...stored };
      }
    } catch (error) {
      console.warn("Unable to load pre-flight toggles", error);
    }
    return { ...DEFAULT_PREFLIGHT_TOGGLES };
  }

  function savePreflightToggles(state) {
    try {
      localStorage.setItem(PREFLIGHT_TOGGLES_KEY, JSON.stringify(state));
    } catch (error) {
      console.warn("Unable to save pre-flight toggles", error);
    }
  }

  function initializePreflightToggles() {
    const buttons = document.querySelectorAll('[data-preflight-toggle]');
    if (!buttons.length) return;
    const state = loadPreflightToggles();
    buttons.forEach(button => {
      const key = button.getAttribute("data-preflight-toggle");
      if (!key) return;
      const active = Boolean(state[key]);
      button.classList.toggle("is-active", active);
      button.setAttribute("aria-pressed", active ? "true" : "false");
      button.addEventListener("click", () => {
        const next = !button.classList.contains("is-active");
        state[key] = next;
        button.classList.toggle("is-active", next);
        button.setAttribute("aria-pressed", next ? "true" : "false");
        savePreflightToggles(state);
      });
    });
  }

  function clampMmpMinutes(value) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric <= 0) return MMP_MIN_MINUTES;
    return Math.max(MMP_MIN_MINUTES, Math.min(MMP_MAX_MINUTES, Math.round(numeric)));
  }

  function loadNextBestInputs() {
    try {
      const stored = JSON.parse(localStorage.getItem(NEXT_BEST_STORAGE_KEY) || "null");
      if (stored && typeof stored === "object") {
        const frictions = Array.isArray(stored.frictions)
          ? Array.from(new Set(stored.frictions.map(String)))
          : [];
        return {
          ...DEFAULT_NEXT_BEST_INPUTS,
          ...stored,
          time: Number(stored.time) || DEFAULT_NEXT_BEST_INPUTS.time,
          energy: clampScale(stored.energy, DEFAULT_NEXT_BEST_INPUTS.energy),
          deadline: clampScale(stored.deadline, DEFAULT_NEXT_BEST_INPUTS.deadline),
          size: stored.size || DEFAULT_NEXT_BEST_INPUTS.size,
          frictions
        };
      }
    } catch (error) {
      console.warn("Unable to load Next Best inputs", error);
    }
    return { ...DEFAULT_NEXT_BEST_INPUTS };
  }

  function saveNextBestInputs(inputs) {
    try {
      localStorage.setItem(NEXT_BEST_STORAGE_KEY, JSON.stringify(inputs));
    } catch (error) {
      console.warn("Unable to save Next Best inputs", error);
    }
  }

  function applyNextBestInputs(inputs) {
    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.value = String(inputs.time);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.value = String(inputs.energy);
      energySlider.setAttribute("data-value", String(inputs.energy));
    }
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect) {
      deadlineSelect.value = String(inputs.deadline);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.value = inputs.size || "any";
    }
    const checkboxes = document.querySelectorAll('input[name="nextBestFriction"]');
    checkboxes.forEach(box => {
      box.checked = inputs.frictions.includes(box.value);
    });
    alignEnergySliders(inputs.energy, "next");
  }

  function getSelectedFrictionTags() {
    return Array.from(document.querySelectorAll('input[name="nextBestFriction"]:checked'))
      .map(input => input.value)
      .filter(Boolean);
  }

  function getNextBestInputs() {
    const defaults = loadNextBestInputs();
    const timeSelect = $("nextBestTime");
    const energySlider = $("nextBestEnergy");
    const deadlineSelect = $("nextBestDeadline");
    const sizeSelect = $("nextBestSize");
    const timeValue = Number(timeSelect?.value || defaults.time);
    const energyValue = Number(energySlider?.value || defaults.energy);
    const deadlineValue = Number(deadlineSelect?.value || defaults.deadline);
    const frictions = getSelectedFrictionTags();
    const resolvedEnergy = alignEnergySliders(energyValue, "next");
    return {
      time: Number.isFinite(timeValue) && timeValue > 0 ? timeValue : defaults.time,
      energy: resolvedEnergy,
      deadline: clampScale(deadlineValue, defaults.deadline),
      size: sizeSelect?.value || defaults.size,
      frictions
    };
  }

  function estimateSubTaskMinutes(task, sub) {
    if (!sub) return null;
    const recorded = Number(sub.durationMinutes);
    if (Number.isFinite(recorded) && recorded > 0) {
      return clampMmpMinutes(recorded);
    }
    const total = estimateTaskMinutes(task);
    const remainingCount = Array.isArray(task.subTasks) && task.subTasks.length
      ? task.subTasks.filter(step => !step.completed).length || 1
      : 1;
    const approx = Number.isFinite(total)
      ? Math.max(6, total / Math.max(1, remainingCount))
      : 15;
    return clampMmpMinutes(approx);
  }

  function deriveMmpChunk(task) {
    if (!task) return null;
    const remainingSubs = Array.isArray(task.subTasks)
      ? task.subTasks.filter(sub => !sub.completed)
      : [];
    if (remainingSubs.length) {
      const prioritized = remainingSubs.map(sub => ({ sub, minutes: estimateSubTaskMinutes(task, sub) }));
      const candidate = prioritized.find(entry => entry.minutes <= MMP_MAX_MINUTES) || prioritized[0];
      if (candidate) {
        return {
          label: candidate.sub.name,
          minutes: clampMmpMinutes(candidate.minutes),
          subId: candidate.sub.id || null
        };
      }
    }
    const fallback = estimateTaskMinutes(task);
    const sprint = Number.isFinite(fallback) ? Math.max(fallback * 0.5, MMP_MIN_MINUTES) : MMP_MIN_MINUTES;
    const minutes = clampMmpMinutes(sprint);
    return {
      label: `First ${minutes} minutes on ${task.name}`,
      minutes,
      subId: null
    };
  }

  function isEasyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    return difficulty <= 3 && evaluation.chunk.minutes <= 15;
  }

  function isBuddyNextBest(evaluation) {
    if (!evaluation) return false;
    const difficulty = Number(evaluation.task?.difficulty || 3);
    const category = evaluation.task?.category || "";
    return difficulty >= 4 || evaluation.chunk.minutes >= 18 || ["Calls", "Teaching"].includes(category);
  }

  function evaluateTaskForNextBest(task, inputs) {
    if (!task || isTaskCompleted(task)) return null;
    const chunk = deriveMmpChunk(task);
    if (!chunk) return null;
    const timeBudget = Number.isFinite(inputs.time) ? inputs.time : Infinity;
    const energyLevel = clampScale(inputs.energy, 3);
    let score = computeFocusScore(task, energyLevel, timeBudget);
    if (!Number.isFinite(score)) score = 0;
    (inputs.frictions || []).forEach(tag => {
      const rule = NEXT_BEST_FRICTION_RULES[tag];
      if (typeof rule === "function") {
        score *= rule(task) ? 1.08 : 0.78;
      }
    });
    const deadlineLevel = clampScale(inputs.deadline, 3);
    if (deadlineLevel !== 3) {
      const daysUntil = task.dueDate ? calculateDaysUntil(task.dueDate) : null;
      const overdue = Number.isFinite(daysUntil) && daysUntil < 0;
      const dueSoon = Number.isFinite(daysUntil) && daysUntil >= 0 && daysUntil <= 2;
      const daysSince = Number(task.daysSinceVisit);
      if (deadlineLevel > 3) {
        const boost = 1 + (deadlineLevel - 3) * 0.12;
        if (overdue || dueSoon || (Number.isFinite(daysSince) && daysSince >= 5)) {
          score *= boost;
        } else {
          score *= 1 + (deadlineLevel - 3) * 0.05;
        }
      } else {
        score *= Math.max(0.6, 1 - (3 - deadlineLevel) * 0.06);
      }
    }
    const estimate = estimateTaskMinutes(task);
    const effectiveEstimate = Number.isFinite(estimate) && estimate > 0 ? estimate : chunk.minutes;
    if (inputs.size === "small") {
      score *= effectiveEstimate <= 20 ? 1.1 : 0.82;
    } else if (inputs.size === "medium") {
      score *= effectiveEstimate >= 15 && effectiveEstimate <= 40 ? 1.08 : 0.88;
    } else if (inputs.size === "large") {
      score *= effectiveEstimate >= 30 ? 1.12 : 0.85;
    }
    const impact = Number(task.priority || 0);
    const impactPerMinute = chunk.minutes > 0 ? impact / chunk.minutes : impact;
    const insights = buildNextTaskInsights(task, energyLevel, timeBudget);
    return {
      task,
      score,
      chunk,
      impactPerMinute,
      estimate: effectiveEstimate,
      insights
    };
  }

  function launchNextBestOption(label, evaluation) {
    if (!evaluation || !evaluation.task) return;
    const minutes = Number.isFinite(evaluation.chunk?.minutes)
      ? evaluation.chunk.minutes
      : MMP_MIN_MINUTES;
    showToast("Next Best Thing", `${label}: ${evaluation.chunk?.label || evaluation.task.name}`);
    startFocus(evaluation.task.id, { sprintMinutes: minutes });
  }

  function setActivationSuggestion(evaluation) {
    const suggestionBtn = $("focusSuggestionButton");
    const detailEl = $("focusSuggestionDetail");
    const previewEl = $("focusSuggestionText");
    const heroHint = $("focusLaunchHint");
    if (!suggestionBtn || !detailEl || !previewEl || !heroHint) return;
    const hasActiveTasks = tasks.some(task => !isTaskCompleted(task));
    if (evaluation && evaluation.task) {
      const message = evaluation.chunk?.label || evaluation.task.name;
      detailEl.textContent = message;
      previewEl.textContent = message;
      heroHint.textContent = message;
      suggestionBtn.disabled = false;
      suggestionBtn.setAttribute("aria-disabled", "false");
      suggestionBtn.dataset.pickKey = "now";
      suggestionBtn.dataset.taskId = evaluation.task.id || "";
    } else {
      const fallback = hasActiveTasks
        ? "Refresh Next Best to see a top pick."
        : "Add a task to unlock focus.";
      detailEl.textContent = fallback;
      previewEl.textContent = fallback;
      heroHint.textContent = fallback;
      suggestionBtn.disabled = true;
      suggestionBtn.setAttribute("aria-disabled", "true");
      delete suggestionBtn.dataset.pickKey;
      delete suggestionBtn.dataset.taskId;
    }
  }

  function createNextBestCard(config) {
    const { label, payoff, cta, evaluation, inputs } = config;
    if (!evaluation) return null;

    const energyValue = Number(inputs?.energy) || DEFAULT_NEXT_BEST_INPUTS.energy;
    const energyLabelRaw = ENERGY_LABELS && ENERGY_LABELS[energyValue] ? ENERGY_LABELS[energyValue] : "Current";
    const energyLabel = typeof energyLabelRaw === "string" ? energyLabelRaw : String(energyLabelRaw);
    const energyMode = energyValue <= 2 ? "low" : energyValue >= 4 ? "high" : "steady";
    const minutesWindow = Number.isFinite(inputs?.time) ? `${inputs.time}m` : `${Math.max(5, evaluation.chunk?.minutes || DEFAULT_NEXT_BEST_INPUTS.time)}m`;

    const card = document.createElement("article");
    card.className = "next-best-option";
    card.dataset.energyMode = energyMode;

    const ring = document.createElement("div");
    ring.className = "next-best-ring";
    const ringLabel = document.createElement("span");
    ringLabel.textContent = "Primed";
    ring.appendChild(ringLabel);
    card.appendChild(ring);

    const labelEl = document.createElement("span");
    labelEl.className = "next-best-option__label";
    labelEl.textContent = label;
    card.appendChild(labelEl);

    const heading = document.createElement("h3");
    heading.className = "next-best-option__title";
    heading.textContent = evaluation.task.name;
    card.appendChild(heading);

    if (payoff) {
      const payoffLine = document.createElement("p");
      payoffLine.className = "next-best-option__payoff";
      payoffLine.textContent = `${payoff} for ${minutesWindow} + ${energyLabel.toLowerCase()} energy`;
      card.appendChild(payoffLine);
    }

    const chips = document.createElement("div");
    chips.className = "next-best-option__chips";

    const addChip = text => {
      if (!text) return;
      const chip = document.createElement("span");
      chip.className = "chip spec-chip";
      chip.textContent = text;
      chips.appendChild(chip);
    };

    const estimatedMinutes = Math.max(1, Math.round(evaluation.estimate || evaluation.chunk?.minutes || inputs?.time || DEFAULT_NEXT_BEST_INPUTS.time));
    addChip(`Est. time • ${estimatedMinutes}m`);
    if (evaluation.chunk?.label) {
      addChip(`Stretch • ${evaluation.chunk.label}`);
    }
    addChip(`Energy • ${energyLabel}`);

    if (chips.childElementCount) {
      card.appendChild(chips);
    }

    const meter = document.createElement("div");
    meter.className = "next-best-meter";
    const meterLabel = document.createElement("div");
    meterLabel.className = "next-best-meter__label";
    meterLabel.textContent = "Impact/min";
    meter.appendChild(meterLabel);

    const track = document.createElement("div");
    track.className = "next-best-meter__track";
    const bar = document.createElement("div");
    bar.className = "next-best-meter__bar";
    const normalizedImpact = Number.isFinite(evaluation.impactPerMinute)
      ? Math.max(4, Math.min(100, (evaluation.impactPerMinute / 10) * 100))
      : 4;
    bar.style.width = `${normalizedImpact}%`;
    track.appendChild(bar);
    meter.appendChild(track);

    const scale = document.createElement("div");
    scale.className = "next-best-meter__scale";
    const startTick = document.createElement("span");
    startTick.textContent = "0";
    const endTick = document.createElement("span");
    endTick.textContent = "≥10";
    scale.appendChild(startTick);
    scale.appendChild(endTick);
    meter.appendChild(scale);
    card.appendChild(meter);

    const button = document.createElement("button");
    button.type = "button";
    button.className = `btn next-best-cta next-best-cta--${energyMode}`;
    button.textContent = cta || "Start";
    button.addEventListener("click", () => launchNextBestOption(label, evaluation));
    card.appendChild(button);

    return card;
  }

  function handleNextBestRefresh(event) {
    if (event) event.preventDefault();
    const button = event?.currentTarget || $("nextBestRefresh");
    if (button) {
      button.classList.add("is-loading");
      button.disabled = true;
    }
    try {
      updateNextBestOptions({ force: true });
    } finally {
      if (button) {
        window.setTimeout(() => {
          button.classList.remove("is-loading");
          button.disabled = false;
        }, 320);
      }
    }
  }

  function updateNextBestOptions(options = {}) {
    const forceUpdate = Boolean(options.force);
    const results = $("nextBestResults");
    const empty = $("nextBestEmpty");
    if (!results || !empty) return;

    if (!forceUpdate && !isElementMostlyInView(results, 0.25)) {
      nextBestUpdatePending = true;
      return;
    }

    nextBestUpdatePending = false;
    setActivationSuggestion(null);
    const inputs = getNextBestInputs();
    saveNextBestInputs(inputs);

    results.innerHTML = "";
    empty.classList.add("hidden");
    latestNextBestPicks = {};

    const candidates = tasks.filter(task => !isTaskCompleted(task));
    if (!candidates.length) {
      empty.textContent = "Add a task to see your next best options.";
      empty.classList.remove("hidden");
      return;
    }

    const evaluations = candidates
      .map(task => evaluateTaskForNextBest(task, inputs))
      .filter(Boolean)
      .sort((a, b) => b.score - a.score);

    if (!evaluations.length) {
      empty.textContent = "No tasks match this window. Adjust your filters.";
      empty.classList.remove("hidden");
      return;
    }

    const used = new Set();
    const picks = {};
    const assignCandidate = (key, predicate = null) => {
      const match = evaluations.find(entry => !used.has(entry.task.id) && (!predicate || predicate(entry)));
      if (match) {
        used.add(match.task.id);
        picks[key] = match;
      }
    };

    assignCandidate("now");
    assignCandidate("easy", isEasyNextBest);
    assignCandidate("buddy", isBuddyNextBest);

    ["easy", "buddy"].forEach(key => {
      if (!picks[key]) {
        const fallback = evaluations.find(entry => !used.has(entry.task.id));
        if (fallback) {
          used.add(fallback.task.id);
          picks[key] = fallback;
        }
      }
    });

    const configs = [
      { key: "now", label: "Do now", payoff: "Highest ROI", cta: "Start" },
      { key: "easy", label: "Do if easy", payoff: "Low friction win", cta: "Start easy" },
      { key: "buddy", label: "Do with buddy", payoff: "Accountability boost", cta: "Start with buddy" }
    ];

    setActivationSuggestion(picks.now || null);

    configs.forEach(config => {
      const evaluation = picks[config.key];
      if (evaluation) {
        const card = createNextBestCard({ ...config, evaluation, inputs });
        if (card) results.appendChild(card);
      }
    });
    latestNextBestPicks = { ...picks };
  }

  function initializeNextBestEngine() {
    const results = $("nextBestResults");
    if (!results) return;
    const storedRaw = localStorage.getItem(NEXT_BEST_STORAGE_KEY);
    const deadlineSelect = $("nextBestDeadline");
    if (deadlineSelect && deadlineSelect.options.length === 0) {
      for (let i = 1; i <= 5; i += 1) {
        const option = document.createElement("option");
        option.value = String(i);
        option.textContent = String(i);
        deadlineSelect.appendChild(option);
      }
    }
    const stored = loadNextBestInputs();
    applyNextBestInputs(stored);

    const controlsPanel = $("nextBestControls");
    const adjustToggle = $("nextBestAdjustToggle");
    const stuckBtn = $("nextBestStuck");
    const setControlsOpen = open => {
      if (!controlsPanel || !adjustToggle) return;
      controlsPanel.hidden = !open;
      controlsPanel.setAttribute("aria-hidden", open ? "false" : "true");
      adjustToggle.setAttribute("aria-expanded", open ? "true" : "false");
      adjustToggle.classList.toggle("is-active", open);
    };
    if (controlsPanel) {
      setControlsOpen(!storedRaw);
    }
    if (adjustToggle) {
      adjustToggle.addEventListener("click", () => {
        const nextOpen = controlsPanel ? controlsPanel.hidden : false;
        setControlsOpen(nextOpen);
      });
    }
    if (stuckBtn) {
      stuckBtn.addEventListener("click", () => {
        setControlsOpen(true);
        const firstFriction = controlsPanel?.querySelector('input[name="nextBestFriction"]');
        if (firstFriction) {
          firstFriction.focus();
        }
      });
    }

    const timeSelect = $("nextBestTime");
    if (timeSelect) {
      timeSelect.addEventListener("change", updateNextBestOptions);
    }
    const energySlider = $("nextBestEnergy");
    if (energySlider) {
      energySlider.addEventListener("input", event => {
        const value = Number(event.target.value || stored.energy);
        alignEnergySliders(value, "next");
        updateNextBestOptions();
      });
    }
    if (deadlineSelect) {
      deadlineSelect.addEventListener("change", updateNextBestOptions);
    }
    const sizeSelect = $("nextBestSize");
    if (sizeSelect) {
      sizeSelect.addEventListener("change", updateNextBestOptions);
    }
    const frictionBoxes = document.querySelectorAll('input[name="nextBestFriction"]');
    frictionBoxes.forEach(box => {
      box.addEventListener("change", updateNextBestOptions);
    });
    const refreshBtn = $("nextBestRefresh");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", handleNextBestRefresh);
    }
    updateNextBestOptions();
  }

  function prepareAccordionContainers() {
    const counters = {};
    document.querySelectorAll('[data-accordion]').forEach(container => {
      const name = container.dataset.accordion || "accordion";
      const index = counters[name] || 0;
      counters[name] = index + 1;
      const summary = container.querySelector('[data-accordion-summary]');
      const panel = container.querySelector('[data-accordion-panel]');
      if (!summary || !panel) return;
      const suffix = index === 0 ? "" : `-${index}`;
      const panelId = `${name}Panel${suffix}`;
      panel.id = panelId;
      summary.setAttribute("aria-controls", panelId);
    });
  }

  function getDueTodaySections() {
    return Array.from(document.querySelectorAll('[data-due-today-section]'))
      .map(section => {
        const accordion = section.querySelector('[data-accordion="dueToday"]');
        const summaryBtn = accordion?.querySelector('[data-accordion-summary]');
        const summaryText = accordion?.querySelector('[data-due-today-summary-text]');
        const listEl = section.querySelector('[data-due-today-list]');
        const emptyEl = section.querySelector('[data-due-today-empty]');
        return { section, accordion, summaryBtn, summaryText, listEl, emptyEl };
      })
      .filter(instance => instance.section && instance.accordion && instance.summaryBtn && instance.summaryText && instance.listEl && instance.emptyEl);
  }

  function initializeDueTodayAccordionState() {
    const sections = getDueTodaySections();
    if (!sections.length) return;

    sections.forEach(({ accordion, summaryBtn, listEl }) => {
      if (!accordion || !summaryBtn || !listEl) return;

      // Set initial state to CLOSED
      accordion.dataset.open = "false";
      summaryBtn.setAttribute("aria-expanded", "false");
      listEl.hidden = true;

      // Attach click listener once during initialization
      if (!summaryBtn.dataset.listenerBound) {
        summaryBtn.dataset.listenerBound = "true";
        summaryBtn.addEventListener("click", () => {
          const nextOpen = accordion.dataset.open !== "true";
          setDueTodayAccordionOpen(nextOpen, { highlight: nextOpen, source: accordion });
        });
      }
    });
  }

  function createDueTodayItem(entry) {
    const item = document.createElement("div");
    item.className = "due-today-item";

    const title = document.createElement("p");
    title.className = "due-today-title";
    title.textContent = entry.task.name;
    item.appendChild(title);

    const meta = document.createElement("div");
    meta.className = "due-today-meta";
    const metaBits = ["Due today"];
    if (entry.fallback && entry.task.dateOfService) {
      metaBits.push(`Visit ${entry.task.dateOfService}`);
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" • ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }
    if (isChartTask(entry.task)
      && Number.isFinite(Number(entry.task.chartDurationMinutes))
      && Number(entry.task.chartDurationMinutes) > 0) {
      metaBits.push(`Chart ${formatDuration(Number(entry.task.chartDurationMinutes))}`);
    }
    meta.textContent = metaBits.join(" • ");
    item.appendChild(meta);

    if (entry.task.subTasks && entry.task.subTasks.length) {
      const progressElement = createProgressElement(entry.task);
      if (progressElement) {
        item.appendChild(progressElement);
      }
    }

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready • est —";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    const pillRow = document.createElement("div");
    pillRow.className = "due-today-pills";
    const sprintBtn = document.createElement("button");
    sprintBtn.className = "pill pill-primary";
    sprintBtn.type = "button";
    sprintBtn.textContent = "Start 5m";
    sprintBtn.addEventListener("click", () => startFiveMinuteSprint(entry.task.id));
    pillRow.appendChild(sprintBtn);

    const fullBtn = document.createElement("button");
    fullBtn.className = "pill";
    fullBtn.type = "button";
    fullBtn.textContent = "Start full";
    fullBtn.addEventListener("click", () => startFocus(entry.task.id));
    pillRow.appendChild(fullBtn);

    item.appendChild(pillRow);
    return item;
  }

  function renderDueTodayList(entries) {
    const instances = getDueTodaySections();
    if (!instances.length) return;

    instances.forEach(({ section, accordion, summaryBtn, summaryText, listEl, emptyEl }) => {
      listEl.innerHTML = "";
      if (!entries.length) {
        section.classList.add("hidden");
        emptyEl.classList.remove("hidden");
        accordion.classList.add("hidden");
        accordion.dataset.open = "false";
        summaryBtn.setAttribute("aria-expanded", "false");
        summaryText.textContent = "0 ready • est —";
        listEl.hidden = true;
      } else {
        section.classList.remove("hidden");
        emptyEl.classList.add("hidden");
        accordion.classList.remove("hidden");
      }
    });

    if (!entries.length) {
      return;
    }

    const readyLabel = entries.length === 1 ? "1 ready" : `${entries.length} ready`;
    const estimatedMinutes = entries.reduce((sum, entry) => {
      const minutes = estimateTaskMinutes(entry.task);
      return Number.isFinite(minutes) ? sum + minutes : sum;
    }, 0);
    const hasEstimate = Number.isFinite(estimatedMinutes) && estimatedMinutes > 0;
    const estimateText = hasEstimate ? `est ${Math.max(1, Math.round(estimatedMinutes))} min` : "est —";

    instances.forEach(({ accordion, summaryBtn, summaryText, listEl }) => {
      summaryText.textContent = `${readyLabel} • ${estimateText}`;
      entries.forEach(entry => {
        listEl.appendChild(createDueTodayItem(entry));
      });
      const isOpen = accordion.dataset.open === "true";
      summaryBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
      listEl.hidden = !isOpen;
    });
  }

  function setDueTodayAccordionOpen(open, options = {}) {
    const { highlight = true, focusSummary = false, skipSync = false, source = null } = options;
    const instances = getDueTodaySections();
    if (!instances.length) return;
    instances.forEach(({ accordion, summaryBtn, listEl, section }) => {
      const nextState = open ? "true" : "false";
      accordion.dataset.open = nextState;
      summaryBtn.setAttribute("aria-expanded", open ? "true" : "false");
      listEl.hidden = !open;
      if (open && highlight !== false && (!source || source === section || source === accordion)) {
        window.requestAnimationFrame(() => {
          const firstCard = listEl.querySelector(".due-today-item");
          if (firstCard) {
            firstCard.classList.add("due-today-item--spotlight");
            window.setTimeout(() => firstCard.classList.remove("due-today-item--spotlight"), 900);
          }
        });
      }
      if (open && focusSummary && (!source || source === section || source === accordion)) {
        summaryBtn.focus();
      }
    });
    if (open && !skipSync) {
      setAllTasksAccordionOpen(false, { skipSync: true });
    }
  }

  function computeWantScore(task) {
    const interest = Number(task?.interest || 3);
    const novelty = Number(task?.novelty || 3);
    const difficulty = Number(task?.difficulty || 3);
    const est = estimateTaskMinutes(task);
    const ease = Number.isFinite(est) && est <= 20 ? 1.15 : 0.95;
    return (interest + novelty) * ease - difficulty * 0.2;
  }

  function renderConflictList(candidates, container, type) {
    if (!container) return;
    container.innerHTML = "";
    if (!candidates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No tasks available.";
      container.appendChild(empty);
      return;
    }
    candidates.slice(0, 3).forEach(({ task, descriptor }) => {
      const item = document.createElement("div");
      item.className = "conflict-item";
      item.setAttribute("draggable", "true");
      item.setAttribute("role", "button");
      item.setAttribute("tabindex", "0");
      item.dataset.type = type;
      item.dataset.taskId = task.id;
      const title = document.createElement("strong");
      title.textContent = task.name;
      const meta = document.createElement("span");
      meta.textContent = descriptor;
      item.appendChild(title);
      item.appendChild(meta);
      item.addEventListener("dragstart", event => {
        if (!event.dataTransfer) return;
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", JSON.stringify({ type, taskId: task.id }));
      });
      item.addEventListener("click", () => setConflictSelection(type, task.id));
      item.addEventListener("keydown", event => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          setConflictSelection(type, task.id);
        }
      });
      container.appendChild(item);
    });
  }

  function getActiveTaskById(taskId) {
    return tasks.find(task => task.id === taskId && !isTaskCompleted(task));
  }

  function renderConflictArena() {
    const arena = $("conflictArena");
    if (!arena) return;
    arena.innerHTML = "";
    const selections = [];
    if (conflictArenaSelection.should) {
      selections.push({ label: "Should-do", task: conflictArenaSelection.should });
    }
    if (conflictArenaSelection.want) {
      selections.push({ label: "Want-to", task: conflictArenaSelection.want });
    }
    if (!selections.length) {
      const prompt = document.createElement("div");
      prompt.id = "conflictArenaPrompt";
      prompt.textContent = "Drag a contender from each side into the arena.";
      arena.appendChild(prompt);
      arena.classList.remove("is-ready");
      return;
    }
    selections.forEach(selection => {
      const slot = document.createElement("div");
      slot.className = "arena-slot";
      slot.textContent = `${selection.label}: ${selection.task.name}`;
      arena.appendChild(slot);
    });
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      arena.classList.add("is-ready");
    } else {
      arena.classList.remove("is-ready");
    }
  }

  function setConflictSelection(type, taskId) {
    const task = getActiveTaskById(taskId);
    if (!task) return;
    conflictArenaSelection = {
      ...conflictArenaSelection,
      [type]: task
    };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
    if (conflictArenaSelection.should && conflictArenaSelection.want) {
      evaluateConflictArena();
    }
  }

  function resetConflictArena() {
    conflictArenaSelection = { should: null, want: null };
    const result = $("conflictResult");
    if (result) result.textContent = "";
    renderConflictArena();
  }

  function handleConflictDrop(event) {
    event.preventDefault();
    if (!event.dataTransfer) return;
    try {
      const payload = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (payload?.type && payload?.taskId) {
        setConflictSelection(payload.type, payload.taskId);
      }
    } catch (error) {
      console.warn("Unable to parse dropped conflict item", error);
    }
  }

  function evaluateConflictArena() {
    const shouldTask = conflictArenaSelection.should;
    const wantTask = conflictArenaSelection.want;
    if (!shouldTask || !wantTask) return;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldChunk = deriveMmpChunk(shouldTask);
    const wantChunk = deriveMmpChunk(wantTask);
    const shouldScore = computeFocusScore(shouldTask, energy, timeBudget) * 0.6
      + (Number(shouldTask.importance) || 1) * 2
      + (shouldChunk.minutes <= 15 ? 1.1 : 1);
    const wantScore = computeFocusScore(wantTask, energy, timeBudget) * 0.45
      + (Number(wantTask.interest) || 3) + (Number(wantTask.novelty) || 3)
      + (wantChunk.minutes <= 15 ? 1.05 : 0.9);
    const recommended = shouldScore >= wantScore
      ? { task: shouldTask, chunk: shouldChunk, label: "Should-do" }
      : { task: wantTask, chunk: wantChunk, label: "Want-to" };
    const sprintMinutes = Number.isFinite(recommended.chunk?.minutes)
      ? recommended.chunk.minutes
      : CONFLICT_DEFAULT_SPRINT;
    showToast("Conflict resolved", `${recommended.label} wins: ${recommended.task.name}`);
    const result = $("conflictResult");
    if (result) {
      result.textContent = `${recommended.label} wins – ${sprintMinutes} minute sprint queued.`;
    }
    startFocus(recommended.task.id, { sprintMinutes });
    resetConflictArena();
    updateConflictResolver();
  }

  function updateConflictResolver() {
    const shouldList = $("conflictShouldList");
    const wantList = $("conflictWantList");
    if (!shouldList || !wantList) return;
    const activeTasks = tasks.filter(task => !isTaskCompleted(task));
    conflictArenaSelection.should = conflictArenaSelection.should
      ? getActiveTaskById(conflictArenaSelection.should.id)
      : null;
    conflictArenaSelection.want = conflictArenaSelection.want
      ? getActiveTaskById(conflictArenaSelection.want.id)
      : null;
    const energy = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const shouldCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Focus score ${computeFocusScore(task, energy, timeBudget).toFixed(1)}`
      }))
      .sort((a, b) => computeFocusScore(b.task, energy, timeBudget) - computeFocusScore(a.task, energy, timeBudget));
    const wantCandidates = activeTasks
      .map(task => ({
        task,
        descriptor: `Spark score ${computeWantScore(task).toFixed(1)}`
      }))
      .sort((a, b) => computeWantScore(b.task) - computeWantScore(a.task));
    renderConflictList(shouldCandidates, shouldList, "should");
    renderConflictList(wantCandidates, wantList, "want");
    renderConflictArena();
  }

  function initializeConflictResolverModule() {
    const module = $("conflictResolverModule");
    if (!module) return;
    const arena = $("conflictArena");
    if (arena) {
      arena.addEventListener("dragover", event => {
        event.preventDefault();
        arena.classList.add("is-ready");
      });
      arena.addEventListener("dragleave", () => {
        if (!conflictArenaSelection.should || !conflictArenaSelection.want) {
          arena.classList.remove("is-ready");
        }
      });
      arena.addEventListener("drop", handleConflictDrop);
    }
    const resetBtn = $("conflictReset");
    if (resetBtn) {
      resetBtn.addEventListener("click", resetConflictArena);
    }
    updateConflictResolver();
  }

  function getDefuseBaseMinutes() {
    const stored = Number(localStorage.getItem(DEFUSE_BASE_MINUTES_KEY));
    if (Number.isFinite(stored) && stored >= DEFUSE_MINUTES_MIN) {
      return Math.min(DEFUSE_MINUTES_MAX, Math.max(DEFUSE_MINUTES_MIN, Math.round(stored)));
    }
    return DEFUSE_MINUTES_MIN;
  }

  function setDefuseBaseMinutes(value) {
    const clamped = Math.max(DEFUSE_MINUTES_MIN, Math.min(DEFUSE_MINUTES_MAX, Math.round(value)));
    try {
      localStorage.setItem(DEFUSE_BASE_MINUTES_KEY, String(clamped));
    } catch (error) {
      console.warn("Unable to store DEFUSE base minutes", error);
    }
    defuseState.uptime = clamped;
    updateDefuseUptimeUI();
  }

  function getDefuseLocks() {
    try {
      const raw = JSON.parse(localStorage.getItem(DEFUSE_LOCKS_KEY) || "[]");
      return Array.isArray(raw) ? raw.map(String) : [];
    } catch (error) {
      console.warn("Unable to parse DEFUSE locks", error);
      return [];
    }
  }

  function saveDefuseLocks(values) {
    try {
      localStorage.setItem(DEFUSE_LOCKS_KEY, JSON.stringify(values));
    } catch (error) {
      console.warn("Unable to save DEFUSE locks", error);
    }
  }

  function loadDefuseAction() {
    try {
      const stored = localStorage.getItem(DEFUSE_ACTION_KEY);
      return stored || DEFAULT_DEFUSE_ACTION;
    } catch (error) {
      console.warn("Unable to load DEFUSE action", error);
      return DEFAULT_DEFUSE_ACTION;
    }
  }

  function saveDefuseAction(action) {
    try {
      if (!action) {
        localStorage.removeItem(DEFUSE_ACTION_KEY);
      } else {
        localStorage.setItem(DEFUSE_ACTION_KEY, action);
      }
    } catch (error) {
      console.warn("Unable to store DEFUSE action", error);
    }
  }

  function getSelectedDefuseLocks() {
    return Array.from(document.querySelectorAll('#defuseLocks input[type="checkbox"]:checked'))
      .map(box => box.value)
      .filter(Boolean);
  }

  function updateDefuseLocksUI() {
    const stored = getDefuseLocks();
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    boxes.forEach(box => {
      box.checked = stored.includes(box.value);
    });
  }

  function updateDefuseUptimeUI() {
    const base = defuseState.uptime || getDefuseBaseMinutes();
    const uptime = $("defuseUptime");
    if (uptime) {
      uptime.textContent = `Next sprint: ${base} minutes`;
    }
    const fill = $("defuseUptimeFill");
    if (fill) {
      const ratio = (base - DEFUSE_MINUTES_MIN) / (DEFUSE_MINUTES_MAX - DEFUSE_MINUTES_MIN);
      fill.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
  }

  function updateDefuseCountdownUI() {
    const countdownEl = $("defuseCountdown");
    if (countdownEl) {
      countdownEl.textContent = `${Math.max(0, defuseState.countdown)}s`;
    }
    const progress = $("defuseProgressFill");
    if (progress) {
      const ratio = defuseState.active ? (1 - defuseState.countdown / 90) : 0;
      progress.style.width = `${Math.max(0, Math.min(1, ratio)) * 100}%`;
    }
    if (defuseState.active) {
      const prompt = DEFUSE_PROMPTS.find(entry => defuseState.countdown <= entry.threshold);
      const promptEl = $("defusePrompt");
      if (prompt && promptEl) {
        promptEl.textContent = prompt.message;
      }
    } else {
      const promptEl = $("defusePrompt");
      if (promptEl) {
        promptEl.textContent = DEFUSE_PROMPTS[0].message;
      }
    }
  }

  function setDefuseStatus(message) {
    const status = $("defuseStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function selectDefuseAction(action) {
    defuseState.selectedAction = action || DEFAULT_DEFUSE_ACTION;
    saveDefuseAction(defuseState.selectedAction);
    const preview = $("defuseActionPreview");
    if (preview) {
      preview.textContent = `Action picked: ${defuseState.selectedAction}`;
    }
  }

  function autoLockDefuseApps() {
    const boxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    const values = [];
    boxes.forEach(box => {
      box.checked = true;
      values.push(box.value);
    });
    saveDefuseLocks(values);
  }

  function startDefusePreflight() {
    if (defuseState.active) return;
    defuseState.active = true;
    defuseState.countdown = 90;
    defuseState.selectedAction = defuseState.selectedAction || DEFAULT_DEFUSE_ACTION;
    autoLockDefuseApps();
    updateDefuseCountdownUI();
    setDefuseStatus("Preflight running… stay with the prompt.");
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = true;
    if (cancelBtn) cancelBtn.disabled = false;
    defuseState.intervalId = setInterval(() => {
      defuseState.countdown -= 1;
      if (defuseState.countdown <= 0) {
        completeDefusePreflight();
      } else {
        updateDefuseCountdownUI();
      }
    }, 1000);
    updateDefuseModeUI();
  }

  function cancelDefusePreflight() {
    if (!defuseState.active) return;
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    setDefuseStatus("Preflight cancelled.");
    updateDefuseModeUI();
  }

  function completeDefusePreflight() {
    if (defuseState.intervalId) {
      clearInterval(defuseState.intervalId);
      defuseState.intervalId = null;
    }
    defuseState.active = false;
    const sprintMinutes = getDefuseBaseMinutes();
    setDefuseStatus(`Launching ${sprintMinutes}-minute DEFUSE sprint.`);
    showToast("DEFUSE Mode", `${defuseState.selectedAction}. Sprinting for ${sprintMinutes} minutes.`);
    const nextBase = Math.min(DEFUSE_MINUTES_MAX, sprintMinutes + 2);
    setDefuseBaseMinutes(nextBase);
    startFocus(null, { sprintMinutes });
    defuseState.countdown = 90;
    updateDefuseCountdownUI();
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = false;
    if (cancelBtn) cancelBtn.disabled = true;
    updateDefuseModeUI();
  }

  function updateDefuseModeUI() {
    updateDefuseLocksUI();
    updateDefuseUptimeUI();
    updateDefuseCountdownUI();
    selectDefuseAction(defuseState.selectedAction || DEFAULT_DEFUSE_ACTION);
    const startBtn = $("defuseStart");
    const cancelBtn = $("defuseCancel");
    if (startBtn) startBtn.disabled = defuseState.active;
    if (cancelBtn) cancelBtn.disabled = !defuseState.active;
  }

  function initializeDefuseMode() {
    const module = $("defuseModule");
    if (!module) return;
    defuseState.selectedAction = loadDefuseAction();
    defuseState.uptime = getDefuseBaseMinutes();
    updateDefuseModeUI();
    const actionButtons = document.querySelectorAll('[data-defuse-action]');
    actionButtons.forEach(button => {
      button.addEventListener("click", () => selectDefuseAction(button.getAttribute("data-defuse-action")));
    });
    const lockBoxes = document.querySelectorAll('#defuseLocks input[type="checkbox"]');
    lockBoxes.forEach(box => {
      box.addEventListener("change", () => saveDefuseLocks(getSelectedDefuseLocks()));
    });
    const startBtn = $("defuseStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDefusePreflight);
    }
    const cancelBtn = $("defuseCancel");
    if (cancelBtn) {
      cancelBtn.addEventListener("click", cancelDefusePreflight);
    }
  }

  function loadDopamineReward() {
    const stored = localStorage.getItem(DOPAMINE_REWARD_KEY);
    return stored || "music";
  }

  function saveDopamineReward(value) {
    try {
      localStorage.setItem(DOPAMINE_REWARD_KEY, value);
    } catch (error) {
      console.warn("Unable to save dopamine reward preference", error);
    }
  }

  function updateDopamineStatus(message) {
    const status = $("dopamineStatus");
    if (status) {
      status.textContent = message || "";
    }
  }

  function renderDopamineIntervals() {
    const container = $("dopamineIntervals");
    if (!container) return;
    container.innerHTML = "";
    DOPAMINE_INTERVALS.forEach((minutes, index) => {
      const row = document.createElement("div");
      row.className = "dopamine-interval";
      const label = document.createElement("span");
      label.textContent = `${minutes} min`;
      const status = document.createElement("span");
      if (dopamineState?.currentIntervalIndex > index) {
        status.textContent = "✅ complete";
      } else if (dopamineState?.active && dopamineState.currentIntervalIndex === index) {
        status.textContent = "▶️ now";
      } else {
        status.textContent = "… pending";
      }
      row.appendChild(label);
      row.appendChild(status);
      container.appendChild(row);
    });
  }

  function updateDopamineProgress() {
    const progress = $("dopamineProgressFill");
    if (!progress) return;
    if (!dopamineState || !dopamineState.active) {
      const completed = dopamineState?.currentIntervalIndex >= DOPAMINE_INTERVALS.length;
      progress.style.width = completed ? "100%" : "0%";
      updateGanttOverlayProgress();
      return;
    }
    const totalMinutes = DOPAMINE_INTERVALS[DOPAMINE_INTERVALS.length - 1];
    const totalMs = Math.max(1, totalMinutes * 60 * 1000);
    const elapsed = Date.now() - dopamineState.startTime;
    const ratio = Math.max(0, Math.min(1, elapsed / totalMs));
    progress.style.width = `${Math.round(ratio * 100)}%`;
    updateGanttOverlayProgress();
  }

  function spawnConfetti() {
    const burst = document.createElement("div");
    burst.className = "confetti-burst";
    const icons = ["🎉", "✨", "🪄", "🎊", "💫"];
    burst.textContent = icons[Math.floor(Math.random() * icons.length)];
    document.body.appendChild(burst);
    setTimeout(() => {
      if (burst.parentNode) {
        burst.parentNode.removeChild(burst);
      }
    }, 900);
  }

  function playTone(frequency, durationMs = 320) {
    try {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) return;
      const context = new AudioContextClass();
      const oscillator = context.createOscillator();
      const gain = context.createGain();
      oscillator.type = "sine";
      oscillator.frequency.value = frequency;
      gain.gain.setValueAtTime(0.2, context.currentTime);
      oscillator.connect(gain);
      gain.connect(context.destination);
      oscillator.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + durationMs / 1000);
      oscillator.stop(context.currentTime + durationMs / 1000);
      setTimeout(() => context.close(), durationMs + 120);
    } catch (error) {
      console.warn("Tone playback unavailable", error);
    }
  }

  function triggerDopamineReward(index) {
    if (!dopamineState) return;
    dopamineState.currentIntervalIndex = Math.max(dopamineState.currentIntervalIndex, index + 1);
    renderDopamineIntervals();
    updateDopamineProgress();
    const minutes = DOPAMINE_INTERVALS[index];
    if (dopamineState.rewardType === "music") {
      playTone(440, 320);
      setTimeout(() => playTone(660, 200), 180);
    } else if (dopamineState.rewardType === "coin") {
      playTone(880, 200);
      setTimeout(() => playTone(660, 180), 180);
    } else if (dopamineState.rewardType === "confetti") {
      spawnConfetti();
    } else {
      showToast("Stretch cue", "Stand, reach tall, breathe for 10 seconds.");
    }
    if (index >= DOPAMINE_INTERVALS.length - 1) {
      updateDopamineStatus("Intervals complete. Ride the momentum!");
      stopDopaminePlaylist({ completed: true });
    } else {
      const next = DOPAMINE_INTERVALS[index + 1] - minutes;
      updateDopamineStatus(`Nice! Next reward in ${next} min.`);
    }
  }

  function stopDopaminePlaylist(options = {}) {
    if (!dopamineState) return;
    (dopamineState.timers || []).forEach(timerId => clearTimeout(timerId));
    if (dopamineState.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    const completed = Boolean(options.completed);
    const rewardType = dopamineState.rewardType || loadDopamineReward();
    const currentIndex = completed ? DOPAMINE_INTERVALS.length : (dopamineState.currentIntervalIndex || 0);
    dopamineState = {
      active: false,
      rewardType,
      currentIntervalIndex: currentIndex,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    if (!completed) {
      updateDopamineStatus("Playlist stopped.");
    }
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = false;
    if (stopBtn) stopBtn.disabled = true;
  }

  function startDopaminePlaylist() {
    if (dopamineState?.active) return;
    const select = $("dopamineReward");
    const rewardType = select?.value || loadDopamineReward();
    saveDopamineReward(rewardType);
    const startBtn = $("dopamineStart");
    const stopBtn = $("dopamineStop");
    if (startBtn) startBtn.disabled = true;
    if (stopBtn) stopBtn.disabled = false;
    const timers = DOPAMINE_INTERVALS.map((minutes, index) =>
      setTimeout(() => triggerDopamineReward(index), minutes * 60 * 1000)
    );
    if (dopamineState?.tickIntervalId) {
      clearInterval(dopamineState.tickIntervalId);
    }
    dopamineState = {
      active: true,
      rewardType,
      timers,
      startTime: Date.now(),
      tickIntervalId: setInterval(updateDopamineProgress, 1000),
      currentIntervalIndex: 0
    };
    renderDopamineIntervals();
    updateDopamineProgress();
    updateGanttOverlayProgress();
    updateDopamineStatus("Playlist started – settle in.");
  }

  function initializeDopamineModule() {
    const module = $("dopamineModule");
    if (!module) return;
    const stored = loadDopamineReward();
    dopamineState = {
      active: false,
      rewardType: stored,
      currentIntervalIndex: 0,
      timers: [],
      tickIntervalId: null,
      startTime: null
    };
    const select = $("dopamineReward");
    if (select) {
      select.value = stored;
      select.addEventListener("change", event => {
        const value = event.target.value || "music";
        saveDopamineReward(value);
        if (dopamineState) {
          dopamineState.rewardType = value;
        }
      });
    }
    const startBtn = $("dopamineStart");
    if (startBtn) {
      startBtn.addEventListener("click", startDopaminePlaylist);
    }
    const stopBtn = $("dopamineStop");
    if (stopBtn) {
      stopBtn.addEventListener("click", () => stopDopaminePlaylist({ completed: false }));
      stopBtn.disabled = true;
    }
    renderDopamineIntervals();
    updateDopamineProgress();
    updateDopamineStatus("Stretch rewards from 2 → 6 → 12 minutes.");
  }

  function buildAdaptiveGanttPlan(windowMinutes = GANTT_WINDOW_MINUTES) {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const available = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({
        task,
        score: computeFocusScore(task, energyLevel, timeBudget),
        minutes: Math.max(5, Math.round(estimateTaskMinutes(task) || 15))
      }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    const entries = [];
    let remaining = Number.isFinite(windowMinutes) && windowMinutes > 0 ? windowMinutes : GANTT_WINDOW_MINUTES;
    available.forEach(entry => {
      if (remaining <= 0) return;
      const blockMinutes = Math.min(entry.minutes, remaining);
      entries.push({
        task: entry.task,
        minutes: blockMinutes,
        fullMinutes: entry.minutes
      });
      remaining -= blockMinutes;
    });
    const totalMinutes = entries.reduce((sum, entry) => sum + entry.minutes, 0);
    return { entries, totalMinutes };
  }

  function renderGanttSnapshot(plan) {
    ganttPlanState = plan;
    const container = $("ganttBlocks");
    const status = $("ganttStatus");
    if (container) {
      container.innerHTML = "";
      if (!plan.entries.length) {
        const empty = document.createElement("div");
        empty.className = "score";
        empty.textContent = "Add a task to see your next blocks.";
        container.appendChild(empty);
      } else {
        plan.entries.forEach((entry, index) => {
          const block = document.createElement("div");
          block.className = "gantt-block";
          block.style.flex = String(Math.max(1, entry.minutes));
          const title = document.createElement("strong");
          title.textContent = entry.task.name || "Task";
          const detail = document.createElement("small");
          const startOffset = plan.entries.slice(0, index).reduce((sum, current) => sum + current.minutes, 0);
          const start = new Date(Date.now() + startOffset * 60000);
          detail.textContent = `${entry.minutes} min • starts ${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
          block.appendChild(title);
          block.appendChild(detail);
          container.appendChild(block);
        });
      }
    }
    if (status) {
      status.textContent = plan.entries.length
        ? `Covers ${plan.totalMinutes} min. Playlist progress will sweep across.`
        : "";
    }
  }

    function updateGanttOverlayProgress() {
    const bar = $("ganttProgressBar");
    const status = $("ganttStatus");
    if (!bar || !ganttPlanState) return;
    const total = ganttPlanState.totalMinutes || 0;
    if (!ganttOverlayStartTime || total <= 0) {
      bar.style.width = "0%";
      bar.classList.add("is-paused");
      if (status && status.textContent === "") {
        status.textContent = "Hit play on the playlist to animate your time.";
      }
      return;
    }
    if (!dopamineState || !dopamineState.active) {
      bar.classList.add("is-paused");
      if (status) {
        status.textContent = "Playlist paused — progress holds until you press play.";
      }
      return;
    }
    bar.classList.remove("is-paused");
    const elapsed = Math.max(0, Date.now() - ganttOverlayStartTime);
    const ratio = Math.min(1, elapsed / (total * 60000));
    bar.style.width = `${Math.round(ratio * 100)}%`;
    if (status) {
      status.textContent = `Playlist pacing ${Math.round(ratio * 100)}% of this snapshot.`;
    }
  }

    function openGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    updateGanttOverlayProgress();
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
    }
    ganttProgressIntervalId = setInterval(updateGanttOverlayProgress, 1000);
  }

    function closeGanttSnapshot() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (ganttProgressIntervalId) {
      clearInterval(ganttProgressIntervalId);
      ganttProgressIntervalId = null;
    }
    ganttOverlayStartTime = null;
  }

    function refreshGanttSnapshotIfOpen() {
    const overlay = $("ganttSnapshotOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    const plan = buildAdaptiveGanttPlan();
    renderGanttSnapshot(plan);
    ganttOverlayStartTime = Date.now();
    updateGanttOverlayProgress();
  }

    function initializeGanttSnapshot() {
    const trigger = $("ganttSnapshotAction");
    if (trigger) {
      trigger.addEventListener("click", openGanttSnapshot);
    }
    const closeBtn = $("ganttCloseButton");
    if (closeBtn) {
      closeBtn.addEventListener("click", closeGanttSnapshot);
    }
    const overlay = $("ganttSnapshotOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          closeGanttSnapshot();
        }
      });
    }
    document.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        closeGanttSnapshot();
      }
    });
  }

  function setAddTaskCardCollapsed(collapsed, options = {}) {
    const overlay = $("addTaskOverlay");
    const body = $("addTaskCardBody");
    if (!overlay || !body) return;
    const { skipFocus = false, skipPersist = false, focusTarget = null } = options;
    const open = !collapsed;
    overlay.classList.toggle("hidden", collapsed);
    overlay.setAttribute("aria-hidden", collapsed ? "true" : "false");
    if (document?.body) {
      document.body.classList.toggle("modal-active", open);
    }
    if (!skipPersist) {
      localStorage.setItem(ADD_TASK_CARD_STATE_KEY, collapsed ? "collapsed" : "expanded");
    }
    if (!open) {
      return;
    }
    window.setTimeout(() => {
      if (skipFocus) return;
      if (focusTarget === "dueDate") {
        if (!focusDueDateField()) {
          focusFirstEditableField();
        }
        return;
      }
      focusFirstEditableField();
    }, 120);
  }

  function toggleAddTaskCard() {
    const overlay = $("addTaskOverlay");
    const collapsed = !overlay || overlay.classList.contains("hidden") ? true : false;
    setAddTaskCardCollapsed(!collapsed);
  }

  function initializeAddTaskCardState() {
    let stored = localStorage.getItem(ADD_TASK_CARD_STATE_KEY);
    if (!stored) {
      const legacy = localStorage.getItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      if (legacy) {
        stored = legacy;
        localStorage.setItem(ADD_TASK_CARD_STATE_KEY, legacy);
        localStorage.removeItem(LEGACY_ADD_TASK_CARD_STATE_KEY);
      }
    }
    const collapsed = stored ? stored !== "expanded" : true;
    setAddTaskCardCollapsed(collapsed, { skipFocus: true, skipPersist: true });
  }


  function getAllTasksCards() {
    return Array.from(document.querySelectorAll('[data-all-tasks-card]')).map(card => {
      const panel = card.querySelector('[data-all-tasks-panel]') || null;
      const title = card.querySelector('[data-all-tasks-title]') || null;
      const categoryLabel = card.querySelector('[data-all-tasks-category]') || null;
      const divider = card.querySelector('[data-all-tasks-divider]') || null;
      const summaryText = card.querySelector('[data-all-tasks-summary-text]') || null;
      const heading = card.querySelector('[data-all-tasks-heading]') || null;
      const toggle = card.querySelector('[data-all-tasks-toggle]') || heading || null;
      return { card, panel, title, categoryLabel, divider, summaryText, heading, toggle };
    });
  }

  function initializeAllTasksCardState() {
    const cards = getAllTasksCards();
    if (!cards.length) return;
    const hasStandaloneScreen = cards.some(({ card }) => card?.closest('[data-all-tasks-screen]'));
    cards.forEach(({ toggle, card }) => {
      if (!toggle) return;
      toggle.addEventListener("click", () => {
        const expanded = toggle.getAttribute("aria-expanded") === "true";
        setAllTasksAccordionOpen(!expanded, { source: card });
      });
    });
    if (hasStandaloneScreen) {
      setAllTasksAccordionOpen(true, { skipPersist: true, skipSync: true });
      return;
    }
    let storedState = null;
    try {
      storedState = localStorage.getItem(ALL_TASKS_CARD_STATE_KEY);
    } catch (error) {
      console.warn("Unable to access stored All Tasks state", error);
    }
    const shouldOpen = storedState ? storedState === "expanded" : false;
    setAllTasksAccordionOpen(shouldOpen, { skipPersist: true, skipSync: true });
  }

  function focusFirstEditableField() {
    const nameField = $("name");
    if (nameField) {
      window.requestAnimationFrame(() => {
        nameField.focus();
        if (typeof nameField.select === "function") {
          nameField.select();
        }
      });
    }
  }

  function focusDueDateField() {
    const dueField = $("dueDate");
    if (dueField) {
      window.requestAnimationFrame(() => dueField.focus());
      return true;
    }
    const serviceField = $("dateOfService");
    if (serviceField) {
      window.requestAnimationFrame(() => serviceField.focus());
      return true;
    }
    return false;
  }

  function scrollCardHeaderIntoView(card) {
    if (!card) return;
    const target = card.querySelector(".card-head") || card;
    window.requestAnimationFrame(() => {
      const rect = target.getBoundingClientRect();
      const offset = Math.max(0, window.scrollY + rect.top - 24);
      window.scrollTo({ top: offset, behavior: "smooth" });
    });
  }

  function handleTemplateModalKeydown(event) {
    if (event.key === "Escape") {
      closeTemplateModal();
    }
  }

  function closeTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    document.removeEventListener("keydown", handleTemplateModalKeydown);
    if (lastFocusedBeforeTemplateModal && typeof lastFocusedBeforeTemplateModal.focus === "function") {
      lastFocusedBeforeTemplateModal.focus();
    }
    lastFocusedBeforeTemplateModal = null;
  }

  function renderTemplateCards(list) {
    const grid = $("template-grid");
    if (!grid) return;
    grid.innerHTML = "";
    if (!list || !list.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      grid.appendChild(empty);
      return;
    }
    list.forEach(template => {
      const card = document.createElement("div");
      card.className = "template-card";
      const title = document.createElement("strong");
      title.textContent = template.name;
      card.appendChild(title);
      const meta = document.createElement("p");
      meta.className = "score";
      const categoryLabel = template.category || "General";
      meta.textContent = `Category: ${categoryLabel}`;
      card.appendChild(meta);
      const stats = document.createElement("p");
      stats.className = "score";
      stats.textContent = `Imp ${template.importance || 1} • Urg ${template.urgency || 3} • Diff ${template.difficulty || 3}`;
      card.appendChild(stats);
      const applyBtn = document.createElement("button");
      applyBtn.type = "button";
      applyBtn.className = "btn btn-primary";
      applyBtn.textContent = "Apply";
      applyBtn.addEventListener("click", () => applyTemplate(template));
      card.appendChild(applyBtn);
      grid.appendChild(card);
    });
  }

  function openTemplateModal() {
    const modal = $("template-modal");
    if (!modal) return;
    lastFocusedBeforeTemplateModal = document.activeElement;
    const category = $("taskCategory")?.value || "General";
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    document.addEventListener("keydown", handleTemplateModalKeydown);
    const firstButton = modal.querySelector(".template-card button") || modal.querySelector(".modal__close");
    if (firstButton) {
      firstButton.focus();
    }
  }

  function fillTaskFormFromTemplate(template, options = {}) {
    if (!template) return;
    $("name").value = template.name || "";
    const keepCurrent = Boolean(options.keepCurrentCategory);
    const categoryField = $("taskCategory");
    const currentCategory = categoryField ? (categoryField.value || "General") : "General";
    const category = keepCurrent ? currentCategory : (template.category || currentCategory);
    if (categoryField) {
      categoryField.value = category;
    }
    handleCategoryChange(category);
    $("importance").value = String(template.importance || 1);
    $("novelty").value = String(template.novelty || 1);
    $("interest").value = String(template.interest || 1);
    const authorField = $("authorType");
    if (authorField) authorField.value = template.authorType || "attending";
    const patientField = $("patientType");
    if (patientField) patientField.value = normalizePatientType(template.patientType);
    const visitField = $("visitType");
    if (visitField) visitField.value = normalizeVisitType(template.visitType);
    const clinicField = $("clinicSite");
    if (clinicField) clinicField.value = normalizeClinicSite(template.clinicSite);
    const urgencyField = $("urgency");
    if (urgencyField) urgencyField.value = String(template.urgency || 3);
    const pressureField = $("externalPressure");
    if (pressureField) pressureField.value = String(template.externalPressure || 1);
    $("timeToStart").value = String(template.timeToStart || 1);
    $("difficulty").value = String(template.difficulty || 1);
    const dateField = $("dateOfService");
    if (dateField) dateField.value = formatDateForInput(new Date());
    urgencyAuto = false;
    updateDerivedFields();
  }

  function applyTemplate(template) {
    fillTaskFormFromTemplate(template, { keepCurrentCategory: true });
    setTaskDetailsCollapsed(false);
    setAddTaskCardCollapsed(false, { focusTarget: "dueDate" });
    closeTemplateModal();
  }

  function updateTemplateModalForCategory(category) {
    const modal = $("template-modal");
    if (!modal || modal.classList.contains("hidden")) return;
    const filtered = templates.filter(t => (t.category || "General") === category);
    renderTemplateCards(filtered);
  }

  function setTaskDetailsCollapsed(collapsed) {
    const panel = $("taskDetails");
    const button = $("expandTaskDetailsButton");
    if (!panel || !button) return;
    panel.dataset.collapsed = collapsed ? "true" : "false";
    button.textContent = collapsed ? "Show details" : "Hide details";
    button.setAttribute("aria-expanded", collapsed ? "false" : "true");
    panel.setAttribute("aria-hidden", collapsed ? "true" : "false");
  }

  function toggleTaskDetails() {
    const panel = $("taskDetails");
    if (!panel) return;
    const collapsed = panel.dataset.collapsed !== "false";
    setTaskDetailsCollapsed(!collapsed);
  }

  function syncAddTaskActions() {
    const nameField = $("name");
    const addBtn = $("addTaskBtn");
    const startBtn = $("startBtn");
    if (!nameField || !addBtn || !startBtn) return;
    const hasName = Boolean(nameField.value.trim());
    const hasTasks = startBtn.dataset.hasTasks === "true";
    addBtn.classList.toggle("btn-primary", !hasName);
    addBtn.classList.toggle("btn-quiet", hasName);
    startBtn.classList.toggle("hero-cta", hasName);
    startBtn.classList.toggle("btn-secondary", !hasName);
    startBtn.disabled = !hasName && !hasTasks;
  }


  let allTasksAccordionOpen = true;

  function setAllTasksAccordionOpen(open, options = {}) {
    const { skipPersist = false, highlight = false, skipSync = false, source = null } = options;
    const cards = getAllTasksCards();
    if (!cards.length) return;
    const previousState = allTasksAccordionOpen;
    allTasksAccordionOpen = Boolean(open);
    cards.forEach(({ panel, card, toggle }) => {
      if (panel) {
        panel.hidden = !allTasksAccordionOpen;
        panel.setAttribute("aria-hidden", allTasksAccordionOpen ? "false" : "true");
        if (highlight && allTasksAccordionOpen && (!source || source === card || source === panel)) {
          panel.classList.add("is-highlighted");
          window.setTimeout(() => panel.classList.remove("is-highlighted"), 600);
        }
      }
      if (toggle) {
        toggle.setAttribute("aria-expanded", allTasksAccordionOpen ? "true" : "false");
        toggle.classList.toggle("is-open", allTasksAccordionOpen);
      }
      if (card) {
        card.classList.toggle("is-collapsed", !allTasksAccordionOpen);
        card.classList.toggle("is-open", allTasksAccordionOpen);
        if (highlight && allTasksAccordionOpen && (!source || source === card)) {
          card.classList.add("is-highlighted");
          window.setTimeout(() => card.classList.remove("is-highlighted"), 600);
        }
      }
    });
    if (allTasksAccordionOpen && !skipSync) {
      setDueTodayAccordionOpen(false, { skipSync: true });
    }
    if (!skipPersist) {
      try {
        localStorage.setItem(ALL_TASKS_CARD_STATE_KEY, allTasksAccordionOpen ? "expanded" : "collapsed");
      } catch (error) {
        console.warn("Unable to persist All Tasks state", error);
      }
    }
    if (previousState !== allTasksAccordionOpen) {
      if (allTasksAccordionOpen) {
        readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
        readyToLaunchRevealBaseline = 0;
        updateUI();
      } else {
        resetReadyToLaunchVisibility();
      }
    }
  }

  function handleAllTasksOverlayKeydown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      closeAllTasksOverlay();
    }
  }

  function openAllTasksOverlay() {
    const overlay = $("AllTasksOverlay");
    if (!overlay || !overlay.classList.contains("hidden")) return;
    const sheet = overlay.querySelector(".all-tasks-overlay__sheet");
    const trigger = $("openAllTasksButton");
    lastFocusedBeforeAllTasksOverlay = document.activeElement instanceof HTMLElement
      ? document.activeElement
      : trigger;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    document.body.classList.add("all-tasks-overlay-active");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "true");
      trigger.classList.add("is-active");
      trigger.setAttribute("aria-current", "true");
    }
    setAllTasksAccordionOpen(true, { skipPersist: true, skipSync: true });
    window.requestAnimationFrame(() => {
      if (sheet && typeof sheet.focus === "function") {
        sheet.focus();
      }
    });
    document.addEventListener("keydown", handleAllTasksOverlayKeydown);
  }

  function closeAllTasksOverlay({ restoreFocus = true } = {}) {
    const overlay = $("AllTasksOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    document.body.classList.remove("all-tasks-overlay-active");
    const trigger = $("openAllTasksButton");
    if (trigger) {
      trigger.setAttribute("aria-expanded", "false");
      trigger.classList.remove("is-active");
      trigger.removeAttribute("aria-current");
    }
    document.removeEventListener("keydown", handleAllTasksOverlayKeydown);
    if (restoreFocus) {
      const focusTarget = (lastFocusedBeforeAllTasksOverlay && typeof lastFocusedBeforeAllTasksOverlay.focus === "function")
        ? lastFocusedBeforeAllTasksOverlay
        : trigger;
      if (focusTarget && typeof focusTarget.focus === "function") {
        window.requestAnimationFrame(() => focusTarget.focus());
      }
    }
    lastFocusedBeforeAllTasksOverlay = null;
  }

  function initializeAllTasksOverlay() {
    const overlay = $("AllTasksOverlay");
    const trigger = $("openAllTasksButton");
    if (!overlay || !trigger) return;
    const closeButton = overlay.querySelector("[data-all-tasks-close]");
    const backdrop = overlay.querySelector("[data-all-tasks-dismiss]");
    trigger.addEventListener("click", () => {
      if (overlay.classList.contains("hidden")) {
        openAllTasksOverlay();
      } else {
        closeAllTasksOverlay();
      }
    });
    if (closeButton) {
      closeButton.addEventListener("click", () => closeAllTasksOverlay());
    }
    if (backdrop) {
      backdrop.addEventListener("click", () => closeAllTasksOverlay());
    }
  }


  let lastFocusedBeforeRoutineOverlay = null;

  function handleRoutineOverlayKeydown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      closeRoutineOverlay();
    }
  }

  function openRoutineOverlay(trigger = null) {
    const overlay = $("routineOverlay");
    if (!overlay || !overlay.classList.contains("hidden")) return;
    const sheet = overlay.querySelector(".routine-overlay__sheet");
    lastFocusedBeforeRoutineOverlay = trigger instanceof HTMLElement ? trigger : document.activeElement;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    document.body.classList.add("routine-overlay-active");
    const toggle = $("routineOverlayToggle");
    if (toggle) {
      toggle.setAttribute("aria-expanded", "true");
      toggle.classList.add("is-active");
    }
    window.requestAnimationFrame(() => {
      if (sheet && typeof sheet.focus === "function") {
        sheet.focus();
      }
    });
    document.addEventListener("keydown", handleRoutineOverlayKeydown);
  }

  function closeRoutineOverlay({ restoreFocus = true } = {}) {
    const overlay = $("routineOverlay");
    if (!overlay || overlay.classList.contains("hidden")) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    document.body.classList.remove("routine-overlay-active");
    const toggle = $("routineOverlayToggle");
    if (toggle) {
      toggle.setAttribute("aria-expanded", "false");
      toggle.classList.remove("is-active");
    }
    document.removeEventListener("keydown", handleRoutineOverlayKeydown);
    if (restoreFocus) {
      const focusTarget = (lastFocusedBeforeRoutineOverlay && typeof lastFocusedBeforeRoutineOverlay.focus === "function")
        ? lastFocusedBeforeRoutineOverlay
        : toggle;
      if (focusTarget && typeof focusTarget.focus === "function") {
        window.requestAnimationFrame(() => focusTarget.focus());
      }
    }
    lastFocusedBeforeRoutineOverlay = null;
  }

  function initializeRoutineOverlay() {
    const overlay = $("routineOverlay");
    const toggle = $("routineOverlayToggle");
    if (!overlay || !toggle) return;
    const closeButton = overlay.querySelector('[data-routine-overlay-close]');
    const backdrop = overlay.querySelector('[data-routine-overlay-dismiss]');
    toggle.addEventListener("click", () => {
      if (overlay.classList.contains("hidden")) {
        openRoutineOverlay(toggle);
      } else {
        closeRoutineOverlay();
      }
    });
    if (closeButton) {
      closeButton.addEventListener("click", () => closeRoutineOverlay());
    }
    if (backdrop) {
      backdrop.addEventListener("click", () => closeRoutineOverlay());
    }
  }

  function setModuleOpenState(module, body, open, header = null) {
    if (!module || !body) return;
    module.classList.toggle("is-open", open);
    body.hidden = !open;
    if (header) {
      header.setAttribute("aria-expanded", open ? "true" : "false");
    }
    body.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function openModuleById(id) {
    const routineDef = getRoutineDefinition(id) || ROUTINE_DEFINITIONS.find(def => def.moduleId === id);
    if (routineDef) {
      openRoutineTile(routineDef.id, { scrollIntoView: true });
      return;
    }
    const module = $(id);
    if (!module) return;
    const body = module.querySelector(".module-body");
    const header = module.querySelector(".module-header");
    if (!body) return;
    setModuleOpenState(module, body, true, header);
    localStorage.setItem(`${MODULE_STATE_PREFIX}${id}`, "open");
  }

  function initializeCollapsibleModules() {
    initializeRoutineTiles();
  }

  function getMostMeaningfulTask() {
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    const scored = tasks
      .filter(task => !isTaskCompleted(task))
      .map(task => ({ task, score: computeFocusScore(task, energyLevel, timeBudget) }))
      .sort((a, b) => (b.score || 0) - (a.score || 0));
    return scored.length ? scored[0].task : null;
  }

  function getHighestPriorityTask() {
    const candidates = tasks.filter(task => !isTaskCompleted(task));
    if (!candidates.length) return null;
    return candidates.reduce((best, task) => {
      const bestScore = Number(best?.priority) || 0;
      const taskScore = Number(task?.priority) || 0;
      if (!best || taskScore > bestScore) {
        return task;
      }
      return best;
    }, null);
  }

  function updateWorstDayBanner() {
    const button = $("worstDayButton");
    const hint = $("worstDayHint");
    const focusTask = getMostMeaningfulTask();
    const hasTask = Boolean(focusTask);
    if (button) {
      button.disabled = !hasTask;
      button.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    const focusFab = $("startFocusFab");
    if (focusFab) {
      focusFab.disabled = !hasTask;
      focusFab.setAttribute("aria-disabled", hasTask ? "false" : "true");
    }
    if (hint) {
      hint.textContent = hasTask ? `Most meaningful project: ${focusTask.name}` : "Add a task to unlock Worst-Day Mode.";
    }
  }

    function startWorstDayMode() {
    if (worstDayState.active) return;
    const overlay = $("worstDayOverlay");
    const focusLine = $("worstDayFocus");
    const prompt = $("worstDayPrompt");
    const timerEl = $("worstDayTimer");
    const actions = $("worstDayActions");
    const celebration = $("worstDayCelebration");
    const focusTask = getMostMeaningfulTask();
    if (!overlay || !focusTask) {
      showToast("Worst-Day Mode", "Add a task to give yourself something kind to focus on.");
      return;
    }
    const chunk = deriveMmpChunk(focusTask) || { label: focusTask.name, minutes: 5, subId: null };
    worstDayState = {
      active: true,
      countdownId: null,
      endTime: Date.now() + WORST_DAY_DURATION_MS,
      task: focusTask,
      chunk
    };
    if (focusLine) {
      focusLine.textContent = chunk.label || focusTask.name;
    }
    if (prompt) {
      prompt.textContent = "Move gently. Drift happens — we'll reset together.";
    }
    if (timerEl) {
      timerEl.textContent = "05:00";
    }
    if (actions) {
      actions.classList.add("hidden");
    }
    if (celebration) {
      celebration.textContent = "";
    }
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = setInterval(updateWorstDayTimer, 250);
    updateWorstDayTimer();
  }

    function updateWorstDayTimer() {
    if (!worstDayState.active) return;
    const timerEl = $("worstDayTimer");
    const prompt = $("worstDayPrompt");
    if (!timerEl) return;
    const remaining = Math.max(0, worstDayState.endTime - Date.now());
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    if (remaining <= 0) {
      completeWorstDaySprint();
      if (prompt) {
        prompt.textContent = "You stayed. Pick a gentle reward.";
      }
    }
  }

    function completeWorstDaySprint() {
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState.countdownId = null;
    worstDayState.active = false;
    worstDayState.endTime = null;
    const actions = $("worstDayActions");
    if (actions) {
      actions.classList.remove("hidden");
    }
    const celebration = $("worstDayCelebration");
    if (celebration) {
      celebration.textContent = "";
    }
  }

    function handleWorstDayChoice(choice) {
    const celebration = $("worstDayCelebration");
    if (choice === "laugh") {
      const line = WORST_DAY_LAUGHS[Math.floor(Math.random() * WORST_DAY_LAUGHS.length)] || "You showed up.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stretch") {
      const line = WORST_DAY_STRETCHES[Math.floor(Math.random() * WORST_DAY_STRETCHES.length)] || "Shoulder rolls, deep breath.";
      if (celebration) celebration.textContent = line;
    } else if (choice === "stop") {
      stopWorstDayMode({ celebrate: true });
    }
  }

    function stopWorstDayMode(options = {}) {
    const overlay = $("worstDayOverlay");
    if (worstDayState.countdownId) {
      clearInterval(worstDayState.countdownId);
    }
    worstDayState = { active: false, countdownId: null, endTime: null, task: null, chunk: null };
    if (overlay) {
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
    }
    if (options.celebrate) {
      showToast("Worst-Day Mode", "Five minutes banked. That counts.");
    }
    updateWorstDayBanner();
  }

    function initializeWorstDayMode() {
    const button = $("worstDayButton");
    if (button) {
      button.addEventListener("click", startWorstDayMode);
    }
    const overlay = $("worstDayOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          stopWorstDayMode();
        }
      });
    }
    const closeBtn = $("worstDayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const exitBtn = $("worstDayExit");
    if (exitBtn) {
      exitBtn.addEventListener("click", () => stopWorstDayMode());
    }
    const actions = $("worstDayActions");
    if (actions) {
      actions.addEventListener("click", event => {
        const buttonEl = event.target.closest('[data-worst-day-choice]');
        if (!buttonEl) return;
        handleWorstDayChoice(buttonEl.getAttribute('data-worst-day-choice'));
      });
    }
    updateWorstDayBanner();
  }

  function startFiveMinuteSprint(taskId = null) {
    setTaskDetailsCollapsed(false);
    const targetId = taskId || nextTaskId || null;
    startFocus(targetId, { sprintMinutes: 5 });
  }

  function extendSprintBy(minutes) {
    const extraMinutes = Number(minutes);
    if (!Number.isFinite(extraMinutes) || extraMinutes <= 0) return;
    const extraMs = extraMinutes * 60000;
    const now = Date.now();
    if (focusTimerStart === null) {
      startFocus(nextTaskId, { sprintMinutes: extraMinutes });
      return;
    }
    if (!Number.isFinite(sprintDurationMinutes) || sprintDurationMinutes <= 0 || !sprintEndTime) {
      const elapsed = Math.max(0, now - focusTimerStart);
      sprintDurationMinutes = Math.max(extraMinutes, (elapsed + extraMs) / 60000);
      sprintEndTime = now + extraMs;
      setSprintVisualState(true);
    } else {
      sprintEndTime += extraMs;
      const total = Math.max(sprintEndTime - focusTimerStart, extraMs);
      sprintDurationMinutes = Math.max(sprintDurationMinutes, total / 60000);
    }
    const remaining = Math.max(0, sprintEndTime - now);
    const totalDuration = Math.max(remaining, sprintDurationMinutes * 60000);
    setFocusProgress(totalDuration > 0 ? ((totalDuration - remaining) / totalDuration) * 100 : 0);
    showToast("Focus cocoon", `Sprint extended by ${extraMinutes} minute${extraMinutes === 1 ? "" : "s"}.`);
  }

  function quickAddTask(nameOverride = null) {
    const provided = typeof nameOverride === "string" ? nameOverride : prompt("Quick add task");
    if (!provided) return;
    const name = provided.trim();
    if (!name) return;
    const nowIso = new Date().toISOString();
    const task = {
      id: Date.now().toString(),
      name,
      category: QUICK_TASK_CATEGORY,
      authorType: "attending",
      patientType: "Non-Complex",
      visitType: "Follow-Up",
      clinicSite: "General Clinic",
      dateOfService: null,
      daysSinceVisit: null,
      importance: 1,
      urgency: 1,
      novelty: 1,
      interest: 1,
      externalPressure: 1,
      timeToStart: 1,
      difficulty: 1,
      dueDate: null,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: false
    };
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    tasks.push(task);
    showTaskAddedConfirmation();
    persist();
    setTaskDetailsCollapsed(true);
    updateUI();
  }

  let quickCaptureKeydownHandler = null;

  function openQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const input = $("quickCaptureInput");
    if (input) {
      input.value = "";
      window.requestAnimationFrame(() => input.focus());
    }
    quickCaptureKeydownHandler = event => {
      if (event.key === "Escape") {
        event.preventDefault();
        closeQuickCaptureModal();
      }
      if (event.key === "Enter" && event.target === input) {
        event.preventDefault();
        handleQuickCaptureSubmit();
      }
    };
    document.addEventListener("keydown", quickCaptureKeydownHandler);
  }

  function closeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (quickCaptureKeydownHandler) {
      document.removeEventListener("keydown", quickCaptureKeydownHandler);
      quickCaptureKeydownHandler = null;
    }
    const trigger = $("nextTaskActionButton");
    if (trigger) {
      window.requestAnimationFrame(() => trigger.focus());
    }
  }

  function handleQuickCaptureSubmit() {
    const input = $("quickCaptureInput");
    if (!input) return;
    const value = input.value.trim();
    if (!value) {
      input.focus();
      return;
    }
    quickAddTask(value);
    closeQuickCaptureModal();
  }

  function initializeFocusLaunchSheet() {
    const fab = $("startFocusFab");
    const sheet = $("focusLaunchSheet");
    const backdrop = $("focusLaunchBackdrop");
    const handle = $("focusLaunchHandle");
    const suggestionBtn = $("focusSuggestionButton");
    const options = sheet ? sheet.querySelector(".focus-sheet__options") : null;
    const labelMap = { now: "Do now", easy: "Do if easy", buddy: "Do with buddy" };
    const nextTaskAction = $("nextTaskActionButton");

    const activatePick = pickKey => {
      if (!pickKey) return false;
      const evaluation = latestNextBestPicks[pickKey];
      if (!evaluation) return false;
      launchNextBestOption(labelMap[pickKey] || "Start", evaluation);
      return true;
    };

    if (nextTaskAction) {
      const LONG_PRESS_MS = 650;
      let longPressTriggered = false;
      let pressTimer = null;

      const clearPressTimer = () => {
        if (pressTimer) {
          window.clearTimeout(pressTimer);
          pressTimer = null;
        }
      };

      const handlePointerEnd = () => {
        if (longPressTriggered) {
          window.setTimeout(() => nextTaskAction.classList.remove("is-long-press"), 220);
        }
        clearPressTimer();
      };

      nextTaskAction.addEventListener("pointerdown", event => {
        if (event.button !== 0) return;
        clearPressTimer();
        longPressTriggered = false;
        pressTimer = window.setTimeout(() => {
          longPressTriggered = true;
          nextTaskAction.classList.add("is-long-press");
          openQuickCaptureModal();
        }, LONG_PRESS_MS);
      });

      nextTaskAction.addEventListener("pointerup", handlePointerEnd);
      nextTaskAction.addEventListener("pointerleave", handlePointerEnd);
      nextTaskAction.addEventListener("pointercancel", handlePointerEnd);

      nextTaskAction.addEventListener("click", event => {
        if (longPressTriggered) {
          event.preventDefault();
          longPressTriggered = false;
          return;
        }
        startFiveMinuteSprint(nextTaskId);
      });
    }

    if (fab) {
      fab.addEventListener("click", event => {
        event.preventDefault();
        if (fab.disabled) return;
        setFocusLaunchOpen(!focusLaunchOpen);
      });
    }

    if (handle) {
      handle.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (backdrop) {
      backdrop.addEventListener("click", () => setFocusLaunchOpen(false));
    }

    if (options) {
      options.addEventListener("click", event => {
        const button = event.target.closest(".focus-sheet__option");
        if (!button || button.disabled || button.getAttribute("aria-disabled") === "true") return;
        const mode = button.getAttribute("data-focus-mode");
        setFocusLaunchOpen(false);
        if (mode === "sprint") {
          if (!activatePick("now")) {
            startFiveMinuteSprint(nextTaskId);
          }
          return;
        }
        if (mode === "session") {
          if (!activatePick("easy")) {
            const fallbackId = latestNextBestPicks.now?.task?.id || nextTaskId;
            if (fallbackId) {
              startFocus(fallbackId);
            } else {
              startFocus();
            }
          }
          return;
        }
        if (mode === "suggestion") {
          const pickKey = button.dataset.pickKey || "now";
          if (!activatePick(pickKey)) {
            startFiveMinuteSprint(nextTaskId);
          }
        }
      });
    }

    if (suggestionBtn) {
      suggestionBtn.addEventListener("click", () => {
        const pickKey = suggestionBtn.dataset.pickKey;
        setFocusLaunchOpen(false);
        if (!activatePick(pickKey)) {
          startFiveMinuteSprint(nextTaskId);
        }
      });
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && focusLaunchOpen) {
        setFocusLaunchOpen(false);
      }
    });
  }

  function openDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function initializeQuickCaptureModal() {
    const overlay = $("quickCaptureOverlay");
    if (!overlay) return;
    const cancelBtn = $("quickCaptureCancel");
    const saveBtn = $("quickCaptureSave");
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeQuickCaptureModal();
      }
    });
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => closeQuickCaptureModal());
    }
    if (saveBtn) {
      saveBtn.addEventListener("click", () => handleQuickCaptureSubmit());
    }
  }

  function closeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (lastDefuseOpener) {
      lastDefuseOpener.focus();
      lastDefuseOpener = null;
    }
  }

  function initializeDefuseOverlay() {
    const overlay = $("defuseOverlay");
    if (!overlay) return;
    const closeBtn = $("defuseClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeDefuseOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeDefuseOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeDefuseOverlay();
      }
    });
  }

  function openTemplatesOverlay(trigger = null) {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    lastTemplatesOpener = trigger || document.activeElement;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("templatesOverlayClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function closeTemplatesOverlay({ restoreFocus = true } = {}) {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (restoreFocus && lastTemplatesOpener) {
      const target = lastTemplatesOpener;
      lastTemplatesOpener = null;
      window.requestAnimationFrame(() => target?.focus?.());
    } else {
      lastTemplatesOpener = null;
    }
  }

  function initializeTemplatesOverlay() {
    const overlay = $("templatesOverlay");
    if (!overlay) return;
    const closeBtn = $("templatesOverlayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeTemplatesOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeTemplatesOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeTemplatesOverlay();
      }
    });
  }

  function openConflictOverlay(trigger = null) {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    lastConflictOpener = trigger || document.activeElement;
    overlay.classList.remove("hidden");
    overlay.setAttribute("aria-hidden", "false");
    const closeBtn = $("conflictOverlayClose");
    if (closeBtn) {
      closeBtn.focus();
    }
  }

  function closeConflictOverlay({ restoreFocus = true } = {}) {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
    if (restoreFocus && lastConflictOpener) {
      const target = lastConflictOpener;
      lastConflictOpener = null;
      window.requestAnimationFrame(() => target?.focus?.());
    } else {
      lastConflictOpener = null;
    }
  }

  function initializeConflictOverlay() {
    const overlay = $("conflictOverlay");
    if (!overlay) return;
    const closeBtn = $("conflictOverlayClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeConflictOverlay());
    }
    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        closeConflictOverlay();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
        closeConflictOverlay();
      }
    });
  }

  function initializeSettingsMenu() {
    const toggle = $("settingsToggle");
    const menu = $("settingsMenu");
    if (!toggle || !menu) return;

    let open = false;

    const setOpen = value => {
      open = Boolean(value);
      menu.classList.toggle("is-open", open);
      menu.setAttribute("aria-hidden", open ? "false" : "true");
      toggle.setAttribute("aria-expanded", open ? "true" : "false");
    };

    setOpen(false);

    const closeMenu = () => setOpen(false);

    toggle.addEventListener("click", () => {
      setOpen(!open);
    });

    document.addEventListener("click", event => {
      if (!open) return;
      if (event.target === toggle || toggle.contains(event.target)) return;
      if (menu.contains(event.target)) return;
      closeMenu();
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && open) {
        event.stopPropagation();
        closeMenu();
        toggle.focus();
      }
    });

    const templatesBtn = $("settingsTemplates");
    if (templatesBtn) {
      templatesBtn.addEventListener("click", () => {
        closeMenu();
        openTemplatesOverlay(templatesBtn);
      });
    }
  }

  function initializeResourcesDrawer() {
    const toggle = $("resourcesToggle");
    const drawer = $("resourcesDrawer");
    const closeBtn = $("resourcesClose");
    const backdrop = $("resourcesBackdrop");
    const viewToggle = document.getElementById("resourcesViewToggle");
    const form = document.getElementById("addResourceForm");
    const messageEl = form?.querySelector("[data-resource-form-message]");
    if (!toggle || !drawer || !backdrop) return;

    let currentView = drawer.dataset.view === "form" ? "form" : "list";
    const clearFormMessage = () => {
      if (!messageEl) return;
      messageEl.textContent = "";
      messageEl.dataset.status = "neutral";
    };
    const focusFirstField = () => {
      if (!form) return;
      const first = form.querySelector("input, textarea, select");
      if (first) {
        first.focus();
      }
    };

    const setDrawerView = (view, { focusField = false } = {}) => {
      currentView = view === "form" ? "form" : "list";
      drawer.dataset.view = currentView;
      if (viewToggle) {
        if (currentView === "form") {
          viewToggle.textContent = "✕";
          viewToggle.setAttribute("aria-label", "Back to resource list");
          viewToggle.classList.add("resources-drawer__toggle--form");
          if (focusField) {
            window.requestAnimationFrame(() => focusFirstField());
          }
        } else {
          viewToggle.textContent = "📘";
          viewToggle.setAttribute("aria-label", "Add a resource");
          viewToggle.classList.remove("resources-drawer__toggle--form");
          if (focusField) {
            window.requestAnimationFrame(() => viewToggle.focus());
          }
        }
      }
      if (currentView === "list") {
        clearFormMessage();
      }
    };

    setResourcesDrawerView = (view, options = {}) => {
      setDrawerView(view, options);
    };

    let drawerOpen = false;
    const setDrawerOpen = (open, { focusToggle = true } = {}) => {
      drawerOpen = Boolean(open);
      drawer.classList.toggle("is-open", drawerOpen);
      drawer.setAttribute("aria-hidden", drawerOpen ? "false" : "true");
      toggle.setAttribute("aria-expanded", drawerOpen ? "true" : "false");
      if (drawerOpen) {
        backdrop.hidden = false;
        requestAnimationFrame(() => backdrop.classList.add("is-visible"));
        drawer.focus();
        setDrawerView("list");
      } else {
        backdrop.classList.remove("is-visible");
        window.setTimeout(() => {
          if (!drawerOpen) {
            backdrop.hidden = true;
          }
        }, 200);
        if (focusToggle) {
          toggle.focus();
        }
        setDrawerView("list");
      }
    };

    openResourcesDrawer = () => setDrawerOpen(true);
    closeResourcesDrawer = () => setDrawerOpen(false);

    setDrawerOpen(false, { focusToggle: false });

    toggle.addEventListener("click", openResourcesDrawer);
    if (closeBtn) {
      closeBtn.addEventListener("click", closeResourcesDrawer);
    }
    if (viewToggle) {
      viewToggle.addEventListener("click", () => {
        if (currentView === "form") {
          setDrawerView("list", { focusField: true });
        } else {
          setDrawerView("form", { focusField: true });
        }
      });
    }
    backdrop.addEventListener("click", closeResourcesDrawer);
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && drawerOpen) {
        event.preventDefault();
        closeResourcesDrawer();
      }
    });
  }

  function initializeSosPanel() {
    const overlay = $("sosOverlay");
    const closeBtn = $("sosOverlayClose");
    const shieldBtn = $("sosShield");
    const defuseBtn = $("sosDefuse");
    const conflictBtn = $("sosConflict");
    const worstDayBtn = $("worstDayButton");
    const triggers = ["rescueLaunchButton", "meltdownSosButton"].map(id => $(id)).filter(Boolean);
    if (!triggers.length || !overlay) return;

    let sosOpen = false;
    let activeTrigger = null;

    const updateTriggerExpanded = () => {
      triggers.forEach(trigger => {
        trigger.setAttribute("aria-expanded", sosOpen && trigger === activeTrigger ? "true" : "false");
      });
    };

    updateTriggerExpanded();

    const setSosOpen = (open, { restoreFocus = true, focusTarget = null } = {}) => {
      sosOpen = Boolean(open);
      updateTriggerExpanded();
      if (sosOpen) {
        overlay.classList.remove("hidden");
        overlay.setAttribute("aria-hidden", "false");
        if (closeBtn) {
          closeBtn.focus();
        }
        lastSosTrigger = activeTrigger || triggers[0] || null;
      } else {
        overlay.classList.add("hidden");
        overlay.setAttribute("aria-hidden", "true");
        if (restoreFocus) {
          const target = focusTarget || activeTrigger || lastSosTrigger || triggers[0] || null;
          if (target) {
            window.requestAnimationFrame(() => target.focus());
          }
        }
      }
    };

    triggers.forEach(trigger => {
      trigger.addEventListener("click", () => {
        activeTrigger = trigger;
        lastSosTrigger = trigger;
        setSosOpen(true);
      });
    });

    if (closeBtn) {
      closeBtn.addEventListener("click", () => setSosOpen(false));
    }

    overlay.addEventListener("click", event => {
      if (event.target === overlay) {
        setSosOpen(false);
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && sosOpen) {
        setSosOpen(false);
      }
    });

    if (shieldBtn) {
      shieldBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        activateShield();
      });
    }

    if (defuseBtn) {
      defuseBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        lastDefuseOpener = activeTrigger || lastSosTrigger || triggers[0] || null;
        openDefuseOverlay();
      });
    }

    if (conflictBtn) {
      conflictBtn.addEventListener("click", () => {
        setSosOpen(false, { restoreFocus: false });
        openConflictOverlay(conflictBtn);
      });
    }

    if (worstDayBtn) {
      worstDayBtn.addEventListener("click", () => setSosOpen(false, { restoreFocus: false }));
    }
  }

  function initializeCommandBarAutohide() {
    const bar = document.querySelector(".command-bar");
    if (!bar) return;
    let lastScrollY = window.scrollY || 0;
    let rafId = null;
    let hidden = false;

    const evaluate = () => {
      rafId = null;
      const currentY = window.scrollY || 0;
      const delta = currentY - lastScrollY;
      const hide = currentY > 96 && delta > 6;
      const reveal = delta < -6 || currentY <= 96;
      if (hide && !hidden) {
        bar.classList.add("is-hidden");
        hidden = true;
      } else if (reveal && hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = currentY;
    };

    window.addEventListener(
      "scroll",
      () => {
        if (rafId !== null) return;
        rafId = window.requestAnimationFrame(evaluate);
      },
      { passive: true }
    );

    window.addEventListener("focusin", () => {
      if (hidden) {
        bar.classList.remove("is-hidden");
        hidden = false;
      }
      lastScrollY = window.scrollY || 0;
    });
  }

  function initializeTaskForm() {
    setTaskDetailsCollapsed(true);
    const expandBtn = $("expandTaskDetailsButton");
    if (expandBtn) {
      expandBtn.addEventListener("click", toggleTaskDetails);
    }
    const templateBtn = $("btn-use-template");
    if (templateBtn) {
      templateBtn.addEventListener("click", () => {
        setAddTaskCardCollapsed(false, { skipFocus: true });
        openTemplateModal();
      });
    }
    const saveTemplateBtn = $("btn-save-template");
    if (saveTemplateBtn) {
      saveTemplateBtn.addEventListener("click", () => saveAsTemplate());
    }
    const openCardBtn = $("openAddTaskPanel");
    if (openCardBtn) {
      openCardBtn.addEventListener("click", () => setAddTaskCardCollapsed(false));
    }
    const closeBtn = $("addTaskClose");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => setAddTaskCardCollapsed(true));
    }
    const overlay = $("addTaskOverlay");
    if (overlay) {
      overlay.addEventListener("click", event => {
        if (event.target === overlay) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
      document.addEventListener("keydown", event => {
        if (event.key === "Escape" && !overlay.classList.contains("hidden")) {
          setAddTaskCardCollapsed(true, { skipPersist: true, skipFocus: true });
        }
      });
    }
    const modal = $("template-modal");
    if (modal) {
      modal.addEventListener("click", event => {
        if (event.target === modal) {
          closeTemplateModal();
        }
      });
      const closeBtn = modal.querySelector(".modal__close");
      if (closeBtn) {
        closeBtn.addEventListener("click", closeTemplateModal);
      }
    }
    syncAddTaskActions();
    const nameInput = $("name");
    if (nameInput) {
      nameInput.addEventListener("input", syncAddTaskActions);
    }
    const subField = $("initialSubTasks");
    if (subField) {
      subField.addEventListener("input", () => {
        delete subField.dataset.quickPreset;
        delete subField.dataset.allowChartTemplate;
      });
    }
  }

  function applyQuickAddBlockBatchPreset(batchId, options = {}) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return false;
    loadBlockBatchProfiles();
    const profile = getBlockBatchProfile(batchId);
    if (!profile) return false;
    const template = {
      name: options.nameOverride || `${definition.label} Note`,
      category: profile.category,
      authorType: profile.authorType,
      patientType: profile.patientType,
      visitType: profile.visitType,
      clinicSite: profile.clinicSite,
      importance: profile.importance,
      urgency: profile.urgency,
      novelty: profile.novelty,
      interest: profile.interest,
      externalPressure: profile.externalPressure,
      timeToStart: profile.timeToStart,
      difficulty: profile.difficulty
    };

    cancelEdit();
    fillTaskFormFromTemplate(template, { keepCurrentCategory: false });
    const today = new Date();
    const serviceDateField = $("dateOfService");
    if (serviceDateField) {
      serviceDateField.value = formatDateForInput(today);
    }
    const dueDateField = $("dueDate");
    if (dueDateField) {
      dueDateField.value = formatDateForInput(addDays(today, 3));
    }
    const subField = $("initialSubTasks");
    if (subField) {
      subField.value = Array.isArray(profile.subTasks) ? profile.subTasks.join("\n") : "";
      if (profile.useChartTemplate !== false) {
        subField.dataset.allowChartTemplate = "true";
      } else {
        delete subField.dataset.allowChartTemplate;
      }
      subField.dataset.quickPreset = batchId;
    }
    setTaskDetailsCollapsed(false);
    setAddTaskCardCollapsed(false);
    setQuickTaskTemplateMode(false);
    syncAddTaskActions();
    showToast("Template ready", `${definition.label} defaults loaded.`, { timeout: 2600 });
    return true;
  }

  function initializeQuickAddMenu() {
    const plusButtons = Array.from(document.querySelectorAll(".quick-add-button--plus"));
    if (plusButtons.length) {
      plusButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          cancelEdit();
          setAddTaskCardCollapsed(false);
          syncAddTaskActions();
        });
      });
    }
    const quickTemplateBtn = document.querySelector(".quick-add-button--cherry");
    if (quickTemplateBtn) {
      quickTemplateBtn.addEventListener("click", () => {
        cancelEdit();
        const categoryField = $("taskCategory");
        if (categoryField) {
          categoryField.value = QUICK_TASK_CATEGORY;
        }
        handleCategoryChange(QUICK_TASK_CATEGORY);
        setAddTaskCardCollapsed(false, { skipFocus: true });
        const nameField = $("name");
        if (nameField) {
          nameField.value = "";
          window.requestAnimationFrame(() => {
            nameField.focus();
            if (typeof nameField.select === "function") {
              nameField.select();
            }
          });
        }
        syncAddTaskActions();
      });
    }
    const bulkOrderBtn = document.querySelector(".quick-add-button--muscle");
    if (bulkOrderBtn) {
      bulkOrderBtn.addEventListener("click", () => {
        cancelEdit();
        if (typeof openBlockBatchModal === "function") {
          openBlockBatchModal();
        }
      });
    }
    const quickPresets = [
      {
        selector: ".quick-add-button--unicorn",
        batchId: "complex-care",
        nameOverride: "Complex Care Follow-Up"
      },
      {
        selector: ".quick-add-button--home",
        batchId: "st-pjs",
        nameOverride: "St. PJ’s Shelter Note"
      },
      {
        selector: ".quick-add-button--kiddo",
        batchId: "craniofacial",
        nameOverride: "Craniofacial Clinic Update"
      }
    ];
    quickPresets.forEach(({ selector, batchId, nameOverride }) => {
      const button = document.querySelector(selector);
      if (!button) return;
      button.addEventListener("click", () => {
        applyQuickAddBlockBatchPreset(batchId, { nameOverride });
      });
    });
  }

  function initializeQuickTaskShortcut() {
    const shortcut = $("quickTaskShortcut");
    if (!shortcut) return;
    shortcut.addEventListener("click", () => {
      const card = document.querySelector("[data-quick-tasks-card]");
      if (!card) return;
      scrollCardHeaderIntoView(card);
      card.classList.add("is-highlighted");
      window.setTimeout(() => card.classList.remove("is-highlighted"), 650);
    });
  }

  function initializeShredTopTaskButton() {
    const button = $("shredTopTaskButton");
    if (!button) return;
    button.addEventListener("click", () => {
      const topTask = getHighestPriorityTask();
      if (!topTask) {
        showToast("Shred Top Task", "No active tasks to shred right now.");
        return;
      }
      startFocus(topTask.id);
      window.setTimeout(() => {
        const completeBtn = $("focusCompleteButton");
        if (completeBtn) {
          completeBtn.focus();
        }
      }, 260);
      showToast("Shred Top Task", `Ready to complete: ${topTask.name}`);
    });
  }
// === START: Long-press Quick Capture from Focus button ===
function initializeFocusFabLongPress() {
  const fab = document.getElementById("nextTaskActionButton");
  if (!fab) return;

  const LONG_PRESS_MS = 600;
  let timer = null;

  fab.addEventListener("pointerdown", () => {
    timer = setTimeout(() => {
      // open your Quick Capture modal
      openModal();
    }, LONG_PRESS_MS);
  });

  ["pointerup", "pointerleave", "pointercancel"].forEach(type =>
    fab.addEventListener(type, () => clearTimeout(timer))
  );
}

// Call this once at startup
initializeFocusFabLongPress();
// === END: Long-press Quick Capture from Focus button ===
    
  // main UI update
  function updateUI() {
    tasks = tasks.map(recalcTaskPriority);
    persist();
    renderCategoryFilter();
    renderCategoryProgress();
    renderQuickTasks();
    renderNeuroChecklist();

    const totalTasks = tasks.length;
    const activeTasksCount = tasks.filter(t => !isTaskCompleted(t)).length;
    const shredButton = $("shredTopTaskButton");
    if (shredButton) {
      const hasActiveTasks = activeTasksCount > 0;
      shredButton.disabled = !hasActiveTasks;
      shredButton.setAttribute("aria-disabled", hasActiveTasks ? "false" : "true");
    }
    const categoryDisplay = activeCategory === "All" ? "All categories" : activeCategory;
    const hasTasks = totalTasks > 0;
    getAllTasksCards().forEach(({ title, summaryText, categoryLabel, divider }) => {
      if (title) {
        title.textContent = `All Tasks (${totalTasks})`;
      }
      if (summaryText) {
        summaryText.textContent = hasTasks
          ? `${activeTasksCount} active • ${totalTasks} total`
          : "No tasks yet";
      }
      if (categoryLabel) {
        if (hasTasks) {
          categoryLabel.textContent = categoryDisplay;
          categoryLabel.classList.remove("hidden");
        } else {
          categoryLabel.classList.add("hidden");
        }
      }
      if (divider) {
        divider.classList.toggle("hidden", !hasTasks);
      }
    });

    const taskList = $("taskList");
    taskList.innerHTML = "";

    const taskViewSelect = $("taskViewMode");
    if (taskViewSelect) {
      taskViewSelect.value = taskListMode;
    }

    const sortSelect = $("taskSortMode");
    if (sortSelect) {
      const validSortValues = Object.values(TASK_SORT_MODES);
      sortSelect.value = validSortValues.includes(taskSortMode) ? taskSortMode : TASK_SORT_MODES.PRIORITY;
    }

    const eligibleTasks = tasks.filter(t => activeCategory === "All" || t.category === activeCategory);
    const remaining = eligibleTasks.filter(t => !isTaskCompleted(t));
    const startBtn = $("startBtn");
    if (startBtn) {
      startBtn.dataset.hasTasks = remaining.length > 0 ? "true" : "false";
    }
    syncAddTaskActions();
    const timeBudget = getTimeBudgetMinutes();
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const hasTimeBudget = Number.isFinite(timeBudget);
    const sortedRemaining = sortTasksByMode(remaining, taskSortMode);
    const budgetFilteredRemaining = hasTimeBudget
      ? sortedRemaining.filter(task => estimateTaskMinutes(task) <= timeBudget)
      : sortedRemaining;

    const isActiveMode = taskListMode === TASK_LIST_MODES.ACTIVE;

    let allDisplayableTasks;
    if (taskListMode === TASK_LIST_MODES.COMPLETED) {
      const completedTasks = eligibleTasks.filter(t => isTaskCompleted(t));
      if (taskSortMode === TASK_SORT_MODES.PRIORITY) {
        allDisplayableTasks = [...completedTasks].sort((a, b) => {
          const aDate = getCompletionTimestamp(a) ? new Date(getCompletionTimestamp(a)).getTime() : 0;
          const bDate = getCompletionTimestamp(b) ? new Date(getCompletionTimestamp(b)).getTime() : 0;
          return bDate - aDate;
        });
      } else {
        allDisplayableTasks = sortTasksByMode(completedTasks, taskSortMode);
      }
    } else {
      allDisplayableTasks = budgetFilteredRemaining;
    }

    const visibleCount = isActiveMode
      ? Math.min(readyToLaunchVisibleCount, allDisplayableTasks.length)
      : allDisplayableTasks.length;
    const displayTasks = visibleCount > 0 ? allDisplayableTasks.slice(0, visibleCount) : [];

    const showMoreBtn = $("readyToLaunchMoreBtn");
    if (showMoreBtn) {
      const hasMore = isActiveMode && visibleCount < allDisplayableTasks.length;
      showMoreBtn.classList.toggle("is-visible", hasMore);
      showMoreBtn.disabled = !hasMore;
      showMoreBtn.setAttribute("aria-hidden", hasMore ? "false" : "true");
    }

    const revealBaseline = isActiveMode
      ? Math.min(readyToLaunchRevealBaseline, displayTasks.length)
      : displayTasks.length;

    if (!displayTasks.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      if (taskListMode === TASK_LIST_MODES.ACTIVE && hasTimeBudget && remaining.length > 0 && budgetFilteredRemaining.length === 0) {
        empty.textContent = "No tasks fit the selected time budget.";
      } else {
        empty.textContent = taskListMode === TASK_LIST_MODES.COMPLETED
          ? "No completed tasks yet."
          : "No active tasks to show.";
      }
      taskList.appendChild(empty);
    } else {
      displayTasks.forEach((task, index) => {
        const card = renderTaskListCard(task, taskListMode, hasTimeBudget ? timeBudget : null);
        if (isActiveMode && index >= revealBaseline) {
          card.classList.add("task-card--reveal");
        }
        taskList.appendChild(card);
        if (isActiveMode && index >= revealBaseline) {
          requestAnimationFrame(() => {
            card.classList.add("is-visible");
          });
        }
      });
    }

    if (isActiveMode) {
      readyToLaunchRevealBaseline = displayTasks.length ? visibleCount : READY_TO_LAUNCH_INITIAL_COUNT;
    }

    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const today = now.toISOString().split("T")[0];
    const dueTodayEntries = [];

    tasks.forEach(task => {
      if (isTaskCompleted(task)) return;
      if (activeCategory !== "All" && task.category !== activeCategory) return;

      const fallbackDueDate = (!task.dueDate && task.dateOfService)
        ? (() => {
            const dt = new Date(`${task.dateOfService}T00:00:00`);
            if (!Number.isNaN(dt.getTime())) {
              dt.setDate(dt.getDate() + 3);
              return dt.toISOString().split("T")[0];
            }
            return null;
          })()
        : null;

      if (task.dueDate === today || (fallbackDueDate && fallbackDueDate === today)) {
        dueTodayEntries.push({
          task,
          fallback: Boolean(fallbackDueDate && !task.dueDate)
        });
      }
    });

    dueTodayEntries.sort((a, b) => computeFocusScore(b.task, energyLevel, timeBudget) - computeFocusScore(a.task, energyLevel, timeBudget));
    renderDueTodayList(dueTodayEntries);
    updateNextTaskCard();
    updateNextBestOptions();
    updateConflictResolver();
    refreshGanttSnapshotIfOpen();
    updateWorstDayBanner();
    updateSleepToolkitUI();
    refreshTaskGestureTargets();
  }

  function resetReadyToLaunchVisibility() {
    readyToLaunchVisibleCount = READY_TO_LAUNCH_INITIAL_COUNT;
    readyToLaunchRevealBaseline = READY_TO_LAUNCH_INITIAL_COUNT;
  }

  function showMoreReadyToLaunchTasks() {
    const previousVisible = readyToLaunchVisibleCount;
    readyToLaunchVisibleCount += READY_TO_LAUNCH_INCREMENT;
    readyToLaunchRevealBaseline = previousVisible;
    updateUI();
  }

  function startFocus(initialTaskId = null, options = {}) {
    if (editingTaskId) cancelEdit();
    if (options && options.expandDetails) {
      setTaskDetailsCollapsed(false);
    }
    const sprintMinutes = Number(options?.sprintMinutes);
    stopFocusTimer();
    if (Number.isFinite(sprintMinutes) && sprintMinutes > 0) {
      sprintDurationMinutes = sprintMinutes;
    } else {
      sprintDurationMinutes = null;
    }
    setSprintVisualState(Boolean(sprintDurationMinutes));
    setFocusLaunchOpen(false);
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.setAttribute("aria-hidden", "true");
    }
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.remove("hidden");
      focusSection.setAttribute("aria-hidden", "false");
      const focusSheet = focusSection.querySelector(".focus-overlay__sheet");
      if (focusSheet) {
        window.requestAnimationFrame(() => focusSheet.focus());
      }
    }
    document.body.classList.add("focus-overlay-active");
    const energyLevel = clampScale(getEnergyLevel(), 3);
    const timeBudget = getTimeBudgetMinutes();
    lastFocusEnergyLevel = energyLevel;
    lastFocusTimeBudget = timeBudget;
    const score = task => Number(task?.priority || 0) * energyFit(task, energyLevel) * timeFit(task, timeBudget);
    focusQueue = tasks
      .filter(t => !isTaskCompleted(t) && (activeCategory === "All" || t.category === activeCategory))
      .sort((a, b) => score(b) - score(a));
    if (initialTaskId) {
      const targetIndex = focusQueue.findIndex(task => task.id === initialTaskId);
      if (targetIndex > 0) {
        const [selected] = focusQueue.splice(targetIndex, 1);
        focusQueue.unshift(selected);
      } else if (targetIndex === -1) {
        const directTask = tasks.find(t => t.id === initialTaskId && !isTaskCompleted(t));
        if (directTask) {
          focusQueue.unshift(directTask);
        }
      }
    }
    showNextTask();
  }

  function showNextTask() {
    const display = document.querySelector(".focus");
    const scoreView = $("scoreView");
    if (focusQueue.length === 0) {
      display.textContent = "✅ All tasks complete!";
      scoreView.textContent = "";
      updateFocusFitHint(null, lastFocusEnergyLevel, lastFocusTimeBudget);
      const subTaskView = $("subTaskView");
      if (subTaskView) subTaskView.innerHTML = "";
      clearRunningTimers();
      stopFocusTimer();
      currentFocusTaskIndex = null;
      setSprintVisualState(false);
      return;
    }
    const current = focusQueue[0];
    display.textContent = current.name;
    startFocusTimer();
    const idx = tasks.findIndex(t => t.id === current.id);
    const task = idx !== -1 ? tasks[idx] : current;
    scoreView.textContent = `Score: ${task.priority.toFixed(1)}`;
    updateFocusFitHint(task, lastFocusEnergyLevel, lastFocusTimeBudget);
    renderFocusTask(task, idx);
  }

  function updateFocusFitHint(task, energyLevel, timeBudget) {
    const hintEl = $("focusFitHint");
    if (!hintEl) return;
    if (!task) {
      hintEl.textContent = "";
      return;
    }
    const pieces = [];
    const estimated = estimateTaskMinutes(task);
    if (Number.isFinite(timeBudget)) {
      if (Number.isFinite(estimated) && estimated > 0) {
        const rounded = Math.max(1, Math.round(estimated));
        if (rounded <= timeBudget) {
          pieces.push(`Fits your ${timeBudget}-minute block (est. ${rounded} min)`);
        } else {
          pieces.push(`Stretch past ${timeBudget}-minute block (est. ${rounded} min)`);
        }
      } else {
        pieces.push(`Focus window: ${timeBudget} min`);
      }
    }
    if (Number.isFinite(energyLevel)) {
      const difficulty = clampScale(task?.difficulty, 3);
      if (energyLevel <= 2) {
        if (estimated <= 20) {
          pieces.push("Easiest win for low energy");
        } else {
          pieces.push("Try a 5-min pass—energy is low");
        }
      } else if (energyLevel >= 4) {
        if (difficulty >= 4) {
          pieces.push("Perfect for your high energy window");
        } else {
          pieces.push("Use the high energy to bank progress");
        }
      }
    }
    hintEl.textContent = pieces.length ? pieces.join(" • ") : "Working the highest-impact task next.";
  }

  function completeTaskById(taskId, options = {}) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (task.completed) return false;
    const nowIso = new Date().toISOString();
    task.completed = true;
    task.completedAt = nowIso;
    updateChartDurationForTask(task);
    if (Array.isArray(task.subTasks)) {
      task.subTasks.forEach(sub => stopTimerForSubTask(sub.id));
    }
    persist();
    recordTaskCompletion(task);
    maybeShowEndOfDayAudit();
    if (!options.skipUI) {
      updateUI();
    }
    return true;
  }

  function restoreTaskById(taskId) {
    const idx = tasks.findIndex(t => t.id === taskId);
    if (idx === -1) return false;
    const task = tasks[idx];
    if (!task.completed) return false;
    task.completed = false;
    task.completedAt = null;
    if (Object.prototype.hasOwnProperty.call(task, "completionTime")) {
      task.completionTime = null;
    }
    persist();
    updateUI();
    return true;
  }

  function markTaskDoneFromPeek(taskId) {
    const completed = completeTaskById(taskId);
    if (!completed) return;
    const wasCurrentFocus = focusQueue.length && focusQueue[0].id === taskId;
    focusQueue = focusQueue.filter(t => t.id !== taskId);
    if (wasCurrentFocus) {
      clearRunningTimers();
      stopFocusTimer();
    }
    const focusSection = $("focus");
    if (focusSection && !focusSection.classList.contains("hidden")) {
      showNextTask();
    }
  }

  function completeTask() {
    if (!focusQueue.length) return;
    const current = focusQueue[0];
    const completed = completeTaskById(current.id, { skipUI: true });
    clearRunningTimers();
    if (completed) {
      updateUI();
    }
    focusQueue.shift();
    showNextTask();
  }

  function backToCapture() {
    clearRunningTimers();
    stopFocusTimer();
    currentFocusTaskIndex = null;
    const focusSection = $("focus");
    if (focusSection) {
      focusSection.classList.add("hidden");
      focusSection.setAttribute("aria-hidden", "true");
    }
    const captureSection = $("capture");
    if (captureSection) {
      captureSection.classList.remove("hidden");
      captureSection.removeAttribute("aria-hidden");
    }
    document.body.classList.remove("focus-overlay-active");
    setSprintVisualState(false);
    setFocusLaunchOpen(false);
    updateUI();
  }

  function reset() {
    if (!confirm("Clear all tasks?")) return;
    cancelEdit();
    tasks = [];
    localStorage.removeItem("tasks");
    updateUI();
  }

  function saveAsTemplate() {
    const name = $("name").value.trim();
    if (!name) return alert("Task name is required");
    const authorField = $("authorType");
    const authorType = authorField ? (authorField.value || "attending") : "attending";
    const patientField = $("patientType");
    const patientType = normalizePatientType(patientField ? patientField.value : "Non-Complex");
    const visitField = $("visitType");
    const visitType = normalizeVisitType(visitField ? visitField.value : "Follow-Up");
    const clinicField = $("clinicSite");
    const clinicSite = normalizeClinicSite(clinicField ? clinicField.value : "General Clinic");
    const template = {
      name,
      category: $("taskCategory").value || "General",
      authorType,
      patientType,
      visitType,
      clinicSite,
      importance: clampScale($("importance").value, 1),
      urgency: clampScale($("urgency").value, 3),
      novelty: clampScale($("novelty").value, 1),
      interest: clampScale($("interest").value, 1),
      externalPressure: clampScale($("externalPressure").value, 1),
      timeToStart: clampScale($("timeToStart").value, 1),
      difficulty: clampScale($("difficulty").value, 1)
    };
    templates.push(template);
    persistTemplates();
    renderTemplates();
  }

  function renderTemplates() {
    const container = $("templateButtons");
    const selectedCategory = $("taskCategory")?.value || "General";
    const matchingTemplates = templates
      .map((template, index) => ({ template, index }))
      .filter(({ template }) => (template.category || "General") === selectedCategory);

    const useTemplateBtn = $("btn-use-template");
    if (useTemplateBtn) {
      const hasTemplates = matchingTemplates.length > 0;
      useTemplateBtn.disabled = !hasTemplates;
      useTemplateBtn.setAttribute("aria-disabled", hasTemplates ? "false" : "true");
      useTemplateBtn.title = hasTemplates ? "" : "No templates for this category yet";
    }

    updateTemplateModalForCategory(selectedCategory);

    if (!container) return;

    container.innerHTML = "";

    if (!matchingTemplates.length) {
      const empty = document.createElement("p");
      empty.className = "score";
      empty.textContent = "No templates for this category yet.";
      container.appendChild(empty);
      return;
    }

    matchingTemplates.forEach(({ template: t, index: templateIndex }) => {
      const wrapper = document.createElement("div");
      wrapper.className = "template-entry";
      const useBtn = document.createElement("button");
      useBtn.textContent = `📋 ${t.name}`;
      useBtn.onclick = () => {
        applyTemplate(t);
      };
      const editBtn = document.createElement("button");
      editBtn.textContent = "✏️";
      editBtn.title = "Edit template";
      editBtn.setAttribute("aria-label", "Edit template");
      editBtn.onclick = () => {
        const newName = prompt("Edit template name:", t.name);
        if (!newName) return;
        t.name = newName;
        persistTemplates();
        renderTemplates();
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "🗑️";
      deleteBtn.title = "Delete template";
      deleteBtn.setAttribute("aria-label", "Delete template");
      deleteBtn.onclick = () => {
        if (!confirm("Delete this template?")) return;
        templates.splice(templateIndex, 1);
        persistTemplates();
        renderTemplates();
      };
      [useBtn, editBtn, deleteBtn].forEach(b => {
        b.style.marginRight = "0.3rem";
        b.style.fontSize = "0.9rem";
      });
      wrapper.appendChild(useBtn);
      wrapper.appendChild(editBtn);
      wrapper.appendChild(deleteBtn);
      container.appendChild(wrapper);
    });
  }

  function normalizeBlockBatchProfile(profile = {}) {
    const normalized = {
      category: profile.category || "General",
      authorType: profile.authorType || "attending",
      patientType: normalizePatientType(profile.patientType || "Non-Complex"),
      visitType: normalizeVisitType(profile.visitType || "Follow-Up"),
      clinicSite: normalizeClinicSite(profile.clinicSite || "General Clinic"),
      importance: clampScale(profile.importance, 1),
      urgency: clampScale(profile.urgency, 3),
      novelty: clampScale(profile.novelty, 1),
      interest: clampScale(profile.interest, 1),
      externalPressure: clampScale(profile.externalPressure, 1),
      timeToStart: clampScale(profile.timeToStart, 1),
      difficulty: clampScale(profile.difficulty, 1),
      useChartTemplate: Boolean(profile.useChartTemplate)
    };
    if (Array.isArray(profile.subTasks)) {
      normalized.subTasks = profile.subTasks.map(line => line.trim()).filter(Boolean);
    } else if (typeof profile.subTasks === "string") {
      normalized.subTasks = profile.subTasks
        .split("\n")
        .map(line => line.trim())
        .filter(Boolean);
    } else {
      normalized.subTasks = [];
    }
    return normalized;
  }

  function getBlockBatchDefinition(batchId) {
    return DEFAULT_BLOCK_BATCHES.find(batch => batch.id === batchId) || null;
  }

  function getBlockBatchProfile(batchId) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return null;
    const base = normalizeBlockBatchProfile(definition.defaultProfile);
    const stored = blockBatchProfiles[batchId];
    if (!stored) {
      return { ...base };
    }
    const overrides = normalizeBlockBatchProfile(stored);
    const merged = { ...base, ...overrides };
    merged.subTasks = overrides.subTasks.slice();
    merged.useChartTemplate = overrides.useChartTemplate;
    return merged;
  }

  function loadBlockBatchProfiles() {
    const saved = localStorage.getItem(BLOCK_BATCH_STORAGE_KEY);
    blockBatchProfiles = {};
    if (!saved) return;
    try {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === "object") {
        Object.entries(parsed).forEach(([batchId, profile]) => {
          if (!getBlockBatchDefinition(batchId)) return;
          blockBatchProfiles[batchId] = normalizeBlockBatchProfile(profile);
        });
      }
    } catch (error) {
      console.warn("Block batch profiles could not be parsed", error);
      blockBatchProfiles = {};
    }
  }

  function saveBlockBatchProfiles() {
    localStorage.setItem(BLOCK_BATCH_STORAGE_KEY, JSON.stringify(blockBatchProfiles));
  }

  function renderBlockBatchList() {
    const list = $("blockBatchList");
    if (!list) return;
    list.innerHTML = "";
    const activeId = blockBatchState.activeId || (DEFAULT_BLOCK_BATCHES[0]?.id || null);
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const item = document.createElement("div");
      item.className = "block-batch-item";
      item.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        item.classList.add("is-active");
      }
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "block-batch-item__edit";
      editBtn.setAttribute("aria-label", `Edit ${definition.label} default profile`);
      editBtn.textContent = "✏️";
      editBtn.addEventListener("click", event => {
        event.preventDefault();
        event.stopPropagation();
        showBlockBatchEditor(definition.id);
      });
      const selectBtn = document.createElement("button");
      selectBtn.type = "button";
      selectBtn.className = "block-batch-item__select";
      selectBtn.textContent = definition.label;
      selectBtn.setAttribute("role", "option");
      selectBtn.setAttribute("aria-selected", definition.id === activeId ? "true" : "false");
      selectBtn.addEventListener("click", () => setActiveBlockBatch(definition.id, { focusInput: true }));
      item.appendChild(editBtn);
      item.appendChild(selectBtn);
      list.appendChild(item);
    });
  }

  function renderBlockBatchCounts() {
    const container = $("blockBatchCounts");
    if (!container) return;
    container.innerHTML = "";
    const activeId = blockBatchState.activeId;
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const label = document.createElement("label");
      label.className = "block-batch-count";
      label.dataset.batchId = definition.id;
      if (definition.id === activeId) {
        label.classList.add("is-active");
      }
      const title = document.createElement("span");
      title.textContent = definition.label;
      const input = document.createElement("input");
      input.type = "number";
      input.id = `blockBatchCount-${definition.id}`;
      input.name = `blockBatchCount-${definition.id}`;
      input.min = "0";
      input.step = "1";
      const current = Number(blockBatchState.counts?.[definition.id] || 0);
      input.value = String(current);
      input.addEventListener("input", () => {
        const parsed = Math.max(0, Math.floor(Number(input.value) || 0));
        input.value = String(parsed);
        blockBatchState.counts[definition.id] = parsed;
      });
      input.addEventListener("focus", () => {
        if (blockBatchState.activeId !== definition.id) {
          setActiveBlockBatch(definition.id);
        } else {
          updateBlockBatchHighlights();
        }
      });
      label.appendChild(title);
      label.appendChild(input);
      container.appendChild(label);
    });
  }

  function updateBlockBatchHighlights({ focusInput = false } = {}) {
    const activeId = blockBatchState.activeId;
    const list = $("blockBatchList");
    if (list) {
      list.querySelectorAll(".block-batch-item").forEach(item => {
        const isActive = item.dataset.batchId === activeId;
        item.classList.toggle("is-active", isActive);
        const optionBtn = item.querySelector(".block-batch-item__select");
        if (optionBtn) {
          optionBtn.setAttribute("aria-selected", isActive ? "true" : "false");
        }
      });
    }
    const countsContainer = $("blockBatchCounts");
    if (countsContainer) {
      countsContainer.querySelectorAll(".block-batch-count").forEach(wrapper => {
        wrapper.classList.toggle("is-active", wrapper.dataset.batchId === activeId);
      });
    }
    if (focusInput) {
      const targetInput = document.getElementById(`blockBatchCount-${activeId}`);
      if (targetInput) {
        window.setTimeout(() => {
          targetInput.focus();
          targetInput.select();
        }, 0);
      }
    }
  }

  function setActiveBlockBatch(batchId, options = {}) {
    const definition = getBlockBatchDefinition(batchId);
    if (!definition) return;
    blockBatchState.activeId = definition.id;
    updateBlockBatchHighlights(options);
  }

  function populateBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    const profile = getBlockBatchProfile(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (!profile || !definition) return;
    editor.dataset.batchId = batchId;
    const title = $("blockBatchEditorTitle");
    if (title) {
      title.textContent = `Edit default profile · ${definition.label}`;
    }
    const setValue = (id, value) => {
      const field = $(id);
      if (!field) return;
      field.value = value;
    };
    setValue("blockBatchCategory", profile.category || "General");
    setValue("blockBatchAuthor", profile.authorType || "attending");
    setValue("blockBatchPatient", profile.patientType || "Non-Complex");
    setValue("blockBatchVisit", profile.visitType || "Follow-Up");
    setValue("blockBatchClinic", profile.clinicSite || "General Clinic");
    setValue("blockBatchImportance", String(profile.importance || 1));
    setValue("blockBatchUrgency", String(profile.urgency || 3));
    setValue("blockBatchNovelty", String(profile.novelty || 1));
    setValue("blockBatchInterest", String(profile.interest || 1));
    setValue("blockBatchExternalPressure", String(profile.externalPressure || 1));
    setValue("blockBatchTimeToStart", String(profile.timeToStart || 1));
    setValue("blockBatchDifficulty", String(profile.difficulty || 1));
    const subtasksField = $("blockBatchSubtasks");
    if (subtasksField) {
      subtasksField.value = (profile.subTasks || []).join("\n");
    }
    const templateToggle = $("blockBatchUseChartTemplate");
    if (templateToggle) {
      templateToggle.checked = Boolean(profile.useChartTemplate);
    }
  }

  function showBlockBatchEditor(batchId) {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    setActiveBlockBatch(batchId);
    populateBlockBatchEditor(batchId);
    editor.classList.remove("hidden");
    const firstField = editor.querySelector("select, textarea, input");
    if (firstField) {
      window.setTimeout(() => firstField.focus(), 0);
    }
  }

  function hideBlockBatchEditor() {
    const editor = $("blockBatchEditor");
    if (!editor) return;
    editor.classList.add("hidden");
    delete editor.dataset.batchId;
  }

  function handleBlockBatchSaveProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    const profile = normalizeBlockBatchProfile({
      category: $("blockBatchCategory")?.value || "General",
      authorType: $("blockBatchAuthor")?.value || "attending",
      patientType: $("blockBatchPatient")?.value || "Non-Complex",
      visitType: $("blockBatchVisit")?.value || "Follow-Up",
      clinicSite: $("blockBatchClinic")?.value || "General Clinic",
      importance: $("blockBatchImportance")?.value || 1,
      urgency: $("blockBatchUrgency")?.value || 3,
      novelty: $("blockBatchNovelty")?.value || 1,
      interest: $("blockBatchInterest")?.value || 1,
      externalPressure: $("blockBatchExternalPressure")?.value || 1,
      timeToStart: $("blockBatchTimeToStart")?.value || 1,
      difficulty: $("blockBatchDifficulty")?.value || 1,
      subTasks: $("blockBatchSubtasks")?.value || "",
      useChartTemplate: $("blockBatchUseChartTemplate")?.checked || false
    });
    blockBatchProfiles[batchId] = profile;
    saveBlockBatchProfiles();
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile saved.`);
    }
    hideBlockBatchEditor();
  }

  function handleBlockBatchResetProfile() {
    const batchId = blockBatchState.activeId;
    if (!batchId) return;
    delete blockBatchProfiles[batchId];
    saveBlockBatchProfiles();
    populateBlockBatchEditor(batchId);
    const definition = getBlockBatchDefinition(batchId);
    if (definition) {
      showToast("Block Batch", `${definition.label} profile reset to default.`);
    }
  }

  function buildBlockBatchTaskName(prefix, serviceDate, index) {
    const date = serviceDate instanceof Date && !Number.isNaN(serviceDate.getTime()) ? serviceDate : new Date();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${prefix}_${month}_${day}_pt${index + 1}`;
  }

  function buildTaskFromBatchProfile(profile, overrides = {}) {
    if (!profile) return null;
    const normalized = normalizeBlockBatchProfile(profile);
    const nowIso = new Date().toISOString();
    const dateOfService = overrides.dateOfService || null;
    const dueDate = overrides.dueDate || null;
    const task = {
      id: `${Date.now()}-${blockBatchIdCounter++}`,
      name: overrides.name || "Block Batch Task",
      category: normalized.category,
      authorType: normalized.authorType,
      patientType: normalized.patientType,
      visitType: normalized.visitType,
      clinicSite: normalized.clinicSite,
      dateOfService,
      daysSinceVisit: calculateDaysSince(dateOfService),
      importance: normalized.importance,
      urgency: normalized.urgency,
      novelty: normalized.novelty,
      interest: normalized.interest,
      externalPressure: normalized.externalPressure,
      timeToStart: normalized.timeToStart,
      difficulty: normalized.difficulty,
      dueDate,
      completed: false,
      completedAt: null,
      createdAt: nowIso,
      addedAt: nowIso,
      subTasks: [],
      firstThreeMode: false,
      firstThreeUnlocked: true,
      firstThreeSteps: [],
      useChartTemplate: Boolean(normalized.useChartTemplate)
    };
    const basePriority = computePriority({ ...task, subTasks: [] });
    const subLines = Array.isArray(normalized.subTasks) ? normalized.subTasks : [];
    task.subTasks = subLines.map(line => createSubTask(line, basePriority));
    if (isChartTask(task)) {
      const defaultsAdded = ensureChartSubTasks(task, { basePriority });
      if (defaultsAdded) {
        task.subTasks = task.subTasks.map(sub => normalizeSubTask(sub, basePriority));
      }
    }
    maybeUnlockFirstThree(task, { silent: true });
    task.priority = computePriority(task);
    updateChartDurationForTask(task);
    return task;
  }

  function resetBlockBatchCounts() {
    blockBatchState.counts = {};
    const container = $("blockBatchCounts");
    if (container) {
      container.querySelectorAll('input[type="number"]').forEach(input => {
        input.value = "0";
      });
    }
  }

  function handleBlockBatchAdd() {
    const dateField = $("blockBatchDate");
    const rawDate = dateField && dateField.value ? dateField.value : null;
    let serviceDateObj = rawDate ? new Date(rawDate) : new Date();
    if (Number.isNaN(serviceDateObj.getTime())) {
      serviceDateObj = new Date();
    }
    const serviceDate = formatDateForInput(serviceDateObj);
    const dueDate = formatDateForInput(addDays(serviceDateObj, 3));
    const additions = [];
    DEFAULT_BLOCK_BATCHES.forEach(definition => {
      const count = Math.max(0, Number(blockBatchState.counts?.[definition.id] || 0));
      if (!count) return;
      const profile = getBlockBatchProfile(definition.id);
      for (let index = 0; index < count; index += 1) {
        const name = buildBlockBatchTaskName(definition.prefix, serviceDateObj, index);
        const task = buildTaskFromBatchProfile(profile, {
          name,
          dateOfService: serviceDate,
          dueDate
        });
        if (task) {
          additions.push(task);
        }
      }
    });
    if (!additions.length) {
      showToast("Block Batch", "Set at least one batch count to add tasks.");
      return;
    }
    additions.forEach(task => tasks.push(task));
    showTaskAddedConfirmation(additions.length);
    persist();
    updateUI();
    showToast("Block Batch", `Added ${additions.length} tasks.`);
    resetBlockBatchCounts();
    closeBlockBatchModal();
  }

  function updateBlockBatchModal({ focusActive = false } = {}) {
    renderBlockBatchList();
    renderBlockBatchCounts();
    updateBlockBatchHighlights({ focusInput: focusActive });
  }

  function openBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    loadBlockBatchProfiles();
    if (!blockBatchState.activeId && DEFAULT_BLOCK_BATCHES.length) {
      blockBatchState.activeId = DEFAULT_BLOCK_BATCHES[0].id;
    }
    updateBlockBatchModal({ focusActive: true });
    hideBlockBatchEditor();
    const dateField = $("blockBatchDate");
    if (dateField) {
      const today = formatDateForInput(new Date());
      dateField.value = dateField.value || today;
    }
    modal.classList.remove("hidden");
    modal.setAttribute("aria-hidden", "false");
    const firstOption = modal.querySelector(".block-batch-item__select");
    if (firstOption) {
      window.setTimeout(() => firstOption.focus(), 0);
    }
  }

  function closeBlockBatchModal() {
    const modal = $("block-batch-modal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.setAttribute("aria-hidden", "true");
    hideBlockBatchEditor();
    resetBlockBatchCounts();
  }

  function initializeBlockBatchModule() {
    const openBtn = $("blockBatchOpen");
    const modal = $("block-batch-modal");
    if (!openBtn || !modal) return;
    openBtn.addEventListener("click", () => openBlockBatchModal());
    const closeBtn = modal.querySelector(".modal__close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => closeBlockBatchModal());
    }
    modal.addEventListener("click", event => {
      if (event.target === modal) {
        closeBlockBatchModal();
      }
    });
    modal.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        event.stopPropagation();
        closeBlockBatchModal();
      }
    });
    const saveBtn = $("blockBatchSaveProfile");
    if (saveBtn) {
      saveBtn.addEventListener("click", handleBlockBatchSaveProfile);
    }
    const resetBtn = $("blockBatchResetProfile");
    if (resetBtn) {
      resetBtn.addEventListener("click", handleBlockBatchResetProfile);
    }
    const closeEditorBtn = $("blockBatchEditorClose");
    if (closeEditorBtn) {
      closeEditorBtn.addEventListener("click", hideBlockBatchEditor);
    }
    const addBtn = $("blockBatchAdd");
    if (addBtn) {
      addBtn.addEventListener("click", handleBlockBatchAdd);
    }
    loadBlockBatchProfiles();
  }

  function updateHeaderSubtitle() {
    const dateEl = $("headerDate");
    if (!dateEl) return;
    try {
      const formatted = new Date().toLocaleDateString(undefined, {
        weekday: "long",
        month: "short",
        day: "numeric"
      });
      dateEl.textContent = formatted;
    } catch (error) {
      dateEl.textContent = "";
    }
  }

  function updateBillingReminder() {
    const reminder = $("billingReminder");
    if (!reminder) return;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const cutoff = new Date(today);
    cutoff.setDate(cutoff.getDate() - 95);
    const formatted = cutoff.toLocaleDateString(undefined, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
    reminder.innerHTML = `<span class="header-chip"><span class="header-chip__label">Eligibility cutoff</span><span class="header-chip__value">${formatted}</span></span>`;
  }

  function registerFieldListeners() {
    const dateField = $("dateOfService");
    if (dateField) {
      dateField.addEventListener("change", () => {
        updateDerivedFields();
      });
    }
    const categoryField = $("taskCategory");
    if (categoryField) {
      categoryField.addEventListener("change", event => {
        handleCategoryChange(event.target.value);
      });
    }
    const urgencyField = $("urgency");
    if (urgencyField) {
      urgencyField.addEventListener("change", () => {
        urgencyAuto = false;
        updateUrgencyHint(getSuggestedUrgency(derivedDaysSinceVisit));
      });
    }
  }

  function registerTaskListModeControl() {
    const modeSelect = $("taskViewMode");
    if (!modeSelect) return;
    modeSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_LIST_MODES.ACTIVE).toLowerCase();
      taskListMode = value === TASK_LIST_MODES.COMPLETED ? TASK_LIST_MODES.COMPLETED : TASK_LIST_MODES.ACTIVE;
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerTimeBudgetControl() {
    const budgetSelect = $("timeBudget");
    if (!budgetSelect) return;
    budgetSelect.addEventListener("change", () => {
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerCategoryFilterControl() {
    const categorySelect = $("taskCategoryFilter");
    if (!categorySelect) return;
    categorySelect.addEventListener("change", event => {
      const value = (event.target.value || "All").toString();
      activeCategory = categories.includes(value) || value === "All" ? value : "All";
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerTaskSortControl() {
    const sortSelect = $("taskSortMode");
    if (!sortSelect) return;
    sortSelect.addEventListener("change", event => {
      const value = String(event.target.value || TASK_SORT_MODES.PRIORITY);
      const validValues = Object.values(TASK_SORT_MODES);
      taskSortMode = validValues.includes(value) ? value : TASK_SORT_MODES.PRIORITY;
      resetReadyToLaunchVisibility();
      updateUI();
    });
  }

  function registerReadyToLaunchControl() {
    const showMoreBtn = $("readyToLaunchMoreBtn");
    if (!showMoreBtn) return;
    showMoreBtn.addEventListener("click", () => {
      showMoreReadyToLaunchTasks();
    });
  }

  function triggerStartReward(button) {
    if (!button) return;
    button.classList.add("start-action");
    button.classList.remove("cta-reward-active");
    void button.offsetWidth;
    button.classList.add("cta-reward-active");
    if (navigator?.vibrate) {
      navigator.vibrate(12);
    }
    window.setTimeout(() => {
      button.classList.remove("cta-reward-active");
    }, 240);
  }

  function markStartRewardButtons() {
    const buttons = document.querySelectorAll("button");
    buttons.forEach(button => {
      if (button.dataset.startReward === "ready") return;
      const label = (button.textContent || button.getAttribute("aria-label") || "")
        .trim()
        .toLowerCase();
      if (!label.startsWith("start")) return;
      button.dataset.startReward = "ready";
      button.classList.add("start-action");
      button.addEventListener("click", () => triggerStartReward(button));
    });
  }

  function setupStartRewardObserver() {
    markStartRewardButtons();
    const observer = new MutationObserver(() => {
      markStartRewardButtons();
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }
/* === Phase 4 – Win Log logic === */

function openWinLogPrompt() {

const hud = $("winLogHUD");

if (!hud) return;

document.body.classList.add("win-flash");
recordEvent("reflection_open");

setTimeout(()=>document.body.classList.remove("win-flash"), 900);

hud.classList.remove("hidden");

const note = $("winLogNote");

if (note) note.value = "";

}



function saveWinLogEntry(payload = {}) {

const storeKey = "winLog";

const existing = JSON.parse(localStorage.getItem(storeKey) || "[]");

const entry = {

t: Date.now(),

tag: payload.tag || "other",

note: payload.note || ""

};

existing.push(entry);

localStorage.setItem(storeKey, JSON.stringify(existing));
recordEvent("reflection_save", entry);

}



function wireWinLogHUD() {

const hud = $("winLogHUD"); if (!hud) return;

let chosen = null;

hud.querySelectorAll("[data-log]").forEach(btn=>{

btn.addEventListener("click", ()=>{ chosen = btn.dataset.log; });

});

const save = $("winLogSave");

const dismiss = $("winLogDismiss");

save.addEventListener("click", ()=>{

const note = ($("winLogNote") || {}).value || "";

saveWinLogEntry({ tag: chosen || "other", note });

hud.classList.add("hidden");

});

dismiss.addEventListener("click", ()=> hud.classList.add("hidden"));

}

/* === Phase 5 – Insights wiring === */
function wireInsights() {
  const btn = $("insightButton");
  const closeBtn = $("closeInsights");
  if (btn) btn.addEventListener("click", openInsights);
  if (closeBtn) closeBtn.addEventListener("click", closeInsights);
}
  window.addEventListener('DOMContentLoaded', () => {
    const nextStepBtn = $("meltdownShieldNext");
    if (nextStepBtn) {
      nextStepBtn.addEventListener("click", completeCurrentMeltdownStep);
    }
    prepareAccordionContainers();
    function showToast(message, duration = 2000) {
  const toast = document.createElement("div");
  toast.textContent = message;
  Object.assign(toast.style, {
    position: "fixed",
    bottom: "90px",
    left: "50%",
    transform: "translateX(-50%)",
    background: "#00bfa5", // teal
    color: "#fff",
    padding: "10px 18px",
    borderRadius: "20px",
    fontSize: "14px",
    boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
    opacity: "0",
    transition: "opacity 0.3s ease",
    zIndex: "9999",
  });
  document.body.appendChild(toast);
  requestAnimationFrame(() => (toast.style.opacity = "1"));
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 300);
  }, duration);
    }
    const hydrationOutcome = hydrateTasksFromStorage();
    hydrateTemplatesFromStorage();
    restoreBriefModePreference();
    setupMomentumZones();
    setupNextBestObserver();
    setupSmartCollapse();
    setupTaskGestures();
    setupFocusOverlay();
    setupLazyMedia();
    initializeChartFields();
    registerFieldListeners();
    registerTaskListModeControl();
    registerTimeBudgetControl();
    registerReadyToLaunchControl();
    setDefaultFieldValues();
    updateHeaderSubtitle();
    updateBillingReminder();
    initializeSoundPreference();
    initializeFirstThreeWizard();
    initializeTaskForm();
    initializeQuickAddMenu();
    initializeQuickTaskShortcut();
    initializeShredTopTaskButton();
    initializeBlockBatchModule();
    initializeAddTaskCardState();
    initializePreflightToggles();
    initializeDueTodayAccordionState();
    initializeAllTasksCardState();
    initializeAllTasksOverlay();
    initializeFocusLaunchSheet();
    initializeQuickCaptureModal();
    initializeSettingsMenu();
    initializeTemplatesOverlay();
    initializeConflictOverlay();

// === START: Accordions ===
// Existing accordion wiring lives in renderDueTodayList and initializeAllTasksCardState.
// Keep the two sections mutually exclusive by collapsing the other when one opens.
// === END: Accordions ===

    renderResourceLinks();
    initializeResourceCreation();
    initializeResourcesDrawer();
    initializeSosPanel();
    initializeCommandBarAutohide();
    initializeDefuseOverlay();
    initializeRoutineOverlay();
    initializeCollapsibleModules();
    initializeMorningLaunchModule();
    initializeLaunchPadModule();
    initializeSleepToolkitModule();
    initializeNextBestEngine();
    initializeConflictResolverModule();
    initializeDefuseMode();
    initializeDopamineModule();
    wireWinLogHUD();
    wireInsights();
    recalculateAdaptiveBias();
    initializeDistractionTools();
    initializeGanttSnapshot();
    initializeWorstDayMode();
    initializeTaskBackupControls();
    registerCategoryFilterControl();
    registerTaskSortControl();
    setupStartRewardObserver();
    startReminderLoop();
    renderTemplates();
    if (!hydrationOutcome?.scheduledUpdate) {
      updateUI();
    }
    updateSleepToolkitUI();
    updateDerivedFields();
  });
  </script>
    <script>
  (function () {
    const root = document.querySelector('.focus-command-deck');
    if (!root) return;

    const fill = root.querySelector('.cm-fill');
    const doneEl = root.querySelector('.cm-done');
    const totalEl = root.querySelector('.cm-total');
    const floatEl = root.querySelector('.cm-float');

    function zone(pct) {
      if (pct >= 1) return 'high';
      if (pct >= 0.3) return 'mid';
      return 'low';
    }

    function setFill(pct) {
      const z = zone(pct);
      fill.dataset.zone = z;
      fill.style.width = (pct * 100).toFixed(0) + '%';
    }

    window.updateChartProgress = function (completed, total) {
      const prev = parseFloat((fill.style.width || '0').replace('%', '')) / 100 || 0;
      const pct = total > 0 ? completed / total : 0;

      doneEl.textContent = completed;
      totalEl.textContent = total;
      setFill(pct);

      floatEl.textContent = Math.round(pct * 100) + '% complete';
      floatEl.style.opacity = '1';
      floatEl.style.transform = 'translateY(-4px)';

      setTimeout(() => {
        floatEl.style.opacity = '0';
        floatEl.style.transform = 'translateY(-10px)';
      }, 700);

      if (pct > prev || pct >= 1) {
        fill.classList.remove('pulse');
        void fill.offsetWidth; // force reflow
        fill.classList.add('pulse');
      }
    };

    // Optional: initialize from any existing DOM values
    const initDone = parseInt(doneEl.textContent, 10) || 0;
    const initTotal = parseInt(totalEl.textContent, 10) || 0;
    setFill(initTotal ? initDone / initTotal : 0);
  })();

  document.addEventListener("DOMContentLoaded", () => {
    // Debugging script for the 2x2 recovery routines grid layout
    const container = document.querySelector(".recovery-routines-container");
    if (!container) {
      console.error("Error: Rounded container for recovery routines is missing.");
    } else {
      console.log("Recovery routines container found:", container);

      const containerStyles = getComputedStyle(container);
      if (containerStyles.display !== "grid") {
        console.error(
          "Error: Container is not using grid layout. Current display property:",
          containerStyles.display
        );
      } else {
        console.log("Container is using grid layout.");
      }

      const modules = container.querySelectorAll(".routine-tile");
      if (modules.length !== 4) {
        console.error(`Error: Expected 4 routine modules, found ${modules.length}.`);
      } else {
        console.info("Routine modules found:", modules);
        const expectedTitles = ["🌅 AM Start", "🚀 Launch Pad", "😴 Sleep Toolkit", "🎵 Dopa-Me"];

        modules.forEach((module, index) => {
          const titleElement = module.querySelector(".routine-tile__title");
          const title = titleElement ? titleElement.textContent.trim() : null;

          if (title !== expectedTitles[index]) {
            console.error(
              `Error: Routine ${index + 1} has incorrect title. Expected: "${expectedTitles[index]}", Found: "${title}".`
            );
          } else {
            console.info(`Routine ${index + 1} title is correct: "${title}".`);
          }
        });
      }

      const outline = containerStyles.border || containerStyles.boxShadow;
      if (!outline || outline === "none") {
        console.error("Error: No outline is applied to the container.");
      } else {
        console.log("Outline applied to the container:", outline);
      }
    }

    const outline = containerStyles.border || containerStyles.boxShadow;
    if (!outline || outline === "none") {
      console.error("Error: No outline is applied to the container.");
    } else {
      console.log("Outline applied to the container:", outline);
    }

    const overlay = document.querySelector(".all-tasks-overlay");
    const openBtn = document.getElementById("openAllTasksButton");
    const closeBtn = overlay?.querySelector(".all-tasks-overlay__close");

    if (overlay && openBtn) {
      openBtn.addEventListener("click", () => {
        overlay.removeAttribute("hidden");
        document.body.classList.add("all-tasks-overlay-active");
      });
    }

    if (overlay && closeBtn) {
      closeBtn.addEventListener("click", () => {
        overlay.setAttribute("hidden", "");
        document.body.classList.remove("all-tasks-overlay-active");
      });
    }
  });
    </script>
  <script>
    (function () {
      const CLINIC_DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
      const CLINIC_OPTIONS = [
        "Faculty",
        "Continuity",
        "St. PJs",
        "Admin Time",
        "Academics"
      ];
      const SLOT_TIMES = {
        AM: ["08:00", "09:00", "10:00", "11:00"],
        PM: ["13:00", "14:00", "15:00", "16:00"]
      };

      const isOpenCapacityClinic = value => {
        if (typeof value !== "string") {
          return false;
        }
        const normalized = value.trim().toLowerCase();
        if (!normalized) {
          return false;
        }
        return normalized.includes("admin") || normalized.includes("academ");
      };

      function getTodayClinicDay() {
        const name = new Date().toLocaleDateString("en-US", { weekday: "long" });
        return CLINIC_DAYS.includes(name) ? name : CLINIC_DAYS[0];
      }

      function ensureScheduleFallback() {
        const grid = document.getElementById("weeklyScheduleGrid");
        if (!grid || grid.children.length > 0) {
          return;
        }

        const STORAGE_KEY = "taskerScheduleState";

        const clonePatientSlots = source => {
          if (!source || typeof source !== "object") return {};
          return Object.fromEntries(
            Object.entries(source).map(([key, slots]) => [
              key,
              Array.isArray(slots)
                ? slots.map(slot => ({
                    id: typeof slot?.id === "string" ? slot.id : "",
                    time: typeof slot?.time === "string" ? slot.time : "",
                    label: typeof slot?.label === "string" ? slot.label : "Visit",
                    resident: slot?.resident === true,
                    isCustom: slot?.isCustom === true,
                  }))
                : [],
            ]),
          );
        };

        const defaultState = () => ({
          currentDay: null,
          currentBlock: null,
          clinicType: null,
          clinicSelections: {},
          blockResidentPresence: {},
          residentMap: {},
          patientSlots: {},
        });

        const loadScheduleState = () => {
          if (typeof window === "undefined" || !window.localStorage) {
            return defaultState();
          }
          try {
            const raw = window.localStorage.getItem(STORAGE_KEY);
            if (!raw) {
              return defaultState();
            }
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") {
              return defaultState();
            }
            return {
              currentDay: typeof parsed.currentDay === "string" ? parsed.currentDay : null,
              currentBlock: typeof parsed.currentBlock === "string" ? parsed.currentBlock : null,
              clinicType: typeof parsed.clinicType === "string" ? parsed.clinicType : null,
              clinicSelections: { ...(parsed.clinicSelections || {}) },
              blockResidentPresence: { ...(parsed.blockResidentPresence || {}) },
              residentMap: { ...(parsed.residentMap || {}) },
              patientSlots: clonePatientSlots(parsed.patientSlots || {}),
            };
          } catch (error) {
            console.warn("[fallback] Unable to load schedule state:", error);
            return defaultState();
          }
        };

        let scheduleState = loadScheduleState();

        const saveScheduleState = () => {
          if (typeof window === "undefined" || !window.localStorage) {
            return;
          }
          try {
            window.localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({
                currentDay: scheduleState.currentDay,
                currentBlock: scheduleState.currentBlock,
                clinicType: scheduleState.clinicType,
                clinicSelections: { ...(scheduleState.clinicSelections || {}) },
                blockResidentPresence: { ...(scheduleState.blockResidentPresence || {}) },
                residentMap: { ...(scheduleState.residentMap || {}) },
                patientSlots: clonePatientSlots(scheduleState.patientSlots || {}),
              }),
            );
          } catch (error) {
            console.warn("[fallback] Unable to persist schedule state:", error);
          }
        };

        const dispatchScheduleUpdate = reason => {
          if (typeof window === "undefined") return;
          const detail = {
            reason,
            dayState: {
              currentDay: scheduleState.currentDay,
              currentBlock: scheduleState.currentBlock,
              clinicType: scheduleState.clinicType,
              clinicSelections: { ...(scheduleState.clinicSelections || {}) },
              blockResidentPresence: { ...(scheduleState.blockResidentPresence || {}) },
              residentMap: { ...(scheduleState.residentMap || {}) },
              patientSlots: clonePatientSlots(scheduleState.patientSlots || {}),
            },
          };
          if (typeof loadClinicBasketStateFromStorage === "function") {
            detail.clinicBasket = loadClinicBasketStateFromStorage();
          }
          window.dispatchEvent(new CustomEvent("scheduleStateUpdated", { detail }));
        };

        const blockKeyFor = (dayValue, blockValue) => `${dayValue}|${blockValue}`;

        grid.classList.add("weekly-grid--single-day");

        const overlay = document.querySelector("#weeklyScheduleCard [data-day-overlay]");
        const title = overlay?.querySelector("[data-day-overlay-title]") || null;
        const subtitle = overlay?.querySelector("[data-day-overlay-subtitle]") || null;
        const slotsHost = overlay?.querySelector("[data-day-overlay-slots]") || null;
        const closeBtn = overlay?.querySelector("[data-day-overlay-close]") || null;
        const confirmBtn = overlay?.querySelector("[data-day-overlay-confirm]") || null;
        const addBtn = overlay?.querySelector("[data-day-overlay-add-patient]") || null;

        const day = getTodayClinicDay();
        const blocks = ["AM", "PM"];
        let currentSlots = [];
        let activeCell = null;
        let activeBlock = null;

        const getSlotsForBlock = (dayValue, blockValue) => {
          const key = blockKeyFor(dayValue, blockValue);
          const clinicSelection = scheduleState.clinicSelections?.[key];
          const openCapacity = isOpenCapacityClinic(clinicSelection);
          const stored = scheduleState.patientSlots?.[key];
          if (Array.isArray(stored) && stored.length > 0) {
            const normalized = stored.map((slot, index) => ({
              id: typeof slot.id === "string" && slot.id.trim() ? slot.id : `slot-${index}`,
              time: typeof slot.time === "string" ? slot.time : "",
              label: typeof slot.label === "string" && slot.label.trim() ? slot.label.trim() : "Visit",
              resident: slot.resident === true,
              isCustom: slot.isCustom === true,
            }));
            const hasManual = normalized.some(slot => slot.isCustom);
            if (openCapacity && !hasManual) {
              if (scheduleState.patientSlots) {
                delete scheduleState.patientSlots[key];
              }
              if (scheduleState.blockResidentPresence) {
                delete scheduleState.blockResidentPresence[key];
              }
              if (scheduleState.residentMap) {
                const prefix = `${key}|`;
                Object.keys(scheduleState.residentMap).forEach(resKey => {
                  if (resKey.startsWith(prefix)) {
                    delete scheduleState.residentMap[resKey];
                  }
                });
              }
              saveScheduleState();
              dispatchScheduleUpdate("patient-slot:clear-open");
              return [];
            }
            return normalized;
          }
          if (openCapacity) {
            return [];
          }
          const times = SLOT_TIMES[blockValue] || [];
          return times.map((time, index) => ({
            id: `default-${blockValue}-${index}`,
            time,
            label: "Visit",
            resident: scheduleState.residentMap?.[`${key}|${index}`] === true,
            isCustom: false,
          }));
        };

        const persistSlotsForBlock = (dayValue, blockValue, slots) => {
          const key = blockKeyFor(dayValue, blockValue);
          if (!scheduleState.patientSlots) scheduleState.patientSlots = {};
          scheduleState.patientSlots[key] = slots.map((slot, index) => ({
            id: typeof slot.id === "string" && slot.id.trim() ? slot.id : `slot-${index}`,
            time: typeof slot.time === "string" ? slot.time : "",
            label: typeof slot.label === "string" && slot.label.trim() ? slot.label.trim() : "Visit",
            resident: slot.resident === true,
            isCustom: slot.isCustom === true,
          }));
          if (!scheduleState.residentMap) scheduleState.residentMap = {};
          const prefix = `${key}|`;
          Object.keys(scheduleState.residentMap).forEach(resKey => {
            if (resKey.startsWith(prefix)) {
              delete scheduleState.residentMap[resKey];
            }
          });
          scheduleState.patientSlots[key].forEach((slot, index) => {
            scheduleState.residentMap[`${key}|${index}`] = slot.resident === true;
          });
          if (!scheduleState.blockResidentPresence) scheduleState.blockResidentPresence = {};
          scheduleState.blockResidentPresence[key] = scheduleState.patientSlots[key].some(slot => slot.resident === true);
          saveScheduleState();
          dispatchScheduleUpdate("patient-slot:update");
          return getSlotsForBlock(dayValue, blockValue);
        };

        const updateActiveResidentIcon = () => {
          if (!activeCell || !activeBlock) return;
          const iconEl = activeCell.querySelector(".weekly-grid__resident-icon");
          if (!iconEl) return;
          const key = blockKeyFor(day, activeBlock);
          const hasResident = scheduleState.blockResidentPresence?.[key] === true;
          iconEl.classList.toggle("weekly-grid__resident-icon--visible", hasResident);
          iconEl.setAttribute("aria-hidden", hasResident ? "false" : "true");
        };

        const renderSlots = () => {
          if (!slotsHost) return;
          slotsHost.innerHTML = "";
          currentSlots.forEach((slot, index) => {
            slotsHost.appendChild(buildSlotRow(slot, index));
          });
        };

        const buildSlotRow = (slot, index) => {
          const row = document.createElement("div");
          row.className = "day-overlay__slot";
          row.dataset.slotId = slot.id;

          const info = document.createElement("div");
          info.className = "day-overlay__slot-info";

          if (slot.isCustom) {
            const timeInput = document.createElement("input");
            timeInput.type = "time";
            timeInput.className = "day-overlay__custom-time";
            timeInput.value = slot.time || "";
            timeInput.addEventListener("input", () => {
              currentSlots[index].time = timeInput.value;
              currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
            });

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.className = "day-overlay__custom-label";
            labelInput.placeholder = "Patient details";
            labelInput.value = slot.label || "";
            labelInput.addEventListener("input", () => {
              currentSlots[index].label = labelInput.value;
              currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
            });

            info.append(timeInput, labelInput);
          } else {
            const timeEl = document.createElement("div");
            timeEl.className = "day-overlay__slot-time";
            timeEl.textContent = slot.time || "—";

            const labelEl = document.createElement("div");
            labelEl.className = "day-overlay__slot-label";
            labelEl.textContent = slot.label || "Visit";

            info.append(timeEl, labelEl);
          }

          const actions = document.createElement("div");
          actions.className = "day-overlay__slot-actions";

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "resident-toggle";
          toggle.textContent = "🧑‍⚕️";
          toggle.setAttribute("aria-pressed", slot.resident ? "true" : "false");
          toggle.addEventListener("click", () => {
            const pressed = toggle.getAttribute("aria-pressed") === "true";
            const next = !pressed;
            toggle.setAttribute("aria-pressed", next ? "true" : "false");
            currentSlots[index].resident = next;
            currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
            updateActiveResidentIcon();
          });

          actions.appendChild(toggle);

          if (slot.isCustom) {
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "day-overlay__remove-patient";
            removeBtn.setAttribute("aria-label", "Remove patient");
            removeBtn.textContent = "✕";
            removeBtn.addEventListener("click", () => {
              currentSlots.splice(index, 1);
              currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
              renderSlots();
              updateActiveResidentIcon();
            });
            actions.appendChild(removeBtn);
          }

          row.append(info, actions);
          return row;
        };

        const renderOverlay = (block, cell) => {
          if (!overlay || !title || !subtitle || !slotsHost) {
            return;
          }

          activeCell = cell || null;
          activeBlock = block;
          const key = blockKeyFor(day, block);
          scheduleState.currentDay = day;
          scheduleState.currentBlock = block;
          scheduleState.clinicType = scheduleState.clinicSelections?.[key] || CLINIC_OPTIONS[0];
          saveScheduleState();
          dispatchScheduleUpdate("fallback:open");
          currentSlots = getSlotsForBlock(day, block);

          title.textContent = `${day} — ${block}`;
          subtitle.textContent = "Tap 👩‍⚕️ to include a resident.";
          renderSlots();

          overlay.removeAttribute("hidden");
        };

        blocks.forEach(block => {
          const cell = document.createElement("div");
          cell.className = "weekly-grid__cell";
          cell.dataset.day = day;
          cell.dataset.block = block;
          cell.setAttribute("role", "group");
          cell.tabIndex = -1;

          const dayLabel = document.createElement("div");
          dayLabel.className = "weekly-grid__day";
          dayLabel.textContent = day;

          const clinicWrapper = document.createElement("div");
          clinicWrapper.className = "weekly-grid__clinic-wrapper";

          const select = document.createElement("select");
          select.className = "weekly-grid__clinic-select";
          CLINIC_OPTIONS.forEach(option => {
            const optionEl = document.createElement("option");
            optionEl.value = option;
            optionEl.textContent = option;
            select.appendChild(optionEl);
          });

          const blockKey = blockKeyFor(day, block);
          const storedClinic = scheduleState.clinicSelections?.[blockKey] || CLINIC_OPTIONS[0];
          select.value = storedClinic;
          select.addEventListener("change", () => {
            if (!scheduleState.clinicSelections) scheduleState.clinicSelections = {};
            scheduleState.clinicSelections[blockKey] = select.value;
            scheduleState.currentDay = day;
            scheduleState.currentBlock = block;
            scheduleState.clinicType = select.value;
            if (isOpenCapacityClinic(select.value)) {
              if (scheduleState.patientSlots) {
                delete scheduleState.patientSlots[blockKey];
              }
              if (scheduleState.blockResidentPresence) {
                delete scheduleState.blockResidentPresence[blockKey];
              }
              if (scheduleState.residentMap) {
                const prefix = `${blockKey}|`;
                Object.keys(scheduleState.residentMap).forEach(resKey => {
                  if (resKey.startsWith(prefix)) {
                    delete scheduleState.residentMap[resKey];
                  }
                });
              }
              residentIcon.classList.remove("weekly-grid__resident-icon--visible");
              residentIcon.setAttribute("aria-hidden", "true");
            }
            saveScheduleState();
            dispatchScheduleUpdate("fallback:clinic-selection");
          });
          select.addEventListener("click", event => {
            event.stopPropagation();
          });

          const residentIcon = document.createElement("span");
          residentIcon.className = "weekly-grid__resident-icon";
          residentIcon.textContent = "👥";
          const hasResident = scheduleState.blockResidentPresence?.[blockKey] === true;
          residentIcon.classList.toggle("weekly-grid__resident-icon--visible", hasResident);
          residentIcon.setAttribute("aria-hidden", hasResident ? "false" : "true");

          clinicWrapper.append(select, residentIcon);

          const blockLabel = document.createElement("div");
          blockLabel.className = "weekly-grid__time";
          blockLabel.textContent = block;

          cell.addEventListener("click", () => {
            renderOverlay(block, cell);
          });
          cell.addEventListener("keydown", event => {
            if ((event.key === "Enter" || event.key === " ") && event.target === cell) {
              event.preventDefault();
              renderOverlay(block, cell);
            }
          });

          cell.append(dayLabel, clinicWrapper, blockLabel, manageBtn);
          grid.appendChild(cell);
        });

        if (addBtn) {
          addBtn.addEventListener("click", () => {
            if (!activeBlock) return;
            const customCount = currentSlots.filter(slot => slot.isCustom).length + 1;
            currentSlots.push({
              id: `custom-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`,
              time: "",
              label: `Added patient ${customCount}`,
              resident: false,
              isCustom: true,
            });
            currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
            renderSlots();
            updateActiveResidentIcon();
            const latestInput = slotsHost?.querySelector(
              ".day-overlay__slot:last-of-type .day-overlay__custom-time",
            );
            latestInput?.focus();
          });
        }

        if (closeBtn) {
          closeBtn.addEventListener("click", () => {
            const focusTarget = activeTrigger || activeCell;
            overlay?.setAttribute("hidden", "");
            activeCell = null;
            activeBlock = null;
            currentSlots = [];
            focusTarget?.focus();
          });
        }

        if (confirmBtn) {
          confirmBtn.addEventListener("click", () => {
            if (!overlay || !currentSlots.length) {
              return;
            }

            currentSlots = persistSlotsForBlock(day, activeBlock, currentSlots);
            updateActiveResidentIcon();

            const plan = [
              { time: "07:30", type: "task", label: "Morning Launch", source: "ritual" }
            ].concat(
              currentSlots.map(slot => ({
                time: slot.time || "",
                type: "patient",
                label: `${(slot.label || "Visit").trim()} (${slot.resident ? "with" : "no"} resident)`,
                source: "schedule"
              }))
            );

            document.dispatchEvent(new CustomEvent("planReady", { detail: plan }));
            const focusTarget = activeTrigger || activeCell;
            overlay.setAttribute("hidden", "");
            if (activeCell) {
              activeCell.focus();
            }
            currentSlots = [];
            activeCell = null;
            activeBlock = null;
          });
        }

        dispatchScheduleUpdate("fallback:init");
      }

      if (typeof window !== "undefined") {
        window.ensureScheduleFallback = ensureScheduleFallback;
      }

      function runFallback() {
        window.setTimeout(ensureScheduleFallback, 0);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", runFallback);
      } else {
        runFallback();
      }
      function getCapacityBackdrop() {
  let b = document.getElementById('capacityBackdrop');
  if (!b) {
    b = document.createElement('div');
    b.id = 'capacityBackdrop';
    b.className = 'checklist-capacity-backdrop';
    document.body.appendChild(b);
    b.addEventListener('click', () => {
      closeCapacitySheet();
      closeEnergySheet();
    });
  }
  return b;
}

  let focusTimer = null;
let focusSeconds = 0;
let focusRunning = false;

function startFocusSprint(minutes = 25) {
  focusSeconds = minutes * 60;
  focusRunning = true;
  updateFocusTimer();
  clearInterval(focusTimer);
  focusTimer = setInterval(tickFocusTimer, 1000);
  $("focusStartBtn").disabled = true;
  $("focusPauseBtn").disabled = false;
  $("focusEndBtn").disabled = false;
  speakBuddy(`Starting a ${minutes}-minute sprint. You’ve got this.`);
  recordEvent("sprint_start", { duration: minutes });
}

function tickFocusTimer() {
  if (!focusRunning) return;
  focusSeconds--;
  updateFocusTimer();
  if (focusSeconds <= 0) endFocusSprint(true);
}

function updateFocusTimer() {
  const m = Math.floor(focusSeconds / 60).toString().padStart(2, "0");
  const s = (focusSeconds % 60).toString().padStart(2, "0");
  $("focusTimerDisplay").textContent = `${m}:${s}`;
}

function pauseFocusSprint() { focusRunning = !focusRunning; }
function endFocusSprint(auto = false) {
  clearInterval(focusTimer);
  $("focusStartBtn").disabled = false;
  $("focusPauseBtn").disabled = true;
  $("focusEndBtn").disabled = true;
  if (auto) triggerDopamineFeedback();
  recordEvent("sprint_end", { auto });
}

function speakBuddy(text) {
  if ("speechSynthesis" in window) {
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 1.05;
    speechSynthesis.speak(u);
  }
}

$("focusStartBtn").onclick = () => startFocusSprint(Number($("sprintModeSelect").value));
$("focusPauseBtn").onclick = pauseFocusSprint;
$("focusEndBtn").onclick = () => endFocusSprint(false);
}
      /* === Phase 2 – Step 2 : Sound + haptic cue === */
function playPositiveCue() {
  try {
    if ("vibrate" in navigator) navigator.vibrate(40);
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    osc.frequency.value = 440;            // gentle tone
    osc.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.1);
  } catch (e) {
    console.warn("Cue error", e);
  }
}

/* === Phase 5 – Event Logger === */
function recordEvent(type, payload = {}) {
  try {
    const key = "taskerMetrics";
    const log = JSON.parse(localStorage.getItem(key) || "[]");
    const entry = {
      t: Date.now(),
      type,
      ...payload
    };
    log.push(entry);
    // cap log at 2000 entries to avoid unbounded growth
    if (log.length > 2000) log.splice(0, log.length - 2000);
    localStorage.setItem(key, JSON.stringify(log));
  } catch (err) {
    console.warn("recordEvent error", err);
  }
}

/* === Phase 5 – Insights Overlay logic === */
function openInsights() {
  const overlay = $("insightOverlay");
  if (!overlay) return;
  overlay.classList.remove("hidden");
  renderInsights();
}

function closeInsights() {
  const overlay = $("insightOverlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderInsights() {
  const raw = JSON.parse(localStorage.getItem("taskerMetrics") || "[]");
  if (!raw.length) {
    $("insightStats").textContent = "No activity logged yet.";
    if (window._insightChart) {
      window._insightChart.destroy();
      window._insightChart = null;
    }
    return;
  }

  const weekAgo = Date.now() - 7 * 864e5;
  const recent = raw.filter(e => e.t >= weekAgo);
  if (!recent.length) {
    $("insightStats").textContent = "No activity logged in the past week.";
    if (window._insightChart) {
      window._insightChart.destroy();
      window._insightChart = null;
    }
    return;
  }
  const counts = {};
  recent.forEach(e => { counts[e.type] = (counts[e.type] || 0) + 1; });

  $("insightStats").innerHTML =
    Object.entries(counts).map(([k,v])=>`${k}: ${v}`).join("<br>");

  // Simple sparkline bar chart
  const ctx = document.getElementById("insightChart").getContext("2d");
  if (window._insightChart) window._insightChart.destroy();
  window._insightChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(counts),
      datasets: [{
        label: "Events this week",
        data: Object.values(counts),
        backgroundColor: "rgba(45,212,195,0.6)"
      }]
    },
    options: {
      scales: { y: { beginAtZero: true, ticks: { precision: 0 } } },
      plugins: { legend: { display: false } }
    }
  });
}
/* === Phase 5 – Adaptive Bias Engine === */
function recalculateAdaptiveBias() {
  try {
    const raw = JSON.parse(localStorage.getItem("taskerMetrics") || "[]");
    if (!raw.length) return;

    const cutoff = Date.now() - 7 * 864e5;           // last 7 days
    const week = raw.filter(e => e.t >= cutoff);
    const counts = {};
    week.forEach(e => counts[e.type] = (counts[e.type] || 0) + 1);

    const sprints = counts.sprint_end || 0;
    const meltdowns = counts.meltdown_start || 0;
    const reflections = counts.reflection_save || 0;

    const resilience = sprints ? Math.max(0, 1 - meltdowns / (sprints + 1)) : 1;

    const profile = {
      lastUpdate: Date.now(),
      avgSprints: sprints,
      meltdownRate: meltdowns,
      reflectionRate: reflections,
      resilience,
      defaultSprintMinutes: resilience < 0.6 ? 20 : resilience > 0.9 ? 35 : 25,
      quickWinBias: resilience < 0.7 ? 1.5 : 1,
      shieldPromptTone: resilience < 0.5 ? "gentle" : "standard"
    };

    localStorage.setItem("adaptiveProfile", JSON.stringify(profile));
    console.log("Adaptive profile updated", profile);
  } catch (err) {
    console.warn("recalculateAdaptiveBias error", err);
  }
}
      // Edit: JS – Jumpback capture + restore

function setLastContext(ctx){ try{ localStorage.setItem("lastContext", JSON.stringify({...ctx, t:Date.now()})); }catch{} }

function getLastContext(){ try{ return JSON.parse(localStorage.getItem("lastContext")||""); }catch{ return null } }

function restoreLastContext(){

const c=getLastContext(); if(!c) return;

// naive restore: focus a task row by id and scroll into view

const el=document.querySelector(`[data-task-id="${c.taskId}"]`);

if(el){ el.scrollIntoView({block:"center"}); el.focus(); }

}
     // Edit: in your save/create handler

if($("humorizeName")?.checked){ task.name = playfulName(task.name); }

function playfulName(s){ return s?.replace(/chart/i,"Chart Dragon") || s; }
    })();
   <script>
  // Auto-backup to file once a day
  const now = Date.now();
  const last = +localStorage.getItem("lastBackupTime") || 0;
  if (now - last > 24*60*60*1000) {
    const data = localStorage.getItem("tasks") || "[]";
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `tasker-backup-${new Date().toISOString().split("T")[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    localStorage.setItem("lastBackupTime", now);
  }
</script>

  <script>
    (function () {
      const GRID_ID = "weeklyScheduleGrid";
      const AVAIL_KEY = "taskerWeekendAvailability";
      const AVAIL_DEFAULT = { sat: false, sun: true };

      function loadAvailability() {
        const storage = typeof window !== "undefined" ? window.localStorage : null;
        if (!storage) {
          return { ...AVAIL_DEFAULT };
        }
        try {
          const raw = storage.getItem(AVAIL_KEY);
          if (!raw) {
            return { ...AVAIL_DEFAULT };
          }
          const parsed = JSON.parse(raw);
          return {
            sat: Boolean(parsed?.sat),
            sun: parsed && Object.prototype.hasOwnProperty.call(parsed, "sun") ? Boolean(parsed.sun) : true,
          };
        } catch (error) {
          console.warn("[schedule] Unable to load weekend availability", error);
          return { ...AVAIL_DEFAULT };
        }
      }

      function persistAvailability(next) {
        const storage = typeof window !== "undefined" ? window.localStorage : null;
        if (!storage) {
          return;
        }
        try {
          storage.setItem(AVAIL_KEY, JSON.stringify(next));
        } catch (error) {
          console.warn("[schedule] Unable to persist weekend availability", error);
        }
      }

      function applyAvailabilityUI(state, badge, toggle, label) {
        const isOn = Boolean(state);
        const statusText = isOn ? "Available" : "Off duty";
        badge.textContent = statusText;
        badge.classList.toggle("weekend-card__badge--on", isOn);
        badge.classList.toggle("weekend-card__badge--off", !isOn);
        toggle.textContent = statusText;
        toggle.classList.toggle("weekend-card__toggle--active", isOn);
        toggle.setAttribute("aria-pressed", isOn ? "true" : "false");
        const action = isOn ? "Mark off duty" : "Mark available";
        const statusLabel = `${label} — ${statusText}`;
        const description = `${action} (${statusLabel})`;
        toggle.setAttribute("aria-label", description);
        toggle.title = description;
      }

      function createWeekendCell(dayKey, label, availability) {
        const cell = document.createElement("div");
        cell.className = "weekly-grid__cell weekly-grid__cell--weekend";
        cell.dataset.weekendDay = dayKey;
        cell.setAttribute("role", "group");
        cell.tabIndex = -1;

        const dayLabel = document.createElement("div");
        dayLabel.className = "weekly-grid__day";
        dayLabel.textContent = label;

        const card = document.createElement("div");
        card.className = "weekend-card";

        const header = document.createElement("div");
        header.className = "weekend-card__header";

        const title = document.createElement("div");
        title.className = "weekend-card__title";
        title.textContent = "Admin Day";

        const note = document.createElement("p");
        note.className = "weekend-card__note";
        note.textContent = "Dedicated space for inbox, planning, and catch-up.";

        const badge = document.createElement("span");
        badge.className = "weekend-card__badge";

        const toggle = document.createElement("button");
        toggle.type = "button";
        toggle.className = "weekend-card__toggle";
        toggle.dataset.weekendToggle = dayKey;

        header.append(title, toggle);

        const setState = () => {
          const isAvailable = dayKey === "sun" ? availability.sun : availability.sat;
          applyAvailabilityUI(isAvailable, badge, toggle, label);
        };

        setState();

        toggle.addEventListener("click", () => {
          if (dayKey === "sun") {
            availability.sun = !availability.sun;
          } else {
            availability.sat = !availability.sat;
          }
          setState();
          persistAvailability(availability);
          try {
            window.dispatchEvent(
              new CustomEvent("tasker:weekendAvailabilityChanged", {
                detail: { ...availability },
              }),
            );
          } catch (error) {
            console.warn("[schedule] Weekend availability dispatch failed", error);
          }
        });

        card.append(header, note, badge);
        cell.append(dayLabel, card);
        return cell;
      }

      function injectWeekendPlaceholders(grid) {
        const availability = loadAvailability();
        persistAvailability(availability);
        grid.classList.add("weekly-grid--with-weekend");
        grid.append(
          createWeekendCell("sat", "Saturday", availability),
          createWeekendCell("sun", "Sunday", availability),
        );
      }

      function initializeWatchdog() {
        const grid = document.getElementById(GRID_ID);
        if (!grid) {
          return;
        }

        try {
          const fallback = window.ensureScheduleFallback;
          if (typeof fallback === "function") {
            fallback();
          }
        } catch (error) {
          console.warn("[schedule] ensureScheduleFallback failed", error);
        }

        setTimeout(() => {
          if (grid.children.length === 0) {
            injectWeekendPlaceholders(grid);
          }
        }, 0);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeWatchdog);
      } else {
        initializeWatchdog();
      }
    })();
  </script>
</body>
</html>
